PASS
ok  	archive/tar	0.021s
BenchmarkCompressedZipGarbage-12    	     100	  11673901 ns/op	    5592 B/op	      44 allocs/op
BenchmarkZip64Test-12               	      20	  72170490 ns/op
PASS
ok  	archive/zip	8.662s
BenchmarkReaderCopyOptimal-12       	10000000	       214 ns/op
BenchmarkReaderCopyUnoptimal-12     	 5000000	       304 ns/op
BenchmarkReaderCopyNoWriteTo-12     	  200000	      5335 ns/op
BenchmarkReaderWriteToOptimal-12    	 3000000	       529 ns/op
BenchmarkWriterCopyOptimal-12       	10000000	       207 ns/op
BenchmarkWriterCopyUnoptimal-12     	 5000000	       297 ns/op
BenchmarkWriterCopyNoReadFrom-12    	  300000	      4067 ns/op
BenchmarkReaderEmpty-12             	 2000000	       972 ns/op	    4224 B/op	       3 allocs/op
BenchmarkWriterEmpty-12             	 1000000	      1332 ns/op	    4096 B/op	       1 allocs/op
BenchmarkWriterFlush-12             	100000000	        13.8 ns/op	       0 B/op	       0 allocs/op
PASS
ok  	bufio	20.194s
?   	builtin	[no test files]
BenchmarkReadString-12                     	  200000	     11134 ns/op	2943.02 MB/s
BenchmarkWriteRune-12                      	   30000	     44580 ns/op	 275.64 MB/s
BenchmarkBufferNotEmptyWriteRead-12        	    5000	    378274 ns/op
BenchmarkBufferFullSmallReads-12           	   10000	    138267 ns/op
BenchmarkIndexByte/10-12                   	300000000	         4.90 ns/op	2042.65 MB/s
BenchmarkIndexByte/32-12                   	300000000	         4.76 ns/op	6720.42 MB/s
BenchmarkIndexByte/4K-12                   	20000000	        76.2 ns/op	53724.49 MB/s
BenchmarkIndexByte/4M-12                   	   10000	    111179 ns/op	37725.36 MB/s
BenchmarkIndexByte/64M-12                  	     300	   4400370 ns/op	15250.73 MB/s
BenchmarkIndexBytePortable/10-12           	200000000	         6.76 ns/op	1479.72 MB/s
BenchmarkIndexBytePortable/32-12           	100000000	        24.9 ns/op	1287.59 MB/s
BenchmarkIndexBytePortable/4K-12           	 1000000	      1550 ns/op	2640.98 MB/s
BenchmarkIndexBytePortable/4M-12           	    1000	   1587396 ns/op	2642.25 MB/s
BenchmarkIndexBytePortable/64M-12          	      50	  26160249 ns/op	2565.30 MB/s
BenchmarkIndexRune/10-12                   	100000000	        14.8 ns/op	 674.87 MB/s
BenchmarkIndexRune/32-12                   	100000000	        17.6 ns/op	1823.18 MB/s
BenchmarkIndexRune/4K-12                   	20000000	        96.5 ns/op	42464.90 MB/s
BenchmarkIndexRune/4M-12                   	   10000	    110365 ns/op	38003.76 MB/s
BenchmarkIndexRune/64M-12                  	     300	   4239064 ns/op	15831.06 MB/s
BenchmarkIndexRuneASCII/10-12              	200000000	         5.76 ns/op	1735.35 MB/s
BenchmarkIndexRuneASCII/32-12              	200000000	         7.38 ns/op	4337.71 MB/s
BenchmarkIndexRuneASCII/4K-12              	20000000	        81.9 ns/op	50029.52 MB/s
BenchmarkIndexRuneASCII/4M-12              	   10000	    108983 ns/op	38485.61 MB/s
BenchmarkIndexRuneASCII/64M-12             	     300	   4218654 ns/op	15907.65 MB/s
BenchmarkEqual/0-12                        	500000000	         3.06 ns/op
BenchmarkEqual/1-12                        	300000000	         3.77 ns/op	 265.10 MB/s
BenchmarkEqual/6-12                        	300000000	         3.79 ns/op	1581.52 MB/s
BenchmarkEqual/9-12                        	300000000	         4.25 ns/op	2117.84 MB/s
BenchmarkEqual/15-12                       	300000000	         4.32 ns/op	3475.42 MB/s
BenchmarkEqual/16-12                       	300000000	         4.26 ns/op	3758.39 MB/s
BenchmarkEqual/20-12                       	300000000	         5.12 ns/op	3903.95 MB/s
BenchmarkEqual/32-12                       	200000000	         6.01 ns/op	5326.40 MB/s
BenchmarkEqual/4K-12                       	20000000	        70.5 ns/op	58089.18 MB/s
BenchmarkEqual/4M-12                       	   10000	    184840 ns/op	22691.53 MB/s
BenchmarkEqual/64M-12                      	     200	   8420315 ns/op	7969.88 MB/s
BenchmarkEqualPort/1-12                    	300000000	         3.50 ns/op	 285.38 MB/s
BenchmarkEqualPort/6-12                    	300000000	         5.89 ns/op	1018.88 MB/s
BenchmarkEqualPort/32-12                   	100000000	        19.6 ns/op	1634.90 MB/s
BenchmarkEqualPort/4K-12                   	 1000000	      1843 ns/op	2222.04 MB/s
BenchmarkEqualPort/4M-12                   	    1000	   1895963 ns/op	2212.23 MB/s
BenchmarkEqualPort/64M-12                  	      50	  31869228 ns/op	2105.76 MB/s
BenchmarkIndex/10-12                       	100000000	        11.4 ns/op	 874.63 MB/s
BenchmarkIndex/32-12                       	100000000	        10.5 ns/op	3042.84 MB/s
BenchmarkIndex/4K-12                       	 1000000	      2138 ns/op	1915.37 MB/s
BenchmarkIndex/4M-12                       	    1000	   2212328 ns/op	1895.88 MB/s
BenchmarkIndex/64M-12                      	      30	  37315907 ns/op	1798.40 MB/s
BenchmarkIndexEasy/10-12                   	200000000	         8.38 ns/op	1193.33 MB/s
BenchmarkIndexEasy/32-12                   	100000000	        10.6 ns/op	3007.15 MB/s
BenchmarkIndexEasy/4K-12                   	20000000	        93.3 ns/op	43898.11 MB/s
BenchmarkIndexEasy/4M-12                   	   10000	    115397 ns/op	36346.69 MB/s
BenchmarkIndexEasy/64M-12                  	     300	   4470932 ns/op	15010.04 MB/s
BenchmarkCount/10-12                       	100000000	        23.6 ns/op	 423.95 MB/s
BenchmarkCount/32-12                       	10000000	       139 ns/op	 228.84 MB/s
BenchmarkCount/4K-12                       	   50000	     27964 ns/op	 146.47 MB/s
BenchmarkCount/4M-12                       	      50	  32736651 ns/op	 128.12 MB/s
BenchmarkCount/64M-12                      	       3	 439787837 ns/op	 152.59 MB/s
BenchmarkCountEasy/10-12                   	100000000	        14.7 ns/op	 682.41 MB/s
BenchmarkCountEasy/32-12                   	100000000	        15.8 ns/op	2027.96 MB/s
BenchmarkCountEasy/4K-12                   	10000000	       101 ns/op	40347.72 MB/s
BenchmarkCountEasy/4M-12                   	   10000	    118334 ns/op	35444.54 MB/s
BenchmarkCountEasy/64M-12                  	     300	   4415861 ns/op	15197.23 MB/s
BenchmarkFields-12                         	      50	  21433666 ns/op	  48.92 MB/s
BenchmarkFieldsFunc-12                     	     100	  21034041 ns/op	  49.85 MB/s
BenchmarkTrimSpace-12                      	30000000	        38.9 ns/op
BenchmarkRepeat-12                         	20000000	        79.9 ns/op
BenchmarkBytesCompare/1-12                 	300000000	         4.73 ns/op
BenchmarkBytesCompare/2-12                 	300000000	         4.72 ns/op
BenchmarkBytesCompare/4-12                 	300000000	         4.76 ns/op
BenchmarkBytesCompare/8-12                 	500000000	         3.72 ns/op
BenchmarkBytesCompare/16-12                	500000000	         4.01 ns/op
BenchmarkBytesCompare/32-12                	300000000	         4.55 ns/op
BenchmarkBytesCompare/64-12                	200000000	         5.52 ns/op
BenchmarkBytesCompare/128-12               	200000000	         6.72 ns/op
BenchmarkBytesCompare/256-12               	200000000	         8.92 ns/op
BenchmarkBytesCompare/512-12               	100000000	        13.8 ns/op
BenchmarkBytesCompare/1024-12              	100000000	        23.1 ns/op
BenchmarkBytesCompare/2048-12              	30000000	        44.4 ns/op
BenchmarkIndexAnyASCII/1:1-12              	300000000	         4.54 ns/op
BenchmarkIndexAnyASCII/1:2-12              	300000000	         4.93 ns/op
BenchmarkIndexAnyASCII/1:4-12              	300000000	         5.72 ns/op
BenchmarkIndexAnyASCII/1:8-12              	200000000	         7.79 ns/op
BenchmarkIndexAnyASCII/1:16-12             	100000000	        11.9 ns/op
BenchmarkIndexAnyASCII/16:1-12             	50000000	        29.6 ns/op
BenchmarkIndexAnyASCII/16:2-12             	50000000	        34.7 ns/op
BenchmarkIndexAnyASCII/16:4-12             	30000000	        36.1 ns/op
BenchmarkIndexAnyASCII/16:8-12             	20000000	        71.2 ns/op
BenchmarkIndexAnyASCII/16:16-12            	20000000	        93.5 ns/op
BenchmarkIndexAnyASCII/256:1-12            	 2000000	       605 ns/op
BenchmarkIndexAnyASCII/256:2-12            	 3000000	       586 ns/op
BenchmarkIndexAnyASCII/256:4-12            	 3000000	       569 ns/op
BenchmarkIndexAnyASCII/256:8-12            	 3000000	       595 ns/op
BenchmarkIndexAnyASCII/256:16-12           	 3000000	       399 ns/op
BenchmarkIndexAnyASCII/4096:1-12           	  300000	      5437 ns/op
BenchmarkIndexAnyASCII/4096:2-12           	  300000	      5600 ns/op
BenchmarkIndexAnyASCII/4096:4-12           	  200000	      5935 ns/op
BenchmarkIndexAnyASCII/4096:8-12           	  200000	      7784 ns/op
BenchmarkIndexAnyASCII/4096:16-12          	  200000	      5941 ns/op
BenchmarkTrimASCII/1:1-12                  	20000000	        53.7 ns/op
BenchmarkTrimASCII/1:2-12                  	20000000	       113 ns/op
BenchmarkTrimASCII/1:4-12                  	10000000	       112 ns/op
BenchmarkTrimASCII/1:8-12                  	10000000	       115 ns/op
BenchmarkTrimASCII/1:16-12                 	10000000	       107 ns/op
BenchmarkTrimASCII/16:1-12                 	20000000	       109 ns/op
BenchmarkTrimASCII/16:2-12                 	10000000	       141 ns/op
BenchmarkTrimASCII/16:4-12                 	10000000	       138 ns/op
BenchmarkTrimASCII/16:8-12                 	10000000	       149 ns/op
BenchmarkTrimASCII/16:16-12                	10000000	       180 ns/op
BenchmarkTrimASCII/256:1-12                	 2000000	       801 ns/op
BenchmarkTrimASCII/256:2-12                	 2000000	       917 ns/op
BenchmarkTrimASCII/256:4-12                	 1000000	      1094 ns/op
BenchmarkTrimASCII/256:8-12                	 1000000	      1307 ns/op
BenchmarkTrimASCII/256:16-12               	 2000000	       999 ns/op
BenchmarkTrimASCII/4096:1-12               	  100000	     11976 ns/op
BenchmarkTrimASCII/4096:2-12               	  100000	     13298 ns/op
BenchmarkTrimASCII/4096:4-12               	  100000	     13914 ns/op
BenchmarkTrimASCII/4096:8-12               	  100000	     13716 ns/op
BenchmarkTrimASCII/4096:16-12              	  100000	     15071 ns/op
BenchmarkCompareBytesEqual-12              	300000000	         3.99 ns/op
BenchmarkCompareBytesToNil-12              	300000000	         3.47 ns/op
BenchmarkCompareBytesEmpty-12              	1000000000	         2.64 ns/op
BenchmarkCompareBytesIdentical-12          	1000000000	         2.66 ns/op
BenchmarkCompareBytesSameLength-12         	300000000	         4.25 ns/op
BenchmarkCompareBytesDifferentLength-12    	300000000	         4.33 ns/op
BenchmarkCompareBytesBigUnaligned-12       	   30000	     46450 ns/op	22574.44 MB/s
BenchmarkCompareBytesBig-12                	   30000	     47677 ns/op	21993.26 MB/s
BenchmarkCompareBytesBigIdentical-12       	1000000000	         2.66 ns/op	394757390.88 MB/s
PASS
ok  	bytes	242.642s
PASS
ok  	cmd/addr2line	0.461s
BenchmarkAll-12    	       1	3789425221 ns/op
PASS
ok  	cmd/api	4.145s
?   	cmd/asm	[no test files]
?   	cmd/asm/internal/arch	[no test files]
PASS
ok  	cmd/asm/internal/asm	0.114s
?   	cmd/asm/internal/flags	[no test files]
PASS
ok  	cmd/asm/internal/lex	0.013s
?   	cmd/cgo	[no test files]

PASS
ok  	cmd/compile	2.493s
?   	cmd/compile/internal/amd64	[no test files]
?   	cmd/compile/internal/arm	[no test files]
?   	cmd/compile/internal/arm64	[no test files]
BenchmarkEfaceInteger-12    	500000000	         2.73 ns/op
PASS
ok  	cmd/compile/internal/gc	12.164s
?   	cmd/compile/internal/mips	[no test files]
?   	cmd/compile/internal/mips64	[no test files]
?   	cmd/compile/internal/ppc64	[no test files]
?   	cmd/compile/internal/s390x	[no test files]
BenchmarkCopyElim1-12               	  500000	      2455 ns/op
BenchmarkCopyElim10-12              	  200000	      9710 ns/op
BenchmarkCopyElim100-12             	   20000	     62931 ns/op
BenchmarkCopyElim1000-12            	    2000	   1006972 ns/op
BenchmarkCopyElim10000-12           	     100	  18357576 ns/op
BenchmarkCopyElim100000-12          	      10	 180372889 ns/op
BenchmarkDeadCode/1-12              	  500000	      3546 ns/op
BenchmarkDeadCode/10-12             	  200000	     10791 ns/op
BenchmarkDeadCode/100-12            	   20000	     77578 ns/op
BenchmarkDeadCode/1000-12           	    2000	    974765 ns/op
BenchmarkDeadCode/10000-12          	     100	  11492558 ns/op
BenchmarkDeadCode/100000-12         	      10	 128366136 ns/op
BenchmarkDeadCode/200000-12         	       5	 250494293 ns/op
BenchmarkDominatorsLinear-12        	    2000	   1325983 ns/op	   7.54 MB/s
BenchmarkDominatorsFwdBack-12       	    1000	   2189771 ns/op	   4.57 MB/s
BenchmarkDominatorsManyPred-12      	    1000	   1693330 ns/op	   5.91 MB/s
BenchmarkDominatorsMaxPred-12       	    1000	   1803054 ns/op	   5.55 MB/s
BenchmarkDominatorsMaxPredVal-12    	    1000	   1895407 ns/op	   5.28 MB/s
BenchmarkFuse/1-12                  	  300000	      4607 ns/op
BenchmarkFuse/10-12                 	  100000	     21420 ns/op
BenchmarkFuse/100-12                	   10000	    183600 ns/op
BenchmarkFuse/1000-12               	    1000	   1908580 ns/op
BenchmarkFuse/10000-12              	      50	  27024299 ns/op
BenchmarkNilCheckDeep1-12           	10000000	       213 ns/op	   4.67 MB/s	       5 B/op	       1 allocs/op
BenchmarkNilCheckDeep10-12          	 3000000	       548 ns/op	  18.23 MB/s	      32 B/op	       1 allocs/op
BenchmarkNilCheckDeep100-12         	  300000	      4041 ns/op	  24.74 MB/s	     208 B/op	       1 allocs/op
BenchmarkNilCheckDeep1000-12        	   30000	     53363 ns/op	  18.74 MB/s	    2048 B/op	       1 allocs/op
BenchmarkNilCheckDeep10000-12       	    3000	    428069 ns/op	  23.36 MB/s	   20480 B/op	       1 allocs/op
BenchmarkDSEPass-12                 	    5000	    313428 ns/op	   41192 B/op	       8 allocs/op
BenchmarkDSEPassBlock-12            	     300	   5672606 ns/op	  554873 B/op	     400 allocs/op
BenchmarkCSEPass-12                 	     500	   3210556 ns/op	  188864 B/op	      11 allocs/op
BenchmarkCSEPassBlock-12            	      50	  36251412 ns/op	 3204040 B/op	    3300 allocs/op
BenchmarkDeadcodePass-12            	   20000	     62031 ns/op	   10506 B/op	       3 allocs/op
BenchmarkDeadcodePassBlock-12       	    3000	   1155574 ns/op	  151758 B/op	      15 allocs/op
BenchmarkMultiPass-12               	   10000	    173571 ns/op	  240248 B/op	      13 allocs/op
BenchmarkMultiPassBlock-12          	    1000	   2314942 ns/op	 3603683 B/op	     195 allocs/op
PASS
ok  	cmd/compile/internal/ssa	94.783s
     1  *syntax.File {
     2  .  PkgName: syntax
     3  .  DeclList: []syntax.Decl (76 entries) {
     4  .  .  0: *syntax.ImportDecl {
     5  .  .  .  LocalPkgName: nil
     6  .  .  .  Path: *syntax.BasicLit {
     7  .  .  .  .  Value: "\"fmt\""
     8  .  .  .  .  Kind: 4
     9  .  .  .  }
    10  .  .  .  Group: *syntax.Group {}
    11  .  .  }
    12  .  .  1: *syntax.ImportDecl {
    13  .  .  .  LocalPkgName: nil
    14  .  .  .  Path: *syntax.BasicLit {
    15  .  .  .  .  Value: "\"io\""
    16  .  .  .  .  Kind: 4
    17  .  .  .  }
    18  .  .  .  Group: *syntax.Group {}
    19  .  .  }
    20  .  .  2: *syntax.ImportDecl {
    21  .  .  .  LocalPkgName: nil
    22  .  .  .  Path: *syntax.BasicLit {
    23  .  .  .  .  Value: "\"strings\""
    24  .  .  .  .  Kind: 4
    25  .  .  .  }
    26  .  .  .  Group: *syntax.Group {}
    27  .  .  }
    28  .  .  3: *syntax.ConstDecl {
    29  .  .  .  NameList: []*syntax.Name (1 entries) {
    30  .  .  .  .  0: debug
    31  .  .  .  }
    32  .  .  .  Type: nil
    33  .  .  .  Values: false
    34  .  .  .  Group: nil
    35  .  .  }
    36  .  .  4: *syntax.ConstDecl {
    37  .  .  .  NameList: []*syntax.Name (1 entries) {
    38  .  .  .  .  0: trace
    39  .  .  .  }
    40  .  .  .  Type: nil
    41  .  .  .  Values: false
    42  .  .  .  Group: nil
    43  .  .  }
    44  .  .  5: *syntax.ConstDecl {
    45  .  .  .  NameList: []*syntax.Name (1 entries) {
    46  .  .  .  .  0: gcCompat
    47  .  .  .  }
    48  .  .  .  Type: nil
    49  .  .  .  Values: true
    50  .  .  .  Group: nil
    51  .  .  }
    52  .  .  6: *syntax.TypeDecl {
    53  .  .  .  Name: parser
    54  .  .  .  Type: *syntax.StructType {
    55  .  .  .  .  FieldList: []*syntax.Field (4 entries) {
    56  .  .  .  .  .  0: *syntax.Field {
    57  .  .  .  .  .  .  Name: nil
    58  .  .  .  .  .  .  Type: scanner
    59  .  .  .  .  .  }
    60  .  .  .  .  .  1: *syntax.Field {
    61  .  .  .  .  .  .  Name: fnest
    62  .  .  .  .  .  .  Type: int
    63  .  .  .  .  .  }
    64  .  .  .  .  .  2: *syntax.Field {
    65  .  .  .  .  .  .  Name: xnest
    66  .  .  .  .  .  .  Type: int
    67  .  .  .  .  .  }
    68  .  .  .  .  .  3: *syntax.Field {
    69  .  .  .  .  .  .  Name: indent
    70  .  .  .  .  .  .  Type: *syntax.SliceType {
    71  .  .  .  .  .  .  .  Elem: byte
    72  .  .  .  .  .  .  }
    73  .  .  .  .  .  }
    74  .  .  .  .  }
    75  .  .  .  .  TagList: nil
    76  .  .  .  }
    77  .  .  .  Group: nil
    78  .  .  .  Pragma: 0
    79  .  .  }
    80  .  .  7: *syntax.FuncDecl {
    81  .  .  .  Attr: map[]
    82  .  .  .  Recv: *syntax.Field {
    83  .  .  .  .  Name: p
    84  .  .  .  .  Type: *syntax.Operation {
    85  .  .  .  .  .  Op: *
    86  .  .  .  .  .  X: parser
    87  .  .  .  .  .  Y: nil
    88  .  .  .  .  }
    89  .  .  .  }
    90  .  .  .  Name: init
    91  .  .  .  Type: *syntax.FuncType {
    92  .  .  .  .  ParamList: []*syntax.Field (3 entries) {
    93  .  .  .  .  .  0: *syntax.Field {
    94  .  .  .  .  .  .  Name: src
    95  .  .  .  .  .  .  Type: *syntax.SelectorExpr {
    96  .  .  .  .  .  .  .  X: io
    97  .  .  .  .  .  .  .  Sel: Reader
    98  .  .  .  .  .  .  }
    99  .  .  .  .  .  }
   100  .  .  .  .  .  1: *syntax.Field {
   101  .  .  .  .  .  .  Name: errh
   102  .  .  .  .  .  .  Type: ErrorHandler
   103  .  .  .  .  .  }
   104  .  .  .  .  .  2: *syntax.Field {
   105  .  .  .  .  .  .  Name: pragh
   106  .  .  .  .  .  .  Type: PragmaHandler
   107  .  .  .  .  .  }
   108  .  .  .  .  }
   109  .  .  .  .  ResultList: nil
   110  .  .  .  }
   111  .  .  .  Body: []syntax.Stmt (4 entries) {
   112  .  .  .  .  0: *syntax.ExprStmt {
   113  .  .  .  .  .  X: *syntax.CallExpr {
   114  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   115  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   116  .  .  .  .  .  .  .  .  X: p
   117  .  .  .  .  .  .  .  .  Sel: scanner
   118  .  .  .  .  .  .  .  }
   119  .  .  .  .  .  .  .  Sel: init
   120  .  .  .  .  .  .  }
   121  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
   122  .  .  .  .  .  .  .  0: src
   123  .  .  .  .  .  .  .  1: errh
   124  .  .  .  .  .  .  .  2: pragh
   125  .  .  .  .  .  .  }
   126  .  .  .  .  .  .  HasDots: false
   127  .  .  .  .  .  }
   128  .  .  .  .  }
   129  .  .  .  .  1: *syntax.AssignStmt {
   130  .  .  .  .  .  Op: <op-0>
   131  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   132  .  .  .  .  .  .  X: p
   133  .  .  .  .  .  .  Sel: fnest
   134  .  .  .  .  .  }
   135  .  .  .  .  .  Rhs: *syntax.BasicLit {
   136  .  .  .  .  .  .  Value: "0"
   137  .  .  .  .  .  .  Kind: 0
   138  .  .  .  .  .  }
   139  .  .  .  .  }
   140  .  .  .  .  2: *syntax.AssignStmt {
   141  .  .  .  .  .  Op: <op-0>
   142  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   143  .  .  .  .  .  .  X: p
   144  .  .  .  .  .  .  Sel: xnest
   145  .  .  .  .  .  }
   146  .  .  .  .  .  Rhs: *syntax.BasicLit {
   147  .  .  .  .  .  .  Value: "0"
   148  .  .  .  .  .  .  Kind: 0
   149  .  .  .  .  .  }
   150  .  .  .  .  }
   151  .  .  .  .  3: *syntax.AssignStmt {
   152  .  .  .  .  .  Op: <op-0>
   153  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   154  .  .  .  .  .  .  X: p
   155  .  .  .  .  .  .  Sel: indent
   156  .  .  .  .  .  }
   157  .  .  .  .  .  Rhs: nil
   158  .  .  .  .  }
   159  .  .  .  }
   160  .  .  .  Pragma: 0
   161  .  .  .  EndLine: 35
   162  .  .  }
   163  .  .  8: *syntax.FuncDecl {
   164  .  .  .  Attr: map[]
   165  .  .  .  Recv: *syntax.Field {
   166  .  .  .  .  Name: p
   167  .  .  .  .  Type: *syntax.Operation {
   168  .  .  .  .  .  Op: *
   169  .  .  .  .  .  X: parser
   170  .  .  .  .  .  Y: nil
   171  .  .  .  .  }
   172  .  .  .  }
   173  .  .  .  Name: got
   174  .  .  .  Type: *syntax.FuncType {
   175  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
   176  .  .  .  .  .  0: *syntax.Field {
   177  .  .  .  .  .  .  Name: tok
   178  .  .  .  .  .  .  Type: token
   179  .  .  .  .  .  }
   180  .  .  .  .  }
   181  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
   182  .  .  .  .  .  0: *syntax.Field {
   183  .  .  .  .  .  .  Name: nil
   184  .  .  .  .  .  .  Type: bool
   185  .  .  .  .  .  }
   186  .  .  .  .  }
   187  .  .  .  }
   188  .  .  .  Body: []syntax.Stmt (2 entries) {
   189  .  .  .  .  0: *syntax.IfStmt {
   190  .  .  .  .  .  Init: nil
   191  .  .  .  .  .  Cond: *syntax.Operation {
   192  .  .  .  .  .  .  Op: ==
   193  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   194  .  .  .  .  .  .  .  X: p
   195  .  .  .  .  .  .  .  Sel: tok
   196  .  .  .  .  .  .  }
   197  .  .  .  .  .  .  Y: tok
   198  .  .  .  .  .  }
   199  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
   200  .  .  .  .  .  .  0: *syntax.ExprStmt {
   201  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   202  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   203  .  .  .  .  .  .  .  .  .  X: p
   204  .  .  .  .  .  .  .  .  .  Sel: next
   205  .  .  .  .  .  .  .  .  }
   206  .  .  .  .  .  .  .  .  ArgList: nil
   207  .  .  .  .  .  .  .  .  HasDots: false
   208  .  .  .  .  .  .  .  }
   209  .  .  .  .  .  .  }
   210  .  .  .  .  .  .  1: *syntax.ReturnStmt {
   211  .  .  .  .  .  .  .  Results: true
   212  .  .  .  .  .  .  }
   213  .  .  .  .  .  }
   214  .  .  .  .  .  Else: nil
   215  .  .  .  .  }
   216  .  .  .  .  1: *syntax.ReturnStmt {
   217  .  .  .  .  .  Results: false
   218  .  .  .  .  }
   219  .  .  .  }
   220  .  .  .  Pragma: 0
   221  .  .  .  EndLine: 43
   222  .  .  }
   223  .  .  9: *syntax.FuncDecl {
   224  .  .  .  Attr: map[]
   225  .  .  .  Recv: *syntax.Field {
   226  .  .  .  .  Name: p
   227  .  .  .  .  Type: *syntax.Operation {
   228  .  .  .  .  .  Op: *
   229  .  .  .  .  .  X: parser
   230  .  .  .  .  .  Y: nil
   231  .  .  .  .  }
   232  .  .  .  }
   233  .  .  .  Name: want
   234  .  .  .  Type: *syntax.FuncType {
   235  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
   236  .  .  .  .  .  0: *syntax.Field {
   237  .  .  .  .  .  .  Name: tok
   238  .  .  .  .  .  .  Type: token
   239  .  .  .  .  .  }
   240  .  .  .  .  }
   241  .  .  .  .  ResultList: nil
   242  .  .  .  }
   243  .  .  .  Body: []syntax.Stmt (1 entries) {
   244  .  .  .  .  0: *syntax.IfStmt {
   245  .  .  .  .  .  Init: nil
   246  .  .  .  .  .  Cond: *syntax.Operation {
   247  .  .  .  .  .  .  Op: !
   248  .  .  .  .  .  .  X: *syntax.CallExpr {
   249  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   250  .  .  .  .  .  .  .  .  X: p
   251  .  .  .  .  .  .  .  .  Sel: got
   252  .  .  .  .  .  .  .  }
   253  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
   254  .  .  .  .  .  .  .  .  0: tok
   255  .  .  .  .  .  .  .  }
   256  .  .  .  .  .  .  .  HasDots: false
   257  .  .  .  .  .  .  }
   258  .  .  .  .  .  .  Y: nil
   259  .  .  .  .  .  }
   260  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
   261  .  .  .  .  .  .  0: *syntax.ExprStmt {
   262  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   263  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   264  .  .  .  .  .  .  .  .  .  X: p
   265  .  .  .  .  .  .  .  .  .  Sel: syntax_error
   266  .  .  .  .  .  .  .  .  }
   267  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
   268  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
   269  .  .  .  .  .  .  .  .  .  .  Op: +
   270  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   271  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting \""
   272  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   273  .  .  .  .  .  .  .  .  .  .  }
   274  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
   275  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   276  .  .  .  .  .  .  .  .  .  .  .  .  X: tok
   277  .  .  .  .  .  .  .  .  .  .  .  .  Sel: String
   278  .  .  .  .  .  .  .  .  .  .  .  }
   279  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
   280  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   281  .  .  .  .  .  .  .  .  .  .  }
   282  .  .  .  .  .  .  .  .  .  }
   283  .  .  .  .  .  .  .  .  }
   284  .  .  .  .  .  .  .  .  HasDots: false
   285  .  .  .  .  .  .  .  }
   286  .  .  .  .  .  .  }
   287  .  .  .  .  .  .  1: *syntax.ExprStmt {
   288  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   289  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   290  .  .  .  .  .  .  .  .  .  X: p
   291  .  .  .  .  .  .  .  .  .  Sel: advance
   292  .  .  .  .  .  .  .  .  }
   293  .  .  .  .  .  .  .  .  ArgList: nil
   294  .  .  .  .  .  .  .  .  HasDots: false
   295  .  .  .  .  .  .  .  }
   296  .  .  .  .  .  .  }
   297  .  .  .  .  .  }
   298  .  .  .  .  .  Else: nil
   299  .  .  .  .  }
   300  .  .  .  }
   301  .  .  .  Pragma: 0
   302  .  .  .  EndLine: 50
   303  .  .  }
   304  .  .  10: *syntax.FuncDecl {
   305  .  .  .  Attr: map[]
   306  .  .  .  Recv: *syntax.Field {
   307  .  .  .  .  Name: p
   308  .  .  .  .  Type: *syntax.Operation {
   309  .  .  .  .  .  Op: *
   310  .  .  .  .  .  X: parser
   311  .  .  .  .  .  Y: nil
   312  .  .  .  .  }
   313  .  .  .  }
   314  .  .  .  Name: syntax_error
   315  .  .  .  Type: *syntax.FuncType {
   316  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
   317  .  .  .  .  .  0: *syntax.Field {
   318  .  .  .  .  .  .  Name: msg
   319  .  .  .  .  .  .  Type: string
   320  .  .  .  .  .  }
   321  .  .  .  .  }
   322  .  .  .  .  ResultList: nil
   323  .  .  .  }
   324  .  .  .  Body: []syntax.Stmt (1 entries) {
   325  .  .  .  .  0: *syntax.ExprStmt {
   326  .  .  .  .  .  X: *syntax.CallExpr {
   327  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   328  .  .  .  .  .  .  .  X: p
   329  .  .  .  .  .  .  .  Sel: syntax_error_at
   330  .  .  .  .  .  .  }
   331  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
   332  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
   333  .  .  .  .  .  .  .  .  X: p
   334  .  .  .  .  .  .  .  .  Sel: pos
   335  .  .  .  .  .  .  .  }
   336  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
   337  .  .  .  .  .  .  .  .  X: p
   338  .  .  .  .  .  .  .  .  Sel: line
   339  .  .  .  .  .  .  .  }
   340  .  .  .  .  .  .  .  2: msg
   341  .  .  .  .  .  .  }
   342  .  .  .  .  .  .  HasDots: false
   343  .  .  .  .  .  }
   344  .  .  .  .  }
   345  .  .  .  }
   346  .  .  .  Pragma: 0
   347  .  .  .  EndLine: 58
   348  .  .  }
   349  .  .  11: *syntax.FuncDecl {
   350  .  .  .  Attr: map[]
   351  .  .  .  Recv: *syntax.Field {
   352  .  .  .  .  Name: p
   353  .  .  .  .  Type: *syntax.Operation {
   354  .  .  .  .  .  Op: *
   355  .  .  .  .  .  X: parser
   356  .  .  .  .  .  Y: nil
   357  .  .  .  .  }
   358  .  .  .  }
   359  .  .  .  Name: syntax_error_at
   360  .  .  .  Type: *syntax.FuncType {
   361  .  .  .  .  ParamList: []*syntax.Field (3 entries) {
   362  .  .  .  .  .  0: *syntax.Field {
   363  .  .  .  .  .  .  Name: pos
   364  .  .  .  .  .  .  Type: int
   365  .  .  .  .  .  }
   366  .  .  .  .  .  1: *syntax.Field {
   367  .  .  .  .  .  .  Name: line
   368  .  .  .  .  .  .  Type: int
   369  .  .  .  .  .  }
   370  .  .  .  .  .  2: *syntax.Field {
   371  .  .  .  .  .  .  Name: msg
   372  .  .  .  .  .  .  Type: string
   373  .  .  .  .  .  }
   374  .  .  .  .  }
   375  .  .  .  .  ResultList: nil
   376  .  .  .  }
   377  .  .  .  Body: []syntax.Stmt (6 entries) {
   378  .  .  .  .  0: *syntax.IfStmt {
   379  .  .  .  .  .  Init: nil
   380  .  .  .  .  .  Cond: trace
   381  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
   382  .  .  .  .  .  .  0: *syntax.CallStmt {
   383  .  .  .  .  .  .  .  Tok: defer
   384  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
   385  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
   386  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   387  .  .  .  .  .  .  .  .  .  .  X: p
   388  .  .  .  .  .  .  .  .  .  .  Sel: trace
   389  .  .  .  .  .  .  .  .  .  }
   390  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
   391  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
   392  .  .  .  .  .  .  .  .  .  .  .  Op: +
   393  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   394  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
   395  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   396  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"syntax_error (\""
   397  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   398  .  .  .  .  .  .  .  .  .  .  .  .  }
   399  .  .  .  .  .  .  .  .  .  .  .  .  Y: msg
   400  .  .  .  .  .  .  .  .  .  .  .  }
   401  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
   402  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\")\""
   403  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   404  .  .  .  .  .  .  .  .  .  .  .  }
   405  .  .  .  .  .  .  .  .  .  .  }
   406  .  .  .  .  .  .  .  .  .  }
   407  .  .  .  .  .  .  .  .  .  HasDots: false
   408  .  .  .  .  .  .  .  .  }
   409  .  .  .  .  .  .  .  .  ArgList: nil
   410  .  .  .  .  .  .  .  .  HasDots: false
   411  .  .  .  .  .  .  .  }
   412  .  .  .  .  .  .  }
   413  .  .  .  .  .  }
   414  .  .  .  .  .  Else: nil
   415  .  .  .  .  }
   416  .  .  .  .  1: *syntax.IfStmt {
   417  .  .  .  .  .  Init: nil
   418  .  .  .  .  .  Cond: *syntax.Operation {
   419  .  .  .  .  .  .  Op: &&
   420  .  .  .  .  .  .  X: *syntax.Operation {
   421  .  .  .  .  .  .  .  Op: ==
   422  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   423  .  .  .  .  .  .  .  .  X: p
   424  .  .  .  .  .  .  .  .  Sel: tok
   425  .  .  .  .  .  .  .  }
   426  .  .  .  .  .  .  .  Y: _EOF
   427  .  .  .  .  .  .  }
   428  .  .  .  .  .  .  Y: *syntax.Operation {
   429  .  .  .  .  .  .  .  Op: !=
   430  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   431  .  .  .  .  .  .  .  .  X: p
   432  .  .  .  .  .  .  .  .  Sel: first
   433  .  .  .  .  .  .  .  }
   434  .  .  .  .  .  .  .  Y: nil
   435  .  .  .  .  .  .  }
   436  .  .  .  .  .  }
   437  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
   438  .  .  .  .  .  .  0: *syntax.ReturnStmt {
   439  .  .  .  .  .  .  .  Results: nil
   440  .  .  .  .  .  .  }
   441  .  .  .  .  .  }
   442  .  .  .  .  .  Else: nil
   443  .  .  .  .  }
   444  .  .  .  .  2: *syntax.SwitchStmt {
   445  .  .  .  .  .  Init: nil
   446  .  .  .  .  .  Tag: nil
   447  .  .  .  .  .  Body: []*syntax.CaseClause (4 entries) {
   448  .  .  .  .  .  .  0: *syntax.CaseClause {
   449  .  .  .  .  .  .  .  Cases: *syntax.Operation {
   450  .  .  .  .  .  .  .  .  Op: ==
   451  .  .  .  .  .  .  .  .  X: msg
   452  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
   453  .  .  .  .  .  .  .  .  .  Value: "\"\""
   454  .  .  .  .  .  .  .  .  .  Kind: 4
   455  .  .  .  .  .  .  .  .  }
   456  .  .  .  .  .  .  .  }
   457  .  .  .  .  .  .  .  Body: nil
   458  .  .  .  .  .  .  }
   459  .  .  .  .  .  .  1: *syntax.CaseClause {
   460  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
   461  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (3 entries) {
   462  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
   463  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   464  .  .  .  .  .  .  .  .  .  .  .  X: strings
   465  .  .  .  .  .  .  .  .  .  .  .  Sel: HasPrefix
   466  .  .  .  .  .  .  .  .  .  .  }
   467  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
   468  .  .  .  .  .  .  .  .  .  .  .  0: msg
   469  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
   470  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"in\""
   471  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   472  .  .  .  .  .  .  .  .  .  .  .  }
   473  .  .  .  .  .  .  .  .  .  .  }
   474  .  .  .  .  .  .  .  .  .  .  HasDots: false
   475  .  .  .  .  .  .  .  .  .  }
   476  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
   477  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   478  .  .  .  .  .  .  .  .  .  .  .  X: strings
   479  .  .  .  .  .  .  .  .  .  .  .  Sel: HasPrefix
   480  .  .  .  .  .  .  .  .  .  .  }
   481  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
   482  .  .  .  .  .  .  .  .  .  .  .  0: msg
   483  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
   484  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"at\""
   485  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   486  .  .  .  .  .  .  .  .  .  .  .  }
   487  .  .  .  .  .  .  .  .  .  .  }
   488  .  .  .  .  .  .  .  .  .  .  HasDots: false
   489  .  .  .  .  .  .  .  .  .  }
   490  .  .  .  .  .  .  .  .  .  2: *syntax.CallExpr {
   491  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   492  .  .  .  .  .  .  .  .  .  .  .  X: strings
   493  .  .  .  .  .  .  .  .  .  .  .  Sel: HasPrefix
   494  .  .  .  .  .  .  .  .  .  .  }
   495  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
   496  .  .  .  .  .  .  .  .  .  .  .  0: msg
   497  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
   498  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"after\""
   499  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   500  .  .  .  .  .  .  .  .  .  .  .  }
   501  .  .  .  .  .  .  .  .  .  .  }
   502  .  .  .  .  .  .  .  .  .  .  HasDots: false
   503  .  .  .  .  .  .  .  .  .  }
   504  .  .  .  .  .  .  .  .  }
   505  .  .  .  .  .  .  .  }
   506  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
   507  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
   508  .  .  .  .  .  .  .  .  .  Op: <op-0>
   509  .  .  .  .  .  .  .  .  .  Lhs: msg
   510  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
   511  .  .  .  .  .  .  .  .  .  .  Op: +
   512  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   513  .  .  .  .  .  .  .  .  .  .  .  Value: "\" \""
   514  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   515  .  .  .  .  .  .  .  .  .  .  }
   516  .  .  .  .  .  .  .  .  .  .  Y: msg
   517  .  .  .  .  .  .  .  .  .  }
   518  .  .  .  .  .  .  .  .  }
   519  .  .  .  .  .  .  .  }
   520  .  .  .  .  .  .  }
   521  .  .  .  .  .  .  2: *syntax.CaseClause {
   522  .  .  .  .  .  .  .  Cases: *syntax.CallExpr {
   523  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   524  .  .  .  .  .  .  .  .  .  X: strings
   525  .  .  .  .  .  .  .  .  .  Sel: HasPrefix
   526  .  .  .  .  .  .  .  .  }
   527  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
   528  .  .  .  .  .  .  .  .  .  0: msg
   529  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
   530  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting\""
   531  .  .  .  .  .  .  .  .  .  .  Kind: 4
   532  .  .  .  .  .  .  .  .  .  }
   533  .  .  .  .  .  .  .  .  }
   534  .  .  .  .  .  .  .  .  HasDots: false
   535  .  .  .  .  .  .  .  }
   536  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
   537  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
   538  .  .  .  .  .  .  .  .  .  Op: <op-0>
   539  .  .  .  .  .  .  .  .  .  Lhs: msg
   540  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
   541  .  .  .  .  .  .  .  .  .  .  Op: +
   542  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   543  .  .  .  .  .  .  .  .  .  .  .  Value: "\", \""
   544  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   545  .  .  .  .  .  .  .  .  .  .  }
   546  .  .  .  .  .  .  .  .  .  .  Y: msg
   547  .  .  .  .  .  .  .  .  .  }
   548  .  .  .  .  .  .  .  .  }
   549  .  .  .  .  .  .  .  }
   550  .  .  .  .  .  .  }
   551  .  .  .  .  .  .  3: *syntax.CaseClause {
   552  .  .  .  .  .  .  .  Cases: nil
   553  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
   554  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
   555  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   556  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   557  .  .  .  .  .  .  .  .  .  .  .  X: p
   558  .  .  .  .  .  .  .  .  .  .  .  Sel: error_at
   559  .  .  .  .  .  .  .  .  .  .  }
   560  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
   561  .  .  .  .  .  .  .  .  .  .  .  0: pos
   562  .  .  .  .  .  .  .  .  .  .  .  1: line
   563  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.Operation {
   564  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
   565  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   566  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"syntax error: \""
   567  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   568  .  .  .  .  .  .  .  .  .  .  .  .  }
   569  .  .  .  .  .  .  .  .  .  .  .  .  Y: msg
   570  .  .  .  .  .  .  .  .  .  .  .  }
   571  .  .  .  .  .  .  .  .  .  .  }
   572  .  .  .  .  .  .  .  .  .  .  HasDots: false
   573  .  .  .  .  .  .  .  .  .  }
   574  .  .  .  .  .  .  .  .  }
   575  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
   576  .  .  .  .  .  .  .  .  .  Results: nil
   577  .  .  .  .  .  .  .  .  }
   578  .  .  .  .  .  .  .  }
   579  .  .  .  .  .  .  }
   580  .  .  .  .  .  }
   581  .  .  .  .  }
   582  .  .  .  .  3: *syntax.DeclStmt {
   583  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
   584  .  .  .  .  .  .  0: *syntax.VarDecl {
   585  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
   586  .  .  .  .  .  .  .  .  0: tok
   587  .  .  .  .  .  .  .  }
   588  .  .  .  .  .  .  .  Type: string
   589  .  .  .  .  .  .  .  Values: nil
   590  .  .  .  .  .  .  .  Group: nil
   591  .  .  .  .  .  .  }
   592  .  .  .  .  .  }
   593  .  .  .  .  }
   594  .  .  .  .  4: *syntax.SwitchStmt {
   595  .  .  .  .  .  Init: nil
   596  .  .  .  .  .  Tag: *syntax.SelectorExpr {
   597  .  .  .  .  .  .  X: p
   598  .  .  .  .  .  .  Sel: tok
   599  .  .  .  .  .  }
   600  .  .  .  .  .  Body: []*syntax.CaseClause (6 entries) {
   601  .  .  .  .  .  .  0: *syntax.CaseClause {
   602  .  .  .  .  .  .  .  Cases: _Name
   603  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
   604  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
   605  .  .  .  .  .  .  .  .  .  Op: <op-0>
   606  .  .  .  .  .  .  .  .  .  Lhs: tok
   607  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
   608  .  .  .  .  .  .  .  .  .  .  X: p
   609  .  .  .  .  .  .  .  .  .  .  Sel: lit
   610  .  .  .  .  .  .  .  .  .  }
   611  .  .  .  .  .  .  .  .  }
   612  .  .  .  .  .  .  .  }
   613  .  .  .  .  .  .  }
   614  .  .  .  .  .  .  1: *syntax.CaseClause {
   615  .  .  .  .  .  .  .  Cases: _Literal
   616  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
   617  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
   618  .  .  .  .  .  .  .  .  .  Op: <op-0>
   619  .  .  .  .  .  .  .  .  .  Lhs: tok
   620  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
   621  .  .  .  .  .  .  .  .  .  .  Op: +
   622  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   623  .  .  .  .  .  .  .  .  .  .  .  Value: "\"literal \""
   624  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   625  .  .  .  .  .  .  .  .  .  .  }
   626  .  .  .  .  .  .  .  .  .  .  Y: *syntax.SelectorExpr {
   627  .  .  .  .  .  .  .  .  .  .  .  X: p
   628  .  .  .  .  .  .  .  .  .  .  .  Sel: lit
   629  .  .  .  .  .  .  .  .  .  .  }
   630  .  .  .  .  .  .  .  .  .  }
   631  .  .  .  .  .  .  .  .  }
   632  .  .  .  .  .  .  .  }
   633  .  .  .  .  .  .  }
   634  .  .  .  .  .  .  2: *syntax.CaseClause {
   635  .  .  .  .  .  .  .  Cases: _Operator
   636  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
   637  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
   638  .  .  .  .  .  .  .  .  .  Op: <op-0>
   639  .  .  .  .  .  .  .  .  .  Lhs: tok
   640  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
   641  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   642  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   643  .  .  .  .  .  .  .  .  .  .  .  .  X: p
   644  .  .  .  .  .  .  .  .  .  .  .  .  Sel: op
   645  .  .  .  .  .  .  .  .  .  .  .  }
   646  .  .  .  .  .  .  .  .  .  .  .  Sel: String
   647  .  .  .  .  .  .  .  .  .  .  }
   648  .  .  .  .  .  .  .  .  .  .  ArgList: nil
   649  .  .  .  .  .  .  .  .  .  .  HasDots: false
   650  .  .  .  .  .  .  .  .  .  }
   651  .  .  .  .  .  .  .  .  }
   652  .  .  .  .  .  .  .  }
   653  .  .  .  .  .  .  }
   654  .  .  .  .  .  .  3: *syntax.CaseClause {
   655  .  .  .  .  .  .  .  Cases: _AssignOp
   656  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
   657  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
   658  .  .  .  .  .  .  .  .  .  Op: <op-0>
   659  .  .  .  .  .  .  .  .  .  Lhs: tok
   660  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
   661  .  .  .  .  .  .  .  .  .  .  Op: +
   662  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   663  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   664  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   665  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
   666  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: op
   667  .  .  .  .  .  .  .  .  .  .  .  .  }
   668  .  .  .  .  .  .  .  .  .  .  .  .  Sel: String
   669  .  .  .  .  .  .  .  .  .  .  .  }
   670  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
   671  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   672  .  .  .  .  .  .  .  .  .  .  }
   673  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
   674  .  .  .  .  .  .  .  .  .  .  .  Value: "\"=\""
   675  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   676  .  .  .  .  .  .  .  .  .  .  }
   677  .  .  .  .  .  .  .  .  .  }
   678  .  .  .  .  .  .  .  .  }
   679  .  .  .  .  .  .  .  }
   680  .  .  .  .  .  .  }
   681  .  .  .  .  .  .  4: *syntax.CaseClause {
   682  .  .  .  .  .  .  .  Cases: _IncOp
   683  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
   684  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
   685  .  .  .  .  .  .  .  .  .  Op: <op-0>
   686  .  .  .  .  .  .  .  .  .  Lhs: tok
   687  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
   688  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   689  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   690  .  .  .  .  .  .  .  .  .  .  .  .  X: p
   691  .  .  .  .  .  .  .  .  .  .  .  .  Sel: op
   692  .  .  .  .  .  .  .  .  .  .  .  }
   693  .  .  .  .  .  .  .  .  .  .  .  Sel: String
   694  .  .  .  .  .  .  .  .  .  .  }
   695  .  .  .  .  .  .  .  .  .  .  ArgList: nil
   696  .  .  .  .  .  .  .  .  .  .  HasDots: false
   697  .  .  .  .  .  .  .  .  .  }
   698  .  .  .  .  .  .  .  .  }
   699  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
   700  .  .  .  .  .  .  .  .  .  Op: +
   701  .  .  .  .  .  .  .  .  .  Lhs: tok
   702  .  .  .  .  .  .  .  .  .  Rhs: tok
   703  .  .  .  .  .  .  .  .  }
   704  .  .  .  .  .  .  .  }
   705  .  .  .  .  .  .  }
   706  .  .  .  .  .  .  5: *syntax.CaseClause {
   707  .  .  .  .  .  .  .  Cases: nil
   708  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
   709  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
   710  .  .  .  .  .  .  .  .  .  Op: <op-0>
   711  .  .  .  .  .  .  .  .  .  Lhs: tok
   712  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
   713  .  .  .  .  .  .  .  .  .  .  Fun: tokstring
   714  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
   715  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
   716  .  .  .  .  .  .  .  .  .  .  .  .  X: p
   717  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
   718  .  .  .  .  .  .  .  .  .  .  .  }
   719  .  .  .  .  .  .  .  .  .  .  }
   720  .  .  .  .  .  .  .  .  .  .  HasDots: false
   721  .  .  .  .  .  .  .  .  .  }
   722  .  .  .  .  .  .  .  .  }
   723  .  .  .  .  .  .  .  }
   724  .  .  .  .  .  .  }
   725  .  .  .  .  .  }
   726  .  .  .  .  }
   727  .  .  .  .  5: *syntax.ExprStmt {
   728  .  .  .  .  .  X: *syntax.CallExpr {
   729  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   730  .  .  .  .  .  .  .  X: p
   731  .  .  .  .  .  .  .  Sel: error_at
   732  .  .  .  .  .  .  }
   733  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
   734  .  .  .  .  .  .  .  0: pos
   735  .  .  .  .  .  .  .  1: line
   736  .  .  .  .  .  .  .  2: *syntax.Operation {
   737  .  .  .  .  .  .  .  .  Op: +
   738  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   739  .  .  .  .  .  .  .  .  .  Op: +
   740  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   741  .  .  .  .  .  .  .  .  .  .  Value: "\"syntax error: unexpected \""
   742  .  .  .  .  .  .  .  .  .  .  Kind: 4
   743  .  .  .  .  .  .  .  .  .  }
   744  .  .  .  .  .  .  .  .  .  Y: tok
   745  .  .  .  .  .  .  .  .  }
   746  .  .  .  .  .  .  .  .  Y: msg
   747  .  .  .  .  .  .  .  }
   748  .  .  .  .  .  .  }
   749  .  .  .  .  .  .  HasDots: false
   750  .  .  .  .  .  }
   751  .  .  .  .  }
   752  .  .  .  }
   753  .  .  .  Pragma: 0
   754  .  .  .  EndLine: 103
   755  .  .  }
   756  .  .  12: *syntax.ConstDecl {
   757  .  .  .  NameList: []*syntax.Name (1 entries) {
   758  .  .  .  .  0: stopset
   759  .  .  .  }
   760  .  .  .  Type: uint64
   761  .  .  .  Values: *syntax.Operation {
   762  .  .  .  .  Op: |
   763  .  .  .  .  X: *syntax.Operation {
   764  .  .  .  .  .  Op: |
   765  .  .  .  .  .  X: *syntax.Operation {
   766  .  .  .  .  .  .  Op: |
   767  .  .  .  .  .  .  X: *syntax.Operation {
   768  .  .  .  .  .  .  .  Op: |
   769  .  .  .  .  .  .  .  X: *syntax.Operation {
   770  .  .  .  .  .  .  .  .  Op: |
   771  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   772  .  .  .  .  .  .  .  .  .  Op: |
   773  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   774  .  .  .  .  .  .  .  .  .  .  Op: |
   775  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   776  .  .  .  .  .  .  .  .  .  .  .  Op: |
   777  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   778  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
   779  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   780  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
   781  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   782  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
   783  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   784  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
   785  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   786  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
   787  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   788  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
   789  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   790  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
   791  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   792  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
   793  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
   794  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   795  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Break
   796  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   797  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
   798  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
   799  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   800  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
   801  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
   802  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   803  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Const
   804  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   805  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   806  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
   807  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
   808  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   809  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
   810  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
   811  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   812  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Continue
   813  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   814  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   815  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
   816  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
   817  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   818  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
   819  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
   820  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   821  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Defer
   822  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   823  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   824  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
   825  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
   826  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   827  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
   828  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
   829  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   830  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Fallthrough
   831  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   832  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   833  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
   834  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
   835  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   836  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
   837  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
   838  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   839  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _For
   840  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   841  .  .  .  .  .  .  .  .  .  .  .  .  }
   842  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
   843  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
   844  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   845  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
   846  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
   847  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   848  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Func
   849  .  .  .  .  .  .  .  .  .  .  .  .  }
   850  .  .  .  .  .  .  .  .  .  .  .  }
   851  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
   852  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
   853  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   854  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
   855  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
   856  .  .  .  .  .  .  .  .  .  .  .  .  }
   857  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Go
   858  .  .  .  .  .  .  .  .  .  .  .  }
   859  .  .  .  .  .  .  .  .  .  .  }
   860  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
   861  .  .  .  .  .  .  .  .  .  .  .  Op: <<
   862  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   863  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
   864  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
   865  .  .  .  .  .  .  .  .  .  .  .  }
   866  .  .  .  .  .  .  .  .  .  .  .  Y: _Goto
   867  .  .  .  .  .  .  .  .  .  .  }
   868  .  .  .  .  .  .  .  .  .  }
   869  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
   870  .  .  .  .  .  .  .  .  .  .  Op: <<
   871  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   872  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
   873  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
   874  .  .  .  .  .  .  .  .  .  .  }
   875  .  .  .  .  .  .  .  .  .  .  Y: _If
   876  .  .  .  .  .  .  .  .  .  }
   877  .  .  .  .  .  .  .  .  }
   878  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
   879  .  .  .  .  .  .  .  .  .  Op: <<
   880  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   881  .  .  .  .  .  .  .  .  .  .  Value: "1"
   882  .  .  .  .  .  .  .  .  .  .  Kind: 0
   883  .  .  .  .  .  .  .  .  .  }
   884  .  .  .  .  .  .  .  .  .  Y: _Return
   885  .  .  .  .  .  .  .  .  }
   886  .  .  .  .  .  .  .  }
   887  .  .  .  .  .  .  .  Y: *syntax.Operation {
   888  .  .  .  .  .  .  .  .  Op: <<
   889  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   890  .  .  .  .  .  .  .  .  .  Value: "1"
   891  .  .  .  .  .  .  .  .  .  Kind: 0
   892  .  .  .  .  .  .  .  .  }
   893  .  .  .  .  .  .  .  .  Y: _Select
   894  .  .  .  .  .  .  .  }
   895  .  .  .  .  .  .  }
   896  .  .  .  .  .  .  Y: *syntax.Operation {
   897  .  .  .  .  .  .  .  Op: <<
   898  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   899  .  .  .  .  .  .  .  .  Value: "1"
   900  .  .  .  .  .  .  .  .  Kind: 0
   901  .  .  .  .  .  .  .  }
   902  .  .  .  .  .  .  .  Y: _Switch
   903  .  .  .  .  .  .  }
   904  .  .  .  .  .  }
   905  .  .  .  .  .  Y: *syntax.Operation {
   906  .  .  .  .  .  .  Op: <<
   907  .  .  .  .  .  .  X: *syntax.BasicLit {
   908  .  .  .  .  .  .  .  Value: "1"
   909  .  .  .  .  .  .  .  Kind: 0
   910  .  .  .  .  .  .  }
   911  .  .  .  .  .  .  Y: _Type
   912  .  .  .  .  .  }
   913  .  .  .  .  }
   914  .  .  .  .  Y: *syntax.Operation {
   915  .  .  .  .  .  Op: <<
   916  .  .  .  .  .  X: *syntax.BasicLit {
   917  .  .  .  .  .  .  Value: "1"
   918  .  .  .  .  .  .  Kind: 0
   919  .  .  .  .  .  }
   920  .  .  .  .  .  Y: _Var
   921  .  .  .  .  }
   922  .  .  .  }
   923  .  .  .  Group: nil
   924  .  .  }
   925  .  .  13: *syntax.FuncDecl {
   926  .  .  .  Attr: map[]
   927  .  .  .  Recv: *syntax.Field {
   928  .  .  .  .  Name: p
   929  .  .  .  .  Type: *syntax.Operation {
   930  .  .  .  .  .  Op: *
   931  .  .  .  .  .  X: parser
   932  .  .  .  .  .  Y: nil
   933  .  .  .  .  }
   934  .  .  .  }
   935  .  .  .  Name: advance
   936  .  .  .  Type: *syntax.FuncType {
   937  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
   938  .  .  .  .  .  0: *syntax.Field {
   939  .  .  .  .  .  .  Name: followlist
   940  .  .  .  .  .  .  Type: *syntax.DotsType {
   941  .  .  .  .  .  .  .  Elem: token
   942  .  .  .  .  .  .  }
   943  .  .  .  .  .  }
   944  .  .  .  .  }
   945  .  .  .  .  ResultList: nil
   946  .  .  .  }
   947  .  .  .  Body: []syntax.Stmt (4 entries) {
   948  .  .  .  .  0: *syntax.IfStmt {
   949  .  .  .  .  .  Init: nil
   950  .  .  .  .  .  Cond: *syntax.Operation {
   951  .  .  .  .  .  .  Op: ==
   952  .  .  .  .  .  .  X: *syntax.CallExpr {
   953  .  .  .  .  .  .  .  Fun: len
   954  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
   955  .  .  .  .  .  .  .  .  0: followlist
   956  .  .  .  .  .  .  .  }
   957  .  .  .  .  .  .  .  HasDots: false
   958  .  .  .  .  .  .  }
   959  .  .  .  .  .  .  Y: *syntax.BasicLit {
   960  .  .  .  .  .  .  .  Value: "0"
   961  .  .  .  .  .  .  .  Kind: 0
   962  .  .  .  .  .  .  }
   963  .  .  .  .  .  }
   964  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
   965  .  .  .  .  .  .  0: *syntax.ExprStmt {
   966  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   967  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   968  .  .  .  .  .  .  .  .  .  X: p
   969  .  .  .  .  .  .  .  .  .  Sel: next
   970  .  .  .  .  .  .  .  .  }
   971  .  .  .  .  .  .  .  .  ArgList: nil
   972  .  .  .  .  .  .  .  .  HasDots: false
   973  .  .  .  .  .  .  .  }
   974  .  .  .  .  .  .  }
   975  .  .  .  .  .  .  1: *syntax.ReturnStmt {
   976  .  .  .  .  .  .  .  Results: nil
   977  .  .  .  .  .  .  }
   978  .  .  .  .  .  }
   979  .  .  .  .  .  Else: nil
   980  .  .  .  .  }
   981  .  .  .  .  1: *syntax.DeclStmt {
   982  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
   983  .  .  .  .  .  .  0: *syntax.VarDecl {
   984  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
   985  .  .  .  .  .  .  .  .  0: followset
   986  .  .  .  .  .  .  .  }
   987  .  .  .  .  .  .  .  Type: uint64
   988  .  .  .  .  .  .  .  Values: *syntax.Operation {
   989  .  .  .  .  .  .  .  .  Op: <<
   990  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   991  .  .  .  .  .  .  .  .  .  Value: "1"
   992  .  .  .  .  .  .  .  .  .  Kind: 0
   993  .  .  .  .  .  .  .  .  }
   994  .  .  .  .  .  .  .  .  Y: _EOF
   995  .  .  .  .  .  .  .  }
   996  .  .  .  .  .  .  .  Group: nil
   997  .  .  .  .  .  .  }
   998  .  .  .  .  .  }
   999  .  .  .  .  }
  1000  .  .  .  .  2: *syntax.ForStmt {
  1001  .  .  .  .  .  Init: *syntax.RangeClause {
  1002  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
  1003  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  1004  .  .  .  .  .  .  .  .  0: _
  1005  .  .  .  .  .  .  .  .  1: tok
  1006  .  .  .  .  .  .  .  }
  1007  .  .  .  .  .  .  }
  1008  .  .  .  .  .  .  Def: true
  1009  .  .  .  .  .  .  X: followlist
  1010  .  .  .  .  .  }
  1011  .  .  .  .  .  Cond: nil
  1012  .  .  .  .  .  Post: nil
  1013  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1014  .  .  .  .  .  .  0: *syntax.AssignStmt {
  1015  .  .  .  .  .  .  .  Op: |
  1016  .  .  .  .  .  .  .  Lhs: followset
  1017  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
  1018  .  .  .  .  .  .  .  .  Op: <<
  1019  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1020  .  .  .  .  .  .  .  .  .  Value: "1"
  1021  .  .  .  .  .  .  .  .  .  Kind: 0
  1022  .  .  .  .  .  .  .  .  }
  1023  .  .  .  .  .  .  .  .  Y: tok
  1024  .  .  .  .  .  .  .  }
  1025  .  .  .  .  .  .  }
  1026  .  .  .  .  .  }
  1027  .  .  .  .  }
  1028  .  .  .  .  3: *syntax.ForStmt {
  1029  .  .  .  .  .  Init: nil
  1030  .  .  .  .  .  Cond: *syntax.Operation {
  1031  .  .  .  .  .  .  Op: !
  1032  .  .  .  .  .  .  X: *syntax.ParenExpr {
  1033  .  .  .  .  .  .  .  X: *syntax.Operation {
  1034  .  .  .  .  .  .  .  .  Op: ||
  1035  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1036  .  .  .  .  .  .  .  .  .  Fun: contains
  1037  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1038  .  .  .  .  .  .  .  .  .  .  0: followset
  1039  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  1040  .  .  .  .  .  .  .  .  .  .  .  X: p
  1041  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  1042  .  .  .  .  .  .  .  .  .  .  }
  1043  .  .  .  .  .  .  .  .  .  }
  1044  .  .  .  .  .  .  .  .  .  HasDots: false
  1045  .  .  .  .  .  .  .  .  }
  1046  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1047  .  .  .  .  .  .  .  .  .  Op: &&
  1048  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1049  .  .  .  .  .  .  .  .  .  .  Op: >
  1050  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1051  .  .  .  .  .  .  .  .  .  .  .  X: p
  1052  .  .  .  .  .  .  .  .  .  .  .  Sel: fnest
  1053  .  .  .  .  .  .  .  .  .  .  }
  1054  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  1055  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  1056  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1057  .  .  .  .  .  .  .  .  .  .  }
  1058  .  .  .  .  .  .  .  .  .  }
  1059  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
  1060  .  .  .  .  .  .  .  .  .  .  Fun: contains
  1061  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1062  .  .  .  .  .  .  .  .  .  .  .  0: stopset
  1063  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  1064  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1065  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  1066  .  .  .  .  .  .  .  .  .  .  .  }
  1067  .  .  .  .  .  .  .  .  .  .  }
  1068  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1069  .  .  .  .  .  .  .  .  .  }
  1070  .  .  .  .  .  .  .  .  }
  1071  .  .  .  .  .  .  .  }
  1072  .  .  .  .  .  .  }
  1073  .  .  .  .  .  .  Y: nil
  1074  .  .  .  .  .  }
  1075  .  .  .  .  .  Post: nil
  1076  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1077  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1078  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1079  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1080  .  .  .  .  .  .  .  .  .  X: p
  1081  .  .  .  .  .  .  .  .  .  Sel: next
  1082  .  .  .  .  .  .  .  .  }
  1083  .  .  .  .  .  .  .  .  ArgList: nil
  1084  .  .  .  .  .  .  .  .  HasDots: false
  1085  .  .  .  .  .  .  .  }
  1086  .  .  .  .  .  .  }
  1087  .  .  .  .  .  }
  1088  .  .  .  .  }
  1089  .  .  .  }
  1090  .  .  .  Pragma: 0
  1091  .  .  .  EndLine: 144
  1092  .  .  }
  1093  .  .  14: *syntax.FuncDecl {
  1094  .  .  .  Attr: map[]
  1095  .  .  .  Recv: nil
  1096  .  .  .  Name: tokstring
  1097  .  .  .  Type: *syntax.FuncType {
  1098  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  1099  .  .  .  .  .  0: *syntax.Field {
  1100  .  .  .  .  .  .  Name: tok
  1101  .  .  .  .  .  .  Type: token
  1102  .  .  .  .  .  }
  1103  .  .  .  .  }
  1104  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  1105  .  .  .  .  .  0: *syntax.Field {
  1106  .  .  .  .  .  .  Name: nil
  1107  .  .  .  .  .  .  Type: string
  1108  .  .  .  .  .  }
  1109  .  .  .  .  }
  1110  .  .  .  }
  1111  .  .  .  Body: []syntax.Stmt (2 entries) {
  1112  .  .  .  .  0: *syntax.SwitchStmt {
  1113  .  .  .  .  .  Init: nil
  1114  .  .  .  .  .  Tag: tok
  1115  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
  1116  .  .  .  .  .  .  0: *syntax.CaseClause {
  1117  .  .  .  .  .  .  .  Cases: _EOF
  1118  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1119  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  1120  .  .  .  .  .  .  .  .  .  Results: *syntax.BasicLit {
  1121  .  .  .  .  .  .  .  .  .  .  Value: "\"EOF\""
  1122  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1123  .  .  .  .  .  .  .  .  .  }
  1124  .  .  .  .  .  .  .  .  }
  1125  .  .  .  .  .  .  .  }
  1126  .  .  .  .  .  .  }
  1127  .  .  .  .  .  .  1: *syntax.CaseClause {
  1128  .  .  .  .  .  .  .  Cases: _Comma
  1129  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1130  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  1131  .  .  .  .  .  .  .  .  .  Results: *syntax.BasicLit {
  1132  .  .  .  .  .  .  .  .  .  .  Value: "\"comma\""
  1133  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1134  .  .  .  .  .  .  .  .  .  }
  1135  .  .  .  .  .  .  .  .  }
  1136  .  .  .  .  .  .  .  }
  1137  .  .  .  .  .  .  }
  1138  .  .  .  .  .  .  2: *syntax.CaseClause {
  1139  .  .  .  .  .  .  .  Cases: _Semi
  1140  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1141  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  1142  .  .  .  .  .  .  .  .  .  Results: *syntax.BasicLit {
  1143  .  .  .  .  .  .  .  .  .  .  Value: "\"semicolon or newline\""
  1144  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1145  .  .  .  .  .  .  .  .  .  }
  1146  .  .  .  .  .  .  .  .  }
  1147  .  .  .  .  .  .  .  }
  1148  .  .  .  .  .  .  }
  1149  .  .  .  .  .  }
  1150  .  .  .  .  }
  1151  .  .  .  .  1: *syntax.ReturnStmt {
  1152  .  .  .  .  .  Results: *syntax.CallExpr {
  1153  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1154  .  .  .  .  .  .  .  X: tok
  1155  .  .  .  .  .  .  .  Sel: String
  1156  .  .  .  .  .  .  }
  1157  .  .  .  .  .  .  ArgList: nil
  1158  .  .  .  .  .  .  HasDots: false
  1159  .  .  .  .  .  }
  1160  .  .  .  .  }
  1161  .  .  .  }
  1162  .  .  .  Pragma: 0
  1163  .  .  .  EndLine: 156
  1164  .  .  }
  1165  .  .  15: *syntax.FuncDecl {
  1166  .  .  .  Attr: map[]
  1167  .  .  .  Recv: *syntax.Field {
  1168  .  .  .  .  Name: p
  1169  .  .  .  .  Type: *syntax.Operation {
  1170  .  .  .  .  .  Op: *
  1171  .  .  .  .  .  X: parser
  1172  .  .  .  .  .  Y: nil
  1173  .  .  .  .  }
  1174  .  .  .  }
  1175  .  .  .  Name: trace
  1176  .  .  .  Type: *syntax.FuncType {
  1177  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  1178  .  .  .  .  .  0: *syntax.Field {
  1179  .  .  .  .  .  .  Name: msg
  1180  .  .  .  .  .  .  Type: string
  1181  .  .  .  .  .  }
  1182  .  .  .  .  }
  1183  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  1184  .  .  .  .  .  0: *syntax.Field {
  1185  .  .  .  .  .  .  Name: nil
  1186  .  .  .  .  .  .  Type: *syntax.FuncType {
  1187  .  .  .  .  .  .  .  ParamList: nil
  1188  .  .  .  .  .  .  .  ResultList: nil
  1189  .  .  .  .  .  .  }
  1190  .  .  .  .  .  }
  1191  .  .  .  .  }
  1192  .  .  .  }
  1193  .  .  .  Body: []syntax.Stmt (4 entries) {
  1194  .  .  .  .  0: *syntax.ExprStmt {
  1195  .  .  .  .  .  X: *syntax.CallExpr {
  1196  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1197  .  .  .  .  .  .  .  X: fmt
  1198  .  .  .  .  .  .  .  Sel: Printf
  1199  .  .  .  .  .  .  }
  1200  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
  1201  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  1202  .  .  .  .  .  .  .  .  Value: "\"%5d: %s%s (\\n\""
  1203  .  .  .  .  .  .  .  .  Kind: 4
  1204  .  .  .  .  .  .  .  }
  1205  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  1206  .  .  .  .  .  .  .  .  X: p
  1207  .  .  .  .  .  .  .  .  Sel: line
  1208  .  .  .  .  .  .  .  }
  1209  .  .  .  .  .  .  .  2: *syntax.SelectorExpr {
  1210  .  .  .  .  .  .  .  .  X: p
  1211  .  .  .  .  .  .  .  .  Sel: indent
  1212  .  .  .  .  .  .  .  }
  1213  .  .  .  .  .  .  .  3: msg
  1214  .  .  .  .  .  .  }
  1215  .  .  .  .  .  .  HasDots: false
  1216  .  .  .  .  .  }
  1217  .  .  .  .  }
  1218  .  .  .  .  1: *syntax.DeclStmt {
  1219  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
  1220  .  .  .  .  .  .  0: *syntax.ConstDecl {
  1221  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
  1222  .  .  .  .  .  .  .  .  0: tab
  1223  .  .  .  .  .  .  .  }
  1224  .  .  .  .  .  .  .  Type: nil
  1225  .  .  .  .  .  .  .  Values: *syntax.BasicLit {
  1226  .  .  .  .  .  .  .  .  Value: "\". \""
  1227  .  .  .  .  .  .  .  .  Kind: 4
  1228  .  .  .  .  .  .  .  }
  1229  .  .  .  .  .  .  .  Group: nil
  1230  .  .  .  .  .  .  }
  1231  .  .  .  .  .  }
  1232  .  .  .  .  }
  1233  .  .  .  .  2: *syntax.AssignStmt {
  1234  .  .  .  .  .  Op: <op-0>
  1235  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  1236  .  .  .  .  .  .  X: p
  1237  .  .  .  .  .  .  Sel: indent
  1238  .  .  .  .  .  }
  1239  .  .  .  .  .  Rhs: *syntax.CallExpr {
  1240  .  .  .  .  .  .  Fun: append
  1241  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1242  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  1243  .  .  .  .  .  .  .  .  X: p
  1244  .  .  .  .  .  .  .  .  Sel: indent
  1245  .  .  .  .  .  .  .  }
  1246  .  .  .  .  .  .  .  1: tab
  1247  .  .  .  .  .  .  }
  1248  .  .  .  .  .  .  HasDots: true
  1249  .  .  .  .  .  }
  1250  .  .  .  .  }
  1251  .  .  .  .  3: *syntax.ReturnStmt {
  1252  .  .  .  .  .  Results: *syntax.FuncLit {
  1253  .  .  .  .  .  .  Type: *syntax.FuncType {
  1254  .  .  .  .  .  .  .  ParamList: nil
  1255  .  .  .  .  .  .  .  ResultList: nil
  1256  .  .  .  .  .  .  }
  1257  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
  1258  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  1259  .  .  .  .  .  .  .  .  Op: <op-0>
  1260  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  1261  .  .  .  .  .  .  .  .  .  X: p
  1262  .  .  .  .  .  .  .  .  .  Sel: indent
  1263  .  .  .  .  .  .  .  .  }
  1264  .  .  .  .  .  .  .  .  Rhs: *syntax.SliceExpr {
  1265  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1266  .  .  .  .  .  .  .  .  .  .  X: p
  1267  .  .  .  .  .  .  .  .  .  .  Sel: indent
  1268  .  .  .  .  .  .  .  .  .  }
  1269  .  .  .  .  .  .  .  .  .  Index: [<nil> 0xc4200719b0 <nil>]
  1270  .  .  .  .  .  .  .  .  .  Full: false
  1271  .  .  .  .  .  .  .  .  }
  1272  .  .  .  .  .  .  .  }
  1273  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  1274  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
  1275  .  .  .  .  .  .  .  .  .  Op: :
  1276  .  .  .  .  .  .  .  .  .  Lhs: x
  1277  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  1278  .  .  .  .  .  .  .  .  .  .  Fun: recover
  1279  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  1280  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1281  .  .  .  .  .  .  .  .  .  }
  1282  .  .  .  .  .  .  .  .  }
  1283  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  1284  .  .  .  .  .  .  .  .  .  Op: !=
  1285  .  .  .  .  .  .  .  .  .  X: x
  1286  .  .  .  .  .  .  .  .  .  Y: nil
  1287  .  .  .  .  .  .  .  .  }
  1288  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  1289  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1290  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1291  .  .  .  .  .  .  .  .  .  .  .  Fun: panic
  1292  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1293  .  .  .  .  .  .  .  .  .  .  .  .  0: x
  1294  .  .  .  .  .  .  .  .  .  .  .  }
  1295  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1296  .  .  .  .  .  .  .  .  .  .  }
  1297  .  .  .  .  .  .  .  .  .  }
  1298  .  .  .  .  .  .  .  .  }
  1299  .  .  .  .  .  .  .  .  Else: nil
  1300  .  .  .  .  .  .  .  }
  1301  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  1302  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1303  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1304  .  .  .  .  .  .  .  .  .  .  X: fmt
  1305  .  .  .  .  .  .  .  .  .  .  Sel: Printf
  1306  .  .  .  .  .  .  .  .  .  }
  1307  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
  1308  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  1309  .  .  .  .  .  .  .  .  .  .  .  Value: "\"%5d: %s)\\n\""
  1310  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1311  .  .  .  .  .  .  .  .  .  .  }
  1312  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  1313  .  .  .  .  .  .  .  .  .  .  .  X: p
  1314  .  .  .  .  .  .  .  .  .  .  .  Sel: line
  1315  .  .  .  .  .  .  .  .  .  .  }
  1316  .  .  .  .  .  .  .  .  .  .  2: *syntax.SelectorExpr {
  1317  .  .  .  .  .  .  .  .  .  .  .  X: p
  1318  .  .  .  .  .  .  .  .  .  .  .  Sel: indent
  1319  .  .  .  .  .  .  .  .  .  .  }
  1320  .  .  .  .  .  .  .  .  .  }
  1321  .  .  .  .  .  .  .  .  .  HasDots: false
  1322  .  .  .  .  .  .  .  .  }
  1323  .  .  .  .  .  .  .  }
  1324  .  .  .  .  .  .  }
  1325  .  .  .  .  .  .  EndLine: 169
  1326  .  .  .  .  .  }
  1327  .  .  .  .  }
  1328  .  .  .  }
  1329  .  .  .  Pragma: 0
  1330  .  .  .  EndLine: 170
  1331  .  .  }
  1332  .  .  16: *syntax.FuncDecl {
  1333  .  .  .  Attr: map[]
  1334  .  .  .  Recv: *syntax.Field {
  1335  .  .  .  .  Name: p
  1336  .  .  .  .  Type: *syntax.Operation {
  1337  .  .  .  .  .  Op: *
  1338  .  .  .  .  .  X: parser
  1339  .  .  .  .  .  Y: nil
  1340  .  .  .  .  }
  1341  .  .  .  }
  1342  .  .  .  Name: file
  1343  .  .  .  Type: *syntax.FuncType {
  1344  .  .  .  .  ParamList: nil
  1345  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  1346  .  .  .  .  .  0: *syntax.Field {
  1347  .  .  .  .  .  .  Name: nil
  1348  .  .  .  .  .  .  Type: *syntax.Operation {
  1349  .  .  .  .  .  .  .  Op: *
  1350  .  .  .  .  .  .  .  X: File
  1351  .  .  .  .  .  .  .  Y: nil
  1352  .  .  .  .  .  .  }
  1353  .  .  .  .  .  }
  1354  .  .  .  .  }
  1355  .  .  .  }
  1356  .  .  .  Body: []syntax.Stmt (11 entries) {
  1357  .  .  .  .  0: *syntax.IfStmt {
  1358  .  .  .  .  .  Init: nil
  1359  .  .  .  .  .  Cond: trace
  1360  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  1361  .  .  .  .  .  .  0: *syntax.CallStmt {
  1362  .  .  .  .  .  .  .  Tok: defer
  1363  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  1364  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  1365  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1366  .  .  .  .  .  .  .  .  .  .  X: p
  1367  .  .  .  .  .  .  .  .  .  .  Sel: trace
  1368  .  .  .  .  .  .  .  .  .  }
  1369  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1370  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  1371  .  .  .  .  .  .  .  .  .  .  .  Value: "\"file\""
  1372  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1373  .  .  .  .  .  .  .  .  .  .  }
  1374  .  .  .  .  .  .  .  .  .  }
  1375  .  .  .  .  .  .  .  .  .  HasDots: false
  1376  .  .  .  .  .  .  .  .  }
  1377  .  .  .  .  .  .  .  .  ArgList: nil
  1378  .  .  .  .  .  .  .  .  HasDots: false
  1379  .  .  .  .  .  .  .  }
  1380  .  .  .  .  .  .  }
  1381  .  .  .  .  .  }
  1382  .  .  .  .  .  Else: nil
  1383  .  .  .  .  }
  1384  .  .  .  .  1: *syntax.AssignStmt {
  1385  .  .  .  .  .  Op: :
  1386  .  .  .  .  .  Lhs: f
  1387  .  .  .  .  .  Rhs: *syntax.CallExpr {
  1388  .  .  .  .  .  .  Fun: new
  1389  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1390  .  .  .  .  .  .  .  0: File
  1391  .  .  .  .  .  .  }
  1392  .  .  .  .  .  .  HasDots: false
  1393  .  .  .  .  .  }
  1394  .  .  .  .  }
  1395  .  .  .  .  2: *syntax.ExprStmt {
  1396  .  .  .  .  .  X: *syntax.CallExpr {
  1397  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1398  .  .  .  .  .  .  .  X: f
  1399  .  .  .  .  .  .  .  Sel: init
  1400  .  .  .  .  .  .  }
  1401  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1402  .  .  .  .  .  .  .  0: p
  1403  .  .  .  .  .  .  }
  1404  .  .  .  .  .  .  HasDots: false
  1405  .  .  .  .  .  }
  1406  .  .  .  .  }
  1407  .  .  .  .  3: *syntax.IfStmt {
  1408  .  .  .  .  .  Init: nil
  1409  .  .  .  .  .  Cond: *syntax.Operation {
  1410  .  .  .  .  .  .  Op: !
  1411  .  .  .  .  .  .  X: *syntax.CallExpr {
  1412  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1413  .  .  .  .  .  .  .  .  X: p
  1414  .  .  .  .  .  .  .  .  Sel: got
  1415  .  .  .  .  .  .  .  }
  1416  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1417  .  .  .  .  .  .  .  .  0: _Package
  1418  .  .  .  .  .  .  .  }
  1419  .  .  .  .  .  .  .  HasDots: false
  1420  .  .  .  .  .  .  }
  1421  .  .  .  .  .  .  Y: nil
  1422  .  .  .  .  .  }
  1423  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
  1424  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1425  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1426  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1427  .  .  .  .  .  .  .  .  .  X: p
  1428  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  1429  .  .  .  .  .  .  .  .  }
  1430  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1431  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  1432  .  .  .  .  .  .  .  .  .  .  Value: "\"package statement must be first\""
  1433  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1434  .  .  .  .  .  .  .  .  .  }
  1435  .  .  .  .  .  .  .  .  }
  1436  .  .  .  .  .  .  .  .  HasDots: false
  1437  .  .  .  .  .  .  .  }
  1438  .  .  .  .  .  .  }
  1439  .  .  .  .  .  .  1: *syntax.ReturnStmt {
  1440  .  .  .  .  .  .  .  Results: nil
  1441  .  .  .  .  .  .  }
  1442  .  .  .  .  .  }
  1443  .  .  .  .  .  Else: nil
  1444  .  .  .  .  }
  1445  .  .  .  .  4: *syntax.AssignStmt {
  1446  .  .  .  .  .  Op: <op-0>
  1447  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  1448  .  .  .  .  .  .  X: f
  1449  .  .  .  .  .  .  Sel: PkgName
  1450  .  .  .  .  .  }
  1451  .  .  .  .  .  Rhs: *syntax.CallExpr {
  1452  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1453  .  .  .  .  .  .  .  X: p
  1454  .  .  .  .  .  .  .  Sel: name
  1455  .  .  .  .  .  .  }
  1456  .  .  .  .  .  .  ArgList: nil
  1457  .  .  .  .  .  .  HasDots: false
  1458  .  .  .  .  .  }
  1459  .  .  .  .  }
  1460  .  .  .  .  5: *syntax.ExprStmt {
  1461  .  .  .  .  .  X: *syntax.CallExpr {
  1462  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1463  .  .  .  .  .  .  .  X: p
  1464  .  .  .  .  .  .  .  Sel: want
  1465  .  .  .  .  .  .  }
  1466  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1467  .  .  .  .  .  .  .  0: _Semi
  1468  .  .  .  .  .  .  }
  1469  .  .  .  .  .  .  HasDots: false
  1470  .  .  .  .  .  }
  1471  .  .  .  .  }
  1472  .  .  .  .  6: *syntax.IfStmt {
  1473  .  .  .  .  .  Init: nil
  1474  .  .  .  .  .  Cond: *syntax.Operation {
  1475  .  .  .  .  .  .  Op: !=
  1476  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1477  .  .  .  .  .  .  .  X: p
  1478  .  .  .  .  .  .  .  Sel: first
  1479  .  .  .  .  .  .  }
  1480  .  .  .  .  .  .  Y: nil
  1481  .  .  .  .  .  }
  1482  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  1483  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  1484  .  .  .  .  .  .  .  Results: nil
  1485  .  .  .  .  .  .  }
  1486  .  .  .  .  .  }
  1487  .  .  .  .  .  Else: nil
  1488  .  .  .  .  }
  1489  .  .  .  .  7: *syntax.ForStmt {
  1490  .  .  .  .  .  Init: nil
  1491  .  .  .  .  .  Cond: *syntax.CallExpr {
  1492  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1493  .  .  .  .  .  .  .  X: p
  1494  .  .  .  .  .  .  .  Sel: got
  1495  .  .  .  .  .  .  }
  1496  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1497  .  .  .  .  .  .  .  0: _Import
  1498  .  .  .  .  .  .  }
  1499  .  .  .  .  .  .  HasDots: false
  1500  .  .  .  .  .  }
  1501  .  .  .  .  .  Post: nil
  1502  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  1503  .  .  .  .  .  .  0: *syntax.AssignStmt {
  1504  .  .  .  .  .  .  .  Op: <op-0>
  1505  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  1506  .  .  .  .  .  .  .  .  X: f
  1507  .  .  .  .  .  .  .  .  Sel: DeclList
  1508  .  .  .  .  .  .  .  }
  1509  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  1510  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1511  .  .  .  .  .  .  .  .  .  X: p
  1512  .  .  .  .  .  .  .  .  .  Sel: appendGroup
  1513  .  .  .  .  .  .  .  .  }
  1514  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1515  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  1516  .  .  .  .  .  .  .  .  .  .  X: f
  1517  .  .  .  .  .  .  .  .  .  .  Sel: DeclList
  1518  .  .  .  .  .  .  .  .  .  }
  1519  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  1520  .  .  .  .  .  .  .  .  .  .  X: p
  1521  .  .  .  .  .  .  .  .  .  .  Sel: importDecl
  1522  .  .  .  .  .  .  .  .  .  }
  1523  .  .  .  .  .  .  .  .  }
  1524  .  .  .  .  .  .  .  .  HasDots: false
  1525  .  .  .  .  .  .  .  }
  1526  .  .  .  .  .  .  }
  1527  .  .  .  .  .  .  1: *syntax.ExprStmt {
  1528  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1529  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1530  .  .  .  .  .  .  .  .  .  X: p
  1531  .  .  .  .  .  .  .  .  .  Sel: want
  1532  .  .  .  .  .  .  .  .  }
  1533  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1534  .  .  .  .  .  .  .  .  .  0: _Semi
  1535  .  .  .  .  .  .  .  .  }
  1536  .  .  .  .  .  .  .  .  HasDots: false
  1537  .  .  .  .  .  .  .  }
  1538  .  .  .  .  .  .  }
  1539  .  .  .  .  .  }
  1540  .  .  .  .  }
  1541  .  .  .  .  8: *syntax.ForStmt {
  1542  .  .  .  .  .  Init: nil
  1543  .  .  .  .  .  Cond: *syntax.Operation {
  1544  .  .  .  .  .  .  Op: !=
  1545  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1546  .  .  .  .  .  .  .  X: p
  1547  .  .  .  .  .  .  .  Sel: tok
  1548  .  .  .  .  .  .  }
  1549  .  .  .  .  .  .  Y: _EOF
  1550  .  .  .  .  .  }
  1551  .  .  .  .  .  Post: nil
  1552  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
  1553  .  .  .  .  .  .  0: *syntax.SwitchStmt {
  1554  .  .  .  .  .  .  .  Init: nil
  1555  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  1556  .  .  .  .  .  .  .  .  X: p
  1557  .  .  .  .  .  .  .  .  Sel: tok
  1558  .  .  .  .  .  .  .  }
  1559  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (5 entries) {
  1560  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  1561  .  .  .  .  .  .  .  .  .  Cases: _Const
  1562  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  1563  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1564  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1565  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1566  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1567  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  1568  .  .  .  .  .  .  .  .  .  .  .  .  }
  1569  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  1570  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1571  .  .  .  .  .  .  .  .  .  .  .  }
  1572  .  .  .  .  .  .  .  .  .  .  }
  1573  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  1574  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  1575  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  1576  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  1577  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList
  1578  .  .  .  .  .  .  .  .  .  .  .  }
  1579  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  1580  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1581  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1582  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: appendGroup
  1583  .  .  .  .  .  .  .  .  .  .  .  .  }
  1584  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1585  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  1586  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  1587  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList
  1588  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1589  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  1590  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1591  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: constDecl
  1592  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1593  .  .  .  .  .  .  .  .  .  .  .  .  }
  1594  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1595  .  .  .  .  .  .  .  .  .  .  .  }
  1596  .  .  .  .  .  .  .  .  .  .  }
  1597  .  .  .  .  .  .  .  .  .  }
  1598  .  .  .  .  .  .  .  .  }
  1599  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  1600  .  .  .  .  .  .  .  .  .  Cases: _Type
  1601  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  1602  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1603  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1604  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1605  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1606  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  1607  .  .  .  .  .  .  .  .  .  .  .  .  }
  1608  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  1609  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1610  .  .  .  .  .  .  .  .  .  .  .  }
  1611  .  .  .  .  .  .  .  .  .  .  }
  1612  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  1613  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  1614  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  1615  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  1616  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList
  1617  .  .  .  .  .  .  .  .  .  .  .  }
  1618  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  1619  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1620  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1621  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: appendGroup
  1622  .  .  .  .  .  .  .  .  .  .  .  .  }
  1623  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1624  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  1625  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  1626  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList
  1627  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1628  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  1629  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1630  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: typeDecl
  1631  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1632  .  .  .  .  .  .  .  .  .  .  .  .  }
  1633  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1634  .  .  .  .  .  .  .  .  .  .  .  }
  1635  .  .  .  .  .  .  .  .  .  .  }
  1636  .  .  .  .  .  .  .  .  .  }
  1637  .  .  .  .  .  .  .  .  }
  1638  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  1639  .  .  .  .  .  .  .  .  .  Cases: _Var
  1640  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  1641  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1642  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1643  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1644  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1645  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  1646  .  .  .  .  .  .  .  .  .  .  .  .  }
  1647  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  1648  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1649  .  .  .  .  .  .  .  .  .  .  .  }
  1650  .  .  .  .  .  .  .  .  .  .  }
  1651  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  1652  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  1653  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  1654  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  1655  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList
  1656  .  .  .  .  .  .  .  .  .  .  .  }
  1657  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  1658  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1659  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1660  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: appendGroup
  1661  .  .  .  .  .  .  .  .  .  .  .  .  }
  1662  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1663  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  1664  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  1665  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList
  1666  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1667  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  1668  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1669  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: varDecl
  1670  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1671  .  .  .  .  .  .  .  .  .  .  .  .  }
  1672  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1673  .  .  .  .  .  .  .  .  .  .  .  }
  1674  .  .  .  .  .  .  .  .  .  .  }
  1675  .  .  .  .  .  .  .  .  .  }
  1676  .  .  .  .  .  .  .  .  }
  1677  .  .  .  .  .  .  .  .  3: *syntax.CaseClause {
  1678  .  .  .  .  .  .  .  .  .  Cases: _Func
  1679  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  1680  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1681  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1682  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1683  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1684  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  1685  .  .  .  .  .  .  .  .  .  .  .  .  }
  1686  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  1687  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1688  .  .  .  .  .  .  .  .  .  .  .  }
  1689  .  .  .  .  .  .  .  .  .  .  }
  1690  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  1691  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  1692  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  1693  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  1694  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList
  1695  .  .  .  .  .  .  .  .  .  .  .  }
  1696  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  1697  .  .  .  .  .  .  .  .  .  .  .  .  Fun: append
  1698  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1699  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  1700  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  1701  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList
  1702  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1703  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
  1704  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1705  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1706  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: funcDecl
  1707  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1708  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  1709  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1710  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1711  .  .  .  .  .  .  .  .  .  .  .  .  }
  1712  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1713  .  .  .  .  .  .  .  .  .  .  .  }
  1714  .  .  .  .  .  .  .  .  .  .  }
  1715  .  .  .  .  .  .  .  .  .  }
  1716  .  .  .  .  .  .  .  .  }
  1717  .  .  .  .  .  .  .  .  4: *syntax.CaseClause {
  1718  .  .  .  .  .  .  .  .  .  Cases: nil
  1719  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
  1720  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
  1721  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  1722  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  1723  .  .  .  .  .  .  .  .  .  .  .  .  Op: &&
  1724  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1725  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: &&
  1726  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1727  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  1728  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1729  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1730  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  1731  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1732  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Lbrace
  1733  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1734  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1735  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: >
  1736  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1737  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: len
  1738  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1739  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  1740  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  1741  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList
  1742  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1743  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1744  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1745  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1746  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  1747  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  1748  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1749  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1750  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1751  .  .  .  .  .  .  .  .  .  .  .  .  }
  1752  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
  1753  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: emptyFuncDecl
  1754  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1755  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IndexExpr {
  1756  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1757  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  1758  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList
  1759  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1760  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.Operation {
  1761  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: -
  1762  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1763  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: len
  1764  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1765  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  1766  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  1767  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList
  1768  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1769  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1770  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1771  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1772  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  1773  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1774  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1775  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1776  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1777  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1778  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1779  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1780  .  .  .  .  .  .  .  .  .  .  .  .  }
  1781  .  .  .  .  .  .  .  .  .  .  .  }
  1782  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  1783  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1784  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1785  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1786  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1787  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  1788  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1789  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1790  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  1791  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"unexpected semicolon or newline before {\""
  1792  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1793  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1794  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1795  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1796  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1797  .  .  .  .  .  .  .  .  .  .  .  .  }
  1798  .  .  .  .  .  .  .  .  .  .  .  }
  1799  .  .  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
  1800  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1801  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1802  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1803  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1804  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1805  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  1806  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1807  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1808  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  1809  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"non-declaration statement outside function body\""
  1810  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1811  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1812  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1813  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1814  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1815  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1816  .  .  .  .  .  .  .  .  .  .  .  .  }
  1817  .  .  .  .  .  .  .  .  .  .  .  }
  1818  .  .  .  .  .  .  .  .  .  .  }
  1819  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  1820  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1821  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1822  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  1823  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
  1824  .  .  .  .  .  .  .  .  .  .  .  .  }
  1825  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
  1826  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Const
  1827  .  .  .  .  .  .  .  .  .  .  .  .  .  1: _Type
  1828  .  .  .  .  .  .  .  .  .  .  .  .  .  2: _Var
  1829  .  .  .  .  .  .  .  .  .  .  .  .  .  3: _Func
  1830  .  .  .  .  .  .  .  .  .  .  .  .  }
  1831  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1832  .  .  .  .  .  .  .  .  .  .  .  }
  1833  .  .  .  .  .  .  .  .  .  .  }
  1834  .  .  .  .  .  .  .  .  .  .  2: *syntax.BranchStmt {
  1835  .  .  .  .  .  .  .  .  .  .  .  Tok: continue
  1836  .  .  .  .  .  .  .  .  .  .  .  Label: nil
  1837  .  .  .  .  .  .  .  .  .  .  }
  1838  .  .  .  .  .  .  .  .  .  }
  1839  .  .  .  .  .  .  .  .  }
  1840  .  .  .  .  .  .  .  }
  1841  .  .  .  .  .  .  }
  1842  .  .  .  .  .  .  1: *syntax.AssignStmt {
  1843  .  .  .  .  .  .  .  Op: <op-0>
  1844  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  1845  .  .  .  .  .  .  .  .  X: p
  1846  .  .  .  .  .  .  .  .  Sel: pragma
  1847  .  .  .  .  .  .  .  }
  1848  .  .  .  .  .  .  .  Rhs: *syntax.BasicLit {
  1849  .  .  .  .  .  .  .  .  Value: "0"
  1850  .  .  .  .  .  .  .  .  Kind: 0
  1851  .  .  .  .  .  .  .  }
  1852  .  .  .  .  .  .  }
  1853  .  .  .  .  .  .  2: *syntax.IfStmt {
  1854  .  .  .  .  .  .  .  Init: nil
  1855  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  1856  .  .  .  .  .  .  .  .  Op: &&
  1857  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1858  .  .  .  .  .  .  .  .  .  Op: !=
  1859  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1860  .  .  .  .  .  .  .  .  .  .  X: p
  1861  .  .  .  .  .  .  .  .  .  .  Sel: tok
  1862  .  .  .  .  .  .  .  .  .  }
  1863  .  .  .  .  .  .  .  .  .  Y: _EOF
  1864  .  .  .  .  .  .  .  .  }
  1865  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1866  .  .  .  .  .  .  .  .  .  Op: !
  1867  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1868  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1869  .  .  .  .  .  .  .  .  .  .  .  X: p
  1870  .  .  .  .  .  .  .  .  .  .  .  Sel: got
  1871  .  .  .  .  .  .  .  .  .  .  }
  1872  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1873  .  .  .  .  .  .  .  .  .  .  .  0: _Semi
  1874  .  .  .  .  .  .  .  .  .  .  }
  1875  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1876  .  .  .  .  .  .  .  .  .  }
  1877  .  .  .  .  .  .  .  .  .  Y: nil
  1878  .  .  .  .  .  .  .  .  }
  1879  .  .  .  .  .  .  .  }
  1880  .  .  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
  1881  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1882  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1883  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1884  .  .  .  .  .  .  .  .  .  .  .  X: p
  1885  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  1886  .  .  .  .  .  .  .  .  .  .  }
  1887  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1888  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  1889  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"after top level declaration\""
  1890  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1891  .  .  .  .  .  .  .  .  .  .  .  }
  1892  .  .  .  .  .  .  .  .  .  .  }
  1893  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1894  .  .  .  .  .  .  .  .  .  }
  1895  .  .  .  .  .  .  .  .  }
  1896  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  1897  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1898  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1899  .  .  .  .  .  .  .  .  .  .  .  X: p
  1900  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
  1901  .  .  .  .  .  .  .  .  .  .  }
  1902  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
  1903  .  .  .  .  .  .  .  .  .  .  .  0: _Const
  1904  .  .  .  .  .  .  .  .  .  .  .  1: _Type
  1905  .  .  .  .  .  .  .  .  .  .  .  2: _Var
  1906  .  .  .  .  .  .  .  .  .  .  .  3: _Func
  1907  .  .  .  .  .  .  .  .  .  .  }
  1908  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1909  .  .  .  .  .  .  .  .  .  }
  1910  .  .  .  .  .  .  .  .  }
  1911  .  .  .  .  .  .  .  }
  1912  .  .  .  .  .  .  .  Else: nil
  1913  .  .  .  .  .  .  }
  1914  .  .  .  .  .  }
  1915  .  .  .  .  }
  1916  .  .  .  .  9: *syntax.AssignStmt {
  1917  .  .  .  .  .  Op: <op-0>
  1918  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  1919  .  .  .  .  .  .  X: f
  1920  .  .  .  .  .  .  Sel: Lines
  1921  .  .  .  .  .  }
  1922  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  1923  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1924  .  .  .  .  .  .  .  X: p
  1925  .  .  .  .  .  .  .  Sel: source
  1926  .  .  .  .  .  .  }
  1927  .  .  .  .  .  .  Sel: line
  1928  .  .  .  .  .  }
  1929  .  .  .  .  }
  1930  .  .  .  .  10: *syntax.ReturnStmt {
  1931  .  .  .  .  .  Results: f
  1932  .  .  .  .  }
  1933  .  .  .  }
  1934  .  .  .  Pragma: 0
  1935  .  .  .  EndLine: 251
  1936  .  .  }
  1937  .  .  17: *syntax.FuncDecl {
  1938  .  .  .  Attr: map[]
  1939  .  .  .  Recv: nil
  1940  .  .  .  Name: emptyFuncDecl
  1941  .  .  .  Type: *syntax.FuncType {
  1942  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  1943  .  .  .  .  .  0: *syntax.Field {
  1944  .  .  .  .  .  .  Name: dcl
  1945  .  .  .  .  .  .  Type: Decl
  1946  .  .  .  .  .  }
  1947  .  .  .  .  }
  1948  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  1949  .  .  .  .  .  0: *syntax.Field {
  1950  .  .  .  .  .  .  Name: nil
  1951  .  .  .  .  .  .  Type: bool
  1952  .  .  .  .  .  }
  1953  .  .  .  .  }
  1954  .  .  .  }
  1955  .  .  .  Body: []syntax.Stmt (2 entries) {
  1956  .  .  .  .  0: *syntax.AssignStmt {
  1957  .  .  .  .  .  Op: :
  1958  .  .  .  .  .  Lhs: *syntax.ListExpr {
  1959  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  1960  .  .  .  .  .  .  .  0: f
  1961  .  .  .  .  .  .  .  1: ok
  1962  .  .  .  .  .  .  }
  1963  .  .  .  .  .  }
  1964  .  .  .  .  .  Rhs: *syntax.AssertExpr {
  1965  .  .  .  .  .  .  X: dcl
  1966  .  .  .  .  .  .  Type: *syntax.Operation {
  1967  .  .  .  .  .  .  .  Op: *
  1968  .  .  .  .  .  .  .  X: FuncDecl
  1969  .  .  .  .  .  .  .  Y: nil
  1970  .  .  .  .  .  .  }
  1971  .  .  .  .  .  }
  1972  .  .  .  .  }
  1973  .  .  .  .  1: *syntax.ReturnStmt {
  1974  .  .  .  .  .  Results: *syntax.Operation {
  1975  .  .  .  .  .  .  Op: &&
  1976  .  .  .  .  .  .  X: ok
  1977  .  .  .  .  .  .  Y: *syntax.Operation {
  1978  .  .  .  .  .  .  .  Op: ==
  1979  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1980  .  .  .  .  .  .  .  .  X: f
  1981  .  .  .  .  .  .  .  .  Sel: Body
  1982  .  .  .  .  .  .  .  }
  1983  .  .  .  .  .  .  .  Y: nil
  1984  .  .  .  .  .  .  }
  1985  .  .  .  .  .  }
  1986  .  .  .  .  }
  1987  .  .  .  }
  1988  .  .  .  Pragma: 0
  1989  .  .  .  EndLine: 256
  1990  .  .  }
  1991  .  .  18: *syntax.FuncDecl {
  1992  .  .  .  Attr: map[]
  1993  .  .  .  Recv: *syntax.Field {
  1994  .  .  .  .  Name: p
  1995  .  .  .  .  Type: *syntax.Operation {
  1996  .  .  .  .  .  Op: *
  1997  .  .  .  .  .  X: parser
  1998  .  .  .  .  .  Y: nil
  1999  .  .  .  .  }
  2000  .  .  .  }
  2001  .  .  .  Name: appendGroup
  2002  .  .  .  Type: *syntax.FuncType {
  2003  .  .  .  .  ParamList: []*syntax.Field (2 entries) {
  2004  .  .  .  .  .  0: *syntax.Field {
  2005  .  .  .  .  .  .  Name: list
  2006  .  .  .  .  .  .  Type: *syntax.SliceType {
  2007  .  .  .  .  .  .  .  Elem: Decl
  2008  .  .  .  .  .  .  }
  2009  .  .  .  .  .  }
  2010  .  .  .  .  .  1: *syntax.Field {
  2011  .  .  .  .  .  .  Name: f
  2012  .  .  .  .  .  .  Type: *syntax.FuncType {
  2013  .  .  .  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  2014  .  .  .  .  .  .  .  .  0: *syntax.Field {
  2015  .  .  .  .  .  .  .  .  .  Name: nil
  2016  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
  2017  .  .  .  .  .  .  .  .  .  .  Op: *
  2018  .  .  .  .  .  .  .  .  .  .  X: Group
  2019  .  .  .  .  .  .  .  .  .  .  Y: nil
  2020  .  .  .  .  .  .  .  .  .  }
  2021  .  .  .  .  .  .  .  .  }
  2022  .  .  .  .  .  .  .  }
  2023  .  .  .  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  2024  .  .  .  .  .  .  .  .  0: *syntax.Field {
  2025  .  .  .  .  .  .  .  .  .  Name: nil
  2026  .  .  .  .  .  .  .  .  .  Type: Decl
  2027  .  .  .  .  .  .  .  .  }
  2028  .  .  .  .  .  .  .  }
  2029  .  .  .  .  .  .  }
  2030  .  .  .  .  .  }
  2031  .  .  .  .  }
  2032  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  2033  .  .  .  .  .  0: *syntax.Field {
  2034  .  .  .  .  .  .  Name: nil
  2035  .  .  .  .  .  .  Type: *syntax.SliceType {
  2036  .  .  .  .  .  .  .  Elem: Decl
  2037  .  .  .  .  .  .  }
  2038  .  .  .  .  .  }
  2039  .  .  .  .  }
  2040  .  .  .  }
  2041  .  .  .  Body: []syntax.Stmt (2 entries) {
  2042  .  .  .  .  0: *syntax.IfStmt {
  2043  .  .  .  .  .  Init: nil
  2044  .  .  .  .  .  Cond: *syntax.CallExpr {
  2045  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2046  .  .  .  .  .  .  .  X: p
  2047  .  .  .  .  .  .  .  Sel: got
  2048  .  .  .  .  .  .  }
  2049  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2050  .  .  .  .  .  .  .  0: _Lparen
  2051  .  .  .  .  .  .  }
  2052  .  .  .  .  .  .  HasDots: false
  2053  .  .  .  .  .  }
  2054  .  .  .  .  .  Then: []syntax.Stmt (4 entries) {
  2055  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2056  .  .  .  .  .  .  .  Op: :
  2057  .  .  .  .  .  .  .  Lhs: g
  2058  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2059  .  .  .  .  .  .  .  .  Fun: new
  2060  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2061  .  .  .  .  .  .  .  .  .  0: Group
  2062  .  .  .  .  .  .  .  .  }
  2063  .  .  .  .  .  .  .  .  HasDots: false
  2064  .  .  .  .  .  .  .  }
  2065  .  .  .  .  .  .  }
  2066  .  .  .  .  .  .  1: *syntax.ForStmt {
  2067  .  .  .  .  .  .  .  Init: nil
  2068  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  2069  .  .  .  .  .  .  .  .  Op: &&
  2070  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  2071  .  .  .  .  .  .  .  .  .  Op: !=
  2072  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2073  .  .  .  .  .  .  .  .  .  .  X: p
  2074  .  .  .  .  .  .  .  .  .  .  Sel: tok
  2075  .  .  .  .  .  .  .  .  .  }
  2076  .  .  .  .  .  .  .  .  .  Y: _EOF
  2077  .  .  .  .  .  .  .  .  }
  2078  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  2079  .  .  .  .  .  .  .  .  .  Op: !=
  2080  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2081  .  .  .  .  .  .  .  .  .  .  X: p
  2082  .  .  .  .  .  .  .  .  .  .  Sel: tok
  2083  .  .  .  .  .  .  .  .  .  }
  2084  .  .  .  .  .  .  .  .  .  Y: _Rparen
  2085  .  .  .  .  .  .  .  .  }
  2086  .  .  .  .  .  .  .  }
  2087  .  .  .  .  .  .  .  Post: nil
  2088  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  2089  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2090  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2091  .  .  .  .  .  .  .  .  .  Lhs: list
  2092  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2093  .  .  .  .  .  .  .  .  .  .  Fun: append
  2094  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  2095  .  .  .  .  .  .  .  .  .  .  .  0: list
  2096  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
  2097  .  .  .  .  .  .  .  .  .  .  .  .  Fun: f
  2098  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2099  .  .  .  .  .  .  .  .  .  .  .  .  .  0: g
  2100  .  .  .  .  .  .  .  .  .  .  .  .  }
  2101  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2102  .  .  .  .  .  .  .  .  .  .  .  }
  2103  .  .  .  .  .  .  .  .  .  .  }
  2104  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2105  .  .  .  .  .  .  .  .  .  }
  2106  .  .  .  .  .  .  .  .  }
  2107  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  2108  .  .  .  .  .  .  .  .  .  Init: nil
  2109  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  2110  .  .  .  .  .  .  .  .  .  .  Op: !
  2111  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2112  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2113  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  2114  .  .  .  .  .  .  .  .  .  .  .  .  Sel: osemi
  2115  .  .  .  .  .  .  .  .  .  .  .  }
  2116  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2117  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen
  2118  .  .  .  .  .  .  .  .  .  .  .  }
  2119  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2120  .  .  .  .  .  .  .  .  .  .  }
  2121  .  .  .  .  .  .  .  .  .  .  Y: nil
  2122  .  .  .  .  .  .  .  .  .  }
  2123  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  2124  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  2125  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  2126  .  .  .  .  .  .  .  .  .  .  .  Label: nil
  2127  .  .  .  .  .  .  .  .  .  .  }
  2128  .  .  .  .  .  .  .  .  .  }
  2129  .  .  .  .  .  .  .  .  .  Else: nil
  2130  .  .  .  .  .  .  .  .  }
  2131  .  .  .  .  .  .  .  }
  2132  .  .  .  .  .  .  }
  2133  .  .  .  .  .  .  2: *syntax.ExprStmt {
  2134  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2135  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2136  .  .  .  .  .  .  .  .  .  X: p
  2137  .  .  .  .  .  .  .  .  .  Sel: want
  2138  .  .  .  .  .  .  .  .  }
  2139  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2140  .  .  .  .  .  .  .  .  .  0: _Rparen
  2141  .  .  .  .  .  .  .  .  }
  2142  .  .  .  .  .  .  .  .  HasDots: false
  2143  .  .  .  .  .  .  .  }
  2144  .  .  .  .  .  .  }
  2145  .  .  .  .  .  .  3: *syntax.ReturnStmt {
  2146  .  .  .  .  .  .  .  Results: list
  2147  .  .  .  .  .  .  }
  2148  .  .  .  .  .  }
  2149  .  .  .  .  .  Else: nil
  2150  .  .  .  .  }
  2151  .  .  .  .  1: *syntax.ReturnStmt {
  2152  .  .  .  .  .  Results: *syntax.CallExpr {
  2153  .  .  .  .  .  .  Fun: append
  2154  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  2155  .  .  .  .  .  .  .  0: list
  2156  .  .  .  .  .  .  .  1: *syntax.CallExpr {
  2157  .  .  .  .  .  .  .  .  Fun: f
  2158  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2159  .  .  .  .  .  .  .  .  .  0: nil
  2160  .  .  .  .  .  .  .  .  }
  2161  .  .  .  .  .  .  .  .  HasDots: false
  2162  .  .  .  .  .  .  .  }
  2163  .  .  .  .  .  .  }
  2164  .  .  .  .  .  .  HasDots: false
  2165  .  .  .  .  .  }
  2166  .  .  .  .  }
  2167  .  .  .  }
  2168  .  .  .  Pragma: 0
  2169  .  .  .  EndLine: 276
  2170  .  .  }
  2171  .  .  19: *syntax.FuncDecl {
  2172  .  .  .  Attr: map[]
  2173  .  .  .  Recv: *syntax.Field {
  2174  .  .  .  .  Name: p
  2175  .  .  .  .  Type: *syntax.Operation {
  2176  .  .  .  .  .  Op: *
  2177  .  .  .  .  .  X: parser
  2178  .  .  .  .  .  Y: nil
  2179  .  .  .  .  }
  2180  .  .  .  }
  2181  .  .  .  Name: importDecl
  2182  .  .  .  Type: *syntax.FuncType {
  2183  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  2184  .  .  .  .  .  0: *syntax.Field {
  2185  .  .  .  .  .  .  Name: group
  2186  .  .  .  .  .  .  Type: *syntax.Operation {
  2187  .  .  .  .  .  .  .  Op: *
  2188  .  .  .  .  .  .  .  X: Group
  2189  .  .  .  .  .  .  .  Y: nil
  2190  .  .  .  .  .  .  }
  2191  .  .  .  .  .  }
  2192  .  .  .  .  }
  2193  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  2194  .  .  .  .  .  0: *syntax.Field {
  2195  .  .  .  .  .  .  Name: nil
  2196  .  .  .  .  .  .  Type: Decl
  2197  .  .  .  .  .  }
  2198  .  .  .  .  }
  2199  .  .  .  }
  2200  .  .  .  Body: []syntax.Stmt (7 entries) {
  2201  .  .  .  .  0: *syntax.IfStmt {
  2202  .  .  .  .  .  Init: nil
  2203  .  .  .  .  .  Cond: trace
  2204  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  2205  .  .  .  .  .  .  0: *syntax.CallStmt {
  2206  .  .  .  .  .  .  .  Tok: defer
  2207  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  2208  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  2209  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2210  .  .  .  .  .  .  .  .  .  .  X: p
  2211  .  .  .  .  .  .  .  .  .  .  Sel: trace
  2212  .  .  .  .  .  .  .  .  .  }
  2213  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2214  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2215  .  .  .  .  .  .  .  .  .  .  .  Value: "\"importDecl\""
  2216  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2217  .  .  .  .  .  .  .  .  .  .  }
  2218  .  .  .  .  .  .  .  .  .  }
  2219  .  .  .  .  .  .  .  .  .  HasDots: false
  2220  .  .  .  .  .  .  .  .  }
  2221  .  .  .  .  .  .  .  .  ArgList: nil
  2222  .  .  .  .  .  .  .  .  HasDots: false
  2223  .  .  .  .  .  .  .  }
  2224  .  .  .  .  .  .  }
  2225  .  .  .  .  .  }
  2226  .  .  .  .  .  Else: nil
  2227  .  .  .  .  }
  2228  .  .  .  .  1: *syntax.AssignStmt {
  2229  .  .  .  .  .  Op: :
  2230  .  .  .  .  .  Lhs: d
  2231  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2232  .  .  .  .  .  .  Fun: new
  2233  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2234  .  .  .  .  .  .  .  0: ImportDecl
  2235  .  .  .  .  .  .  }
  2236  .  .  .  .  .  .  HasDots: false
  2237  .  .  .  .  .  }
  2238  .  .  .  .  }
  2239  .  .  .  .  2: *syntax.ExprStmt {
  2240  .  .  .  .  .  X: *syntax.CallExpr {
  2241  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2242  .  .  .  .  .  .  .  X: d
  2243  .  .  .  .  .  .  .  Sel: init
  2244  .  .  .  .  .  .  }
  2245  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2246  .  .  .  .  .  .  .  0: p
  2247  .  .  .  .  .  .  }
  2248  .  .  .  .  .  .  HasDots: false
  2249  .  .  .  .  .  }
  2250  .  .  .  .  }
  2251  .  .  .  .  3: *syntax.SwitchStmt {
  2252  .  .  .  .  .  Init: nil
  2253  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  2254  .  .  .  .  .  .  X: p
  2255  .  .  .  .  .  .  Sel: tok
  2256  .  .  .  .  .  }
  2257  .  .  .  .  .  Body: []*syntax.CaseClause (2 entries) {
  2258  .  .  .  .  .  .  0: *syntax.CaseClause {
  2259  .  .  .  .  .  .  .  Cases: _Name
  2260  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  2261  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2262  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2263  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2264  .  .  .  .  .  .  .  .  .  .  X: d
  2265  .  .  .  .  .  .  .  .  .  .  Sel: LocalPkgName
  2266  .  .  .  .  .  .  .  .  .  }
  2267  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2268  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2269  .  .  .  .  .  .  .  .  .  .  .  X: p
  2270  .  .  .  .  .  .  .  .  .  .  .  Sel: name
  2271  .  .  .  .  .  .  .  .  .  .  }
  2272  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  2273  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2274  .  .  .  .  .  .  .  .  .  }
  2275  .  .  .  .  .  .  .  .  }
  2276  .  .  .  .  .  .  .  }
  2277  .  .  .  .  .  .  }
  2278  .  .  .  .  .  .  1: *syntax.CaseClause {
  2279  .  .  .  .  .  .  .  Cases: _Dot
  2280  .  .  .  .  .  .  .  Body: []syntax.Stmt (5 entries) {
  2281  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2282  .  .  .  .  .  .  .  .  .  Op: :
  2283  .  .  .  .  .  .  .  .  .  Lhs: n
  2284  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2285  .  .  .  .  .  .  .  .  .  .  Fun: new
  2286  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2287  .  .  .  .  .  .  .  .  .  .  .  0: Name
  2288  .  .  .  .  .  .  .  .  .  .  }
  2289  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2290  .  .  .  .  .  .  .  .  .  }
  2291  .  .  .  .  .  .  .  .  }
  2292  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  2293  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2294  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2295  .  .  .  .  .  .  .  .  .  .  .  X: n
  2296  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  2297  .  .  .  .  .  .  .  .  .  .  }
  2298  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2299  .  .  .  .  .  .  .  .  .  .  .  0: p
  2300  .  .  .  .  .  .  .  .  .  .  }
  2301  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2302  .  .  .  .  .  .  .  .  .  }
  2303  .  .  .  .  .  .  .  .  }
  2304  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  2305  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2306  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2307  .  .  .  .  .  .  .  .  .  .  X: n
  2308  .  .  .  .  .  .  .  .  .  .  Sel: Value
  2309  .  .  .  .  .  .  .  .  .  }
  2310  .  .  .  .  .  .  .  .  .  Rhs: *syntax.BasicLit {
  2311  .  .  .  .  .  .  .  .  .  .  Value: "\".\""
  2312  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2313  .  .  .  .  .  .  .  .  .  }
  2314  .  .  .  .  .  .  .  .  }
  2315  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  2316  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2317  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2318  .  .  .  .  .  .  .  .  .  .  X: d
  2319  .  .  .  .  .  .  .  .  .  .  Sel: LocalPkgName
  2320  .  .  .  .  .  .  .  .  .  }
  2321  .  .  .  .  .  .  .  .  .  Rhs: n
  2322  .  .  .  .  .  .  .  .  }
  2323  .  .  .  .  .  .  .  .  4: *syntax.ExprStmt {
  2324  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2325  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2326  .  .  .  .  .  .  .  .  .  .  .  X: p
  2327  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  2328  .  .  .  .  .  .  .  .  .  .  }
  2329  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  2330  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2331  .  .  .  .  .  .  .  .  .  }
  2332  .  .  .  .  .  .  .  .  }
  2333  .  .  .  .  .  .  .  }
  2334  .  .  .  .  .  .  }
  2335  .  .  .  .  .  }
  2336  .  .  .  .  }
  2337  .  .  .  .  4: *syntax.IfStmt {
  2338  .  .  .  .  .  Init: nil
  2339  .  .  .  .  .  Cond: *syntax.Operation {
  2340  .  .  .  .  .  .  Op: &&
  2341  .  .  .  .  .  .  X: *syntax.Operation {
  2342  .  .  .  .  .  .  .  Op: ==
  2343  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2344  .  .  .  .  .  .  .  .  X: p
  2345  .  .  .  .  .  .  .  .  Sel: tok
  2346  .  .  .  .  .  .  .  }
  2347  .  .  .  .  .  .  .  Y: _Literal
  2348  .  .  .  .  .  .  }
  2349  .  .  .  .  .  .  Y: *syntax.ParenExpr {
  2350  .  .  .  .  .  .  .  X: *syntax.Operation {
  2351  .  .  .  .  .  .  .  .  Op: ||
  2352  .  .  .  .  .  .  .  .  X: gcCompat
  2353  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  2354  .  .  .  .  .  .  .  .  .  Op: ==
  2355  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2356  .  .  .  .  .  .  .  .  .  .  X: p
  2357  .  .  .  .  .  .  .  .  .  .  Sel: kind
  2358  .  .  .  .  .  .  .  .  .  }
  2359  .  .  .  .  .  .  .  .  .  Y: StringLit
  2360  .  .  .  .  .  .  .  .  }
  2361  .  .  .  .  .  .  .  }
  2362  .  .  .  .  .  .  }
  2363  .  .  .  .  .  }
  2364  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  2365  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2366  .  .  .  .  .  .  .  Op: <op-0>
  2367  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2368  .  .  .  .  .  .  .  .  X: d
  2369  .  .  .  .  .  .  .  .  Sel: Path
  2370  .  .  .  .  .  .  .  }
  2371  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2372  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2373  .  .  .  .  .  .  .  .  .  X: p
  2374  .  .  .  .  .  .  .  .  .  Sel: oliteral
  2375  .  .  .  .  .  .  .  .  }
  2376  .  .  .  .  .  .  .  .  ArgList: nil
  2377  .  .  .  .  .  .  .  .  HasDots: false
  2378  .  .  .  .  .  .  .  }
  2379  .  .  .  .  .  .  }
  2380  .  .  .  .  .  }
  2381  .  .  .  .  .  Else: *syntax.BlockStmt {
  2382  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  2383  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  2384  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2385  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2386  .  .  .  .  .  .  .  .  .  .  X: p
  2387  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  2388  .  .  .  .  .  .  .  .  .  }
  2389  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2390  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2391  .  .  .  .  .  .  .  .  .  .  .  Value: "\"missing import path; require quoted string\""
  2392  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2393  .  .  .  .  .  .  .  .  .  .  }
  2394  .  .  .  .  .  .  .  .  .  }
  2395  .  .  .  .  .  .  .  .  .  HasDots: false
  2396  .  .  .  .  .  .  .  .  }
  2397  .  .  .  .  .  .  .  }
  2398  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  2399  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2400  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2401  .  .  .  .  .  .  .  .  .  .  X: p
  2402  .  .  .  .  .  .  .  .  .  .  Sel: advance
  2403  .  .  .  .  .  .  .  .  .  }
  2404  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  2405  .  .  .  .  .  .  .  .  .  .  0: _Semi
  2406  .  .  .  .  .  .  .  .  .  .  1: _Rparen
  2407  .  .  .  .  .  .  .  .  .  }
  2408  .  .  .  .  .  .  .  .  .  HasDots: false
  2409  .  .  .  .  .  .  .  .  }
  2410  .  .  .  .  .  .  .  }
  2411  .  .  .  .  .  .  }
  2412  .  .  .  .  .  }
  2413  .  .  .  .  }
  2414  .  .  .  .  5: *syntax.AssignStmt {
  2415  .  .  .  .  .  Op: <op-0>
  2416  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2417  .  .  .  .  .  .  X: d
  2418  .  .  .  .  .  .  Sel: Group
  2419  .  .  .  .  .  }
  2420  .  .  .  .  .  Rhs: group
  2421  .  .  .  .  }
  2422  .  .  .  .  6: *syntax.ReturnStmt {
  2423  .  .  .  .  .  Results: d
  2424  .  .  .  .  }
  2425  .  .  .  }
  2426  .  .  .  Pragma: 0
  2427  .  .  .  EndLine: 305
  2428  .  .  }
  2429  .  .  20: *syntax.FuncDecl {
  2430  .  .  .  Attr: map[]
  2431  .  .  .  Recv: *syntax.Field {
  2432  .  .  .  .  Name: p
  2433  .  .  .  .  Type: *syntax.Operation {
  2434  .  .  .  .  .  Op: *
  2435  .  .  .  .  .  X: parser
  2436  .  .  .  .  .  Y: nil
  2437  .  .  .  .  }
  2438  .  .  .  }
  2439  .  .  .  Name: constDecl
  2440  .  .  .  Type: *syntax.FuncType {
  2441  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  2442  .  .  .  .  .  0: *syntax.Field {
  2443  .  .  .  .  .  .  Name: group
  2444  .  .  .  .  .  .  Type: *syntax.Operation {
  2445  .  .  .  .  .  .  .  Op: *
  2446  .  .  .  .  .  .  .  X: Group
  2447  .  .  .  .  .  .  .  Y: nil
  2448  .  .  .  .  .  .  }
  2449  .  .  .  .  .  }
  2450  .  .  .  .  }
  2451  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  2452  .  .  .  .  .  0: *syntax.Field {
  2453  .  .  .  .  .  .  Name: nil
  2454  .  .  .  .  .  .  Type: Decl
  2455  .  .  .  .  .  }
  2456  .  .  .  .  }
  2457  .  .  .  }
  2458  .  .  .  Body: []syntax.Stmt (7 entries) {
  2459  .  .  .  .  0: *syntax.IfStmt {
  2460  .  .  .  .  .  Init: nil
  2461  .  .  .  .  .  Cond: trace
  2462  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  2463  .  .  .  .  .  .  0: *syntax.CallStmt {
  2464  .  .  .  .  .  .  .  Tok: defer
  2465  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  2466  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  2467  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2468  .  .  .  .  .  .  .  .  .  .  X: p
  2469  .  .  .  .  .  .  .  .  .  .  Sel: trace
  2470  .  .  .  .  .  .  .  .  .  }
  2471  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2472  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2473  .  .  .  .  .  .  .  .  .  .  .  Value: "\"constDecl\""
  2474  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2475  .  .  .  .  .  .  .  .  .  .  }
  2476  .  .  .  .  .  .  .  .  .  }
  2477  .  .  .  .  .  .  .  .  .  HasDots: false
  2478  .  .  .  .  .  .  .  .  }
  2479  .  .  .  .  .  .  .  .  ArgList: nil
  2480  .  .  .  .  .  .  .  .  HasDots: false
  2481  .  .  .  .  .  .  .  }
  2482  .  .  .  .  .  .  }
  2483  .  .  .  .  .  }
  2484  .  .  .  .  .  Else: nil
  2485  .  .  .  .  }
  2486  .  .  .  .  1: *syntax.AssignStmt {
  2487  .  .  .  .  .  Op: :
  2488  .  .  .  .  .  Lhs: d
  2489  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2490  .  .  .  .  .  .  Fun: new
  2491  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2492  .  .  .  .  .  .  .  0: ConstDecl
  2493  .  .  .  .  .  .  }
  2494  .  .  .  .  .  .  HasDots: false
  2495  .  .  .  .  .  }
  2496  .  .  .  .  }
  2497  .  .  .  .  2: *syntax.ExprStmt {
  2498  .  .  .  .  .  X: *syntax.CallExpr {
  2499  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2500  .  .  .  .  .  .  .  X: d
  2501  .  .  .  .  .  .  .  Sel: init
  2502  .  .  .  .  .  .  }
  2503  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2504  .  .  .  .  .  .  .  0: p
  2505  .  .  .  .  .  .  }
  2506  .  .  .  .  .  .  HasDots: false
  2507  .  .  .  .  .  }
  2508  .  .  .  .  }
  2509  .  .  .  .  3: *syntax.AssignStmt {
  2510  .  .  .  .  .  Op: <op-0>
  2511  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2512  .  .  .  .  .  .  X: d
  2513  .  .  .  .  .  .  Sel: NameList
  2514  .  .  .  .  .  }
  2515  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2516  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2517  .  .  .  .  .  .  .  X: p
  2518  .  .  .  .  .  .  .  Sel: nameList
  2519  .  .  .  .  .  .  }
  2520  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2521  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  2522  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2523  .  .  .  .  .  .  .  .  .  X: p
  2524  .  .  .  .  .  .  .  .  .  Sel: name
  2525  .  .  .  .  .  .  .  .  }
  2526  .  .  .  .  .  .  .  .  ArgList: nil
  2527  .  .  .  .  .  .  .  .  HasDots: false
  2528  .  .  .  .  .  .  .  }
  2529  .  .  .  .  .  .  }
  2530  .  .  .  .  .  .  HasDots: false
  2531  .  .  .  .  .  }
  2532  .  .  .  .  }
  2533  .  .  .  .  4: *syntax.IfStmt {
  2534  .  .  .  .  .  Init: nil
  2535  .  .  .  .  .  Cond: *syntax.Operation {
  2536  .  .  .  .  .  .  Op: &&
  2537  .  .  .  .  .  .  X: *syntax.Operation {
  2538  .  .  .  .  .  .  .  Op: &&
  2539  .  .  .  .  .  .  .  X: *syntax.Operation {
  2540  .  .  .  .  .  .  .  .  Op: !=
  2541  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2542  .  .  .  .  .  .  .  .  .  X: p
  2543  .  .  .  .  .  .  .  .  .  Sel: tok
  2544  .  .  .  .  .  .  .  .  }
  2545  .  .  .  .  .  .  .  .  Y: _EOF
  2546  .  .  .  .  .  .  .  }
  2547  .  .  .  .  .  .  .  Y: *syntax.Operation {
  2548  .  .  .  .  .  .  .  .  Op: !=
  2549  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2550  .  .  .  .  .  .  .  .  .  X: p
  2551  .  .  .  .  .  .  .  .  .  Sel: tok
  2552  .  .  .  .  .  .  .  .  }
  2553  .  .  .  .  .  .  .  .  Y: _Semi
  2554  .  .  .  .  .  .  .  }
  2555  .  .  .  .  .  .  }
  2556  .  .  .  .  .  .  Y: *syntax.Operation {
  2557  .  .  .  .  .  .  .  Op: !=
  2558  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2559  .  .  .  .  .  .  .  .  X: p
  2560  .  .  .  .  .  .  .  .  Sel: tok
  2561  .  .  .  .  .  .  .  }
  2562  .  .  .  .  .  .  .  Y: _Rparen
  2563  .  .  .  .  .  .  }
  2564  .  .  .  .  .  }
  2565  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
  2566  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2567  .  .  .  .  .  .  .  Op: <op-0>
  2568  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2569  .  .  .  .  .  .  .  .  X: d
  2570  .  .  .  .  .  .  .  .  Sel: Type
  2571  .  .  .  .  .  .  .  }
  2572  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2573  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2574  .  .  .  .  .  .  .  .  .  X: p
  2575  .  .  .  .  .  .  .  .  .  Sel: tryType
  2576  .  .  .  .  .  .  .  .  }
  2577  .  .  .  .  .  .  .  .  ArgList: nil
  2578  .  .  .  .  .  .  .  .  HasDots: false
  2579  .  .  .  .  .  .  .  }
  2580  .  .  .  .  .  .  }
  2581  .  .  .  .  .  .  1: *syntax.IfStmt {
  2582  .  .  .  .  .  .  .  Init: nil
  2583  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  2584  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2585  .  .  .  .  .  .  .  .  .  X: p
  2586  .  .  .  .  .  .  .  .  .  Sel: got
  2587  .  .  .  .  .  .  .  .  }
  2588  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2589  .  .  .  .  .  .  .  .  .  0: _Assign
  2590  .  .  .  .  .  .  .  .  }
  2591  .  .  .  .  .  .  .  .  HasDots: false
  2592  .  .  .  .  .  .  .  }
  2593  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  2594  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2595  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2596  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2597  .  .  .  .  .  .  .  .  .  .  X: d
  2598  .  .  .  .  .  .  .  .  .  .  Sel: Values
  2599  .  .  .  .  .  .  .  .  .  }
  2600  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2601  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2602  .  .  .  .  .  .  .  .  .  .  .  X: p
  2603  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList
  2604  .  .  .  .  .  .  .  .  .  .  }
  2605  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  2606  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2607  .  .  .  .  .  .  .  .  .  }
  2608  .  .  .  .  .  .  .  .  }
  2609  .  .  .  .  .  .  .  }
  2610  .  .  .  .  .  .  .  Else: nil
  2611  .  .  .  .  .  .  }
  2612  .  .  .  .  .  }
  2613  .  .  .  .  .  Else: nil
  2614  .  .  .  .  }
  2615  .  .  .  .  5: *syntax.AssignStmt {
  2616  .  .  .  .  .  Op: <op-0>
  2617  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2618  .  .  .  .  .  .  X: d
  2619  .  .  .  .  .  .  Sel: Group
  2620  .  .  .  .  .  }
  2621  .  .  .  .  .  Rhs: group
  2622  .  .  .  .  }
  2623  .  .  .  .  6: *syntax.ReturnStmt {
  2624  .  .  .  .  .  Results: d
  2625  .  .  .  .  }
  2626  .  .  .  }
  2627  .  .  .  Pragma: 0
  2628  .  .  .  EndLine: 326
  2629  .  .  }
  2630  .  .  21: *syntax.FuncDecl {
  2631  .  .  .  Attr: map[]
  2632  .  .  .  Recv: *syntax.Field {
  2633  .  .  .  .  Name: p
  2634  .  .  .  .  Type: *syntax.Operation {
  2635  .  .  .  .  .  Op: *
  2636  .  .  .  .  .  X: parser
  2637  .  .  .  .  .  Y: nil
  2638  .  .  .  .  }
  2639  .  .  .  }
  2640  .  .  .  Name: typeDecl
  2641  .  .  .  Type: *syntax.FuncType {
  2642  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  2643  .  .  .  .  .  0: *syntax.Field {
  2644  .  .  .  .  .  .  Name: group
  2645  .  .  .  .  .  .  Type: *syntax.Operation {
  2646  .  .  .  .  .  .  .  Op: *
  2647  .  .  .  .  .  .  .  X: Group
  2648  .  .  .  .  .  .  .  Y: nil
  2649  .  .  .  .  .  .  }
  2650  .  .  .  .  .  }
  2651  .  .  .  .  }
  2652  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  2653  .  .  .  .  .  0: *syntax.Field {
  2654  .  .  .  .  .  .  Name: nil
  2655  .  .  .  .  .  .  Type: Decl
  2656  .  .  .  .  .  }
  2657  .  .  .  .  }
  2658  .  .  .  }
  2659  .  .  .  Body: []syntax.Stmt (9 entries) {
  2660  .  .  .  .  0: *syntax.IfStmt {
  2661  .  .  .  .  .  Init: nil
  2662  .  .  .  .  .  Cond: trace
  2663  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  2664  .  .  .  .  .  .  0: *syntax.CallStmt {
  2665  .  .  .  .  .  .  .  Tok: defer
  2666  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  2667  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  2668  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2669  .  .  .  .  .  .  .  .  .  .  X: p
  2670  .  .  .  .  .  .  .  .  .  .  Sel: trace
  2671  .  .  .  .  .  .  .  .  .  }
  2672  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2673  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2674  .  .  .  .  .  .  .  .  .  .  .  Value: "\"typeDecl\""
  2675  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2676  .  .  .  .  .  .  .  .  .  .  }
  2677  .  .  .  .  .  .  .  .  .  }
  2678  .  .  .  .  .  .  .  .  .  HasDots: false
  2679  .  .  .  .  .  .  .  .  }
  2680  .  .  .  .  .  .  .  .  ArgList: nil
  2681  .  .  .  .  .  .  .  .  HasDots: false
  2682  .  .  .  .  .  .  .  }
  2683  .  .  .  .  .  .  }
  2684  .  .  .  .  .  }
  2685  .  .  .  .  .  Else: nil
  2686  .  .  .  .  }
  2687  .  .  .  .  1: *syntax.AssignStmt {
  2688  .  .  .  .  .  Op: :
  2689  .  .  .  .  .  Lhs: d
  2690  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2691  .  .  .  .  .  .  Fun: new
  2692  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2693  .  .  .  .  .  .  .  0: TypeDecl
  2694  .  .  .  .  .  .  }
  2695  .  .  .  .  .  .  HasDots: false
  2696  .  .  .  .  .  }
  2697  .  .  .  .  }
  2698  .  .  .  .  2: *syntax.ExprStmt {
  2699  .  .  .  .  .  X: *syntax.CallExpr {
  2700  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2701  .  .  .  .  .  .  .  X: d
  2702  .  .  .  .  .  .  .  Sel: init
  2703  .  .  .  .  .  .  }
  2704  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2705  .  .  .  .  .  .  .  0: p
  2706  .  .  .  .  .  .  }
  2707  .  .  .  .  .  .  HasDots: false
  2708  .  .  .  .  .  }
  2709  .  .  .  .  }
  2710  .  .  .  .  3: *syntax.AssignStmt {
  2711  .  .  .  .  .  Op: <op-0>
  2712  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2713  .  .  .  .  .  .  X: d
  2714  .  .  .  .  .  .  Sel: Name
  2715  .  .  .  .  .  }
  2716  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2717  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2718  .  .  .  .  .  .  .  X: p
  2719  .  .  .  .  .  .  .  Sel: name
  2720  .  .  .  .  .  .  }
  2721  .  .  .  .  .  .  ArgList: nil
  2722  .  .  .  .  .  .  HasDots: false
  2723  .  .  .  .  .  }
  2724  .  .  .  .  }
  2725  .  .  .  .  4: *syntax.AssignStmt {
  2726  .  .  .  .  .  Op: <op-0>
  2727  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2728  .  .  .  .  .  .  X: d
  2729  .  .  .  .  .  .  Sel: Type
  2730  .  .  .  .  .  }
  2731  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2732  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2733  .  .  .  .  .  .  .  X: p
  2734  .  .  .  .  .  .  .  Sel: tryType
  2735  .  .  .  .  .  .  }
  2736  .  .  .  .  .  .  ArgList: nil
  2737  .  .  .  .  .  .  HasDots: false
  2738  .  .  .  .  .  }
  2739  .  .  .  .  }
  2740  .  .  .  .  5: *syntax.IfStmt {
  2741  .  .  .  .  .  Init: nil
  2742  .  .  .  .  .  Cond: *syntax.Operation {
  2743  .  .  .  .  .  .  Op: ==
  2744  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2745  .  .  .  .  .  .  .  X: d
  2746  .  .  .  .  .  .  .  Sel: Type
  2747  .  .  .  .  .  .  }
  2748  .  .  .  .  .  .  Y: nil
  2749  .  .  .  .  .  }
  2750  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
  2751  .  .  .  .  .  .  0: *syntax.ExprStmt {
  2752  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2753  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2754  .  .  .  .  .  .  .  .  .  X: p
  2755  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  2756  .  .  .  .  .  .  .  .  }
  2757  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2758  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2759  .  .  .  .  .  .  .  .  .  .  Value: "\"in type declaration\""
  2760  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2761  .  .  .  .  .  .  .  .  .  }
  2762  .  .  .  .  .  .  .  .  }
  2763  .  .  .  .  .  .  .  .  HasDots: false
  2764  .  .  .  .  .  .  .  }
  2765  .  .  .  .  .  .  }
  2766  .  .  .  .  .  .  1: *syntax.ExprStmt {
  2767  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2768  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2769  .  .  .  .  .  .  .  .  .  X: p
  2770  .  .  .  .  .  .  .  .  .  Sel: advance
  2771  .  .  .  .  .  .  .  .  }
  2772  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  2773  .  .  .  .  .  .  .  .  .  0: _Semi
  2774  .  .  .  .  .  .  .  .  .  1: _Rparen
  2775  .  .  .  .  .  .  .  .  }
  2776  .  .  .  .  .  .  .  .  HasDots: false
  2777  .  .  .  .  .  .  .  }
  2778  .  .  .  .  .  .  }
  2779  .  .  .  .  .  }
  2780  .  .  .  .  .  Else: nil
  2781  .  .  .  .  }
  2782  .  .  .  .  6: *syntax.AssignStmt {
  2783  .  .  .  .  .  Op: <op-0>
  2784  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2785  .  .  .  .  .  .  X: d
  2786  .  .  .  .  .  .  Sel: Group
  2787  .  .  .  .  .  }
  2788  .  .  .  .  .  Rhs: group
  2789  .  .  .  .  }
  2790  .  .  .  .  7: *syntax.AssignStmt {
  2791  .  .  .  .  .  Op: <op-0>
  2792  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2793  .  .  .  .  .  .  X: d
  2794  .  .  .  .  .  .  Sel: Pragma
  2795  .  .  .  .  .  }
  2796  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  2797  .  .  .  .  .  .  X: p
  2798  .  .  .  .  .  .  Sel: pragma
  2799  .  .  .  .  .  }
  2800  .  .  .  .  }
  2801  .  .  .  .  8: *syntax.ReturnStmt {
  2802  .  .  .  .  .  Results: d
  2803  .  .  .  .  }
  2804  .  .  .  }
  2805  .  .  .  Pragma: 0
  2806  .  .  .  EndLine: 347
  2807  .  .  }
  2808  .  .  22: *syntax.FuncDecl {
  2809  .  .  .  Attr: map[]
  2810  .  .  .  Recv: *syntax.Field {
  2811  .  .  .  .  Name: p
  2812  .  .  .  .  Type: *syntax.Operation {
  2813  .  .  .  .  .  Op: *
  2814  .  .  .  .  .  X: parser
  2815  .  .  .  .  .  Y: nil
  2816  .  .  .  .  }
  2817  .  .  .  }
  2818  .  .  .  Name: varDecl
  2819  .  .  .  Type: *syntax.FuncType {
  2820  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  2821  .  .  .  .  .  0: *syntax.Field {
  2822  .  .  .  .  .  .  Name: group
  2823  .  .  .  .  .  .  Type: *syntax.Operation {
  2824  .  .  .  .  .  .  .  Op: *
  2825  .  .  .  .  .  .  .  X: Group
  2826  .  .  .  .  .  .  .  Y: nil
  2827  .  .  .  .  .  .  }
  2828  .  .  .  .  .  }
  2829  .  .  .  .  }
  2830  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  2831  .  .  .  .  .  0: *syntax.Field {
  2832  .  .  .  .  .  .  Name: nil
  2833  .  .  .  .  .  .  Type: Decl
  2834  .  .  .  .  .  }
  2835  .  .  .  .  }
  2836  .  .  .  }
  2837  .  .  .  Body: []syntax.Stmt (8 entries) {
  2838  .  .  .  .  0: *syntax.IfStmt {
  2839  .  .  .  .  .  Init: nil
  2840  .  .  .  .  .  Cond: trace
  2841  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  2842  .  .  .  .  .  .  0: *syntax.CallStmt {
  2843  .  .  .  .  .  .  .  Tok: defer
  2844  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  2845  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  2846  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2847  .  .  .  .  .  .  .  .  .  .  X: p
  2848  .  .  .  .  .  .  .  .  .  .  Sel: trace
  2849  .  .  .  .  .  .  .  .  .  }
  2850  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2851  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2852  .  .  .  .  .  .  .  .  .  .  .  Value: "\"varDecl\""
  2853  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2854  .  .  .  .  .  .  .  .  .  .  }
  2855  .  .  .  .  .  .  .  .  .  }
  2856  .  .  .  .  .  .  .  .  .  HasDots: false
  2857  .  .  .  .  .  .  .  .  }
  2858  .  .  .  .  .  .  .  .  ArgList: nil
  2859  .  .  .  .  .  .  .  .  HasDots: false
  2860  .  .  .  .  .  .  .  }
  2861  .  .  .  .  .  .  }
  2862  .  .  .  .  .  }
  2863  .  .  .  .  .  Else: nil
  2864  .  .  .  .  }
  2865  .  .  .  .  1: *syntax.AssignStmt {
  2866  .  .  .  .  .  Op: :
  2867  .  .  .  .  .  Lhs: d
  2868  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2869  .  .  .  .  .  .  Fun: new
  2870  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2871  .  .  .  .  .  .  .  0: VarDecl
  2872  .  .  .  .  .  .  }
  2873  .  .  .  .  .  .  HasDots: false
  2874  .  .  .  .  .  }
  2875  .  .  .  .  }
  2876  .  .  .  .  2: *syntax.ExprStmt {
  2877  .  .  .  .  .  X: *syntax.CallExpr {
  2878  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2879  .  .  .  .  .  .  .  X: d
  2880  .  .  .  .  .  .  .  Sel: init
  2881  .  .  .  .  .  .  }
  2882  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2883  .  .  .  .  .  .  .  0: p
  2884  .  .  .  .  .  .  }
  2885  .  .  .  .  .  .  HasDots: false
  2886  .  .  .  .  .  }
  2887  .  .  .  .  }
  2888  .  .  .  .  3: *syntax.AssignStmt {
  2889  .  .  .  .  .  Op: <op-0>
  2890  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2891  .  .  .  .  .  .  X: d
  2892  .  .  .  .  .  .  Sel: NameList
  2893  .  .  .  .  .  }
  2894  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2895  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2896  .  .  .  .  .  .  .  X: p
  2897  .  .  .  .  .  .  .  Sel: nameList
  2898  .  .  .  .  .  .  }
  2899  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2900  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  2901  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2902  .  .  .  .  .  .  .  .  .  X: p
  2903  .  .  .  .  .  .  .  .  .  Sel: name
  2904  .  .  .  .  .  .  .  .  }
  2905  .  .  .  .  .  .  .  .  ArgList: nil
  2906  .  .  .  .  .  .  .  .  HasDots: false
  2907  .  .  .  .  .  .  .  }
  2908  .  .  .  .  .  .  }
  2909  .  .  .  .  .  .  HasDots: false
  2910  .  .  .  .  .  }
  2911  .  .  .  .  }
  2912  .  .  .  .  4: *syntax.IfStmt {
  2913  .  .  .  .  .  Init: nil
  2914  .  .  .  .  .  Cond: *syntax.CallExpr {
  2915  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2916  .  .  .  .  .  .  .  X: p
  2917  .  .  .  .  .  .  .  Sel: got
  2918  .  .  .  .  .  .  }
  2919  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2920  .  .  .  .  .  .  .  0: _Assign
  2921  .  .  .  .  .  .  }
  2922  .  .  .  .  .  .  HasDots: false
  2923  .  .  .  .  .  }
  2924  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  2925  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2926  .  .  .  .  .  .  .  Op: <op-0>
  2927  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2928  .  .  .  .  .  .  .  .  X: d
  2929  .  .  .  .  .  .  .  .  Sel: Values
  2930  .  .  .  .  .  .  .  }
  2931  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2932  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2933  .  .  .  .  .  .  .  .  .  X: p
  2934  .  .  .  .  .  .  .  .  .  Sel: exprList
  2935  .  .  .  .  .  .  .  .  }
  2936  .  .  .  .  .  .  .  .  ArgList: nil
  2937  .  .  .  .  .  .  .  .  HasDots: false
  2938  .  .  .  .  .  .  .  }
  2939  .  .  .  .  .  .  }
  2940  .  .  .  .  .  }
  2941  .  .  .  .  .  Else: *syntax.BlockStmt {
  2942  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  2943  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2944  .  .  .  .  .  .  .  .  Op: <op-0>
  2945  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2946  .  .  .  .  .  .  .  .  .  X: d
  2947  .  .  .  .  .  .  .  .  .  Sel: Type
  2948  .  .  .  .  .  .  .  .  }
  2949  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2950  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2951  .  .  .  .  .  .  .  .  .  .  X: p
  2952  .  .  .  .  .  .  .  .  .  .  Sel: type_
  2953  .  .  .  .  .  .  .  .  .  }
  2954  .  .  .  .  .  .  .  .  .  ArgList: nil
  2955  .  .  .  .  .  .  .  .  .  HasDots: false
  2956  .  .  .  .  .  .  .  .  }
  2957  .  .  .  .  .  .  .  }
  2958  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  2959  .  .  .  .  .  .  .  .  Init: nil
  2960  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  2961  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2962  .  .  .  .  .  .  .  .  .  .  X: p
  2963  .  .  .  .  .  .  .  .  .  .  Sel: got
  2964  .  .  .  .  .  .  .  .  .  }
  2965  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2966  .  .  .  .  .  .  .  .  .  .  0: _Assign
  2967  .  .  .  .  .  .  .  .  .  }
  2968  .  .  .  .  .  .  .  .  .  HasDots: false
  2969  .  .  .  .  .  .  .  .  }
  2970  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  2971  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2972  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2973  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2974  .  .  .  .  .  .  .  .  .  .  .  X: d
  2975  .  .  .  .  .  .  .  .  .  .  .  Sel: Values
  2976  .  .  .  .  .  .  .  .  .  .  }
  2977  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2978  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2979  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  2980  .  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList
  2981  .  .  .  .  .  .  .  .  .  .  .  }
  2982  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  2983  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2984  .  .  .  .  .  .  .  .  .  .  }
  2985  .  .  .  .  .  .  .  .  .  }
  2986  .  .  .  .  .  .  .  .  }
  2987  .  .  .  .  .  .  .  .  Else: nil
  2988  .  .  .  .  .  .  .  }
  2989  .  .  .  .  .  .  }
  2990  .  .  .  .  .  }
  2991  .  .  .  .  }
  2992  .  .  .  .  5: *syntax.AssignStmt {
  2993  .  .  .  .  .  Op: <op-0>
  2994  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2995  .  .  .  .  .  .  X: d
  2996  .  .  .  .  .  .  Sel: Group
  2997  .  .  .  .  .  }
  2998  .  .  .  .  .  Rhs: group
  2999  .  .  .  .  }
  3000  .  .  .  .  6: *syntax.IfStmt {
  3001  .  .  .  .  .  Init: nil
  3002  .  .  .  .  .  Cond: gcCompat
  3003  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  3004  .  .  .  .  .  .  0: *syntax.ExprStmt {
  3005  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3006  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3007  .  .  .  .  .  .  .  .  .  X: d
  3008  .  .  .  .  .  .  .  .  .  Sel: init
  3009  .  .  .  .  .  .  .  .  }
  3010  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3011  .  .  .  .  .  .  .  .  .  0: p
  3012  .  .  .  .  .  .  .  .  }
  3013  .  .  .  .  .  .  .  .  HasDots: false
  3014  .  .  .  .  .  .  .  }
  3015  .  .  .  .  .  .  }
  3016  .  .  .  .  .  }
  3017  .  .  .  .  .  Else: nil
  3018  .  .  .  .  }
  3019  .  .  .  .  7: *syntax.ReturnStmt {
  3020  .  .  .  .  .  Results: d
  3021  .  .  .  .  }
  3022  .  .  .  }
  3023  .  .  .  Pragma: 0
  3024  .  .  .  EndLine: 373
  3025  .  .  }
  3026  .  .  23: *syntax.FuncDecl {
  3027  .  .  .  Attr: map[]
  3028  .  .  .  Recv: *syntax.Field {
  3029  .  .  .  .  Name: p
  3030  .  .  .  .  Type: *syntax.Operation {
  3031  .  .  .  .  .  Op: *
  3032  .  .  .  .  .  X: parser
  3033  .  .  .  .  .  Y: nil
  3034  .  .  .  .  }
  3035  .  .  .  }
  3036  .  .  .  Name: funcDecl
  3037  .  .  .  Type: *syntax.FuncType {
  3038  .  .  .  .  ParamList: nil
  3039  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  3040  .  .  .  .  .  0: *syntax.Field {
  3041  .  .  .  .  .  .  Name: nil
  3042  .  .  .  .  .  .  Type: *syntax.Operation {
  3043  .  .  .  .  .  .  .  Op: *
  3044  .  .  .  .  .  .  .  X: FuncDecl
  3045  .  .  .  .  .  .  .  Y: nil
  3046  .  .  .  .  .  .  }
  3047  .  .  .  .  .  }
  3048  .  .  .  .  }
  3049  .  .  .  }
  3050  .  .  .  Body: []syntax.Stmt (14 entries) {
  3051  .  .  .  .  0: *syntax.IfStmt {
  3052  .  .  .  .  .  Init: nil
  3053  .  .  .  .  .  Cond: trace
  3054  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  3055  .  .  .  .  .  .  0: *syntax.CallStmt {
  3056  .  .  .  .  .  .  .  Tok: defer
  3057  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  3058  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  3059  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3060  .  .  .  .  .  .  .  .  .  .  X: p
  3061  .  .  .  .  .  .  .  .  .  .  Sel: trace
  3062  .  .  .  .  .  .  .  .  .  }
  3063  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3064  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3065  .  .  .  .  .  .  .  .  .  .  .  Value: "\"funcDecl\""
  3066  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3067  .  .  .  .  .  .  .  .  .  .  }
  3068  .  .  .  .  .  .  .  .  .  }
  3069  .  .  .  .  .  .  .  .  .  HasDots: false
  3070  .  .  .  .  .  .  .  .  }
  3071  .  .  .  .  .  .  .  .  ArgList: nil
  3072  .  .  .  .  .  .  .  .  HasDots: false
  3073  .  .  .  .  .  .  .  }
  3074  .  .  .  .  .  .  }
  3075  .  .  .  .  .  }
  3076  .  .  .  .  .  Else: nil
  3077  .  .  .  .  }
  3078  .  .  .  .  1: *syntax.AssignStmt {
  3079  .  .  .  .  .  Op: :
  3080  .  .  .  .  .  Lhs: f
  3081  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3082  .  .  .  .  .  .  Fun: new
  3083  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3084  .  .  .  .  .  .  .  0: FuncDecl
  3085  .  .  .  .  .  .  }
  3086  .  .  .  .  .  .  HasDots: false
  3087  .  .  .  .  .  }
  3088  .  .  .  .  }
  3089  .  .  .  .  2: *syntax.ExprStmt {
  3090  .  .  .  .  .  X: *syntax.CallExpr {
  3091  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3092  .  .  .  .  .  .  .  X: f
  3093  .  .  .  .  .  .  .  Sel: init
  3094  .  .  .  .  .  .  }
  3095  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3096  .  .  .  .  .  .  .  0: p
  3097  .  .  .  .  .  .  }
  3098  .  .  .  .  .  .  HasDots: false
  3099  .  .  .  .  .  }
  3100  .  .  .  .  }
  3101  .  .  .  .  3: *syntax.AssignStmt {
  3102  .  .  .  .  .  Op: :
  3103  .  .  .  .  .  Lhs: badRecv
  3104  .  .  .  .  .  Rhs: false
  3105  .  .  .  .  }
  3106  .  .  .  .  4: *syntax.IfStmt {
  3107  .  .  .  .  .  Init: nil
  3108  .  .  .  .  .  Cond: *syntax.Operation {
  3109  .  .  .  .  .  .  Op: ==
  3110  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  3111  .  .  .  .  .  .  .  X: p
  3112  .  .  .  .  .  .  .  Sel: tok
  3113  .  .  .  .  .  .  }
  3114  .  .  .  .  .  .  Y: _Lparen
  3115  .  .  .  .  .  }
  3116  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
  3117  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3118  .  .  .  .  .  .  .  Op: :
  3119  .  .  .  .  .  .  .  Lhs: rcvr
  3120  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3121  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3122  .  .  .  .  .  .  .  .  .  X: p
  3123  .  .  .  .  .  .  .  .  .  Sel: paramList
  3124  .  .  .  .  .  .  .  .  }
  3125  .  .  .  .  .  .  .  .  ArgList: nil
  3126  .  .  .  .  .  .  .  .  HasDots: false
  3127  .  .  .  .  .  .  .  }
  3128  .  .  .  .  .  .  }
  3129  .  .  .  .  .  .  1: *syntax.SwitchStmt {
  3130  .  .  .  .  .  .  .  Init: nil
  3131  .  .  .  .  .  .  .  Tag: *syntax.CallExpr {
  3132  .  .  .  .  .  .  .  .  Fun: len
  3133  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3134  .  .  .  .  .  .  .  .  .  0: rcvr
  3135  .  .  .  .  .  .  .  .  }
  3136  .  .  .  .  .  .  .  .  HasDots: false
  3137  .  .  .  .  .  .  .  }
  3138  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
  3139  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  3140  .  .  .  .  .  .  .  .  .  Cases: *syntax.BasicLit {
  3141  .  .  .  .  .  .  .  .  .  .  Value: "0"
  3142  .  .  .  .  .  .  .  .  .  .  Kind: 0
  3143  .  .  .  .  .  .  .  .  .  }
  3144  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  3145  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  3146  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3147  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3148  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  3149  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error
  3150  .  .  .  .  .  .  .  .  .  .  .  .  }
  3151  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3152  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3153  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"method has no receiver\""
  3154  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3155  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3156  .  .  .  .  .  .  .  .  .  .  .  .  }
  3157  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3158  .  .  .  .  .  .  .  .  .  .  .  }
  3159  .  .  .  .  .  .  .  .  .  .  }
  3160  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  3161  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3162  .  .  .  .  .  .  .  .  .  .  .  Lhs: badRecv
  3163  .  .  .  .  .  .  .  .  .  .  .  Rhs: true
  3164  .  .  .  .  .  .  .  .  .  .  }
  3165  .  .  .  .  .  .  .  .  .  }
  3166  .  .  .  .  .  .  .  .  }
  3167  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  3168  .  .  .  .  .  .  .  .  .  Cases: *syntax.BasicLit {
  3169  .  .  .  .  .  .  .  .  .  .  Value: "1"
  3170  .  .  .  .  .  .  .  .  .  .  Kind: 0
  3171  .  .  .  .  .  .  .  .  .  }
  3172  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  3173  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3174  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3175  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3176  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  3177  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Recv
  3178  .  .  .  .  .  .  .  .  .  .  .  }
  3179  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.IndexExpr {
  3180  .  .  .  .  .  .  .  .  .  .  .  .  X: rcvr
  3181  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.BasicLit {
  3182  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  3183  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  3184  .  .  .  .  .  .  .  .  .  .  .  .  }
  3185  .  .  .  .  .  .  .  .  .  .  .  }
  3186  .  .  .  .  .  .  .  .  .  .  }
  3187  .  .  .  .  .  .  .  .  .  }
  3188  .  .  .  .  .  .  .  .  }
  3189  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  3190  .  .  .  .  .  .  .  .  .  Cases: nil
  3191  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  3192  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  3193  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3194  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3195  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  3196  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error
  3197  .  .  .  .  .  .  .  .  .  .  .  .  }
  3198  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3199  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3200  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"method has multiple receivers\""
  3201  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3202  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3203  .  .  .  .  .  .  .  .  .  .  .  .  }
  3204  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3205  .  .  .  .  .  .  .  .  .  .  .  }
  3206  .  .  .  .  .  .  .  .  .  .  }
  3207  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  3208  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3209  .  .  .  .  .  .  .  .  .  .  .  Lhs: badRecv
  3210  .  .  .  .  .  .  .  .  .  .  .  Rhs: true
  3211  .  .  .  .  .  .  .  .  .  .  }
  3212  .  .  .  .  .  .  .  .  .  }
  3213  .  .  .  .  .  .  .  .  }
  3214  .  .  .  .  .  .  .  }
  3215  .  .  .  .  .  .  }
  3216  .  .  .  .  .  }
  3217  .  .  .  .  .  Else: nil
  3218  .  .  .  .  }
  3219  .  .  .  .  5: *syntax.IfStmt {
  3220  .  .  .  .  .  Init: nil
  3221  .  .  .  .  .  Cond: *syntax.Operation {
  3222  .  .  .  .  .  .  Op: !=
  3223  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  3224  .  .  .  .  .  .  .  X: p
  3225  .  .  .  .  .  .  .  Sel: tok
  3226  .  .  .  .  .  .  }
  3227  .  .  .  .  .  .  Y: _Name
  3228  .  .  .  .  .  }
  3229  .  .  .  .  .  Then: []syntax.Stmt (3 entries) {
  3230  .  .  .  .  .  .  0: *syntax.ExprStmt {
  3231  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3232  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3233  .  .  .  .  .  .  .  .  .  X: p
  3234  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  3235  .  .  .  .  .  .  .  .  }
  3236  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3237  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3238  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting name or (\""
  3239  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3240  .  .  .  .  .  .  .  .  .  }
  3241  .  .  .  .  .  .  .  .  }
  3242  .  .  .  .  .  .  .  .  HasDots: false
  3243  .  .  .  .  .  .  .  }
  3244  .  .  .  .  .  .  }
  3245  .  .  .  .  .  .  1: *syntax.ExprStmt {
  3246  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3247  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3248  .  .  .  .  .  .  .  .  .  X: p
  3249  .  .  .  .  .  .  .  .  .  Sel: advance
  3250  .  .  .  .  .  .  .  .  }
  3251  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  3252  .  .  .  .  .  .  .  .  .  0: _Lbrace
  3253  .  .  .  .  .  .  .  .  .  1: _Semi
  3254  .  .  .  .  .  .  .  .  }
  3255  .  .  .  .  .  .  .  .  HasDots: false
  3256  .  .  .  .  .  .  .  }
  3257  .  .  .  .  .  .  }
  3258  .  .  .  .  .  .  2: *syntax.ReturnStmt {
  3259  .  .  .  .  .  .  .  Results: nil
  3260  .  .  .  .  .  .  }
  3261  .  .  .  .  .  }
  3262  .  .  .  .  .  Else: nil
  3263  .  .  .  .  }
  3264  .  .  .  .  6: *syntax.AssignStmt {
  3265  .  .  .  .  .  Op: <op-0>
  3266  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3267  .  .  .  .  .  .  X: f
  3268  .  .  .  .  .  .  Sel: Name
  3269  .  .  .  .  .  }
  3270  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3271  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3272  .  .  .  .  .  .  .  X: p
  3273  .  .  .  .  .  .  .  Sel: name
  3274  .  .  .  .  .  .  }
  3275  .  .  .  .  .  .  ArgList: nil
  3276  .  .  .  .  .  .  HasDots: false
  3277  .  .  .  .  .  }
  3278  .  .  .  .  }
  3279  .  .  .  .  7: *syntax.AssignStmt {
  3280  .  .  .  .  .  Op: <op-0>
  3281  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3282  .  .  .  .  .  .  X: f
  3283  .  .  .  .  .  .  Sel: Type
  3284  .  .  .  .  .  }
  3285  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3286  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3287  .  .  .  .  .  .  .  X: p
  3288  .  .  .  .  .  .  .  Sel: funcType
  3289  .  .  .  .  .  .  }
  3290  .  .  .  .  .  .  ArgList: nil
  3291  .  .  .  .  .  .  HasDots: false
  3292  .  .  .  .  .  }
  3293  .  .  .  .  }
  3294  .  .  .  .  8: *syntax.IfStmt {
  3295  .  .  .  .  .  Init: nil
  3296  .  .  .  .  .  Cond: gcCompat
  3297  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  3298  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3299  .  .  .  .  .  .  .  Op: <op-0>
  3300  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3301  .  .  .  .  .  .  .  .  X: f
  3302  .  .  .  .  .  .  .  .  Sel: node
  3303  .  .  .  .  .  .  .  }
  3304  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  3305  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  3306  .  .  .  .  .  .  .  .  .  X: f
  3307  .  .  .  .  .  .  .  .  .  Sel: Type
  3308  .  .  .  .  .  .  .  .  }
  3309  .  .  .  .  .  .  .  .  Sel: node
  3310  .  .  .  .  .  .  .  }
  3311  .  .  .  .  .  .  }
  3312  .  .  .  .  .  }
  3313  .  .  .  .  .  Else: nil
  3314  .  .  .  .  }
  3315  .  .  .  .  9: *syntax.AssignStmt {
  3316  .  .  .  .  .  Op: <op-0>
  3317  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3318  .  .  .  .  .  .  X: f
  3319  .  .  .  .  .  .  Sel: Body
  3320  .  .  .  .  .  }
  3321  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3322  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3323  .  .  .  .  .  .  .  X: p
  3324  .  .  .  .  .  .  .  Sel: funcBody
  3325  .  .  .  .  .  .  }
  3326  .  .  .  .  .  .  ArgList: nil
  3327  .  .  .  .  .  .  HasDots: false
  3328  .  .  .  .  .  }
  3329  .  .  .  .  }
  3330  .  .  .  .  10: *syntax.AssignStmt {
  3331  .  .  .  .  .  Op: <op-0>
  3332  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3333  .  .  .  .  .  .  X: f
  3334  .  .  .  .  .  .  Sel: Pragma
  3335  .  .  .  .  .  }
  3336  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  3337  .  .  .  .  .  .  X: p
  3338  .  .  .  .  .  .  Sel: pragma
  3339  .  .  .  .  .  }
  3340  .  .  .  .  }
  3341  .  .  .  .  11: *syntax.AssignStmt {
  3342  .  .  .  .  .  Op: <op-0>
  3343  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3344  .  .  .  .  .  .  X: f
  3345  .  .  .  .  .  .  Sel: EndLine
  3346  .  .  .  .  .  }
  3347  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3348  .  .  .  .  .  .  Fun: uint32
  3349  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3350  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  3351  .  .  .  .  .  .  .  .  X: p
  3352  .  .  .  .  .  .  .  .  Sel: line
  3353  .  .  .  .  .  .  .  }
  3354  .  .  .  .  .  .  }
  3355  .  .  .  .  .  .  HasDots: false
  3356  .  .  .  .  .  }
  3357  .  .  .  .  }
  3358  .  .  .  .  12: *syntax.IfStmt {
  3359  .  .  .  .  .  Init: nil
  3360  .  .  .  .  .  Cond: badRecv
  3361  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  3362  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  3363  .  .  .  .  .  .  .  Results: nil
  3364  .  .  .  .  .  .  }
  3365  .  .  .  .  .  }
  3366  .  .  .  .  .  Else: nil
  3367  .  .  .  .  }
  3368  .  .  .  .  13: *syntax.ReturnStmt {
  3369  .  .  .  .  .  Results: f
  3370  .  .  .  .  }
  3371  .  .  .  }
  3372  .  .  .  Pragma: 0
  3373  .  .  .  EndLine: 442
  3374  .  .  }
  3375  .  .  24: *syntax.FuncDecl {
  3376  .  .  .  Attr: map[]
  3377  .  .  .  Recv: *syntax.Field {
  3378  .  .  .  .  Name: p
  3379  .  .  .  .  Type: *syntax.Operation {
  3380  .  .  .  .  .  Op: *
  3381  .  .  .  .  .  X: parser
  3382  .  .  .  .  .  Y: nil
  3383  .  .  .  .  }
  3384  .  .  .  }
  3385  .  .  .  Name: expr
  3386  .  .  .  Type: *syntax.FuncType {
  3387  .  .  .  .  ParamList: nil
  3388  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  3389  .  .  .  .  .  0: *syntax.Field {
  3390  .  .  .  .  .  .  Name: nil
  3391  .  .  .  .  .  .  Type: Expr
  3392  .  .  .  .  .  }
  3393  .  .  .  .  }
  3394  .  .  .  }
  3395  .  .  .  Body: []syntax.Stmt (2 entries) {
  3396  .  .  .  .  0: *syntax.IfStmt {
  3397  .  .  .  .  .  Init: nil
  3398  .  .  .  .  .  Cond: trace
  3399  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  3400  .  .  .  .  .  .  0: *syntax.CallStmt {
  3401  .  .  .  .  .  .  .  Tok: defer
  3402  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  3403  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  3404  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3405  .  .  .  .  .  .  .  .  .  .  X: p
  3406  .  .  .  .  .  .  .  .  .  .  Sel: trace
  3407  .  .  .  .  .  .  .  .  .  }
  3408  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3409  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3410  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expr\""
  3411  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3412  .  .  .  .  .  .  .  .  .  .  }
  3413  .  .  .  .  .  .  .  .  .  }
  3414  .  .  .  .  .  .  .  .  .  HasDots: false
  3415  .  .  .  .  .  .  .  .  }
  3416  .  .  .  .  .  .  .  .  ArgList: nil
  3417  .  .  .  .  .  .  .  .  HasDots: false
  3418  .  .  .  .  .  .  .  }
  3419  .  .  .  .  .  .  }
  3420  .  .  .  .  .  }
  3421  .  .  .  .  .  Else: nil
  3422  .  .  .  .  }
  3423  .  .  .  .  1: *syntax.ReturnStmt {
  3424  .  .  .  .  .  Results: *syntax.CallExpr {
  3425  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3426  .  .  .  .  .  .  .  X: p
  3427  .  .  .  .  .  .  .  Sel: binaryExpr
  3428  .  .  .  .  .  .  }
  3429  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3430  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3431  .  .  .  .  .  .  .  .  Value: "0"
  3432  .  .  .  .  .  .  .  .  Kind: 0
  3433  .  .  .  .  .  .  .  }
  3434  .  .  .  .  .  .  }
  3435  .  .  .  .  .  .  HasDots: false
  3436  .  .  .  .  .  }
  3437  .  .  .  .  }
  3438  .  .  .  }
  3439  .  .  .  Pragma: 0
  3440  .  .  .  EndLine: 453
  3441  .  .  }
  3442  .  .  25: *syntax.FuncDecl {
  3443  .  .  .  Attr: map[]
  3444  .  .  .  Recv: *syntax.Field {
  3445  .  .  .  .  Name: p
  3446  .  .  .  .  Type: *syntax.Operation {
  3447  .  .  .  .  .  Op: *
  3448  .  .  .  .  .  X: parser
  3449  .  .  .  .  .  Y: nil
  3450  .  .  .  .  }
  3451  .  .  .  }
  3452  .  .  .  Name: binaryExpr
  3453  .  .  .  Type: *syntax.FuncType {
  3454  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  3455  .  .  .  .  .  0: *syntax.Field {
  3456  .  .  .  .  .  .  Name: prec
  3457  .  .  .  .  .  .  Type: int
  3458  .  .  .  .  .  }
  3459  .  .  .  .  }
  3460  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  3461  .  .  .  .  .  0: *syntax.Field {
  3462  .  .  .  .  .  .  Name: nil
  3463  .  .  .  .  .  .  Type: Expr
  3464  .  .  .  .  .  }
  3465  .  .  .  .  }
  3466  .  .  .  }
  3467  .  .  .  Body: []syntax.Stmt (3 entries) {
  3468  .  .  .  .  0: *syntax.AssignStmt {
  3469  .  .  .  .  .  Op: :
  3470  .  .  .  .  .  Lhs: x
  3471  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3472  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3473  .  .  .  .  .  .  .  X: p
  3474  .  .  .  .  .  .  .  Sel: unaryExpr
  3475  .  .  .  .  .  .  }
  3476  .  .  .  .  .  .  ArgList: nil
  3477  .  .  .  .  .  .  HasDots: false
  3478  .  .  .  .  .  }
  3479  .  .  .  .  }
  3480  .  .  .  .  1: *syntax.ForStmt {
  3481  .  .  .  .  .  Init: nil
  3482  .  .  .  .  .  Cond: *syntax.Operation {
  3483  .  .  .  .  .  .  Op: &&
  3484  .  .  .  .  .  .  X: *syntax.ParenExpr {
  3485  .  .  .  .  .  .  .  X: *syntax.Operation {
  3486  .  .  .  .  .  .  .  .  Op: ||
  3487  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  3488  .  .  .  .  .  .  .  .  .  Op: ==
  3489  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  3490  .  .  .  .  .  .  .  .  .  .  X: p
  3491  .  .  .  .  .  .  .  .  .  .  Sel: tok
  3492  .  .  .  .  .  .  .  .  .  }
  3493  .  .  .  .  .  .  .  .  .  Y: _Operator
  3494  .  .  .  .  .  .  .  .  }
  3495  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  3496  .  .  .  .  .  .  .  .  .  Op: ==
  3497  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  3498  .  .  .  .  .  .  .  .  .  .  X: p
  3499  .  .  .  .  .  .  .  .  .  .  Sel: tok
  3500  .  .  .  .  .  .  .  .  .  }
  3501  .  .  .  .  .  .  .  .  .  Y: _Star
  3502  .  .  .  .  .  .  .  .  }
  3503  .  .  .  .  .  .  .  }
  3504  .  .  .  .  .  .  }
  3505  .  .  .  .  .  .  Y: *syntax.Operation {
  3506  .  .  .  .  .  .  .  Op: >
  3507  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  3508  .  .  .  .  .  .  .  .  X: p
  3509  .  .  .  .  .  .  .  .  Sel: prec
  3510  .  .  .  .  .  .  .  }
  3511  .  .  .  .  .  .  .  Y: prec
  3512  .  .  .  .  .  .  }
  3513  .  .  .  .  .  }
  3514  .  .  .  .  .  Post: nil
  3515  .  .  .  .  .  Body: []syntax.Stmt (9 entries) {
  3516  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3517  .  .  .  .  .  .  .  Op: :
  3518  .  .  .  .  .  .  .  Lhs: t
  3519  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3520  .  .  .  .  .  .  .  .  Fun: new
  3521  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3522  .  .  .  .  .  .  .  .  .  0: Operation
  3523  .  .  .  .  .  .  .  .  }
  3524  .  .  .  .  .  .  .  .  HasDots: false
  3525  .  .  .  .  .  .  .  }
  3526  .  .  .  .  .  .  }
  3527  .  .  .  .  .  .  1: *syntax.ExprStmt {
  3528  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3529  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3530  .  .  .  .  .  .  .  .  .  X: t
  3531  .  .  .  .  .  .  .  .  .  Sel: init
  3532  .  .  .  .  .  .  .  .  }
  3533  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3534  .  .  .  .  .  .  .  .  .  0: p
  3535  .  .  .  .  .  .  .  .  }
  3536  .  .  .  .  .  .  .  .  HasDots: false
  3537  .  .  .  .  .  .  .  }
  3538  .  .  .  .  .  .  }
  3539  .  .  .  .  .  .  2: *syntax.AssignStmt {
  3540  .  .  .  .  .  .  .  Op: <op-0>
  3541  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3542  .  .  .  .  .  .  .  .  X: t
  3543  .  .  .  .  .  .  .  .  Sel: Op
  3544  .  .  .  .  .  .  .  }
  3545  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  3546  .  .  .  .  .  .  .  .  X: p
  3547  .  .  .  .  .  .  .  .  Sel: op
  3548  .  .  .  .  .  .  .  }
  3549  .  .  .  .  .  .  }
  3550  .  .  .  .  .  .  3: *syntax.AssignStmt {
  3551  .  .  .  .  .  .  .  Op: <op-0>
  3552  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3553  .  .  .  .  .  .  .  .  X: t
  3554  .  .  .  .  .  .  .  .  Sel: X
  3555  .  .  .  .  .  .  .  }
  3556  .  .  .  .  .  .  .  Rhs: x
  3557  .  .  .  .  .  .  }
  3558  .  .  .  .  .  .  4: *syntax.AssignStmt {
  3559  .  .  .  .  .  .  .  Op: :
  3560  .  .  .  .  .  .  .  Lhs: tprec
  3561  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  3562  .  .  .  .  .  .  .  .  X: p
  3563  .  .  .  .  .  .  .  .  Sel: prec
  3564  .  .  .  .  .  .  .  }
  3565  .  .  .  .  .  .  }
  3566  .  .  .  .  .  .  5: *syntax.ExprStmt {
  3567  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3568  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3569  .  .  .  .  .  .  .  .  .  X: p
  3570  .  .  .  .  .  .  .  .  .  Sel: next
  3571  .  .  .  .  .  .  .  .  }
  3572  .  .  .  .  .  .  .  .  ArgList: nil
  3573  .  .  .  .  .  .  .  .  HasDots: false
  3574  .  .  .  .  .  .  .  }
  3575  .  .  .  .  .  .  }
  3576  .  .  .  .  .  .  6: *syntax.AssignStmt {
  3577  .  .  .  .  .  .  .  Op: <op-0>
  3578  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3579  .  .  .  .  .  .  .  .  X: t
  3580  .  .  .  .  .  .  .  .  Sel: Y
  3581  .  .  .  .  .  .  .  }
  3582  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3583  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3584  .  .  .  .  .  .  .  .  .  X: p
  3585  .  .  .  .  .  .  .  .  .  Sel: binaryExpr
  3586  .  .  .  .  .  .  .  .  }
  3587  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3588  .  .  .  .  .  .  .  .  .  0: tprec
  3589  .  .  .  .  .  .  .  .  }
  3590  .  .  .  .  .  .  .  .  HasDots: false
  3591  .  .  .  .  .  .  .  }
  3592  .  .  .  .  .  .  }
  3593  .  .  .  .  .  .  7: *syntax.IfStmt {
  3594  .  .  .  .  .  .  .  Init: nil
  3595  .  .  .  .  .  .  .  Cond: gcCompat
  3596  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  3597  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  3598  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3599  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3600  .  .  .  .  .  .  .  .  .  .  .  X: t
  3601  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  3602  .  .  .  .  .  .  .  .  .  .  }
  3603  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3604  .  .  .  .  .  .  .  .  .  .  .  0: p
  3605  .  .  .  .  .  .  .  .  .  .  }
  3606  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3607  .  .  .  .  .  .  .  .  .  }
  3608  .  .  .  .  .  .  .  .  }
  3609  .  .  .  .  .  .  .  }
  3610  .  .  .  .  .  .  .  Else: nil
  3611  .  .  .  .  .  .  }
  3612  .  .  .  .  .  .  8: *syntax.AssignStmt {
  3613  .  .  .  .  .  .  .  Op: <op-0>
  3614  .  .  .  .  .  .  .  Lhs: x
  3615  .  .  .  .  .  .  .  Rhs: t
  3616  .  .  .  .  .  .  }
  3617  .  .  .  .  .  }
  3618  .  .  .  .  }
  3619  .  .  .  .  2: *syntax.ReturnStmt {
  3620  .  .  .  .  .  Results: x
  3621  .  .  .  .  }
  3622  .  .  .  }
  3623  .  .  .  Pragma: 0
  3624  .  .  .  EndLine: 474
  3625  .  .  }
  3626  .  .  26: *syntax.FuncDecl {
  3627  .  .  .  Attr: map[]
  3628  .  .  .  Recv: *syntax.Field {
  3629  .  .  .  .  Name: p
  3630  .  .  .  .  Type: *syntax.Operation {
  3631  .  .  .  .  .  Op: *
  3632  .  .  .  .  .  X: parser
  3633  .  .  .  .  .  Y: nil
  3634  .  .  .  .  }
  3635  .  .  .  }
  3636  .  .  .  Name: unaryExpr
  3637  .  .  .  Type: *syntax.FuncType {
  3638  .  .  .  .  ParamList: nil
  3639  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  3640  .  .  .  .  .  0: *syntax.Field {
  3641  .  .  .  .  .  .  Name: nil
  3642  .  .  .  .  .  .  Type: Expr
  3643  .  .  .  .  .  }
  3644  .  .  .  .  }
  3645  .  .  .  }
  3646  .  .  .  Body: []syntax.Stmt (3 entries) {
  3647  .  .  .  .  0: *syntax.IfStmt {
  3648  .  .  .  .  .  Init: nil
  3649  .  .  .  .  .  Cond: trace
  3650  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  3651  .  .  .  .  .  .  0: *syntax.CallStmt {
  3652  .  .  .  .  .  .  .  Tok: defer
  3653  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  3654  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  3655  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3656  .  .  .  .  .  .  .  .  .  .  X: p
  3657  .  .  .  .  .  .  .  .  .  .  Sel: trace
  3658  .  .  .  .  .  .  .  .  .  }
  3659  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3660  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3661  .  .  .  .  .  .  .  .  .  .  .  Value: "\"unaryExpr\""
  3662  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3663  .  .  .  .  .  .  .  .  .  .  }
  3664  .  .  .  .  .  .  .  .  .  }
  3665  .  .  .  .  .  .  .  .  .  HasDots: false
  3666  .  .  .  .  .  .  .  .  }
  3667  .  .  .  .  .  .  .  .  ArgList: nil
  3668  .  .  .  .  .  .  .  .  HasDots: false
  3669  .  .  .  .  .  .  .  }
  3670  .  .  .  .  .  .  }
  3671  .  .  .  .  .  }
  3672  .  .  .  .  .  Else: nil
  3673  .  .  .  .  }
  3674  .  .  .  .  1: *syntax.SwitchStmt {
  3675  .  .  .  .  .  Init: nil
  3676  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  3677  .  .  .  .  .  .  X: p
  3678  .  .  .  .  .  .  Sel: tok
  3679  .  .  .  .  .  }
  3680  .  .  .  .  .  Body: []*syntax.CaseClause (2 entries) {
  3681  .  .  .  .  .  .  0: *syntax.CaseClause {
  3682  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  3683  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  3684  .  .  .  .  .  .  .  .  .  0: _Operator
  3685  .  .  .  .  .  .  .  .  .  1: _Star
  3686  .  .  .  .  .  .  .  .  }
  3687  .  .  .  .  .  .  .  }
  3688  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  3689  .  .  .  .  .  .  .  .  0: *syntax.SwitchStmt {
  3690  .  .  .  .  .  .  .  .  .  Init: nil
  3691  .  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  3692  .  .  .  .  .  .  .  .  .  .  X: p
  3693  .  .  .  .  .  .  .  .  .  .  Sel: op
  3694  .  .  .  .  .  .  .  .  .  }
  3695  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (2 entries) {
  3696  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  3697  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  3698  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (5 entries) {
  3699  .  .  .  .  .  .  .  .  .  .  .  .  .  0: Mul
  3700  .  .  .  .  .  .  .  .  .  .  .  .  .  1: Add
  3701  .  .  .  .  .  .  .  .  .  .  .  .  .  2: Sub
  3702  .  .  .  .  .  .  .  .  .  .  .  .  .  3: Not
  3703  .  .  .  .  .  .  .  .  .  .  .  .  .  4: Xor
  3704  .  .  .  .  .  .  .  .  .  .  .  .  }
  3705  .  .  .  .  .  .  .  .  .  .  .  }
  3706  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (7 entries) {
  3707  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3708  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  3709  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x
  3710  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3711  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new
  3712  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3713  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: Operation
  3714  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3715  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3716  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3717  .  .  .  .  .  .  .  .  .  .  .  .  }
  3718  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  3719  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3720  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3721  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x
  3722  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  3723  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3724  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3725  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
  3726  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3727  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3728  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3729  .  .  .  .  .  .  .  .  .  .  .  .  }
  3730  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  3731  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3732  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3733  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x
  3734  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Op
  3735  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3736  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  3737  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  3738  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: op
  3739  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3740  .  .  .  .  .  .  .  .  .  .  .  .  }
  3741  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
  3742  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3743  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3744  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  3745  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  3746  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3747  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3748  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3749  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3750  .  .  .  .  .  .  .  .  .  .  .  .  }
  3751  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  3752  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3753  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3754  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x
  3755  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X
  3756  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3757  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3758  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3759  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  3760  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: unaryExpr
  3761  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3762  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3763  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3764  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3765  .  .  .  .  .  .  .  .  .  .  .  .  }
  3766  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.IfStmt {
  3767  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  3768  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: gcCompat
  3769  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  3770  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  3771  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3772  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3773  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x
  3774  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  3775  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3776  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3777  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
  3778  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3779  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3780  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3781  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3782  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3783  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  3784  .  .  .  .  .  .  .  .  .  .  .  .  }
  3785  .  .  .  .  .  .  .  .  .  .  .  .  6: *syntax.ReturnStmt {
  3786  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: x
  3787  .  .  .  .  .  .  .  .  .  .  .  .  }
  3788  .  .  .  .  .  .  .  .  .  .  .  }
  3789  .  .  .  .  .  .  .  .  .  .  }
  3790  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  3791  .  .  .  .  .  .  .  .  .  .  .  Cases: And
  3792  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
  3793  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  3794  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3795  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3796  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  3797  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  3798  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3799  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3800  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3801  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3802  .  .  .  .  .  .  .  .  .  .  .  .  }
  3803  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  3804  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  3805  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x
  3806  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3807  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new
  3808  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3809  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: Operation
  3810  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3811  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3812  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3813  .  .  .  .  .  .  .  .  .  .  .  .  }
  3814  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  3815  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3816  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3817  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x
  3818  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  3819  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3820  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3821  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
  3822  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3823  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3824  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3825  .  .  .  .  .  .  .  .  .  .  .  .  }
  3826  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  3827  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3828  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3829  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x
  3830  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Op
  3831  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3832  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: And
  3833  .  .  .  .  .  .  .  .  .  .  .  .  }
  3834  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  3835  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3836  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3837  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x
  3838  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X
  3839  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3840  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3841  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: unparen
  3842  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3843  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  3844  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3845  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  3846  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: unaryExpr
  3847  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3848  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3849  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3850  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3851  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3852  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3853  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3854  .  .  .  .  .  .  .  .  .  .  .  .  }
  3855  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
  3856  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: x
  3857  .  .  .  .  .  .  .  .  .  .  .  .  }
  3858  .  .  .  .  .  .  .  .  .  .  .  }
  3859  .  .  .  .  .  .  .  .  .  .  }
  3860  .  .  .  .  .  .  .  .  .  }
  3861  .  .  .  .  .  .  .  .  }
  3862  .  .  .  .  .  .  .  }
  3863  .  .  .  .  .  .  }
  3864  .  .  .  .  .  .  1: *syntax.CaseClause {
  3865  .  .  .  .  .  .  .  Cases: _Arrow
  3866  .  .  .  .  .  .  .  Body: []syntax.Stmt (4 entries) {
  3867  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  3868  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3869  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3870  .  .  .  .  .  .  .  .  .  .  .  X: p
  3871  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  3872  .  .  .  .  .  .  .  .  .  .  }
  3873  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3874  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3875  .  .  .  .  .  .  .  .  .  }
  3876  .  .  .  .  .  .  .  .  }
  3877  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  3878  .  .  .  .  .  .  .  .  .  Op: :
  3879  .  .  .  .  .  .  .  .  .  Lhs: x
  3880  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3881  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3882  .  .  .  .  .  .  .  .  .  .  .  X: p
  3883  .  .  .  .  .  .  .  .  .  .  .  Sel: unaryExpr
  3884  .  .  .  .  .  .  .  .  .  .  }
  3885  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3886  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3887  .  .  .  .  .  .  .  .  .  }
  3888  .  .  .  .  .  .  .  .  }
  3889  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
  3890  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
  3891  .  .  .  .  .  .  .  .  .  .  Op: :
  3892  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
  3893  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  3894  .  .  .  .  .  .  .  .  .  .  .  .  0: _
  3895  .  .  .  .  .  .  .  .  .  .  .  .  1: ok
  3896  .  .  .  .  .  .  .  .  .  .  .  }
  3897  .  .  .  .  .  .  .  .  .  .  }
  3898  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
  3899  .  .  .  .  .  .  .  .  .  .  .  X: x
  3900  .  .  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
  3901  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  3902  .  .  .  .  .  .  .  .  .  .  .  .  X: ChanType
  3903  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  3904  .  .  .  .  .  .  .  .  .  .  .  }
  3905  .  .  .  .  .  .  .  .  .  .  }
  3906  .  .  .  .  .  .  .  .  .  }
  3907  .  .  .  .  .  .  .  .  .  Cond: ok
  3908  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (5 entries) {
  3909  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3910  .  .  .  .  .  .  .  .  .  .  .  Op: :
  3911  .  .  .  .  .  .  .  .  .  .  .  Lhs: dir
  3912  .  .  .  .  .  .  .  .  .  .  .  Rhs: SendOnly
  3913  .  .  .  .  .  .  .  .  .  .  }
  3914  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  3915  .  .  .  .  .  .  .  .  .  .  .  Op: :
  3916  .  .  .  .  .  .  .  .  .  .  .  Lhs: t
  3917  .  .  .  .  .  .  .  .  .  .  .  Rhs: x
  3918  .  .  .  .  .  .  .  .  .  .  }
  3919  .  .  .  .  .  .  .  .  .  .  2: *syntax.ForStmt {
  3920  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  3921  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  3922  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  3923  .  .  .  .  .  .  .  .  .  .  .  .  X: dir
  3924  .  .  .  .  .  .  .  .  .  .  .  .  Y: SendOnly
  3925  .  .  .  .  .  .  .  .  .  .  .  }
  3926  .  .  .  .  .  .  .  .  .  .  .  Post: nil
  3927  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
  3928  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3929  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  3930  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
  3931  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  3932  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: c
  3933  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: ok
  3934  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3935  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3936  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
  3937  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  3938  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
  3939  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  3940  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: ChanType
  3941  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  3942  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3943  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3944  .  .  .  .  .  .  .  .  .  .  .  .  }
  3945  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  3946  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  3947  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  3948  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !
  3949  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: ok
  3950  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  3951  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3952  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  3953  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  3954  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  3955  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
  3956  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3957  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3958  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  3959  .  .  .  .  .  .  .  .  .  .  .  .  }
  3960  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  3961  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3962  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: dir
  3963  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  3964  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: c
  3965  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Dir
  3966  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3967  .  .  .  .  .  .  .  .  .  .  .  .  }
  3968  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  3969  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  3970  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  3971  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  3972  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: dir
  3973  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: RecvOnly
  3974  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3975  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  3976  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  3977  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3978  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3979  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  3980  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  3981  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3982  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3983  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3984  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"unexpected <-, expecting chan\""
  3985  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3986  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3987  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3988  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3989  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3990  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3991  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3992  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  3993  .  .  .  .  .  .  .  .  .  .  .  .  }
  3994  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  3995  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3996  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3997  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: c
  3998  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Dir
  3999  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4000  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: RecvOnly
  4001  .  .  .  .  .  .  .  .  .  .  .  .  }
  4002  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  4003  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4004  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t
  4005  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  4006  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: c
  4007  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Elem
  4008  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4009  .  .  .  .  .  .  .  .  .  .  .  .  }
  4010  .  .  .  .  .  .  .  .  .  .  .  }
  4011  .  .  .  .  .  .  .  .  .  .  }
  4012  .  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  4013  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  4014  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  4015  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  4016  .  .  .  .  .  .  .  .  .  .  .  .  X: dir
  4017  .  .  .  .  .  .  .  .  .  .  .  .  Y: SendOnly
  4018  .  .  .  .  .  .  .  .  .  .  .  }
  4019  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  4020  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4021  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4022  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4023  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4024  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  4025  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4026  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4027  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  4028  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4029  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt
  4030  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf
  4031  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4032  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  4033  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4034  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"unexpected %s, expecting chan\""
  4035  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4036  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4037  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
  4038  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: String
  4039  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4040  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: t
  4041  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4042  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4043  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4044  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4045  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4046  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4047  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4048  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4049  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4050  .  .  .  .  .  .  .  .  .  .  .  .  }
  4051  .  .  .  .  .  .  .  .  .  .  .  }
  4052  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  4053  .  .  .  .  .  .  .  .  .  .  }
  4054  .  .  .  .  .  .  .  .  .  .  4: *syntax.ReturnStmt {
  4055  .  .  .  .  .  .  .  .  .  .  .  Results: x
  4056  .  .  .  .  .  .  .  .  .  .  }
  4057  .  .  .  .  .  .  .  .  .  }
  4058  .  .  .  .  .  .  .  .  .  Else: nil
  4059  .  .  .  .  .  .  .  .  }
  4060  .  .  .  .  .  .  .  .  3: *syntax.ReturnStmt {
  4061  .  .  .  .  .  .  .  .  .  Results: *syntax.Operation {
  4062  .  .  .  .  .  .  .  .  .  .  Op: &
  4063  .  .  .  .  .  .  .  .  .  .  X: *syntax.CompositeLit {
  4064  .  .  .  .  .  .  .  .  .  .  .  Type: Operation
  4065  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  4066  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.KeyValueExpr {
  4067  .  .  .  .  .  .  .  .  .  .  .  .  .  Key: Op
  4068  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: Recv
  4069  .  .  .  .  .  .  .  .  .  .  .  .  }
  4070  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.KeyValueExpr {
  4071  .  .  .  .  .  .  .  .  .  .  .  .  .  Key: X
  4072  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: x
  4073  .  .  .  .  .  .  .  .  .  .  .  .  }
  4074  .  .  .  .  .  .  .  .  .  .  .  }
  4075  .  .  .  .  .  .  .  .  .  .  .  NKeys: 2
  4076  .  .  .  .  .  .  .  .  .  .  .  EndLine: 557
  4077  .  .  .  .  .  .  .  .  .  .  }
  4078  .  .  .  .  .  .  .  .  .  .  Y: nil
  4079  .  .  .  .  .  .  .  .  .  }
  4080  .  .  .  .  .  .  .  .  }
  4081  .  .  .  .  .  .  .  }
  4082  .  .  .  .  .  .  }
  4083  .  .  .  .  .  }
  4084  .  .  .  .  }
  4085  .  .  .  .  2: *syntax.ReturnStmt {
  4086  .  .  .  .  .  Results: *syntax.CallExpr {
  4087  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4088  .  .  .  .  .  .  .  X: p
  4089  .  .  .  .  .  .  .  Sel: pexpr
  4090  .  .  .  .  .  .  }
  4091  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4092  .  .  .  .  .  .  .  0: true
  4093  .  .  .  .  .  .  }
  4094  .  .  .  .  .  .  HasDots: false
  4095  .  .  .  .  .  }
  4096  .  .  .  .  }
  4097  .  .  .  }
  4098  .  .  .  Pragma: 0
  4099  .  .  .  EndLine: 564
  4100  .  .  }
  4101  .  .  27: *syntax.FuncDecl {
  4102  .  .  .  Attr: map[]
  4103  .  .  .  Recv: *syntax.Field {
  4104  .  .  .  .  Name: p
  4105  .  .  .  .  Type: *syntax.Operation {
  4106  .  .  .  .  .  Op: *
  4107  .  .  .  .  .  X: parser
  4108  .  .  .  .  .  Y: nil
  4109  .  .  .  .  }
  4110  .  .  .  }
  4111  .  .  .  Name: callStmt
  4112  .  .  .  Type: *syntax.FuncType {
  4113  .  .  .  .  ParamList: nil
  4114  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  4115  .  .  .  .  .  0: *syntax.Field {
  4116  .  .  .  .  .  .  Name: nil
  4117  .  .  .  .  .  .  Type: *syntax.Operation {
  4118  .  .  .  .  .  .  .  Op: *
  4119  .  .  .  .  .  .  .  X: CallStmt
  4120  .  .  .  .  .  .  .  Y: nil
  4121  .  .  .  .  .  .  }
  4122  .  .  .  .  .  }
  4123  .  .  .  .  }
  4124  .  .  .  }
  4125  .  .  .  Body: []syntax.Stmt (8 entries) {
  4126  .  .  .  .  0: *syntax.IfStmt {
  4127  .  .  .  .  .  Init: nil
  4128  .  .  .  .  .  Cond: trace
  4129  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  4130  .  .  .  .  .  .  0: *syntax.CallStmt {
  4131  .  .  .  .  .  .  .  Tok: defer
  4132  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  4133  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  4134  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4135  .  .  .  .  .  .  .  .  .  .  X: p
  4136  .  .  .  .  .  .  .  .  .  .  Sel: trace
  4137  .  .  .  .  .  .  .  .  .  }
  4138  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4139  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4140  .  .  .  .  .  .  .  .  .  .  .  Value: "\"callStmt\""
  4141  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4142  .  .  .  .  .  .  .  .  .  .  }
  4143  .  .  .  .  .  .  .  .  .  }
  4144  .  .  .  .  .  .  .  .  .  HasDots: false
  4145  .  .  .  .  .  .  .  .  }
  4146  .  .  .  .  .  .  .  .  ArgList: nil
  4147  .  .  .  .  .  .  .  .  HasDots: false
  4148  .  .  .  .  .  .  .  }
  4149  .  .  .  .  .  .  }
  4150  .  .  .  .  .  }
  4151  .  .  .  .  .  Else: nil
  4152  .  .  .  .  }
  4153  .  .  .  .  1: *syntax.AssignStmt {
  4154  .  .  .  .  .  Op: :
  4155  .  .  .  .  .  Lhs: s
  4156  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4157  .  .  .  .  .  .  Fun: new
  4158  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4159  .  .  .  .  .  .  .  0: CallStmt
  4160  .  .  .  .  .  .  }
  4161  .  .  .  .  .  .  HasDots: false
  4162  .  .  .  .  .  }
  4163  .  .  .  .  }
  4164  .  .  .  .  2: *syntax.ExprStmt {
  4165  .  .  .  .  .  X: *syntax.CallExpr {
  4166  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4167  .  .  .  .  .  .  .  X: s
  4168  .  .  .  .  .  .  .  Sel: init
  4169  .  .  .  .  .  .  }
  4170  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4171  .  .  .  .  .  .  .  0: p
  4172  .  .  .  .  .  .  }
  4173  .  .  .  .  .  .  HasDots: false
  4174  .  .  .  .  .  }
  4175  .  .  .  .  }
  4176  .  .  .  .  3: *syntax.AssignStmt {
  4177  .  .  .  .  .  Op: <op-0>
  4178  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4179  .  .  .  .  .  .  X: s
  4180  .  .  .  .  .  .  Sel: Tok
  4181  .  .  .  .  .  }
  4182  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  4183  .  .  .  .  .  .  X: p
  4184  .  .  .  .  .  .  Sel: tok
  4185  .  .  .  .  .  }
  4186  .  .  .  .  }
  4187  .  .  .  .  4: *syntax.ExprStmt {
  4188  .  .  .  .  .  X: *syntax.CallExpr {
  4189  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4190  .  .  .  .  .  .  .  X: p
  4191  .  .  .  .  .  .  .  Sel: next
  4192  .  .  .  .  .  .  }
  4193  .  .  .  .  .  .  ArgList: nil
  4194  .  .  .  .  .  .  HasDots: false
  4195  .  .  .  .  .  }
  4196  .  .  .  .  }
  4197  .  .  .  .  5: *syntax.AssignStmt {
  4198  .  .  .  .  .  Op: :
  4199  .  .  .  .  .  Lhs: x
  4200  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4201  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4202  .  .  .  .  .  .  .  X: p
  4203  .  .  .  .  .  .  .  Sel: pexpr
  4204  .  .  .  .  .  .  }
  4205  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4206  .  .  .  .  .  .  .  0: *syntax.Operation {
  4207  .  .  .  .  .  .  .  .  Op: ==
  4208  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  4209  .  .  .  .  .  .  .  .  .  X: p
  4210  .  .  .  .  .  .  .  .  .  Sel: tok
  4211  .  .  .  .  .  .  .  .  }
  4212  .  .  .  .  .  .  .  .  Y: _Lparen
  4213  .  .  .  .  .  .  .  }
  4214  .  .  .  .  .  .  }
  4215  .  .  .  .  .  .  HasDots: false
  4216  .  .  .  .  .  }
  4217  .  .  .  .  }
  4218  .  .  .  .  6: *syntax.SwitchStmt {
  4219  .  .  .  .  .  Init: nil
  4220  .  .  .  .  .  Tag: *syntax.TypeSwitchGuard {
  4221  .  .  .  .  .  .  Lhs: x
  4222  .  .  .  .  .  .  X: x
  4223  .  .  .  .  .  }
  4224  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
  4225  .  .  .  .  .  .  0: *syntax.CaseClause {
  4226  .  .  .  .  .  .  .  Cases: *syntax.Operation {
  4227  .  .  .  .  .  .  .  .  Op: *
  4228  .  .  .  .  .  .  .  .  X: CallExpr
  4229  .  .  .  .  .  .  .  .  Y: nil
  4230  .  .  .  .  .  .  .  }
  4231  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  4232  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4233  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4234  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4235  .  .  .  .  .  .  .  .  .  .  X: s
  4236  .  .  .  .  .  .  .  .  .  .  Sel: Call
  4237  .  .  .  .  .  .  .  .  .  }
  4238  .  .  .  .  .  .  .  .  .  Rhs: x
  4239  .  .  .  .  .  .  .  .  }
  4240  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  4241  .  .  .  .  .  .  .  .  .  Init: nil
  4242  .  .  .  .  .  .  .  .  .  Cond: gcCompat
  4243  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  4244  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4245  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4246  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4247  .  .  .  .  .  .  .  .  .  .  .  .  X: s
  4248  .  .  .  .  .  .  .  .  .  .  .  .  Sel: node
  4249  .  .  .  .  .  .  .  .  .  .  .  }
  4250  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  4251  .  .  .  .  .  .  .  .  .  .  .  .  X: x
  4252  .  .  .  .  .  .  .  .  .  .  .  .  Sel: node
  4253  .  .  .  .  .  .  .  .  .  .  .  }
  4254  .  .  .  .  .  .  .  .  .  .  }
  4255  .  .  .  .  .  .  .  .  .  }
  4256  .  .  .  .  .  .  .  .  .  Else: nil
  4257  .  .  .  .  .  .  .  .  }
  4258  .  .  .  .  .  .  .  }
  4259  .  .  .  .  .  .  }
  4260  .  .  .  .  .  .  1: *syntax.CaseClause {
  4261  .  .  .  .  .  .  .  Cases: *syntax.Operation {
  4262  .  .  .  .  .  .  .  .  Op: *
  4263  .  .  .  .  .  .  .  .  X: ParenExpr
  4264  .  .  .  .  .  .  .  .  Y: nil
  4265  .  .  .  .  .  .  .  }
  4266  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  4267  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4268  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4269  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4270  .  .  .  .  .  .  .  .  .  .  .  X: p
  4271  .  .  .  .  .  .  .  .  .  .  .  Sel: error
  4272  .  .  .  .  .  .  .  .  .  .  }
  4273  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4274  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  4275  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4276  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt
  4277  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf
  4278  .  .  .  .  .  .  .  .  .  .  .  .  }
  4279  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  4280  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4281  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expression in %s must not be parenthesized\""
  4282  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4283  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4284  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  4285  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s
  4286  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Tok
  4287  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4288  .  .  .  .  .  .  .  .  .  .  .  .  }
  4289  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4290  .  .  .  .  .  .  .  .  .  .  .  }
  4291  .  .  .  .  .  .  .  .  .  .  }
  4292  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4293  .  .  .  .  .  .  .  .  .  }
  4294  .  .  .  .  .  .  .  .  }
  4295  .  .  .  .  .  .  .  }
  4296  .  .  .  .  .  .  }
  4297  .  .  .  .  .  .  2: *syntax.CaseClause {
  4298  .  .  .  .  .  .  .  Cases: nil
  4299  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  4300  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4301  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4302  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4303  .  .  .  .  .  .  .  .  .  .  .  X: p
  4304  .  .  .  .  .  .  .  .  .  .  .  Sel: error
  4305  .  .  .  .  .  .  .  .  .  .  }
  4306  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4307  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  4308  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4309  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt
  4310  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf
  4311  .  .  .  .  .  .  .  .  .  .  .  .  }
  4312  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  4313  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4314  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expression in %s must be function call\""
  4315  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4316  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4317  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  4318  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s
  4319  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Tok
  4320  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4321  .  .  .  .  .  .  .  .  .  .  .  .  }
  4322  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4323  .  .  .  .  .  .  .  .  .  .  .  }
  4324  .  .  .  .  .  .  .  .  .  .  }
  4325  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4326  .  .  .  .  .  .  .  .  .  }
  4327  .  .  .  .  .  .  .  .  }
  4328  .  .  .  .  .  .  .  }
  4329  .  .  .  .  .  .  }
  4330  .  .  .  .  .  }
  4331  .  .  .  .  }
  4332  .  .  .  .  7: *syntax.ReturnStmt {
  4333  .  .  .  .  .  Results: s
  4334  .  .  .  .  }
  4335  .  .  .  }
  4336  .  .  .  Pragma: 0
  4337  .  .  .  EndLine: 593
  4338  .  .  }
  4339  .  .  28: *syntax.FuncDecl {
  4340  .  .  .  Attr: map[]
  4341  .  .  .  Recv: *syntax.Field {
  4342  .  .  .  .  Name: p
  4343  .  .  .  .  Type: *syntax.Operation {
  4344  .  .  .  .  .  Op: *
  4345  .  .  .  .  .  X: parser
  4346  .  .  .  .  .  Y: nil
  4347  .  .  .  .  }
  4348  .  .  .  }
  4349  .  .  .  Name: operand
  4350  .  .  .  Type: *syntax.FuncType {
  4351  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  4352  .  .  .  .  .  0: *syntax.Field {
  4353  .  .  .  .  .  .  Name: keep_parens
  4354  .  .  .  .  .  .  Type: bool
  4355  .  .  .  .  .  }
  4356  .  .  .  .  }
  4357  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  4358  .  .  .  .  .  0: *syntax.Field {
  4359  .  .  .  .  .  .  Name: nil
  4360  .  .  .  .  .  .  Type: Expr
  4361  .  .  .  .  .  }
  4362  .  .  .  .  }
  4363  .  .  .  }
  4364  .  .  .  Body: []syntax.Stmt (2 entries) {
  4365  .  .  .  .  0: *syntax.IfStmt {
  4366  .  .  .  .  .  Init: nil
  4367  .  .  .  .  .  Cond: trace
  4368  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  4369  .  .  .  .  .  .  0: *syntax.CallStmt {
  4370  .  .  .  .  .  .  .  Tok: defer
  4371  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  4372  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  4373  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4374  .  .  .  .  .  .  .  .  .  .  X: p
  4375  .  .  .  .  .  .  .  .  .  .  Sel: trace
  4376  .  .  .  .  .  .  .  .  .  }
  4377  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4378  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
  4379  .  .  .  .  .  .  .  .  .  .  .  Op: +
  4380  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  4381  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"operand \""
  4382  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4383  .  .  .  .  .  .  .  .  .  .  .  }
  4384  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
  4385  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4386  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  4387  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4388  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  4389  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4390  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: String
  4391  .  .  .  .  .  .  .  .  .  .  .  .  }
  4392  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4393  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4394  .  .  .  .  .  .  .  .  .  .  .  }
  4395  .  .  .  .  .  .  .  .  .  .  }
  4396  .  .  .  .  .  .  .  .  .  }
  4397  .  .  .  .  .  .  .  .  .  HasDots: false
  4398  .  .  .  .  .  .  .  .  }
  4399  .  .  .  .  .  .  .  .  ArgList: nil
  4400  .  .  .  .  .  .  .  .  HasDots: false
  4401  .  .  .  .  .  .  .  }
  4402  .  .  .  .  .  .  }
  4403  .  .  .  .  .  }
  4404  .  .  .  .  .  Else: nil
  4405  .  .  .  .  }
  4406  .  .  .  .  1: *syntax.SwitchStmt {
  4407  .  .  .  .  .  Init: nil
  4408  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  4409  .  .  .  .  .  .  X: p
  4410  .  .  .  .  .  .  Sel: tok
  4411  .  .  .  .  .  }
  4412  .  .  .  .  .  Body: []*syntax.CaseClause (7 entries) {
  4413  .  .  .  .  .  .  0: *syntax.CaseClause {
  4414  .  .  .  .  .  .  .  Cases: _Name
  4415  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  4416  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  4417  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  4418  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4419  .  .  .  .  .  .  .  .  .  .  .  X: p
  4420  .  .  .  .  .  .  .  .  .  .  .  Sel: name
  4421  .  .  .  .  .  .  .  .  .  .  }
  4422  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4423  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4424  .  .  .  .  .  .  .  .  .  }
  4425  .  .  .  .  .  .  .  .  }
  4426  .  .  .  .  .  .  .  }
  4427  .  .  .  .  .  .  }
  4428  .  .  .  .  .  .  1: *syntax.CaseClause {
  4429  .  .  .  .  .  .  .  Cases: _Literal
  4430  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  4431  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  4432  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  4433  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4434  .  .  .  .  .  .  .  .  .  .  .  X: p
  4435  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral
  4436  .  .  .  .  .  .  .  .  .  .  }
  4437  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4438  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4439  .  .  .  .  .  .  .  .  .  }
  4440  .  .  .  .  .  .  .  .  }
  4441  .  .  .  .  .  .  .  }
  4442  .  .  .  .  .  .  }
  4443  .  .  .  .  .  .  2: *syntax.CaseClause {
  4444  .  .  .  .  .  .  .  Cases: _Lparen
  4445  .  .  .  .  .  .  .  Body: []syntax.Stmt (8 entries) {
  4446  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4447  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4448  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4449  .  .  .  .  .  .  .  .  .  .  .  X: p
  4450  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  4451  .  .  .  .  .  .  .  .  .  .  }
  4452  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4453  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4454  .  .  .  .  .  .  .  .  .  }
  4455  .  .  .  .  .  .  .  .  }
  4456  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  4457  .  .  .  .  .  .  .  .  .  Op: +
  4458  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4459  .  .  .  .  .  .  .  .  .  .  X: p
  4460  .  .  .  .  .  .  .  .  .  .  Sel: xnest
  4461  .  .  .  .  .  .  .  .  .  }
  4462  .  .  .  .  .  .  .  .  .  Rhs: *syntax.BasicLit {
  4463  .  .  .  .  .  .  .  .  .  .  Value: "1"
  4464  .  .  .  .  .  .  .  .  .  .  Kind: 0
  4465  .  .  .  .  .  .  .  .  .  }
  4466  .  .  .  .  .  .  .  .  }
  4467  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  4468  .  .  .  .  .  .  .  .  .  Op: :
  4469  .  .  .  .  .  .  .  .  .  Lhs: x
  4470  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4471  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4472  .  .  .  .  .  .  .  .  .  .  .  X: p
  4473  .  .  .  .  .  .  .  .  .  .  .  Sel: expr
  4474  .  .  .  .  .  .  .  .  .  .  }
  4475  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4476  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4477  .  .  .  .  .  .  .  .  .  }
  4478  .  .  .  .  .  .  .  .  }
  4479  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  4480  .  .  .  .  .  .  .  .  .  Op: -
  4481  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4482  .  .  .  .  .  .  .  .  .  .  X: p
  4483  .  .  .  .  .  .  .  .  .  .  Sel: xnest
  4484  .  .  .  .  .  .  .  .  .  }
  4485  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  4486  .  .  .  .  .  .  .  .  }
  4487  .  .  .  .  .  .  .  .  4: *syntax.ExprStmt {
  4488  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4489  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4490  .  .  .  .  .  .  .  .  .  .  .  X: p
  4491  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  4492  .  .  .  .  .  .  .  .  .  .  }
  4493  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4494  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen
  4495  .  .  .  .  .  .  .  .  .  .  }
  4496  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4497  .  .  .  .  .  .  .  .  .  }
  4498  .  .  .  .  .  .  .  .  }
  4499  .  .  .  .  .  .  .  .  5: *syntax.IfStmt {
  4500  .  .  .  .  .  .  .  .  .  Init: nil
  4501  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  4502  .  .  .  .  .  .  .  .  .  .  Op: ==
  4503  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  4504  .  .  .  .  .  .  .  .  .  .  .  X: p
  4505  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  4506  .  .  .  .  .  .  .  .  .  .  }
  4507  .  .  .  .  .  .  .  .  .  .  Y: _Lbrace
  4508  .  .  .  .  .  .  .  .  .  }
  4509  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  4510  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4511  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4512  .  .  .  .  .  .  .  .  .  .  .  Lhs: keep_parens
  4513  .  .  .  .  .  .  .  .  .  .  .  Rhs: true
  4514  .  .  .  .  .  .  .  .  .  .  }
  4515  .  .  .  .  .  .  .  .  .  }
  4516  .  .  .  .  .  .  .  .  .  Else: nil
  4517  .  .  .  .  .  .  .  .  }
  4518  .  .  .  .  .  .  .  .  6: *syntax.IfStmt {
  4519  .  .  .  .  .  .  .  .  .  Init: nil
  4520  .  .  .  .  .  .  .  .  .  Cond: keep_parens
  4521  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  4522  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4523  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4524  .  .  .  .  .  .  .  .  .  .  .  Lhs: x
  4525  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
  4526  .  .  .  .  .  .  .  .  .  .  .  .  Op: &
  4527  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CompositeLit {
  4528  .  .  .  .  .  .  .  .  .  .  .  .  .  Type: ParenExpr
  4529  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (1 entries) {
  4530  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.KeyValueExpr {
  4531  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Key: X
  4532  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: x
  4533  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4534  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4535  .  .  .  .  .  .  .  .  .  .  .  .  .  NKeys: 1
  4536  .  .  .  .  .  .  .  .  .  .  .  .  .  EndLine: 640
  4537  .  .  .  .  .  .  .  .  .  .  .  .  }
  4538  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  4539  .  .  .  .  .  .  .  .  .  .  .  }
  4540  .  .  .  .  .  .  .  .  .  .  }
  4541  .  .  .  .  .  .  .  .  .  }
  4542  .  .  .  .  .  .  .  .  .  Else: nil
  4543  .  .  .  .  .  .  .  .  }
  4544  .  .  .  .  .  .  .  .  7: *syntax.ReturnStmt {
  4545  .  .  .  .  .  .  .  .  .  Results: x
  4546  .  .  .  .  .  .  .  .  }
  4547  .  .  .  .  .  .  .  }
  4548  .  .  .  .  .  .  }
  4549  .  .  .  .  .  .  3: *syntax.CaseClause {
  4550  .  .  .  .  .  .  .  Cases: _Func
  4551  .  .  .  .  .  .  .  Body: []syntax.Stmt (4 entries) {
  4552  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4553  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4554  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4555  .  .  .  .  .  .  .  .  .  .  .  X: p
  4556  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  4557  .  .  .  .  .  .  .  .  .  .  }
  4558  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4559  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4560  .  .  .  .  .  .  .  .  .  }
  4561  .  .  .  .  .  .  .  .  }
  4562  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  4563  .  .  .  .  .  .  .  .  .  Op: :
  4564  .  .  .  .  .  .  .  .  .  Lhs: t
  4565  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4566  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4567  .  .  .  .  .  .  .  .  .  .  .  X: p
  4568  .  .  .  .  .  .  .  .  .  .  .  Sel: funcType
  4569  .  .  .  .  .  .  .  .  .  .  }
  4570  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4571  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4572  .  .  .  .  .  .  .  .  .  }
  4573  .  .  .  .  .  .  .  .  }
  4574  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
  4575  .  .  .  .  .  .  .  .  .  Init: nil
  4576  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  4577  .  .  .  .  .  .  .  .  .  .  Op: ==
  4578  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  4579  .  .  .  .  .  .  .  .  .  .  .  X: p
  4580  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  4581  .  .  .  .  .  .  .  .  .  .  }
  4582  .  .  .  .  .  .  .  .  .  .  Y: _Lbrace
  4583  .  .  .  .  .  .  .  .  .  }
  4584  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (10 entries) {
  4585  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4586  .  .  .  .  .  .  .  .  .  .  .  Op: +
  4587  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4588  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4589  .  .  .  .  .  .  .  .  .  .  .  .  Sel: fnest
  4590  .  .  .  .  .  .  .  .  .  .  .  }
  4591  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  4592  .  .  .  .  .  .  .  .  .  .  }
  4593  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  4594  .  .  .  .  .  .  .  .  .  .  .  Op: +
  4595  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4596  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4597  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest
  4598  .  .  .  .  .  .  .  .  .  .  .  }
  4599  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  4600  .  .  .  .  .  .  .  .  .  .  }
  4601  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  4602  .  .  .  .  .  .  .  .  .  .  .  Op: :
  4603  .  .  .  .  .  .  .  .  .  .  .  Lhs: f
  4604  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4605  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new
  4606  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4607  .  .  .  .  .  .  .  .  .  .  .  .  .  0: FuncLit
  4608  .  .  .  .  .  .  .  .  .  .  .  .  }
  4609  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4610  .  .  .  .  .  .  .  .  .  .  .  }
  4611  .  .  .  .  .  .  .  .  .  .  }
  4612  .  .  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
  4613  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4614  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4615  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  4616  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  4617  .  .  .  .  .  .  .  .  .  .  .  .  }
  4618  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4619  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
  4620  .  .  .  .  .  .  .  .  .  .  .  .  }
  4621  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4622  .  .  .  .  .  .  .  .  .  .  .  }
  4623  .  .  .  .  .  .  .  .  .  .  }
  4624  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  4625  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4626  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4627  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  4628  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
  4629  .  .  .  .  .  .  .  .  .  .  .  }
  4630  .  .  .  .  .  .  .  .  .  .  .  Rhs: t
  4631  .  .  .  .  .  .  .  .  .  .  }
  4632  .  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  4633  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4634  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4635  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  4636  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Body
  4637  .  .  .  .  .  .  .  .  .  .  .  }
  4638  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4639  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4640  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4641  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: funcBody
  4642  .  .  .  .  .  .  .  .  .  .  .  .  }
  4643  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4644  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4645  .  .  .  .  .  .  .  .  .  .  .  }
  4646  .  .  .  .  .  .  .  .  .  .  }
  4647  .  .  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
  4648  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4649  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4650  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  4651  .  .  .  .  .  .  .  .  .  .  .  .  Sel: EndLine
  4652  .  .  .  .  .  .  .  .  .  .  .  }
  4653  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4654  .  .  .  .  .  .  .  .  .  .  .  .  Fun: uint32
  4655  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4656  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  4657  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4658  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: line
  4659  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4660  .  .  .  .  .  .  .  .  .  .  .  .  }
  4661  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4662  .  .  .  .  .  .  .  .  .  .  .  }
  4663  .  .  .  .  .  .  .  .  .  .  }
  4664  .  .  .  .  .  .  .  .  .  .  7: *syntax.AssignStmt {
  4665  .  .  .  .  .  .  .  .  .  .  .  Op: -
  4666  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4667  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4668  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest
  4669  .  .  .  .  .  .  .  .  .  .  .  }
  4670  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  4671  .  .  .  .  .  .  .  .  .  .  }
  4672  .  .  .  .  .  .  .  .  .  .  8: *syntax.AssignStmt {
  4673  .  .  .  .  .  .  .  .  .  .  .  Op: -
  4674  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4675  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4676  .  .  .  .  .  .  .  .  .  .  .  .  Sel: fnest
  4677  .  .  .  .  .  .  .  .  .  .  .  }
  4678  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  4679  .  .  .  .  .  .  .  .  .  .  }
  4680  .  .  .  .  .  .  .  .  .  .  9: *syntax.ReturnStmt {
  4681  .  .  .  .  .  .  .  .  .  .  .  Results: f
  4682  .  .  .  .  .  .  .  .  .  .  }
  4683  .  .  .  .  .  .  .  .  .  }
  4684  .  .  .  .  .  .  .  .  .  Else: nil
  4685  .  .  .  .  .  .  .  .  }
  4686  .  .  .  .  .  .  .  .  3: *syntax.ReturnStmt {
  4687  .  .  .  .  .  .  .  .  .  Results: t
  4688  .  .  .  .  .  .  .  .  }
  4689  .  .  .  .  .  .  .  }
  4690  .  .  .  .  .  .  }
  4691  .  .  .  .  .  .  4: *syntax.CaseClause {
  4692  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  4693  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (5 entries) {
  4694  .  .  .  .  .  .  .  .  .  0: _Lbrack
  4695  .  .  .  .  .  .  .  .  .  1: _Chan
  4696  .  .  .  .  .  .  .  .  .  2: _Map
  4697  .  .  .  .  .  .  .  .  .  3: _Struct
  4698  .  .  .  .  .  .  .  .  .  4: _Interface
  4699  .  .  .  .  .  .  .  .  }
  4700  .  .  .  .  .  .  .  }
  4701  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  4702  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  4703  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  4704  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4705  .  .  .  .  .  .  .  .  .  .  .  X: p
  4706  .  .  .  .  .  .  .  .  .  .  .  Sel: type_
  4707  .  .  .  .  .  .  .  .  .  .  }
  4708  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4709  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4710  .  .  .  .  .  .  .  .  .  }
  4711  .  .  .  .  .  .  .  .  }
  4712  .  .  .  .  .  .  .  }
  4713  .  .  .  .  .  .  }
  4714  .  .  .  .  .  .  5: *syntax.CaseClause {
  4715  .  .  .  .  .  .  .  Cases: _Lbrace
  4716  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  4717  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4718  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4719  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4720  .  .  .  .  .  .  .  .  .  .  .  X: p
  4721  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  4722  .  .  .  .  .  .  .  .  .  .  }
  4723  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4724  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4725  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"missing operand\""
  4726  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4727  .  .  .  .  .  .  .  .  .  .  .  }
  4728  .  .  .  .  .  .  .  .  .  .  }
  4729  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4730  .  .  .  .  .  .  .  .  .  }
  4731  .  .  .  .  .  .  .  .  }
  4732  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
  4733  .  .  .  .  .  .  .  .  .  Results: nil
  4734  .  .  .  .  .  .  .  .  }
  4735  .  .  .  .  .  .  .  }
  4736  .  .  .  .  .  .  }
  4737  .  .  .  .  .  .  6: *syntax.CaseClause {
  4738  .  .  .  .  .  .  .  Cases: nil
  4739  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
  4740  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4741  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4742  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4743  .  .  .  .  .  .  .  .  .  .  .  X: p
  4744  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  4745  .  .  .  .  .  .  .  .  .  .  }
  4746  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4747  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4748  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting expression\""
  4749  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4750  .  .  .  .  .  .  .  .  .  .  .  }
  4751  .  .  .  .  .  .  .  .  .  .  }
  4752  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4753  .  .  .  .  .  .  .  .  .  }
  4754  .  .  .  .  .  .  .  .  }
  4755  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  4756  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4757  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4758  .  .  .  .  .  .  .  .  .  .  .  X: p
  4759  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
  4760  .  .  .  .  .  .  .  .  .  .  }
  4761  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4762  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4763  .  .  .  .  .  .  .  .  .  }
  4764  .  .  .  .  .  .  .  .  }
  4765  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
  4766  .  .  .  .  .  .  .  .  .  Results: nil
  4767  .  .  .  .  .  .  .  .  }
  4768  .  .  .  .  .  .  .  }
  4769  .  .  .  .  .  .  }
  4770  .  .  .  .  .  }
  4771  .  .  .  .  }
  4772  .  .  .  }
  4773  .  .  .  Pragma: 0
  4774  .  .  .  EndLine: 680
  4775  .  .  }
  4776  .  .  29: *syntax.FuncDecl {
  4777  .  .  .  Attr: map[]
  4778  .  .  .  Recv: *syntax.Field {
  4779  .  .  .  .  Name: p
  4780  .  .  .  .  Type: *syntax.Operation {
  4781  .  .  .  .  .  Op: *
  4782  .  .  .  .  .  X: parser
  4783  .  .  .  .  .  Y: nil
  4784  .  .  .  .  }
  4785  .  .  .  }
  4786  .  .  .  Name: pexpr
  4787  .  .  .  Type: *syntax.FuncType {
  4788  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  4789  .  .  .  .  .  0: *syntax.Field {
  4790  .  .  .  .  .  .  Name: keep_parens
  4791  .  .  .  .  .  .  Type: bool
  4792  .  .  .  .  .  }
  4793  .  .  .  .  }
  4794  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  4795  .  .  .  .  .  0: *syntax.Field {
  4796  .  .  .  .  .  .  Name: nil
  4797  .  .  .  .  .  .  Type: Expr
  4798  .  .  .  .  .  }
  4799  .  .  .  .  }
  4800  .  .  .  }
  4801  .  .  .  Body: []syntax.Stmt (4 entries) {
  4802  .  .  .  .  0: *syntax.IfStmt {
  4803  .  .  .  .  .  Init: nil
  4804  .  .  .  .  .  Cond: trace
  4805  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  4806  .  .  .  .  .  .  0: *syntax.CallStmt {
  4807  .  .  .  .  .  .  .  Tok: defer
  4808  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  4809  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  4810  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4811  .  .  .  .  .  .  .  .  .  .  X: p
  4812  .  .  .  .  .  .  .  .  .  .  Sel: trace
  4813  .  .  .  .  .  .  .  .  .  }
  4814  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4815  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4816  .  .  .  .  .  .  .  .  .  .  .  Value: "\"pexpr\""
  4817  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4818  .  .  .  .  .  .  .  .  .  .  }
  4819  .  .  .  .  .  .  .  .  .  }
  4820  .  .  .  .  .  .  .  .  .  HasDots: false
  4821  .  .  .  .  .  .  .  .  }
  4822  .  .  .  .  .  .  .  .  ArgList: nil
  4823  .  .  .  .  .  .  .  .  HasDots: false
  4824  .  .  .  .  .  .  .  }
  4825  .  .  .  .  .  .  }
  4826  .  .  .  .  .  }
  4827  .  .  .  .  .  Else: nil
  4828  .  .  .  .  }
  4829  .  .  .  .  1: *syntax.AssignStmt {
  4830  .  .  .  .  .  Op: :
  4831  .  .  .  .  .  Lhs: x
  4832  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4833  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4834  .  .  .  .  .  .  .  X: p
  4835  .  .  .  .  .  .  .  Sel: operand
  4836  .  .  .  .  .  .  }
  4837  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4838  .  .  .  .  .  .  .  0: keep_parens
  4839  .  .  .  .  .  .  }
  4840  .  .  .  .  .  .  HasDots: false
  4841  .  .  .  .  .  }
  4842  .  .  .  .  }
  4843  .  .  .  .  2: *syntax.LabeledStmt {
  4844  .  .  .  .  .  Label: loop
  4845  .  .  .  .  .  Stmt: *syntax.ForStmt {
  4846  .  .  .  .  .  .  Init: nil
  4847  .  .  .  .  .  .  Cond: nil
  4848  .  .  .  .  .  .  Post: nil
  4849  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  4850  .  .  .  .  .  .  .  0: *syntax.SwitchStmt {
  4851  .  .  .  .  .  .  .  .  Init: nil
  4852  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  4853  .  .  .  .  .  .  .  .  .  X: p
  4854  .  .  .  .  .  .  .  .  .  Sel: tok
  4855  .  .  .  .  .  .  .  .  }
  4856  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (5 entries) {
  4857  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  4858  .  .  .  .  .  .  .  .  .  .  Cases: _Dot
  4859  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
  4860  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4861  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4862  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4863  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4864  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  4865  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4866  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4867  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4868  .  .  .  .  .  .  .  .  .  .  .  .  }
  4869  .  .  .  .  .  .  .  .  .  .  .  }
  4870  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SwitchStmt {
  4871  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  4872  .  .  .  .  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  4873  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4874  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  4875  .  .  .  .  .  .  .  .  .  .  .  .  }
  4876  .  .  .  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
  4877  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  4878  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: _Name
  4879  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (5 entries) {
  4880  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4881  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  4882  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t
  4883  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4884  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new
  4885  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4886  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: SelectorExpr
  4887  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4888  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4889  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4890  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4891  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  4892  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4893  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4894  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  4895  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  4896  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4897  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4898  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
  4899  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4900  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4901  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4902  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4903  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  4904  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4905  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4906  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  4907  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X
  4908  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4909  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x
  4910  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4911  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  4912  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4913  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4914  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  4915  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sel
  4916  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4917  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4918  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4919  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4920  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name
  4921  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4922  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4923  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4924  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4925  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4926  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  4927  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4928  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x
  4929  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: t
  4930  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4931  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4932  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4933  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  4934  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: _Lparen
  4935  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
  4936  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4937  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4938  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4939  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4940  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  4941  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4942  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4943  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4944  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4945  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4946  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  4947  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  4948  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  4949  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4950  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  4951  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got
  4952  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4953  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4954  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Type
  4955  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4956  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4957  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4958  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (4 entries) {
  4959  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4960  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  4961  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t
  4962  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4963  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new
  4964  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4965  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: TypeSwitchGuard
  4966  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4967  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4968  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4969  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4970  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  4971  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4972  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4973  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  4974  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  4975  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4976  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4977  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
  4978  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4979  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4980  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4981  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4982  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  4983  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4984  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4985  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  4986  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X
  4987  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4988  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x
  4989  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4990  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  4991  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4992  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x
  4993  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: t
  4994  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4995  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4996  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
  4997  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (5 entries) {
  4998  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4999  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  5000  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t
  5001  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5002  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new
  5003  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5004  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: AssertExpr
  5005  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5006  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5007  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5008  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5009  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  5010  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5011  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5012  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5013  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  5014  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5015  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5016  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
  5017  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5018  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5019  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5020  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5021  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  5022  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5023  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5024  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5025  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X
  5026  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5027  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x
  5028  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5029  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  5030  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5031  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5032  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5033  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
  5034  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5035  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5036  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5037  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5038  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr
  5039  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5040  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5041  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5042  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5043  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5044  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  5045  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5046  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x
  5047  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: t
  5048  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5049  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5050  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5051  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5052  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  5053  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5054  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5055  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5056  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  5057  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5058  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5059  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen
  5060  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5061  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5062  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5063  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5064  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5065  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5066  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  5067  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: nil
  5068  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  5069  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  5070  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5071  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5072  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5073  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  5074  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5075  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5076  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5077  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting name or (\""
  5078  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5079  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5080  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5081  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5082  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5083  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5084  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  5085  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5086  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5087  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5088  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
  5089  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5090  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  5091  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Semi
  5092  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: _Rparen
  5093  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5094  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5095  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5096  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5097  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5098  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5099  .  .  .  .  .  .  .  .  .  .  .  .  }
  5100  .  .  .  .  .  .  .  .  .  .  .  }
  5101  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
  5102  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5103  .  .  .  .  .  .  .  .  .  .  .  .  Cond: gcCompat
  5104  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  5105  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  5106  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5107  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5108  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x
  5109  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  5110  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5111  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5112  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
  5113  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5114  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5115  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5116  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5117  .  .  .  .  .  .  .  .  .  .  .  .  }
  5118  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  5119  .  .  .  .  .  .  .  .  .  .  .  }
  5120  .  .  .  .  .  .  .  .  .  .  }
  5121  .  .  .  .  .  .  .  .  .  }
  5122  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  5123  .  .  .  .  .  .  .  .  .  .  Cases: _Lbrack
  5124  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (14 entries) {
  5125  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  5126  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5127  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5128  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5129  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  5130  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5131  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5132  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5133  .  .  .  .  .  .  .  .  .  .  .  .  }
  5134  .  .  .  .  .  .  .  .  .  .  .  }
  5135  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  5136  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
  5137  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5138  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5139  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest
  5140  .  .  .  .  .  .  .  .  .  .  .  .  }
  5141  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  5142  .  .  .  .  .  .  .  .  .  .  .  }
  5143  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.DeclStmt {
  5144  .  .  .  .  .  .  .  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
  5145  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.VarDecl {
  5146  .  .  .  .  .  .  .  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
  5147  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: i
  5148  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5149  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Type: Expr
  5150  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Values: nil
  5151  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Group: nil
  5152  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5153  .  .  .  .  .  .  .  .  .  .  .  .  }
  5154  .  .  .  .  .  .  .  .  .  .  .  }
  5155  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  5156  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5157  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  5158  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  5159  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5160  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5161  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  5162  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5163  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Colon
  5164  .  .  .  .  .  .  .  .  .  .  .  .  }
  5165  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
  5166  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5167  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5168  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: i
  5169  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5170  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5171  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5172  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr
  5173  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5174  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5175  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5176  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5177  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5178  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  5179  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5180  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  5181  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5182  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5183  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got
  5184  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5185  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5186  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrack
  5187  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5188  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5189  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5190  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (7 entries) {
  5191  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5192  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  5193  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t
  5194  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5195  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new
  5196  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5197  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: IndexExpr
  5198  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5199  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5200  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5201  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5202  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  5203  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5204  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5205  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5206  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  5207  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5208  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5209  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
  5210  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5211  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5212  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5213  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5214  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  5215  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5216  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5217  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5218  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X
  5219  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5220  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x
  5221  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5222  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  5223  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5224  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5225  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5226  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Index
  5227  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5228  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: i
  5229  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5230  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  5231  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5232  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x
  5233  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: t
  5234  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5235  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  5236  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: -
  5237  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5238  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5239  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest
  5240  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5241  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  5242  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5243  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  6: *syntax.BranchStmt {
  5244  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  5245  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
  5246  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5247  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5248  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  5249  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5250  .  .  .  .  .  .  .  .  .  .  .  .  }
  5251  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  5252  .  .  .  .  .  .  .  .  .  .  .  }
  5253  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  5254  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  5255  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t
  5256  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5257  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new
  5258  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5259  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: SliceExpr
  5260  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5261  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5262  .  .  .  .  .  .  .  .  .  .  .  .  }
  5263  .  .  .  .  .  .  .  .  .  .  .  }
  5264  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.ExprStmt {
  5265  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5266  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5267  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5268  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  5269  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5270  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5271  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
  5272  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5273  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5274  .  .  .  .  .  .  .  .  .  .  .  .  }
  5275  .  .  .  .  .  .  .  .  .  .  .  }
  5276  .  .  .  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
  5277  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5278  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5279  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5280  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X
  5281  .  .  .  .  .  .  .  .  .  .  .  .  }
  5282  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x
  5283  .  .  .  .  .  .  .  .  .  .  .  }
  5284  .  .  .  .  .  .  .  .  .  .  .  7: *syntax.AssignStmt {
  5285  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5286  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.IndexExpr {
  5287  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5288  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5289  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Index
  5290  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5291  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.BasicLit {
  5292  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  5293  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  5294  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5295  .  .  .  .  .  .  .  .  .  .  .  .  }
  5296  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: i
  5297  .  .  .  .  .  .  .  .  .  .  .  }
  5298  .  .  .  .  .  .  .  .  .  .  .  8: *syntax.ExprStmt {
  5299  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5300  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5301  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5302  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  5303  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5304  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5305  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Colon
  5306  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5307  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5308  .  .  .  .  .  .  .  .  .  .  .  .  }
  5309  .  .  .  .  .  .  .  .  .  .  .  }
  5310  .  .  .  .  .  .  .  .  .  .  .  9: *syntax.IfStmt {
  5311  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5312  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  5313  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: &&
  5314  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  5315  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  5316  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5317  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5318  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  5319  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5320  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Colon
  5321  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5322  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  5323  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  5324  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5325  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5326  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  5327  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5328  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Rbrack
  5329  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5330  .  .  .  .  .  .  .  .  .  .  .  .  }
  5331  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  5332  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5333  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5334  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.IndexExpr {
  5335  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5336  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5337  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Index
  5338  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5339  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.BasicLit {
  5340  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  5341  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  5342  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5343  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5344  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5345  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5346  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5347  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr
  5348  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5349  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5350  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5351  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5352  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5353  .  .  .  .  .  .  .  .  .  .  .  .  }
  5354  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  5355  .  .  .  .  .  .  .  .  .  .  .  }
  5356  .  .  .  .  .  .  .  .  .  .  .  10: *syntax.IfStmt {
  5357  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5358  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  5359  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5360  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5361  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got
  5362  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5363  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5364  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Colon
  5365  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5366  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5367  .  .  .  .  .  .  .  .  .  .  .  .  }
  5368  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (3 entries) {
  5369  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5370  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5371  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5372  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5373  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Full
  5374  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5375  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: true
  5376  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5377  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  5378  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5379  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  5380  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  5381  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.IndexExpr {
  5382  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5383  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5384  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Index
  5385  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5386  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.BasicLit {
  5387  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  5388  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  5389  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5390  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5391  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  5392  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5393  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  5394  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  5395  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5396  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5397  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5398  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error
  5399  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5400  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5401  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5402  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"middle index required in 3-index slice\""
  5403  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5404  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5405  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5406  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5407  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5408  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5409  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5410  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  5411  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5412  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
  5413  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5414  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  5415  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  5416  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5417  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5418  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  5419  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5420  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Rbrack
  5421  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5422  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  5423  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5424  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5425  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.IndexExpr {
  5426  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5427  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5428  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Index
  5429  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5430  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.BasicLit {
  5431  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "2"
  5432  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  5433  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5434  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5435  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5436  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5437  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5438  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr
  5439  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5440  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5441  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5442  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5443  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5444  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5445  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
  5446  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  5447  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  5448  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5449  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5450  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5451  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error
  5452  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5453  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5454  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5455  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"final index required in 3-index slice\""
  5456  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5457  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5458  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5459  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5460  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5461  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5462  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5463  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5464  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5465  .  .  .  .  .  .  .  .  .  .  .  .  }
  5466  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  5467  .  .  .  .  .  .  .  .  .  .  .  }
  5468  .  .  .  .  .  .  .  .  .  .  .  11: *syntax.ExprStmt {
  5469  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5470  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5471  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5472  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  5473  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5474  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5475  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrack
  5476  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5477  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5478  .  .  .  .  .  .  .  .  .  .  .  .  }
  5479  .  .  .  .  .  .  .  .  .  .  .  }
  5480  .  .  .  .  .  .  .  .  .  .  .  12: *syntax.AssignStmt {
  5481  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5482  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x
  5483  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: t
  5484  .  .  .  .  .  .  .  .  .  .  .  }
  5485  .  .  .  .  .  .  .  .  .  .  .  13: *syntax.AssignStmt {
  5486  .  .  .  .  .  .  .  .  .  .  .  .  Op: -
  5487  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5488  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5489  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest
  5490  .  .  .  .  .  .  .  .  .  .  .  .  }
  5491  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  5492  .  .  .  .  .  .  .  .  .  .  .  }
  5493  .  .  .  .  .  .  .  .  .  .  }
  5494  .  .  .  .  .  .  .  .  .  }
  5495  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  5496  .  .  .  .  .  .  .  .  .  .  Cases: _Lparen
  5497  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  5498  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5499  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5500  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x
  5501  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5502  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5503  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5504  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: call
  5505  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5506  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5507  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: x
  5508  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5509  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5510  .  .  .  .  .  .  .  .  .  .  .  .  }
  5511  .  .  .  .  .  .  .  .  .  .  .  }
  5512  .  .  .  .  .  .  .  .  .  .  }
  5513  .  .  .  .  .  .  .  .  .  }
  5514  .  .  .  .  .  .  .  .  .  3: *syntax.CaseClause {
  5515  .  .  .  .  .  .  .  .  .  .  Cases: _Lbrace
  5516  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (8 entries) {
  5517  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5518  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  5519  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t
  5520  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5521  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: unparen
  5522  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5523  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: x
  5524  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5525  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5526  .  .  .  .  .  .  .  .  .  .  .  .  }
  5527  .  .  .  .  .  .  .  .  .  .  .  }
  5528  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  5529  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  5530  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: complit_ok
  5531  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: false
  5532  .  .  .  .  .  .  .  .  .  .  .  }
  5533  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.SwitchStmt {
  5534  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5535  .  .  .  .  .  .  .  .  .  .  .  .  Tag: *syntax.TypeSwitchGuard {
  5536  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: nil
  5537  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5538  .  .  .  .  .  .  .  .  .  .  .  .  }
  5539  .  .  .  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (2 entries) {
  5540  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  5541  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  5542  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  5543  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
  5544  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  5545  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: Name
  5546  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  5547  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5548  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.Operation {
  5549  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  5550  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: SelectorExpr
  5551  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  5552  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5553  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5554  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5555  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  5556  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
  5557  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5558  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  5559  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: >=
  5560  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5561  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5562  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest
  5563  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5564  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  5565  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  5566  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  5567  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5568  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5569  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  5570  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5571  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5572  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: complit_ok
  5573  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: true
  5574  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5575  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5576  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  5577  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5578  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5579  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5580  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  5581  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  5582  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (4 entries) {
  5583  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
  5584  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  5585  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: ArrayType
  5586  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  5587  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5588  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.Operation {
  5589  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  5590  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: SliceType
  5591  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  5592  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5593  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.Operation {
  5594  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  5595  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: StructType
  5596  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  5597  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5598  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.Operation {
  5599  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  5600  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: MapType
  5601  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  5602  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5603  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5604  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5605  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  5606  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5607  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5608  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: complit_ok
  5609  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: true
  5610  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5611  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5612  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5613  .  .  .  .  .  .  .  .  .  .  .  .  }
  5614  .  .  .  .  .  .  .  .  .  .  .  }
  5615  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  5616  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5617  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  5618  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !
  5619  .  .  .  .  .  .  .  .  .  .  .  .  .  X: complit_ok
  5620  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  5621  .  .  .  .  .  .  .  .  .  .  .  .  }
  5622  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  5623  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  5624  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  5625  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Label: loop
  5626  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5627  .  .  .  .  .  .  .  .  .  .  .  .  }
  5628  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  5629  .  .  .  .  .  .  .  .  .  .  .  }
  5630  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.IfStmt {
  5631  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5632  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  5633  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  5634  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  5635  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: x
  5636  .  .  .  .  .  .  .  .  .  .  .  .  }
  5637  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  5638  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  5639  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5640  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5641  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5642  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  5643  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5644  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5645  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5646  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"cannot parenthesize type in composite literal\""
  5647  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5648  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5649  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5650  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5651  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5652  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5653  .  .  .  .  .  .  .  .  .  .  .  .  }
  5654  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  5655  .  .  .  .  .  .  .  .  .  .  .  }
  5656  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  5657  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  5658  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: n
  5659  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5660  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5661  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  5662  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: complitexpr
  5663  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5664  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5665  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5666  .  .  .  .  .  .  .  .  .  .  .  .  }
  5667  .  .  .  .  .  .  .  .  .  .  .  }
  5668  .  .  .  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
  5669  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5670  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5671  .  .  .  .  .  .  .  .  .  .  .  .  .  X: n
  5672  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
  5673  .  .  .  .  .  .  .  .  .  .  .  .  }
  5674  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x
  5675  .  .  .  .  .  .  .  .  .  .  .  }
  5676  .  .  .  .  .  .  .  .  .  .  .  7: *syntax.AssignStmt {
  5677  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5678  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x
  5679  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: n
  5680  .  .  .  .  .  .  .  .  .  .  .  }
  5681  .  .  .  .  .  .  .  .  .  .  }
  5682  .  .  .  .  .  .  .  .  .  }
  5683  .  .  .  .  .  .  .  .  .  4: *syntax.CaseClause {
  5684  .  .  .  .  .  .  .  .  .  .  Cases: nil
  5685  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  5686  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  5687  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  5688  .  .  .  .  .  .  .  .  .  .  .  .  Label: loop
  5689  .  .  .  .  .  .  .  .  .  .  .  }
  5690  .  .  .  .  .  .  .  .  .  .  }
  5691  .  .  .  .  .  .  .  .  .  }
  5692  .  .  .  .  .  .  .  .  }
  5693  .  .  .  .  .  .  .  }
  5694  .  .  .  .  .  .  }
  5695  .  .  .  .  .  }
  5696  .  .  .  .  }
  5697  .  .  .  .  3: *syntax.ReturnStmt {
  5698  .  .  .  .  .  Results: x
  5699  .  .  .  .  }
  5700  .  .  .  }
  5701  .  .  .  Pragma: 0
  5702  .  .  .  EndLine: 826
  5703  .  .  }
  5704  .  .  30: *syntax.FuncDecl {
  5705  .  .  .  Attr: map[]
  5706  .  .  .  Recv: *syntax.Field {
  5707  .  .  .  .  Name: p
  5708  .  .  .  .  Type: *syntax.Operation {
  5709  .  .  .  .  .  Op: *
  5710  .  .  .  .  .  X: parser
  5711  .  .  .  .  .  Y: nil
  5712  .  .  .  .  }
  5713  .  .  .  }
  5714  .  .  .  Name: bare_complitexpr
  5715  .  .  .  Type: *syntax.FuncType {
  5716  .  .  .  .  ParamList: nil
  5717  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  5718  .  .  .  .  .  0: *syntax.Field {
  5719  .  .  .  .  .  .  Name: nil
  5720  .  .  .  .  .  .  Type: Expr
  5721  .  .  .  .  .  }
  5722  .  .  .  .  }
  5723  .  .  .  }
  5724  .  .  .  Body: []syntax.Stmt (3 entries) {
  5725  .  .  .  .  0: *syntax.IfStmt {
  5726  .  .  .  .  .  Init: nil
  5727  .  .  .  .  .  Cond: trace
  5728  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  5729  .  .  .  .  .  .  0: *syntax.CallStmt {
  5730  .  .  .  .  .  .  .  Tok: defer
  5731  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  5732  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  5733  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5734  .  .  .  .  .  .  .  .  .  .  X: p
  5735  .  .  .  .  .  .  .  .  .  .  Sel: trace
  5736  .  .  .  .  .  .  .  .  .  }
  5737  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5738  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5739  .  .  .  .  .  .  .  .  .  .  .  Value: "\"bare_complitexpr\""
  5740  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5741  .  .  .  .  .  .  .  .  .  .  }
  5742  .  .  .  .  .  .  .  .  .  }
  5743  .  .  .  .  .  .  .  .  .  HasDots: false
  5744  .  .  .  .  .  .  .  .  }
  5745  .  .  .  .  .  .  .  .  ArgList: nil
  5746  .  .  .  .  .  .  .  .  HasDots: false
  5747  .  .  .  .  .  .  .  }
  5748  .  .  .  .  .  .  }
  5749  .  .  .  .  .  }
  5750  .  .  .  .  .  Else: nil
  5751  .  .  .  .  }
  5752  .  .  .  .  1: *syntax.IfStmt {
  5753  .  .  .  .  .  Init: nil
  5754  .  .  .  .  .  Cond: *syntax.Operation {
  5755  .  .  .  .  .  .  Op: ==
  5756  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5757  .  .  .  .  .  .  .  X: p
  5758  .  .  .  .  .  .  .  Sel: tok
  5759  .  .  .  .  .  .  }
  5760  .  .  .  .  .  .  Y: _Lbrace
  5761  .  .  .  .  .  }
  5762  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  5763  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  5764  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  5765  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5766  .  .  .  .  .  .  .  .  .  X: p
  5767  .  .  .  .  .  .  .  .  .  Sel: complitexpr
  5768  .  .  .  .  .  .  .  .  }
  5769  .  .  .  .  .  .  .  .  ArgList: nil
  5770  .  .  .  .  .  .  .  .  HasDots: false
  5771  .  .  .  .  .  .  .  }
  5772  .  .  .  .  .  .  }
  5773  .  .  .  .  .  }
  5774  .  .  .  .  .  Else: nil
  5775  .  .  .  .  }
  5776  .  .  .  .  2: *syntax.ReturnStmt {
  5777  .  .  .  .  .  Results: *syntax.CallExpr {
  5778  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5779  .  .  .  .  .  .  .  X: p
  5780  .  .  .  .  .  .  .  Sel: expr
  5781  .  .  .  .  .  .  }
  5782  .  .  .  .  .  .  ArgList: nil
  5783  .  .  .  .  .  .  HasDots: false
  5784  .  .  .  .  .  }
  5785  .  .  .  .  }
  5786  .  .  .  }
  5787  .  .  .  Pragma: 0
  5788  .  .  .  EndLine: 840
  5789  .  .  }
  5790  .  .  31: *syntax.FuncDecl {
  5791  .  .  .  Attr: map[]
  5792  .  .  .  Recv: *syntax.Field {
  5793  .  .  .  .  Name: p
  5794  .  .  .  .  Type: *syntax.Operation {
  5795  .  .  .  .  .  Op: *
  5796  .  .  .  .  .  X: parser
  5797  .  .  .  .  .  Y: nil
  5798  .  .  .  .  }
  5799  .  .  .  }
  5800  .  .  .  Name: complitexpr
  5801  .  .  .  Type: *syntax.FuncType {
  5802  .  .  .  .  ParamList: nil
  5803  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  5804  .  .  .  .  .  0: *syntax.Field {
  5805  .  .  .  .  .  .  Name: nil
  5806  .  .  .  .  .  .  Type: *syntax.Operation {
  5807  .  .  .  .  .  .  .  Op: *
  5808  .  .  .  .  .  .  .  X: CompositeLit
  5809  .  .  .  .  .  .  .  Y: nil
  5810  .  .  .  .  .  .  }
  5811  .  .  .  .  .  }
  5812  .  .  .  .  }
  5813  .  .  .  }
  5814  .  .  .  Body: []syntax.Stmt (10 entries) {
  5815  .  .  .  .  0: *syntax.IfStmt {
  5816  .  .  .  .  .  Init: nil
  5817  .  .  .  .  .  Cond: trace
  5818  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  5819  .  .  .  .  .  .  0: *syntax.CallStmt {
  5820  .  .  .  .  .  .  .  Tok: defer
  5821  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  5822  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  5823  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5824  .  .  .  .  .  .  .  .  .  .  X: p
  5825  .  .  .  .  .  .  .  .  .  .  Sel: trace
  5826  .  .  .  .  .  .  .  .  .  }
  5827  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5828  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5829  .  .  .  .  .  .  .  .  .  .  .  Value: "\"complitexpr\""
  5830  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5831  .  .  .  .  .  .  .  .  .  .  }
  5832  .  .  .  .  .  .  .  .  .  }
  5833  .  .  .  .  .  .  .  .  .  HasDots: false
  5834  .  .  .  .  .  .  .  .  }
  5835  .  .  .  .  .  .  .  .  ArgList: nil
  5836  .  .  .  .  .  .  .  .  HasDots: false
  5837  .  .  .  .  .  .  .  }
  5838  .  .  .  .  .  .  }
  5839  .  .  .  .  .  }
  5840  .  .  .  .  .  Else: nil
  5841  .  .  .  .  }
  5842  .  .  .  .  1: *syntax.AssignStmt {
  5843  .  .  .  .  .  Op: :
  5844  .  .  .  .  .  Lhs: x
  5845  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5846  .  .  .  .  .  .  Fun: new
  5847  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5848  .  .  .  .  .  .  .  0: CompositeLit
  5849  .  .  .  .  .  .  }
  5850  .  .  .  .  .  .  HasDots: false
  5851  .  .  .  .  .  }
  5852  .  .  .  .  }
  5853  .  .  .  .  2: *syntax.ExprStmt {
  5854  .  .  .  .  .  X: *syntax.CallExpr {
  5855  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5856  .  .  .  .  .  .  .  X: x
  5857  .  .  .  .  .  .  .  Sel: init
  5858  .  .  .  .  .  .  }
  5859  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5860  .  .  .  .  .  .  .  0: p
  5861  .  .  .  .  .  .  }
  5862  .  .  .  .  .  .  HasDots: false
  5863  .  .  .  .  .  }
  5864  .  .  .  .  }
  5865  .  .  .  .  3: *syntax.ExprStmt {
  5866  .  .  .  .  .  X: *syntax.CallExpr {
  5867  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5868  .  .  .  .  .  .  .  X: p
  5869  .  .  .  .  .  .  .  Sel: want
  5870  .  .  .  .  .  .  }
  5871  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5872  .  .  .  .  .  .  .  0: _Lbrace
  5873  .  .  .  .  .  .  }
  5874  .  .  .  .  .  .  HasDots: false
  5875  .  .  .  .  .  }
  5876  .  .  .  .  }
  5877  .  .  .  .  4: *syntax.AssignStmt {
  5878  .  .  .  .  .  Op: +
  5879  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5880  .  .  .  .  .  .  X: p
  5881  .  .  .  .  .  .  Sel: xnest
  5882  .  .  .  .  .  }
  5883  .  .  .  .  .  Rhs: *(Node @ 4462)
  5884  .  .  .  .  }
  5885  .  .  .  .  5: *syntax.ForStmt {
  5886  .  .  .  .  .  Init: nil
  5887  .  .  .  .  .  Cond: *syntax.Operation {
  5888  .  .  .  .  .  .  Op: &&
  5889  .  .  .  .  .  .  X: *syntax.Operation {
  5890  .  .  .  .  .  .  .  Op: !=
  5891  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5892  .  .  .  .  .  .  .  .  X: p
  5893  .  .  .  .  .  .  .  .  Sel: tok
  5894  .  .  .  .  .  .  .  }
  5895  .  .  .  .  .  .  .  Y: _EOF
  5896  .  .  .  .  .  .  }
  5897  .  .  .  .  .  .  Y: *syntax.Operation {
  5898  .  .  .  .  .  .  .  Op: !=
  5899  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5900  .  .  .  .  .  .  .  .  X: p
  5901  .  .  .  .  .  .  .  .  Sel: tok
  5902  .  .  .  .  .  .  .  }
  5903  .  .  .  .  .  .  .  Y: _Rbrace
  5904  .  .  .  .  .  .  }
  5905  .  .  .  .  .  }
  5906  .  .  .  .  .  Post: nil
  5907  .  .  .  .  .  Body: []syntax.Stmt (4 entries) {
  5908  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5909  .  .  .  .  .  .  .  Op: :
  5910  .  .  .  .  .  .  .  Lhs: e
  5911  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5912  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5913  .  .  .  .  .  .  .  .  .  X: p
  5914  .  .  .  .  .  .  .  .  .  Sel: bare_complitexpr
  5915  .  .  .  .  .  .  .  .  }
  5916  .  .  .  .  .  .  .  .  ArgList: nil
  5917  .  .  .  .  .  .  .  .  HasDots: false
  5918  .  .  .  .  .  .  .  }
  5919  .  .  .  .  .  .  }
  5920  .  .  .  .  .  .  1: *syntax.IfStmt {
  5921  .  .  .  .  .  .  .  Init: nil
  5922  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  5923  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5924  .  .  .  .  .  .  .  .  .  X: p
  5925  .  .  .  .  .  .  .  .  .  Sel: got
  5926  .  .  .  .  .  .  .  .  }
  5927  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5928  .  .  .  .  .  .  .  .  .  0: _Colon
  5929  .  .  .  .  .  .  .  .  }
  5930  .  .  .  .  .  .  .  .  HasDots: false
  5931  .  .  .  .  .  .  .  }
  5932  .  .  .  .  .  .  .  Then: []syntax.Stmt (7 entries) {
  5933  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5934  .  .  .  .  .  .  .  .  .  Op: :
  5935  .  .  .  .  .  .  .  .  .  Lhs: l
  5936  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5937  .  .  .  .  .  .  .  .  .  .  Fun: new
  5938  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5939  .  .  .  .  .  .  .  .  .  .  .  0: KeyValueExpr
  5940  .  .  .  .  .  .  .  .  .  .  }
  5941  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5942  .  .  .  .  .  .  .  .  .  }
  5943  .  .  .  .  .  .  .  .  }
  5944  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  5945  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5946  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5947  .  .  .  .  .  .  .  .  .  .  .  X: l
  5948  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  5949  .  .  .  .  .  .  .  .  .  .  }
  5950  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5951  .  .  .  .  .  .  .  .  .  .  .  0: p
  5952  .  .  .  .  .  .  .  .  .  .  }
  5953  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5954  .  .  .  .  .  .  .  .  .  }
  5955  .  .  .  .  .  .  .  .  }
  5956  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  5957  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5958  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5959  .  .  .  .  .  .  .  .  .  .  X: l
  5960  .  .  .  .  .  .  .  .  .  .  Sel: Key
  5961  .  .  .  .  .  .  .  .  .  }
  5962  .  .  .  .  .  .  .  .  .  Rhs: e
  5963  .  .  .  .  .  .  .  .  }
  5964  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  5965  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5966  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5967  .  .  .  .  .  .  .  .  .  .  X: l
  5968  .  .  .  .  .  .  .  .  .  .  Sel: Value
  5969  .  .  .  .  .  .  .  .  .  }
  5970  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5971  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5972  .  .  .  .  .  .  .  .  .  .  .  X: p
  5973  .  .  .  .  .  .  .  .  .  .  .  Sel: bare_complitexpr
  5974  .  .  .  .  .  .  .  .  .  .  }
  5975  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5976  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5977  .  .  .  .  .  .  .  .  .  }
  5978  .  .  .  .  .  .  .  .  }
  5979  .  .  .  .  .  .  .  .  4: *syntax.IfStmt {
  5980  .  .  .  .  .  .  .  .  .  Init: nil
  5981  .  .  .  .  .  .  .  .  .  Cond: gcCompat
  5982  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  5983  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  5984  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5985  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5986  .  .  .  .  .  .  .  .  .  .  .  .  .  X: l
  5987  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  5988  .  .  .  .  .  .  .  .  .  .  .  .  }
  5989  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5990  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
  5991  .  .  .  .  .  .  .  .  .  .  .  .  }
  5992  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5993  .  .  .  .  .  .  .  .  .  .  .  }
  5994  .  .  .  .  .  .  .  .  .  .  }
  5995  .  .  .  .  .  .  .  .  .  }
  5996  .  .  .  .  .  .  .  .  .  Else: nil
  5997  .  .  .  .  .  .  .  .  }
  5998  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  5999  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6000  .  .  .  .  .  .  .  .  .  Lhs: e
  6001  .  .  .  .  .  .  .  .  .  Rhs: l
  6002  .  .  .  .  .  .  .  .  }
  6003  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
  6004  .  .  .  .  .  .  .  .  .  Op: +
  6005  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6006  .  .  .  .  .  .  .  .  .  .  X: x
  6007  .  .  .  .  .  .  .  .  .  .  Sel: NKeys
  6008  .  .  .  .  .  .  .  .  .  }
  6009  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  6010  .  .  .  .  .  .  .  .  }
  6011  .  .  .  .  .  .  .  }
  6012  .  .  .  .  .  .  .  Else: nil
  6013  .  .  .  .  .  .  }
  6014  .  .  .  .  .  .  2: *syntax.AssignStmt {
  6015  .  .  .  .  .  .  .  Op: <op-0>
  6016  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6017  .  .  .  .  .  .  .  .  X: x
  6018  .  .  .  .  .  .  .  .  Sel: ElemList
  6019  .  .  .  .  .  .  .  }
  6020  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6021  .  .  .  .  .  .  .  .  Fun: append
  6022  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  6023  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  6024  .  .  .  .  .  .  .  .  .  .  X: x
  6025  .  .  .  .  .  .  .  .  .  .  Sel: ElemList
  6026  .  .  .  .  .  .  .  .  .  }
  6027  .  .  .  .  .  .  .  .  .  1: e
  6028  .  .  .  .  .  .  .  .  }
  6029  .  .  .  .  .  .  .  .  HasDots: false
  6030  .  .  .  .  .  .  .  }
  6031  .  .  .  .  .  .  }
  6032  .  .  .  .  .  .  3: *syntax.IfStmt {
  6033  .  .  .  .  .  .  .  Init: nil
  6034  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  6035  .  .  .  .  .  .  .  .  Op: !
  6036  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6037  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6038  .  .  .  .  .  .  .  .  .  .  X: p
  6039  .  .  .  .  .  .  .  .  .  .  Sel: ocomma
  6040  .  .  .  .  .  .  .  .  .  }
  6041  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6042  .  .  .  .  .  .  .  .  .  .  0: _Rbrace
  6043  .  .  .  .  .  .  .  .  .  }
  6044  .  .  .  .  .  .  .  .  .  HasDots: false
  6045  .  .  .  .  .  .  .  .  }
  6046  .  .  .  .  .  .  .  .  Y: nil
  6047  .  .  .  .  .  .  .  }
  6048  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  6049  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  6050  .  .  .  .  .  .  .  .  .  Tok: break
  6051  .  .  .  .  .  .  .  .  .  Label: nil
  6052  .  .  .  .  .  .  .  .  }
  6053  .  .  .  .  .  .  .  }
  6054  .  .  .  .  .  .  .  Else: nil
  6055  .  .  .  .  .  .  }
  6056  .  .  .  .  .  }
  6057  .  .  .  .  }
  6058  .  .  .  .  6: *syntax.AssignStmt {
  6059  .  .  .  .  .  Op: <op-0>
  6060  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6061  .  .  .  .  .  .  X: x
  6062  .  .  .  .  .  .  Sel: EndLine
  6063  .  .  .  .  .  }
  6064  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6065  .  .  .  .  .  .  Fun: uint32
  6066  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6067  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  6068  .  .  .  .  .  .  .  .  X: p
  6069  .  .  .  .  .  .  .  .  Sel: line
  6070  .  .  .  .  .  .  .  }
  6071  .  .  .  .  .  .  }
  6072  .  .  .  .  .  .  HasDots: false
  6073  .  .  .  .  .  }
  6074  .  .  .  .  }
  6075  .  .  .  .  7: *syntax.AssignStmt {
  6076  .  .  .  .  .  Op: -
  6077  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6078  .  .  .  .  .  .  X: p
  6079  .  .  .  .  .  .  Sel: xnest
  6080  .  .  .  .  .  }
  6081  .  .  .  .  .  Rhs: *(Node @ 4462)
  6082  .  .  .  .  }
  6083  .  .  .  .  8: *syntax.ExprStmt {
  6084  .  .  .  .  .  X: *syntax.CallExpr {
  6085  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6086  .  .  .  .  .  .  .  X: p
  6087  .  .  .  .  .  .  .  Sel: want
  6088  .  .  .  .  .  .  }
  6089  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6090  .  .  .  .  .  .  .  0: _Rbrace
  6091  .  .  .  .  .  .  }
  6092  .  .  .  .  .  .  HasDots: false
  6093  .  .  .  .  .  }
  6094  .  .  .  .  }
  6095  .  .  .  .  9: *syntax.ReturnStmt {
  6096  .  .  .  .  .  Results: x
  6097  .  .  .  .  }
  6098  .  .  .  }
  6099  .  .  .  Pragma: 0
  6100  .  .  .  EndLine: 880
  6101  .  .  }
  6102  .  .  32: *syntax.FuncDecl {
  6103  .  .  .  Attr: map[]
  6104  .  .  .  Recv: *syntax.Field {
  6105  .  .  .  .  Name: p
  6106  .  .  .  .  Type: *syntax.Operation {
  6107  .  .  .  .  .  Op: *
  6108  .  .  .  .  .  X: parser
  6109  .  .  .  .  .  Y: nil
  6110  .  .  .  .  }
  6111  .  .  .  }
  6112  .  .  .  Name: type_
  6113  .  .  .  Type: *syntax.FuncType {
  6114  .  .  .  .  ParamList: nil
  6115  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  6116  .  .  .  .  .  0: *syntax.Field {
  6117  .  .  .  .  .  .  Name: nil
  6118  .  .  .  .  .  .  Type: Expr
  6119  .  .  .  .  .  }
  6120  .  .  .  .  }
  6121  .  .  .  }
  6122  .  .  .  Body: []syntax.Stmt (5 entries) {
  6123  .  .  .  .  0: *syntax.IfStmt {
  6124  .  .  .  .  .  Init: nil
  6125  .  .  .  .  .  Cond: trace
  6126  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  6127  .  .  .  .  .  .  0: *syntax.CallStmt {
  6128  .  .  .  .  .  .  .  Tok: defer
  6129  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  6130  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  6131  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6132  .  .  .  .  .  .  .  .  .  .  X: p
  6133  .  .  .  .  .  .  .  .  .  .  Sel: trace
  6134  .  .  .  .  .  .  .  .  .  }
  6135  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6136  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  6137  .  .  .  .  .  .  .  .  .  .  .  Value: "\"type_\""
  6138  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  6139  .  .  .  .  .  .  .  .  .  .  }
  6140  .  .  .  .  .  .  .  .  .  }
  6141  .  .  .  .  .  .  .  .  .  HasDots: false
  6142  .  .  .  .  .  .  .  .  }
  6143  .  .  .  .  .  .  .  .  ArgList: nil
  6144  .  .  .  .  .  .  .  .  HasDots: false
  6145  .  .  .  .  .  .  .  }
  6146  .  .  .  .  .  .  }
  6147  .  .  .  .  .  }
  6148  .  .  .  .  .  Else: nil
  6149  .  .  .  .  }
  6150  .  .  .  .  1: *syntax.IfStmt {
  6151  .  .  .  .  .  Init: *syntax.AssignStmt {
  6152  .  .  .  .  .  .  Op: :
  6153  .  .  .  .  .  .  Lhs: typ
  6154  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6155  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6156  .  .  .  .  .  .  .  .  X: p
  6157  .  .  .  .  .  .  .  .  Sel: tryType
  6158  .  .  .  .  .  .  .  }
  6159  .  .  .  .  .  .  .  ArgList: nil
  6160  .  .  .  .  .  .  .  HasDots: false
  6161  .  .  .  .  .  .  }
  6162  .  .  .  .  .  }
  6163  .  .  .  .  .  Cond: *syntax.Operation {
  6164  .  .  .  .  .  .  Op: !=
  6165  .  .  .  .  .  .  X: typ
  6166  .  .  .  .  .  .  Y: nil
  6167  .  .  .  .  .  }
  6168  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  6169  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  6170  .  .  .  .  .  .  .  Results: typ
  6171  .  .  .  .  .  .  }
  6172  .  .  .  .  .  }
  6173  .  .  .  .  .  Else: nil
  6174  .  .  .  .  }
  6175  .  .  .  .  2: *syntax.ExprStmt {
  6176  .  .  .  .  .  X: *syntax.CallExpr {
  6177  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6178  .  .  .  .  .  .  .  X: p
  6179  .  .  .  .  .  .  .  Sel: syntax_error
  6180  .  .  .  .  .  .  }
  6181  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6182  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  6183  .  .  .  .  .  .  .  .  Value: "\"\""
  6184  .  .  .  .  .  .  .  .  Kind: 4
  6185  .  .  .  .  .  .  .  }
  6186  .  .  .  .  .  .  }
  6187  .  .  .  .  .  .  HasDots: false
  6188  .  .  .  .  .  }
  6189  .  .  .  .  }
  6190  .  .  .  .  3: *syntax.ExprStmt {
  6191  .  .  .  .  .  X: *syntax.CallExpr {
  6192  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6193  .  .  .  .  .  .  .  X: p
  6194  .  .  .  .  .  .  .  Sel: advance
  6195  .  .  .  .  .  .  }
  6196  .  .  .  .  .  .  ArgList: nil
  6197  .  .  .  .  .  .  HasDots: false
  6198  .  .  .  .  .  }
  6199  .  .  .  .  }
  6200  .  .  .  .  4: *syntax.ReturnStmt {
  6201  .  .  .  .  .  Results: nil
  6202  .  .  .  .  }
  6203  .  .  .  }
  6204  .  .  .  Pragma: 0
  6205  .  .  .  EndLine: 897
  6206  .  .  }
  6207  .  .  33: *syntax.FuncDecl {
  6208  .  .  .  Attr: map[]
  6209  .  .  .  Recv: nil
  6210  .  .  .  Name: indirect
  6211  .  .  .  Type: *syntax.FuncType {
  6212  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  6213  .  .  .  .  .  0: *syntax.Field {
  6214  .  .  .  .  .  .  Name: typ
  6215  .  .  .  .  .  .  Type: Expr
  6216  .  .  .  .  .  }
  6217  .  .  .  .  }
  6218  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  6219  .  .  .  .  .  0: *syntax.Field {
  6220  .  .  .  .  .  .  Name: nil
  6221  .  .  .  .  .  .  Type: Expr
  6222  .  .  .  .  .  }
  6223  .  .  .  .  }
  6224  .  .  .  }
  6225  .  .  .  Body: []syntax.Stmt (1 entries) {
  6226  .  .  .  .  0: *syntax.ReturnStmt {
  6227  .  .  .  .  .  Results: *syntax.Operation {
  6228  .  .  .  .  .  .  Op: &
  6229  .  .  .  .  .  .  X: *syntax.CompositeLit {
  6230  .  .  .  .  .  .  .  Type: Operation
  6231  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  6232  .  .  .  .  .  .  .  .  0: *syntax.KeyValueExpr {
  6233  .  .  .  .  .  .  .  .  .  Key: Op
  6234  .  .  .  .  .  .  .  .  .  Value: Mul
  6235  .  .  .  .  .  .  .  .  }
  6236  .  .  .  .  .  .  .  .  1: *syntax.KeyValueExpr {
  6237  .  .  .  .  .  .  .  .  .  Key: X
  6238  .  .  .  .  .  .  .  .  .  Value: typ
  6239  .  .  .  .  .  .  .  .  }
  6240  .  .  .  .  .  .  .  }
  6241  .  .  .  .  .  .  .  NKeys: 2
  6242  .  .  .  .  .  .  .  EndLine: 900
  6243  .  .  .  .  .  .  }
  6244  .  .  .  .  .  .  Y: nil
  6245  .  .  .  .  .  }
  6246  .  .  .  .  }
  6247  .  .  .  }
  6248  .  .  .  Pragma: 0
  6249  .  .  .  EndLine: 901
  6250  .  .  }
  6251  .  .  34: *syntax.FuncDecl {
  6252  .  .  .  Attr: map[]
  6253  .  .  .  Recv: *syntax.Field {
  6254  .  .  .  .  Name: p
  6255  .  .  .  .  Type: *syntax.Operation {
  6256  .  .  .  .  .  Op: *
  6257  .  .  .  .  .  X: parser
  6258  .  .  .  .  .  Y: nil
  6259  .  .  .  .  }
  6260  .  .  .  }
  6261  .  .  .  Name: tryType
  6262  .  .  .  Type: *syntax.FuncType {
  6263  .  .  .  .  ParamList: nil
  6264  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  6265  .  .  .  .  .  0: *syntax.Field {
  6266  .  .  .  .  .  .  Name: nil
  6267  .  .  .  .  .  .  Type: Expr
  6268  .  .  .  .  .  }
  6269  .  .  .  .  }
  6270  .  .  .  }
  6271  .  .  .  Body: []syntax.Stmt (3 entries) {
  6272  .  .  .  .  0: *syntax.IfStmt {
  6273  .  .  .  .  .  Init: nil
  6274  .  .  .  .  .  Cond: trace
  6275  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  6276  .  .  .  .  .  .  0: *syntax.CallStmt {
  6277  .  .  .  .  .  .  .  Tok: defer
  6278  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  6279  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  6280  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6281  .  .  .  .  .  .  .  .  .  .  X: p
  6282  .  .  .  .  .  .  .  .  .  .  Sel: trace
  6283  .  .  .  .  .  .  .  .  .  }
  6284  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6285  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  6286  .  .  .  .  .  .  .  .  .  .  .  Value: "\"tryType\""
  6287  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  6288  .  .  .  .  .  .  .  .  .  .  }
  6289  .  .  .  .  .  .  .  .  .  }
  6290  .  .  .  .  .  .  .  .  .  HasDots: false
  6291  .  .  .  .  .  .  .  .  }
  6292  .  .  .  .  .  .  .  .  ArgList: nil
  6293  .  .  .  .  .  .  .  .  HasDots: false
  6294  .  .  .  .  .  .  .  }
  6295  .  .  .  .  .  .  }
  6296  .  .  .  .  .  }
  6297  .  .  .  .  .  Else: nil
  6298  .  .  .  .  }
  6299  .  .  .  .  1: *syntax.SwitchStmt {
  6300  .  .  .  .  .  Init: nil
  6301  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  6302  .  .  .  .  .  .  X: p
  6303  .  .  .  .  .  .  Sel: tok
  6304  .  .  .  .  .  }
  6305  .  .  .  .  .  Body: []*syntax.CaseClause (10 entries) {
  6306  .  .  .  .  .  .  0: *syntax.CaseClause {
  6307  .  .  .  .  .  .  .  Cases: _Star
  6308  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  6309  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6310  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6311  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6312  .  .  .  .  .  .  .  .  .  .  .  X: p
  6313  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  6314  .  .  .  .  .  .  .  .  .  .  }
  6315  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6316  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6317  .  .  .  .  .  .  .  .  .  }
  6318  .  .  .  .  .  .  .  .  }
  6319  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
  6320  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  6321  .  .  .  .  .  .  .  .  .  .  Fun: indirect
  6322  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6323  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  6324  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6325  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  6326  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_
  6327  .  .  .  .  .  .  .  .  .  .  .  .  }
  6328  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6329  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6330  .  .  .  .  .  .  .  .  .  .  .  }
  6331  .  .  .  .  .  .  .  .  .  .  }
  6332  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6333  .  .  .  .  .  .  .  .  .  }
  6334  .  .  .  .  .  .  .  .  }
  6335  .  .  .  .  .  .  .  }
  6336  .  .  .  .  .  .  }
  6337  .  .  .  .  .  .  1: *syntax.CaseClause {
  6338  .  .  .  .  .  .  .  Cases: _Arrow
  6339  .  .  .  .  .  .  .  Body: []syntax.Stmt (7 entries) {
  6340  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6341  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6342  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6343  .  .  .  .  .  .  .  .  .  .  .  X: p
  6344  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  6345  .  .  .  .  .  .  .  .  .  .  }
  6346  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6347  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6348  .  .  .  .  .  .  .  .  .  }
  6349  .  .  .  .  .  .  .  .  }
  6350  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  6351  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6352  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6353  .  .  .  .  .  .  .  .  .  .  .  X: p
  6354  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  6355  .  .  .  .  .  .  .  .  .  .  }
  6356  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6357  .  .  .  .  .  .  .  .  .  .  .  0: _Chan
  6358  .  .  .  .  .  .  .  .  .  .  }
  6359  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6360  .  .  .  .  .  .  .  .  .  }
  6361  .  .  .  .  .  .  .  .  }
  6362  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  6363  .  .  .  .  .  .  .  .  .  Op: :
  6364  .  .  .  .  .  .  .  .  .  Lhs: t
  6365  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6366  .  .  .  .  .  .  .  .  .  .  Fun: new
  6367  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6368  .  .  .  .  .  .  .  .  .  .  .  0: ChanType
  6369  .  .  .  .  .  .  .  .  .  .  }
  6370  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6371  .  .  .  .  .  .  .  .  .  }
  6372  .  .  .  .  .  .  .  .  }
  6373  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
  6374  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6375  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6376  .  .  .  .  .  .  .  .  .  .  .  X: t
  6377  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  6378  .  .  .  .  .  .  .  .  .  .  }
  6379  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6380  .  .  .  .  .  .  .  .  .  .  .  0: p
  6381  .  .  .  .  .  .  .  .  .  .  }
  6382  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6383  .  .  .  .  .  .  .  .  .  }
  6384  .  .  .  .  .  .  .  .  }
  6385  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  6386  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6387  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6388  .  .  .  .  .  .  .  .  .  .  X: t
  6389  .  .  .  .  .  .  .  .  .  .  Sel: Dir
  6390  .  .  .  .  .  .  .  .  .  }
  6391  .  .  .  .  .  .  .  .  .  Rhs: RecvOnly
  6392  .  .  .  .  .  .  .  .  }
  6393  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  6394  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6395  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6396  .  .  .  .  .  .  .  .  .  .  X: t
  6397  .  .  .  .  .  .  .  .  .  .  Sel: Elem
  6398  .  .  .  .  .  .  .  .  .  }
  6399  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6400  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6401  .  .  .  .  .  .  .  .  .  .  .  X: p
  6402  .  .  .  .  .  .  .  .  .  .  .  Sel: chanElem
  6403  .  .  .  .  .  .  .  .  .  .  }
  6404  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6405  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6406  .  .  .  .  .  .  .  .  .  }
  6407  .  .  .  .  .  .  .  .  }
  6408  .  .  .  .  .  .  .  .  6: *syntax.ReturnStmt {
  6409  .  .  .  .  .  .  .  .  .  Results: t
  6410  .  .  .  .  .  .  .  .  }
  6411  .  .  .  .  .  .  .  }
  6412  .  .  .  .  .  .  }
  6413  .  .  .  .  .  .  2: *syntax.CaseClause {
  6414  .  .  .  .  .  .  .  Cases: _Func
  6415  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  6416  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6417  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6418  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6419  .  .  .  .  .  .  .  .  .  .  .  X: p
  6420  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  6421  .  .  .  .  .  .  .  .  .  .  }
  6422  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6423  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6424  .  .  .  .  .  .  .  .  .  }
  6425  .  .  .  .  .  .  .  .  }
  6426  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
  6427  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  6428  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6429  .  .  .  .  .  .  .  .  .  .  .  X: p
  6430  .  .  .  .  .  .  .  .  .  .  .  Sel: funcType
  6431  .  .  .  .  .  .  .  .  .  .  }
  6432  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6433  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6434  .  .  .  .  .  .  .  .  .  }
  6435  .  .  .  .  .  .  .  .  }
  6436  .  .  .  .  .  .  .  }
  6437  .  .  .  .  .  .  }
  6438  .  .  .  .  .  .  3: *syntax.CaseClause {
  6439  .  .  .  .  .  .  .  Cases: _Lbrack
  6440  .  .  .  .  .  .  .  Body: []syntax.Stmt (10 entries) {
  6441  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6442  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6443  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6444  .  .  .  .  .  .  .  .  .  .  .  X: p
  6445  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  6446  .  .  .  .  .  .  .  .  .  .  }
  6447  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6448  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6449  .  .  .  .  .  .  .  .  .  }
  6450  .  .  .  .  .  .  .  .  }
  6451  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  6452  .  .  .  .  .  .  .  .  .  Op: +
  6453  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6454  .  .  .  .  .  .  .  .  .  .  X: p
  6455  .  .  .  .  .  .  .  .  .  .  Sel: xnest
  6456  .  .  .  .  .  .  .  .  .  }
  6457  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  6458  .  .  .  .  .  .  .  .  }
  6459  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
  6460  .  .  .  .  .  .  .  .  .  Init: nil
  6461  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  6462  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6463  .  .  .  .  .  .  .  .  .  .  .  X: p
  6464  .  .  .  .  .  .  .  .  .  .  .  Sel: got
  6465  .  .  .  .  .  .  .  .  .  .  }
  6466  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6467  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrack
  6468  .  .  .  .  .  .  .  .  .  .  }
  6469  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6470  .  .  .  .  .  .  .  .  .  }
  6471  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (5 entries) {
  6472  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6473  .  .  .  .  .  .  .  .  .  .  .  Op: -
  6474  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6475  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  6476  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest
  6477  .  .  .  .  .  .  .  .  .  .  .  }
  6478  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  6479  .  .  .  .  .  .  .  .  .  .  }
  6480  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  6481  .  .  .  .  .  .  .  .  .  .  .  Op: :
  6482  .  .  .  .  .  .  .  .  .  .  .  Lhs: t
  6483  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6484  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new
  6485  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6486  .  .  .  .  .  .  .  .  .  .  .  .  .  0: SliceType
  6487  .  .  .  .  .  .  .  .  .  .  .  .  }
  6488  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6489  .  .  .  .  .  .  .  .  .  .  .  }
  6490  .  .  .  .  .  .  .  .  .  .  }
  6491  .  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  6492  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6493  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6494  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  6495  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  6496  .  .  .  .  .  .  .  .  .  .  .  .  }
  6497  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6498  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
  6499  .  .  .  .  .  .  .  .  .  .  .  .  }
  6500  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6501  .  .  .  .  .  .  .  .  .  .  .  }
  6502  .  .  .  .  .  .  .  .  .  .  }
  6503  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  6504  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6505  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6506  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  6507  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Elem
  6508  .  .  .  .  .  .  .  .  .  .  .  }
  6509  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6510  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6511  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  6512  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_
  6513  .  .  .  .  .  .  .  .  .  .  .  .  }
  6514  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6515  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6516  .  .  .  .  .  .  .  .  .  .  .  }
  6517  .  .  .  .  .  .  .  .  .  .  }
  6518  .  .  .  .  .  .  .  .  .  .  4: *syntax.ReturnStmt {
  6519  .  .  .  .  .  .  .  .  .  .  .  Results: t
  6520  .  .  .  .  .  .  .  .  .  .  }
  6521  .  .  .  .  .  .  .  .  .  }
  6522  .  .  .  .  .  .  .  .  .  Else: nil
  6523  .  .  .  .  .  .  .  .  }
  6524  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  6525  .  .  .  .  .  .  .  .  .  Op: :
  6526  .  .  .  .  .  .  .  .  .  Lhs: t
  6527  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6528  .  .  .  .  .  .  .  .  .  .  Fun: new
  6529  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6530  .  .  .  .  .  .  .  .  .  .  .  0: ArrayType
  6531  .  .  .  .  .  .  .  .  .  .  }
  6532  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6533  .  .  .  .  .  .  .  .  .  }
  6534  .  .  .  .  .  .  .  .  }
  6535  .  .  .  .  .  .  .  .  4: *syntax.ExprStmt {
  6536  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6537  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6538  .  .  .  .  .  .  .  .  .  .  .  X: t
  6539  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  6540  .  .  .  .  .  .  .  .  .  .  }
  6541  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6542  .  .  .  .  .  .  .  .  .  .  .  0: p
  6543  .  .  .  .  .  .  .  .  .  .  }
  6544  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6545  .  .  .  .  .  .  .  .  .  }
  6546  .  .  .  .  .  .  .  .  }
  6547  .  .  .  .  .  .  .  .  5: *syntax.IfStmt {
  6548  .  .  .  .  .  .  .  .  .  Init: nil
  6549  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  6550  .  .  .  .  .  .  .  .  .  .  Op: !
  6551  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6552  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6553  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  6554  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got
  6555  .  .  .  .  .  .  .  .  .  .  .  }
  6556  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6557  .  .  .  .  .  .  .  .  .  .  .  .  0: _DotDotDot
  6558  .  .  .  .  .  .  .  .  .  .  .  }
  6559  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6560  .  .  .  .  .  .  .  .  .  .  }
  6561  .  .  .  .  .  .  .  .  .  .  Y: nil
  6562  .  .  .  .  .  .  .  .  .  }
  6563  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  6564  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6565  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6566  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6567  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  6568  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Len
  6569  .  .  .  .  .  .  .  .  .  .  .  }
  6570  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6571  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6572  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  6573  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr
  6574  .  .  .  .  .  .  .  .  .  .  .  .  }
  6575  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6576  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6577  .  .  .  .  .  .  .  .  .  .  .  }
  6578  .  .  .  .  .  .  .  .  .  .  }
  6579  .  .  .  .  .  .  .  .  .  }
  6580  .  .  .  .  .  .  .  .  .  Else: nil
  6581  .  .  .  .  .  .  .  .  }
  6582  .  .  .  .  .  .  .  .  6: *syntax.ExprStmt {
  6583  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6584  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6585  .  .  .  .  .  .  .  .  .  .  .  X: p
  6586  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  6587  .  .  .  .  .  .  .  .  .  .  }
  6588  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6589  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrack
  6590  .  .  .  .  .  .  .  .  .  .  }
  6591  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6592  .  .  .  .  .  .  .  .  .  }
  6593  .  .  .  .  .  .  .  .  }
  6594  .  .  .  .  .  .  .  .  7: *syntax.AssignStmt {
  6595  .  .  .  .  .  .  .  .  .  Op: -
  6596  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6597  .  .  .  .  .  .  .  .  .  .  X: p
  6598  .  .  .  .  .  .  .  .  .  .  Sel: xnest
  6599  .  .  .  .  .  .  .  .  .  }
  6600  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  6601  .  .  .  .  .  .  .  .  }
  6602  .  .  .  .  .  .  .  .  8: *syntax.AssignStmt {
  6603  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6604  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6605  .  .  .  .  .  .  .  .  .  .  X: t
  6606  .  .  .  .  .  .  .  .  .  .  Sel: Elem
  6607  .  .  .  .  .  .  .  .  .  }
  6608  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6609  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6610  .  .  .  .  .  .  .  .  .  .  .  X: p
  6611  .  .  .  .  .  .  .  .  .  .  .  Sel: type_
  6612  .  .  .  .  .  .  .  .  .  .  }
  6613  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6614  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6615  .  .  .  .  .  .  .  .  .  }
  6616  .  .  .  .  .  .  .  .  }
  6617  .  .  .  .  .  .  .  .  9: *syntax.ReturnStmt {
  6618  .  .  .  .  .  .  .  .  .  Results: t
  6619  .  .  .  .  .  .  .  .  }
  6620  .  .  .  .  .  .  .  }
  6621  .  .  .  .  .  .  }
  6622  .  .  .  .  .  .  4: *syntax.CaseClause {
  6623  .  .  .  .  .  .  .  Cases: _Chan
  6624  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
  6625  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6626  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6627  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6628  .  .  .  .  .  .  .  .  .  .  .  X: p
  6629  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  6630  .  .  .  .  .  .  .  .  .  .  }
  6631  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6632  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6633  .  .  .  .  .  .  .  .  .  }
  6634  .  .  .  .  .  .  .  .  }
  6635  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  6636  .  .  .  .  .  .  .  .  .  Op: :
  6637  .  .  .  .  .  .  .  .  .  Lhs: t
  6638  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6639  .  .  .  .  .  .  .  .  .  .  Fun: new
  6640  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6641  .  .  .  .  .  .  .  .  .  .  .  0: ChanType
  6642  .  .  .  .  .  .  .  .  .  .  }
  6643  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6644  .  .  .  .  .  .  .  .  .  }
  6645  .  .  .  .  .  .  .  .  }
  6646  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  6647  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6648  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6649  .  .  .  .  .  .  .  .  .  .  .  X: t
  6650  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  6651  .  .  .  .  .  .  .  .  .  .  }
  6652  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6653  .  .  .  .  .  .  .  .  .  .  .  0: p
  6654  .  .  .  .  .  .  .  .  .  .  }
  6655  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6656  .  .  .  .  .  .  .  .  .  }
  6657  .  .  .  .  .  .  .  .  }
  6658  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  6659  .  .  .  .  .  .  .  .  .  Init: nil
  6660  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  6661  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6662  .  .  .  .  .  .  .  .  .  .  .  X: p
  6663  .  .  .  .  .  .  .  .  .  .  .  Sel: got
  6664  .  .  .  .  .  .  .  .  .  .  }
  6665  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6666  .  .  .  .  .  .  .  .  .  .  .  0: _Arrow
  6667  .  .  .  .  .  .  .  .  .  .  }
  6668  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6669  .  .  .  .  .  .  .  .  .  }
  6670  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  6671  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6672  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6673  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6674  .  .  .  .  .  .  .  .  .  .  .  .  X: t
  6675  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Dir
  6676  .  .  .  .  .  .  .  .  .  .  .  }
  6677  .  .  .  .  .  .  .  .  .  .  .  Rhs: SendOnly
  6678  .  .  .  .  .  .  .  .  .  .  }
  6679  .  .  .  .  .  .  .  .  .  }
  6680  .  .  .  .  .  .  .  .  .  Else: nil
  6681  .  .  .  .  .  .  .  .  }
  6682  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  6683  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6684  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6685  .  .  .  .  .  .  .  .  .  .  X: t
  6686  .  .  .  .  .  .  .  .  .  .  Sel: Elem
  6687  .  .  .  .  .  .  .  .  .  }
  6688  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6689  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6690  .  .  .  .  .  .  .  .  .  .  .  X: p
  6691  .  .  .  .  .  .  .  .  .  .  .  Sel: chanElem
  6692  .  .  .  .  .  .  .  .  .  .  }
  6693  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6694  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6695  .  .  .  .  .  .  .  .  .  }
  6696  .  .  .  .  .  .  .  .  }
  6697  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
  6698  .  .  .  .  .  .  .  .  .  Results: t
  6699  .  .  .  .  .  .  .  .  }
  6700  .  .  .  .  .  .  .  }
  6701  .  .  .  .  .  .  }
  6702  .  .  .  .  .  .  5: *syntax.CaseClause {
  6703  .  .  .  .  .  .  .  Cases: _Map
  6704  .  .  .  .  .  .  .  Body: []syntax.Stmt (8 entries) {
  6705  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6706  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6707  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6708  .  .  .  .  .  .  .  .  .  .  .  X: p
  6709  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  6710  .  .  .  .  .  .  .  .  .  .  }
  6711  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6712  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6713  .  .  .  .  .  .  .  .  .  }
  6714  .  .  .  .  .  .  .  .  }
  6715  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  6716  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6717  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6718  .  .  .  .  .  .  .  .  .  .  .  X: p
  6719  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  6720  .  .  .  .  .  .  .  .  .  .  }
  6721  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6722  .  .  .  .  .  .  .  .  .  .  .  0: _Lbrack
  6723  .  .  .  .  .  .  .  .  .  .  }
  6724  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6725  .  .  .  .  .  .  .  .  .  }
  6726  .  .  .  .  .  .  .  .  }
  6727  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  6728  .  .  .  .  .  .  .  .  .  Op: :
  6729  .  .  .  .  .  .  .  .  .  Lhs: t
  6730  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6731  .  .  .  .  .  .  .  .  .  .  Fun: new
  6732  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6733  .  .  .  .  .  .  .  .  .  .  .  0: MapType
  6734  .  .  .  .  .  .  .  .  .  .  }
  6735  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6736  .  .  .  .  .  .  .  .  .  }
  6737  .  .  .  .  .  .  .  .  }
  6738  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
  6739  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6740  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6741  .  .  .  .  .  .  .  .  .  .  .  X: t
  6742  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  6743  .  .  .  .  .  .  .  .  .  .  }
  6744  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6745  .  .  .  .  .  .  .  .  .  .  .  0: p
  6746  .  .  .  .  .  .  .  .  .  .  }
  6747  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6748  .  .  .  .  .  .  .  .  .  }
  6749  .  .  .  .  .  .  .  .  }
  6750  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  6751  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6752  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6753  .  .  .  .  .  .  .  .  .  .  X: t
  6754  .  .  .  .  .  .  .  .  .  .  Sel: Key
  6755  .  .  .  .  .  .  .  .  .  }
  6756  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6757  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6758  .  .  .  .  .  .  .  .  .  .  .  X: p
  6759  .  .  .  .  .  .  .  .  .  .  .  Sel: type_
  6760  .  .  .  .  .  .  .  .  .  .  }
  6761  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6762  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6763  .  .  .  .  .  .  .  .  .  }
  6764  .  .  .  .  .  .  .  .  }
  6765  .  .  .  .  .  .  .  .  5: *syntax.ExprStmt {
  6766  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6767  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6768  .  .  .  .  .  .  .  .  .  .  .  X: p
  6769  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  6770  .  .  .  .  .  .  .  .  .  .  }
  6771  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6772  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrack
  6773  .  .  .  .  .  .  .  .  .  .  }
  6774  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6775  .  .  .  .  .  .  .  .  .  }
  6776  .  .  .  .  .  .  .  .  }
  6777  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
  6778  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6779  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6780  .  .  .  .  .  .  .  .  .  .  X: t
  6781  .  .  .  .  .  .  .  .  .  .  Sel: Value
  6782  .  .  .  .  .  .  .  .  .  }
  6783  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6784  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6785  .  .  .  .  .  .  .  .  .  .  .  X: p
  6786  .  .  .  .  .  .  .  .  .  .  .  Sel: type_
  6787  .  .  .  .  .  .  .  .  .  .  }
  6788  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6789  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6790  .  .  .  .  .  .  .  .  .  }
  6791  .  .  .  .  .  .  .  .  }
  6792  .  .  .  .  .  .  .  .  7: *syntax.ReturnStmt {
  6793  .  .  .  .  .  .  .  .  .  Results: t
  6794  .  .  .  .  .  .  .  .  }
  6795  .  .  .  .  .  .  .  }
  6796  .  .  .  .  .  .  }
  6797  .  .  .  .  .  .  6: *syntax.CaseClause {
  6798  .  .  .  .  .  .  .  Cases: _Struct
  6799  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  6800  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  6801  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  6802  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6803  .  .  .  .  .  .  .  .  .  .  .  X: p
  6804  .  .  .  .  .  .  .  .  .  .  .  Sel: structType
  6805  .  .  .  .  .  .  .  .  .  .  }
  6806  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6807  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6808  .  .  .  .  .  .  .  .  .  }
  6809  .  .  .  .  .  .  .  .  }
  6810  .  .  .  .  .  .  .  }
  6811  .  .  .  .  .  .  }
  6812  .  .  .  .  .  .  7: *syntax.CaseClause {
  6813  .  .  .  .  .  .  .  Cases: _Interface
  6814  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  6815  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  6816  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  6817  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6818  .  .  .  .  .  .  .  .  .  .  .  X: p
  6819  .  .  .  .  .  .  .  .  .  .  .  Sel: interfaceType
  6820  .  .  .  .  .  .  .  .  .  .  }
  6821  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6822  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6823  .  .  .  .  .  .  .  .  .  }
  6824  .  .  .  .  .  .  .  .  }
  6825  .  .  .  .  .  .  .  }
  6826  .  .  .  .  .  .  }
  6827  .  .  .  .  .  .  8: *syntax.CaseClause {
  6828  .  .  .  .  .  .  .  Cases: _Name
  6829  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  6830  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  6831  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  6832  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6833  .  .  .  .  .  .  .  .  .  .  .  X: p
  6834  .  .  .  .  .  .  .  .  .  .  .  Sel: dotname
  6835  .  .  .  .  .  .  .  .  .  .  }
  6836  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6837  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  6838  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6839  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  6840  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name
  6841  .  .  .  .  .  .  .  .  .  .  .  .  }
  6842  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6843  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6844  .  .  .  .  .  .  .  .  .  .  .  }
  6845  .  .  .  .  .  .  .  .  .  .  }
  6846  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6847  .  .  .  .  .  .  .  .  .  }
  6848  .  .  .  .  .  .  .  .  }
  6849  .  .  .  .  .  .  .  }
  6850  .  .  .  .  .  .  }
  6851  .  .  .  .  .  .  9: *syntax.CaseClause {
  6852  .  .  .  .  .  .  .  Cases: _Lparen
  6853  .  .  .  .  .  .  .  Body: []syntax.Stmt (4 entries) {
  6854  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6855  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6856  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6857  .  .  .  .  .  .  .  .  .  .  .  X: p
  6858  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  6859  .  .  .  .  .  .  .  .  .  .  }
  6860  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6861  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6862  .  .  .  .  .  .  .  .  .  }
  6863  .  .  .  .  .  .  .  .  }
  6864  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  6865  .  .  .  .  .  .  .  .  .  Op: :
  6866  .  .  .  .  .  .  .  .  .  Lhs: t
  6867  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6868  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6869  .  .  .  .  .  .  .  .  .  .  .  X: p
  6870  .  .  .  .  .  .  .  .  .  .  .  Sel: type_
  6871  .  .  .  .  .  .  .  .  .  .  }
  6872  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6873  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6874  .  .  .  .  .  .  .  .  .  }
  6875  .  .  .  .  .  .  .  .  }
  6876  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  6877  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6878  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6879  .  .  .  .  .  .  .  .  .  .  .  X: p
  6880  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  6881  .  .  .  .  .  .  .  .  .  .  }
  6882  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6883  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen
  6884  .  .  .  .  .  .  .  .  .  .  }
  6885  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6886  .  .  .  .  .  .  .  .  .  }
  6887  .  .  .  .  .  .  .  .  }
  6888  .  .  .  .  .  .  .  .  3: *syntax.ReturnStmt {
  6889  .  .  .  .  .  .  .  .  .  Results: t
  6890  .  .  .  .  .  .  .  .  }
  6891  .  .  .  .  .  .  .  }
  6892  .  .  .  .  .  .  }
  6893  .  .  .  .  .  }
  6894  .  .  .  .  }
  6895  .  .  .  .  2: *syntax.ReturnStmt {
  6896  .  .  .  .  .  Results: nil
  6897  .  .  .  .  }
  6898  .  .  .  }
  6899  .  .  .  Pragma: 0
  6900  .  .  .  EndLine: 1001
  6901  .  .  }
  6902  .  .  35: *syntax.FuncDecl {
  6903  .  .  .  Attr: map[]
  6904  .  .  .  Recv: *syntax.Field {
  6905  .  .  .  .  Name: p
  6906  .  .  .  .  Type: *syntax.Operation {
  6907  .  .  .  .  .  Op: *
  6908  .  .  .  .  .  X: parser
  6909  .  .  .  .  .  Y: nil
  6910  .  .  .  .  }
  6911  .  .  .  }
  6912  .  .  .  Name: funcType
  6913  .  .  .  Type: *syntax.FuncType {
  6914  .  .  .  .  ParamList: nil
  6915  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  6916  .  .  .  .  .  0: *syntax.Field {
  6917  .  .  .  .  .  .  Name: nil
  6918  .  .  .  .  .  .  Type: *syntax.Operation {
  6919  .  .  .  .  .  .  .  Op: *
  6920  .  .  .  .  .  .  .  X: FuncType
  6921  .  .  .  .  .  .  .  Y: nil
  6922  .  .  .  .  .  .  }
  6923  .  .  .  .  .  }
  6924  .  .  .  .  }
  6925  .  .  .  }
  6926  .  .  .  Body: []syntax.Stmt (7 entries) {
  6927  .  .  .  .  0: *syntax.IfStmt {
  6928  .  .  .  .  .  Init: nil
  6929  .  .  .  .  .  Cond: trace
  6930  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  6931  .  .  .  .  .  .  0: *syntax.CallStmt {
  6932  .  .  .  .  .  .  .  Tok: defer
  6933  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  6934  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  6935  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6936  .  .  .  .  .  .  .  .  .  .  X: p
  6937  .  .  .  .  .  .  .  .  .  .  Sel: trace
  6938  .  .  .  .  .  .  .  .  .  }
  6939  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6940  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  6941  .  .  .  .  .  .  .  .  .  .  .  Value: "\"funcType\""
  6942  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  6943  .  .  .  .  .  .  .  .  .  .  }
  6944  .  .  .  .  .  .  .  .  .  }
  6945  .  .  .  .  .  .  .  .  .  HasDots: false
  6946  .  .  .  .  .  .  .  .  }
  6947  .  .  .  .  .  .  .  .  ArgList: nil
  6948  .  .  .  .  .  .  .  .  HasDots: false
  6949  .  .  .  .  .  .  .  }
  6950  .  .  .  .  .  .  }
  6951  .  .  .  .  .  }
  6952  .  .  .  .  .  Else: nil
  6953  .  .  .  .  }
  6954  .  .  .  .  1: *syntax.AssignStmt {
  6955  .  .  .  .  .  Op: :
  6956  .  .  .  .  .  Lhs: typ
  6957  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6958  .  .  .  .  .  .  Fun: new
  6959  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6960  .  .  .  .  .  .  .  0: FuncType
  6961  .  .  .  .  .  .  }
  6962  .  .  .  .  .  .  HasDots: false
  6963  .  .  .  .  .  }
  6964  .  .  .  .  }
  6965  .  .  .  .  2: *syntax.ExprStmt {
  6966  .  .  .  .  .  X: *syntax.CallExpr {
  6967  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6968  .  .  .  .  .  .  .  X: typ
  6969  .  .  .  .  .  .  .  Sel: init
  6970  .  .  .  .  .  .  }
  6971  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6972  .  .  .  .  .  .  .  0: p
  6973  .  .  .  .  .  .  }
  6974  .  .  .  .  .  .  HasDots: false
  6975  .  .  .  .  .  }
  6976  .  .  .  .  }
  6977  .  .  .  .  3: *syntax.AssignStmt {
  6978  .  .  .  .  .  Op: <op-0>
  6979  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6980  .  .  .  .  .  .  X: typ
  6981  .  .  .  .  .  .  Sel: ParamList
  6982  .  .  .  .  .  }
  6983  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6984  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6985  .  .  .  .  .  .  .  X: p
  6986  .  .  .  .  .  .  .  Sel: paramList
  6987  .  .  .  .  .  .  }
  6988  .  .  .  .  .  .  ArgList: nil
  6989  .  .  .  .  .  .  HasDots: false
  6990  .  .  .  .  .  }
  6991  .  .  .  .  }
  6992  .  .  .  .  4: *syntax.AssignStmt {
  6993  .  .  .  .  .  Op: <op-0>
  6994  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6995  .  .  .  .  .  .  X: typ
  6996  .  .  .  .  .  .  Sel: ResultList
  6997  .  .  .  .  .  }
  6998  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6999  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7000  .  .  .  .  .  .  .  X: p
  7001  .  .  .  .  .  .  .  Sel: funcResult
  7002  .  .  .  .  .  .  }
  7003  .  .  .  .  .  .  ArgList: nil
  7004  .  .  .  .  .  .  HasDots: false
  7005  .  .  .  .  .  }
  7006  .  .  .  .  }
  7007  .  .  .  .  5: *syntax.IfStmt {
  7008  .  .  .  .  .  Init: nil
  7009  .  .  .  .  .  Cond: gcCompat
  7010  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7011  .  .  .  .  .  .  0: *syntax.ExprStmt {
  7012  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7013  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7014  .  .  .  .  .  .  .  .  .  X: typ
  7015  .  .  .  .  .  .  .  .  .  Sel: init
  7016  .  .  .  .  .  .  .  .  }
  7017  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7018  .  .  .  .  .  .  .  .  .  0: p
  7019  .  .  .  .  .  .  .  .  }
  7020  .  .  .  .  .  .  .  .  HasDots: false
  7021  .  .  .  .  .  .  .  }
  7022  .  .  .  .  .  .  }
  7023  .  .  .  .  .  }
  7024  .  .  .  .  .  Else: nil
  7025  .  .  .  .  }
  7026  .  .  .  .  6: *syntax.ReturnStmt {
  7027  .  .  .  .  .  Results: typ
  7028  .  .  .  .  }
  7029  .  .  .  }
  7030  .  .  .  Pragma: 0
  7031  .  .  .  EndLine: 1016
  7032  .  .  }
  7033  .  .  36: *syntax.FuncDecl {
  7034  .  .  .  Attr: map[]
  7035  .  .  .  Recv: *syntax.Field {
  7036  .  .  .  .  Name: p
  7037  .  .  .  .  Type: *syntax.Operation {
  7038  .  .  .  .  .  Op: *
  7039  .  .  .  .  .  X: parser
  7040  .  .  .  .  .  Y: nil
  7041  .  .  .  .  }
  7042  .  .  .  }
  7043  .  .  .  Name: chanElem
  7044  .  .  .  Type: *syntax.FuncType {
  7045  .  .  .  .  ParamList: nil
  7046  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  7047  .  .  .  .  .  0: *syntax.Field {
  7048  .  .  .  .  .  .  Name: nil
  7049  .  .  .  .  .  .  Type: Expr
  7050  .  .  .  .  .  }
  7051  .  .  .  .  }
  7052  .  .  .  }
  7053  .  .  .  Body: []syntax.Stmt (4 entries) {
  7054  .  .  .  .  0: *syntax.IfStmt {
  7055  .  .  .  .  .  Init: nil
  7056  .  .  .  .  .  Cond: trace
  7057  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7058  .  .  .  .  .  .  0: *syntax.CallStmt {
  7059  .  .  .  .  .  .  .  Tok: defer
  7060  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  7061  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  7062  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7063  .  .  .  .  .  .  .  .  .  .  X: p
  7064  .  .  .  .  .  .  .  .  .  .  Sel: trace
  7065  .  .  .  .  .  .  .  .  .  }
  7066  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7067  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  7068  .  .  .  .  .  .  .  .  .  .  .  Value: "\"chanElem\""
  7069  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  7070  .  .  .  .  .  .  .  .  .  .  }
  7071  .  .  .  .  .  .  .  .  .  }
  7072  .  .  .  .  .  .  .  .  .  HasDots: false
  7073  .  .  .  .  .  .  .  .  }
  7074  .  .  .  .  .  .  .  .  ArgList: nil
  7075  .  .  .  .  .  .  .  .  HasDots: false
  7076  .  .  .  .  .  .  .  }
  7077  .  .  .  .  .  .  }
  7078  .  .  .  .  .  }
  7079  .  .  .  .  .  Else: nil
  7080  .  .  .  .  }
  7081  .  .  .  .  1: *syntax.IfStmt {
  7082  .  .  .  .  .  Init: *syntax.AssignStmt {
  7083  .  .  .  .  .  .  Op: :
  7084  .  .  .  .  .  .  Lhs: typ
  7085  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7086  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7087  .  .  .  .  .  .  .  .  X: p
  7088  .  .  .  .  .  .  .  .  Sel: tryType
  7089  .  .  .  .  .  .  .  }
  7090  .  .  .  .  .  .  .  ArgList: nil
  7091  .  .  .  .  .  .  .  HasDots: false
  7092  .  .  .  .  .  .  }
  7093  .  .  .  .  .  }
  7094  .  .  .  .  .  Cond: *syntax.Operation {
  7095  .  .  .  .  .  .  Op: !=
  7096  .  .  .  .  .  .  X: typ
  7097  .  .  .  .  .  .  Y: nil
  7098  .  .  .  .  .  }
  7099  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7100  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  7101  .  .  .  .  .  .  .  Results: typ
  7102  .  .  .  .  .  .  }
  7103  .  .  .  .  .  }
  7104  .  .  .  .  .  Else: nil
  7105  .  .  .  .  }
  7106  .  .  .  .  2: *syntax.ExprStmt {
  7107  .  .  .  .  .  X: *syntax.CallExpr {
  7108  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7109  .  .  .  .  .  .  .  X: p
  7110  .  .  .  .  .  .  .  Sel: syntax_error
  7111  .  .  .  .  .  .  }
  7112  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7113  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  7114  .  .  .  .  .  .  .  .  Value: "\"missing channel element type\""
  7115  .  .  .  .  .  .  .  .  Kind: 4
  7116  .  .  .  .  .  .  .  }
  7117  .  .  .  .  .  .  }
  7118  .  .  .  .  .  .  HasDots: false
  7119  .  .  .  .  .  }
  7120  .  .  .  .  }
  7121  .  .  .  .  3: *syntax.ReturnStmt {
  7122  .  .  .  .  .  Results: nil
  7123  .  .  .  .  }
  7124  .  .  .  }
  7125  .  .  .  Pragma: 0
  7126  .  .  .  EndLine: 1030
  7127  .  .  }
  7128  .  .  37: *syntax.FuncDecl {
  7129  .  .  .  Attr: map[]
  7130  .  .  .  Recv: *syntax.Field {
  7131  .  .  .  .  Name: p
  7132  .  .  .  .  Type: *syntax.Operation {
  7133  .  .  .  .  .  Op: *
  7134  .  .  .  .  .  X: parser
  7135  .  .  .  .  .  Y: nil
  7136  .  .  .  .  }
  7137  .  .  .  }
  7138  .  .  .  Name: dotname
  7139  .  .  .  Type: *syntax.FuncType {
  7140  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  7141  .  .  .  .  .  0: *syntax.Field {
  7142  .  .  .  .  .  .  Name: name
  7143  .  .  .  .  .  .  Type: *syntax.Operation {
  7144  .  .  .  .  .  .  .  Op: *
  7145  .  .  .  .  .  .  .  X: Name
  7146  .  .  .  .  .  .  .  Y: nil
  7147  .  .  .  .  .  .  }
  7148  .  .  .  .  .  }
  7149  .  .  .  .  }
  7150  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  7151  .  .  .  .  .  0: *syntax.Field {
  7152  .  .  .  .  .  .  Name: nil
  7153  .  .  .  .  .  .  Type: Expr
  7154  .  .  .  .  .  }
  7155  .  .  .  .  }
  7156  .  .  .  }
  7157  .  .  .  Body: []syntax.Stmt (3 entries) {
  7158  .  .  .  .  0: *syntax.IfStmt {
  7159  .  .  .  .  .  Init: nil
  7160  .  .  .  .  .  Cond: trace
  7161  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7162  .  .  .  .  .  .  0: *syntax.CallStmt {
  7163  .  .  .  .  .  .  .  Tok: defer
  7164  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  7165  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  7166  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7167  .  .  .  .  .  .  .  .  .  .  X: p
  7168  .  .  .  .  .  .  .  .  .  .  Sel: trace
  7169  .  .  .  .  .  .  .  .  .  }
  7170  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7171  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  7172  .  .  .  .  .  .  .  .  .  .  .  Value: "\"dotname\""
  7173  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  7174  .  .  .  .  .  .  .  .  .  .  }
  7175  .  .  .  .  .  .  .  .  .  }
  7176  .  .  .  .  .  .  .  .  .  HasDots: false
  7177  .  .  .  .  .  .  .  .  }
  7178  .  .  .  .  .  .  .  .  ArgList: nil
  7179  .  .  .  .  .  .  .  .  HasDots: false
  7180  .  .  .  .  .  .  .  }
  7181  .  .  .  .  .  .  }
  7182  .  .  .  .  .  }
  7183  .  .  .  .  .  Else: nil
  7184  .  .  .  .  }
  7185  .  .  .  .  1: *syntax.IfStmt {
  7186  .  .  .  .  .  Init: nil
  7187  .  .  .  .  .  Cond: *syntax.CallExpr {
  7188  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7189  .  .  .  .  .  .  .  X: p
  7190  .  .  .  .  .  .  .  Sel: got
  7191  .  .  .  .  .  .  }
  7192  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7193  .  .  .  .  .  .  .  0: _Dot
  7194  .  .  .  .  .  .  }
  7195  .  .  .  .  .  .  HasDots: false
  7196  .  .  .  .  .  }
  7197  .  .  .  .  .  Then: []syntax.Stmt (5 entries) {
  7198  .  .  .  .  .  .  0: *syntax.AssignStmt {
  7199  .  .  .  .  .  .  .  Op: :
  7200  .  .  .  .  .  .  .  Lhs: s
  7201  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7202  .  .  .  .  .  .  .  .  Fun: new
  7203  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7204  .  .  .  .  .  .  .  .  .  0: SelectorExpr
  7205  .  .  .  .  .  .  .  .  }
  7206  .  .  .  .  .  .  .  .  HasDots: false
  7207  .  .  .  .  .  .  .  }
  7208  .  .  .  .  .  .  }
  7209  .  .  .  .  .  .  1: *syntax.ExprStmt {
  7210  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7211  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7212  .  .  .  .  .  .  .  .  .  X: s
  7213  .  .  .  .  .  .  .  .  .  Sel: init
  7214  .  .  .  .  .  .  .  .  }
  7215  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7216  .  .  .  .  .  .  .  .  .  0: p
  7217  .  .  .  .  .  .  .  .  }
  7218  .  .  .  .  .  .  .  .  HasDots: false
  7219  .  .  .  .  .  .  .  }
  7220  .  .  .  .  .  .  }
  7221  .  .  .  .  .  .  2: *syntax.AssignStmt {
  7222  .  .  .  .  .  .  .  Op: <op-0>
  7223  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7224  .  .  .  .  .  .  .  .  X: s
  7225  .  .  .  .  .  .  .  .  Sel: X
  7226  .  .  .  .  .  .  .  }
  7227  .  .  .  .  .  .  .  Rhs: name
  7228  .  .  .  .  .  .  }
  7229  .  .  .  .  .  .  3: *syntax.AssignStmt {
  7230  .  .  .  .  .  .  .  Op: <op-0>
  7231  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7232  .  .  .  .  .  .  .  .  X: s
  7233  .  .  .  .  .  .  .  .  Sel: Sel
  7234  .  .  .  .  .  .  .  }
  7235  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7236  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7237  .  .  .  .  .  .  .  .  .  X: p
  7238  .  .  .  .  .  .  .  .  .  Sel: name
  7239  .  .  .  .  .  .  .  .  }
  7240  .  .  .  .  .  .  .  .  ArgList: nil
  7241  .  .  .  .  .  .  .  .  HasDots: false
  7242  .  .  .  .  .  .  .  }
  7243  .  .  .  .  .  .  }
  7244  .  .  .  .  .  .  4: *syntax.ReturnStmt {
  7245  .  .  .  .  .  .  .  Results: s
  7246  .  .  .  .  .  .  }
  7247  .  .  .  .  .  }
  7248  .  .  .  .  .  Else: nil
  7249  .  .  .  .  }
  7250  .  .  .  .  2: *syntax.ReturnStmt {
  7251  .  .  .  .  .  Results: name
  7252  .  .  .  .  }
  7253  .  .  .  }
  7254  .  .  .  Pragma: 0
  7255  .  .  .  EndLine: 1045
  7256  .  .  }
  7257  .  .  38: *syntax.FuncDecl {
  7258  .  .  .  Attr: map[]
  7259  .  .  .  Recv: *syntax.Field {
  7260  .  .  .  .  Name: p
  7261  .  .  .  .  Type: *syntax.Operation {
  7262  .  .  .  .  .  Op: *
  7263  .  .  .  .  .  X: parser
  7264  .  .  .  .  .  Y: nil
  7265  .  .  .  .  }
  7266  .  .  .  }
  7267  .  .  .  Name: structType
  7268  .  .  .  Type: *syntax.FuncType {
  7269  .  .  .  .  ParamList: nil
  7270  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  7271  .  .  .  .  .  0: *syntax.Field {
  7272  .  .  .  .  .  .  Name: nil
  7273  .  .  .  .  .  .  Type: *syntax.Operation {
  7274  .  .  .  .  .  .  .  Op: *
  7275  .  .  .  .  .  .  .  X: StructType
  7276  .  .  .  .  .  .  .  Y: nil
  7277  .  .  .  .  .  .  }
  7278  .  .  .  .  .  }
  7279  .  .  .  .  }
  7280  .  .  .  }
  7281  .  .  .  Body: []syntax.Stmt (9 entries) {
  7282  .  .  .  .  0: *syntax.IfStmt {
  7283  .  .  .  .  .  Init: nil
  7284  .  .  .  .  .  Cond: trace
  7285  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7286  .  .  .  .  .  .  0: *syntax.CallStmt {
  7287  .  .  .  .  .  .  .  Tok: defer
  7288  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  7289  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  7290  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7291  .  .  .  .  .  .  .  .  .  .  X: p
  7292  .  .  .  .  .  .  .  .  .  .  Sel: trace
  7293  .  .  .  .  .  .  .  .  .  }
  7294  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7295  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  7296  .  .  .  .  .  .  .  .  .  .  .  Value: "\"structType\""
  7297  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  7298  .  .  .  .  .  .  .  .  .  .  }
  7299  .  .  .  .  .  .  .  .  .  }
  7300  .  .  .  .  .  .  .  .  .  HasDots: false
  7301  .  .  .  .  .  .  .  .  }
  7302  .  .  .  .  .  .  .  .  ArgList: nil
  7303  .  .  .  .  .  .  .  .  HasDots: false
  7304  .  .  .  .  .  .  .  }
  7305  .  .  .  .  .  .  }
  7306  .  .  .  .  .  }
  7307  .  .  .  .  .  Else: nil
  7308  .  .  .  .  }
  7309  .  .  .  .  1: *syntax.AssignStmt {
  7310  .  .  .  .  .  Op: :
  7311  .  .  .  .  .  Lhs: typ
  7312  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7313  .  .  .  .  .  .  Fun: new
  7314  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7315  .  .  .  .  .  .  .  0: StructType
  7316  .  .  .  .  .  .  }
  7317  .  .  .  .  .  .  HasDots: false
  7318  .  .  .  .  .  }
  7319  .  .  .  .  }
  7320  .  .  .  .  2: *syntax.ExprStmt {
  7321  .  .  .  .  .  X: *syntax.CallExpr {
  7322  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7323  .  .  .  .  .  .  .  X: typ
  7324  .  .  .  .  .  .  .  Sel: init
  7325  .  .  .  .  .  .  }
  7326  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7327  .  .  .  .  .  .  .  0: p
  7328  .  .  .  .  .  .  }
  7329  .  .  .  .  .  .  HasDots: false
  7330  .  .  .  .  .  }
  7331  .  .  .  .  }
  7332  .  .  .  .  3: *syntax.ExprStmt {
  7333  .  .  .  .  .  X: *syntax.CallExpr {
  7334  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7335  .  .  .  .  .  .  .  X: p
  7336  .  .  .  .  .  .  .  Sel: want
  7337  .  .  .  .  .  .  }
  7338  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7339  .  .  .  .  .  .  .  0: _Struct
  7340  .  .  .  .  .  .  }
  7341  .  .  .  .  .  .  HasDots: false
  7342  .  .  .  .  .  }
  7343  .  .  .  .  }
  7344  .  .  .  .  4: *syntax.ExprStmt {
  7345  .  .  .  .  .  X: *syntax.CallExpr {
  7346  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7347  .  .  .  .  .  .  .  X: p
  7348  .  .  .  .  .  .  .  Sel: want
  7349  .  .  .  .  .  .  }
  7350  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7351  .  .  .  .  .  .  .  0: _Lbrace
  7352  .  .  .  .  .  .  }
  7353  .  .  .  .  .  .  HasDots: false
  7354  .  .  .  .  .  }
  7355  .  .  .  .  }
  7356  .  .  .  .  5: *syntax.ForStmt {
  7357  .  .  .  .  .  Init: nil
  7358  .  .  .  .  .  Cond: *syntax.Operation {
  7359  .  .  .  .  .  .  Op: &&
  7360  .  .  .  .  .  .  X: *syntax.Operation {
  7361  .  .  .  .  .  .  .  Op: !=
  7362  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  7363  .  .  .  .  .  .  .  .  X: p
  7364  .  .  .  .  .  .  .  .  Sel: tok
  7365  .  .  .  .  .  .  .  }
  7366  .  .  .  .  .  .  .  Y: _EOF
  7367  .  .  .  .  .  .  }
  7368  .  .  .  .  .  .  Y: *syntax.Operation {
  7369  .  .  .  .  .  .  .  Op: !=
  7370  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  7371  .  .  .  .  .  .  .  .  X: p
  7372  .  .  .  .  .  .  .  .  Sel: tok
  7373  .  .  .  .  .  .  .  }
  7374  .  .  .  .  .  .  .  Y: _Rbrace
  7375  .  .  .  .  .  .  }
  7376  .  .  .  .  .  }
  7377  .  .  .  .  .  Post: nil
  7378  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  7379  .  .  .  .  .  .  0: *syntax.ExprStmt {
  7380  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7381  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7382  .  .  .  .  .  .  .  .  .  X: p
  7383  .  .  .  .  .  .  .  .  .  Sel: fieldDecl
  7384  .  .  .  .  .  .  .  .  }
  7385  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7386  .  .  .  .  .  .  .  .  .  0: typ
  7387  .  .  .  .  .  .  .  .  }
  7388  .  .  .  .  .  .  .  .  HasDots: false
  7389  .  .  .  .  .  .  .  }
  7390  .  .  .  .  .  .  }
  7391  .  .  .  .  .  .  1: *syntax.IfStmt {
  7392  .  .  .  .  .  .  .  Init: nil
  7393  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  7394  .  .  .  .  .  .  .  .  Op: !
  7395  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7396  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7397  .  .  .  .  .  .  .  .  .  .  X: p
  7398  .  .  .  .  .  .  .  .  .  .  Sel: osemi
  7399  .  .  .  .  .  .  .  .  .  }
  7400  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7401  .  .  .  .  .  .  .  .  .  .  0: _Rbrace
  7402  .  .  .  .  .  .  .  .  .  }
  7403  .  .  .  .  .  .  .  .  .  HasDots: false
  7404  .  .  .  .  .  .  .  .  }
  7405  .  .  .  .  .  .  .  .  Y: nil
  7406  .  .  .  .  .  .  .  }
  7407  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7408  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  7409  .  .  .  .  .  .  .  .  .  Tok: break
  7410  .  .  .  .  .  .  .  .  .  Label: nil
  7411  .  .  .  .  .  .  .  .  }
  7412  .  .  .  .  .  .  .  }
  7413  .  .  .  .  .  .  .  Else: nil
  7414  .  .  .  .  .  .  }
  7415  .  .  .  .  .  }
  7416  .  .  .  .  }
  7417  .  .  .  .  6: *syntax.IfStmt {
  7418  .  .  .  .  .  Init: nil
  7419  .  .  .  .  .  Cond: gcCompat
  7420  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7421  .  .  .  .  .  .  0: *syntax.ExprStmt {
  7422  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7423  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7424  .  .  .  .  .  .  .  .  .  X: typ
  7425  .  .  .  .  .  .  .  .  .  Sel: init
  7426  .  .  .  .  .  .  .  .  }
  7427  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7428  .  .  .  .  .  .  .  .  .  0: p
  7429  .  .  .  .  .  .  .  .  }
  7430  .  .  .  .  .  .  .  .  HasDots: false
  7431  .  .  .  .  .  .  .  }
  7432  .  .  .  .  .  .  }
  7433  .  .  .  .  .  }
  7434  .  .  .  .  .  Else: nil
  7435  .  .  .  .  }
  7436  .  .  .  .  7: *syntax.ExprStmt {
  7437  .  .  .  .  .  X: *syntax.CallExpr {
  7438  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7439  .  .  .  .  .  .  .  X: p
  7440  .  .  .  .  .  .  .  Sel: want
  7441  .  .  .  .  .  .  }
  7442  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7443  .  .  .  .  .  .  .  0: _Rbrace
  7444  .  .  .  .  .  .  }
  7445  .  .  .  .  .  .  HasDots: false
  7446  .  .  .  .  .  }
  7447  .  .  .  .  }
  7448  .  .  .  .  8: *syntax.ReturnStmt {
  7449  .  .  .  .  .  Results: typ
  7450  .  .  .  .  }
  7451  .  .  .  }
  7452  .  .  .  Pragma: 0
  7453  .  .  .  EndLine: 1070
  7454  .  .  }
  7455  .  .  39: *syntax.FuncDecl {
  7456  .  .  .  Attr: map[]
  7457  .  .  .  Recv: *syntax.Field {
  7458  .  .  .  .  Name: p
  7459  .  .  .  .  Type: *syntax.Operation {
  7460  .  .  .  .  .  Op: *
  7461  .  .  .  .  .  X: parser
  7462  .  .  .  .  .  Y: nil
  7463  .  .  .  .  }
  7464  .  .  .  }
  7465  .  .  .  Name: interfaceType
  7466  .  .  .  Type: *syntax.FuncType {
  7467  .  .  .  .  ParamList: nil
  7468  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  7469  .  .  .  .  .  0: *syntax.Field {
  7470  .  .  .  .  .  .  Name: nil
  7471  .  .  .  .  .  .  Type: *syntax.Operation {
  7472  .  .  .  .  .  .  .  Op: *
  7473  .  .  .  .  .  .  .  X: InterfaceType
  7474  .  .  .  .  .  .  .  Y: nil
  7475  .  .  .  .  .  .  }
  7476  .  .  .  .  .  }
  7477  .  .  .  .  }
  7478  .  .  .  }
  7479  .  .  .  Body: []syntax.Stmt (9 entries) {
  7480  .  .  .  .  0: *syntax.IfStmt {
  7481  .  .  .  .  .  Init: nil
  7482  .  .  .  .  .  Cond: trace
  7483  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7484  .  .  .  .  .  .  0: *syntax.CallStmt {
  7485  .  .  .  .  .  .  .  Tok: defer
  7486  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  7487  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  7488  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7489  .  .  .  .  .  .  .  .  .  .  X: p
  7490  .  .  .  .  .  .  .  .  .  .  Sel: trace
  7491  .  .  .  .  .  .  .  .  .  }
  7492  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7493  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  7494  .  .  .  .  .  .  .  .  .  .  .  Value: "\"interfaceType\""
  7495  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  7496  .  .  .  .  .  .  .  .  .  .  }
  7497  .  .  .  .  .  .  .  .  .  }
  7498  .  .  .  .  .  .  .  .  .  HasDots: false
  7499  .  .  .  .  .  .  .  .  }
  7500  .  .  .  .  .  .  .  .  ArgList: nil
  7501  .  .  .  .  .  .  .  .  HasDots: false
  7502  .  .  .  .  .  .  .  }
  7503  .  .  .  .  .  .  }
  7504  .  .  .  .  .  }
  7505  .  .  .  .  .  Else: nil
  7506  .  .  .  .  }
  7507  .  .  .  .  1: *syntax.AssignStmt {
  7508  .  .  .  .  .  Op: :
  7509  .  .  .  .  .  Lhs: typ
  7510  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7511  .  .  .  .  .  .  Fun: new
  7512  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7513  .  .  .  .  .  .  .  0: InterfaceType
  7514  .  .  .  .  .  .  }
  7515  .  .  .  .  .  .  HasDots: false
  7516  .  .  .  .  .  }
  7517  .  .  .  .  }
  7518  .  .  .  .  2: *syntax.ExprStmt {
  7519  .  .  .  .  .  X: *syntax.CallExpr {
  7520  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7521  .  .  .  .  .  .  .  X: typ
  7522  .  .  .  .  .  .  .  Sel: init
  7523  .  .  .  .  .  .  }
  7524  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7525  .  .  .  .  .  .  .  0: p
  7526  .  .  .  .  .  .  }
  7527  .  .  .  .  .  .  HasDots: false
  7528  .  .  .  .  .  }
  7529  .  .  .  .  }
  7530  .  .  .  .  3: *syntax.ExprStmt {
  7531  .  .  .  .  .  X: *syntax.CallExpr {
  7532  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7533  .  .  .  .  .  .  .  X: p
  7534  .  .  .  .  .  .  .  Sel: want
  7535  .  .  .  .  .  .  }
  7536  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7537  .  .  .  .  .  .  .  0: _Interface
  7538  .  .  .  .  .  .  }
  7539  .  .  .  .  .  .  HasDots: false
  7540  .  .  .  .  .  }
  7541  .  .  .  .  }
  7542  .  .  .  .  4: *syntax.ExprStmt {
  7543  .  .  .  .  .  X: *syntax.CallExpr {
  7544  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7545  .  .  .  .  .  .  .  X: p
  7546  .  .  .  .  .  .  .  Sel: want
  7547  .  .  .  .  .  .  }
  7548  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7549  .  .  .  .  .  .  .  0: _Lbrace
  7550  .  .  .  .  .  .  }
  7551  .  .  .  .  .  .  HasDots: false
  7552  .  .  .  .  .  }
  7553  .  .  .  .  }
  7554  .  .  .  .  5: *syntax.ForStmt {
  7555  .  .  .  .  .  Init: nil
  7556  .  .  .  .  .  Cond: *syntax.Operation {
  7557  .  .  .  .  .  .  Op: &&
  7558  .  .  .  .  .  .  X: *syntax.Operation {
  7559  .  .  .  .  .  .  .  Op: !=
  7560  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  7561  .  .  .  .  .  .  .  .  X: p
  7562  .  .  .  .  .  .  .  .  Sel: tok
  7563  .  .  .  .  .  .  .  }
  7564  .  .  .  .  .  .  .  Y: _EOF
  7565  .  .  .  .  .  .  }
  7566  .  .  .  .  .  .  Y: *syntax.Operation {
  7567  .  .  .  .  .  .  .  Op: !=
  7568  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  7569  .  .  .  .  .  .  .  .  X: p
  7570  .  .  .  .  .  .  .  .  Sel: tok
  7571  .  .  .  .  .  .  .  }
  7572  .  .  .  .  .  .  .  Y: _Rbrace
  7573  .  .  .  .  .  .  }
  7574  .  .  .  .  .  }
  7575  .  .  .  .  .  Post: nil
  7576  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  7577  .  .  .  .  .  .  0: *syntax.IfStmt {
  7578  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
  7579  .  .  .  .  .  .  .  .  Op: :
  7580  .  .  .  .  .  .  .  .  Lhs: m
  7581  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7582  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7583  .  .  .  .  .  .  .  .  .  .  X: p
  7584  .  .  .  .  .  .  .  .  .  .  Sel: methodDecl
  7585  .  .  .  .  .  .  .  .  .  }
  7586  .  .  .  .  .  .  .  .  .  ArgList: nil
  7587  .  .  .  .  .  .  .  .  .  HasDots: false
  7588  .  .  .  .  .  .  .  .  }
  7589  .  .  .  .  .  .  .  }
  7590  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  7591  .  .  .  .  .  .  .  .  Op: !=
  7592  .  .  .  .  .  .  .  .  X: m
  7593  .  .  .  .  .  .  .  .  Y: nil
  7594  .  .  .  .  .  .  .  }
  7595  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7596  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  7597  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7598  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7599  .  .  .  .  .  .  .  .  .  .  X: typ
  7600  .  .  .  .  .  .  .  .  .  .  Sel: MethodList
  7601  .  .  .  .  .  .  .  .  .  }
  7602  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7603  .  .  .  .  .  .  .  .  .  .  Fun: append
  7604  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  7605  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  7606  .  .  .  .  .  .  .  .  .  .  .  .  X: typ
  7607  .  .  .  .  .  .  .  .  .  .  .  .  Sel: MethodList
  7608  .  .  .  .  .  .  .  .  .  .  .  }
  7609  .  .  .  .  .  .  .  .  .  .  .  1: m
  7610  .  .  .  .  .  .  .  .  .  .  }
  7611  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7612  .  .  .  .  .  .  .  .  .  }
  7613  .  .  .  .  .  .  .  .  }
  7614  .  .  .  .  .  .  .  }
  7615  .  .  .  .  .  .  .  Else: nil
  7616  .  .  .  .  .  .  }
  7617  .  .  .  .  .  .  1: *syntax.IfStmt {
  7618  .  .  .  .  .  .  .  Init: nil
  7619  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  7620  .  .  .  .  .  .  .  .  Op: !
  7621  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7622  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7623  .  .  .  .  .  .  .  .  .  .  X: p
  7624  .  .  .  .  .  .  .  .  .  .  Sel: osemi
  7625  .  .  .  .  .  .  .  .  .  }
  7626  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7627  .  .  .  .  .  .  .  .  .  .  0: _Rbrace
  7628  .  .  .  .  .  .  .  .  .  }
  7629  .  .  .  .  .  .  .  .  .  HasDots: false
  7630  .  .  .  .  .  .  .  .  }
  7631  .  .  .  .  .  .  .  .  Y: nil
  7632  .  .  .  .  .  .  .  }
  7633  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7634  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  7635  .  .  .  .  .  .  .  .  .  Tok: break
  7636  .  .  .  .  .  .  .  .  .  Label: nil
  7637  .  .  .  .  .  .  .  .  }
  7638  .  .  .  .  .  .  .  }
  7639  .  .  .  .  .  .  .  Else: nil
  7640  .  .  .  .  .  .  }
  7641  .  .  .  .  .  }
  7642  .  .  .  .  }
  7643  .  .  .  .  6: *syntax.IfStmt {
  7644  .  .  .  .  .  Init: nil
  7645  .  .  .  .  .  Cond: gcCompat
  7646  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7647  .  .  .  .  .  .  0: *syntax.ExprStmt {
  7648  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7649  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7650  .  .  .  .  .  .  .  .  .  X: typ
  7651  .  .  .  .  .  .  .  .  .  Sel: init
  7652  .  .  .  .  .  .  .  .  }
  7653  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7654  .  .  .  .  .  .  .  .  .  0: p
  7655  .  .  .  .  .  .  .  .  }
  7656  .  .  .  .  .  .  .  .  HasDots: false
  7657  .  .  .  .  .  .  .  }
  7658  .  .  .  .  .  .  }
  7659  .  .  .  .  .  }
  7660  .  .  .  .  .  Else: nil
  7661  .  .  .  .  }
  7662  .  .  .  .  7: *syntax.ExprStmt {
  7663  .  .  .  .  .  X: *syntax.CallExpr {
  7664  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7665  .  .  .  .  .  .  .  X: p
  7666  .  .  .  .  .  .  .  Sel: want
  7667  .  .  .  .  .  .  }
  7668  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7669  .  .  .  .  .  .  .  0: _Rbrace
  7670  .  .  .  .  .  .  }
  7671  .  .  .  .  .  .  HasDots: false
  7672  .  .  .  .  .  }
  7673  .  .  .  .  }
  7674  .  .  .  .  8: *syntax.ReturnStmt {
  7675  .  .  .  .  .  Results: typ
  7676  .  .  .  .  }
  7677  .  .  .  }
  7678  .  .  .  Pragma: 0
  7679  .  .  .  EndLine: 1097
  7680  .  .  }
  7681  .  .  40: *syntax.FuncDecl {
  7682  .  .  .  Attr: map[]
  7683  .  .  .  Recv: *syntax.Field {
  7684  .  .  .  .  Name: p
  7685  .  .  .  .  Type: *syntax.Operation {
  7686  .  .  .  .  .  Op: *
  7687  .  .  .  .  .  X: parser
  7688  .  .  .  .  .  Y: nil
  7689  .  .  .  .  }
  7690  .  .  .  }
  7691  .  .  .  Name: funcBody
  7692  .  .  .  Type: *syntax.FuncType {
  7693  .  .  .  .  ParamList: nil
  7694  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  7695  .  .  .  .  .  0: *syntax.Field {
  7696  .  .  .  .  .  .  Name: nil
  7697  .  .  .  .  .  .  Type: *syntax.SliceType {
  7698  .  .  .  .  .  .  .  Elem: Stmt
  7699  .  .  .  .  .  .  }
  7700  .  .  .  .  .  }
  7701  .  .  .  .  }
  7702  .  .  .  }
  7703  .  .  .  Body: []syntax.Stmt (3 entries) {
  7704  .  .  .  .  0: *syntax.IfStmt {
  7705  .  .  .  .  .  Init: nil
  7706  .  .  .  .  .  Cond: trace
  7707  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7708  .  .  .  .  .  .  0: *syntax.CallStmt {
  7709  .  .  .  .  .  .  .  Tok: defer
  7710  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  7711  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  7712  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7713  .  .  .  .  .  .  .  .  .  .  X: p
  7714  .  .  .  .  .  .  .  .  .  .  Sel: trace
  7715  .  .  .  .  .  .  .  .  .  }
  7716  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7717  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  7718  .  .  .  .  .  .  .  .  .  .  .  Value: "\"funcBody\""
  7719  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  7720  .  .  .  .  .  .  .  .  .  .  }
  7721  .  .  .  .  .  .  .  .  .  }
  7722  .  .  .  .  .  .  .  .  .  HasDots: false
  7723  .  .  .  .  .  .  .  .  }
  7724  .  .  .  .  .  .  .  .  ArgList: nil
  7725  .  .  .  .  .  .  .  .  HasDots: false
  7726  .  .  .  .  .  .  .  }
  7727  .  .  .  .  .  .  }
  7728  .  .  .  .  .  }
  7729  .  .  .  .  .  Else: nil
  7730  .  .  .  .  }
  7731  .  .  .  .  1: *syntax.IfStmt {
  7732  .  .  .  .  .  Init: nil
  7733  .  .  .  .  .  Cond: *syntax.CallExpr {
  7734  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7735  .  .  .  .  .  .  .  X: p
  7736  .  .  .  .  .  .  .  Sel: got
  7737  .  .  .  .  .  .  }
  7738  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7739  .  .  .  .  .  .  .  0: _Lbrace
  7740  .  .  .  .  .  .  }
  7741  .  .  .  .  .  .  HasDots: false
  7742  .  .  .  .  .  }
  7743  .  .  .  .  .  Then: []syntax.Stmt (6 entries) {
  7744  .  .  .  .  .  .  0: *syntax.AssignStmt {
  7745  .  .  .  .  .  .  .  Op: +
  7746  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7747  .  .  .  .  .  .  .  .  X: p
  7748  .  .  .  .  .  .  .  .  Sel: fnest
  7749  .  .  .  .  .  .  .  }
  7750  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  7751  .  .  .  .  .  .  }
  7752  .  .  .  .  .  .  1: *syntax.AssignStmt {
  7753  .  .  .  .  .  .  .  Op: :
  7754  .  .  .  .  .  .  .  Lhs: body
  7755  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7756  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7757  .  .  .  .  .  .  .  .  .  X: p
  7758  .  .  .  .  .  .  .  .  .  Sel: stmtList
  7759  .  .  .  .  .  .  .  .  }
  7760  .  .  .  .  .  .  .  .  ArgList: nil
  7761  .  .  .  .  .  .  .  .  HasDots: false
  7762  .  .  .  .  .  .  .  }
  7763  .  .  .  .  .  .  }
  7764  .  .  .  .  .  .  2: *syntax.AssignStmt {
  7765  .  .  .  .  .  .  .  Op: -
  7766  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7767  .  .  .  .  .  .  .  .  X: p
  7768  .  .  .  .  .  .  .  .  Sel: fnest
  7769  .  .  .  .  .  .  .  }
  7770  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  7771  .  .  .  .  .  .  }
  7772  .  .  .  .  .  .  3: *syntax.ExprStmt {
  7773  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7774  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7775  .  .  .  .  .  .  .  .  .  X: p
  7776  .  .  .  .  .  .  .  .  .  Sel: want
  7777  .  .  .  .  .  .  .  .  }
  7778  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7779  .  .  .  .  .  .  .  .  .  0: _Rbrace
  7780  .  .  .  .  .  .  .  .  }
  7781  .  .  .  .  .  .  .  .  HasDots: false
  7782  .  .  .  .  .  .  .  }
  7783  .  .  .  .  .  .  }
  7784  .  .  .  .  .  .  4: *syntax.IfStmt {
  7785  .  .  .  .  .  .  .  Init: nil
  7786  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  7787  .  .  .  .  .  .  .  .  Op: ==
  7788  .  .  .  .  .  .  .  .  X: body
  7789  .  .  .  .  .  .  .  .  Y: nil
  7790  .  .  .  .  .  .  .  }
  7791  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7792  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  7793  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7794  .  .  .  .  .  .  .  .  .  Lhs: body
  7795  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CompositeLit {
  7796  .  .  .  .  .  .  .  .  .  .  Type: *syntax.SliceType {
  7797  .  .  .  .  .  .  .  .  .  .  .  Elem: Stmt
  7798  .  .  .  .  .  .  .  .  .  .  }
  7799  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (1 entries) {
  7800  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  7801  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new
  7802  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7803  .  .  .  .  .  .  .  .  .  .  .  .  .  0: EmptyStmt
  7804  .  .  .  .  .  .  .  .  .  .  .  .  }
  7805  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7806  .  .  .  .  .  .  .  .  .  .  .  }
  7807  .  .  .  .  .  .  .  .  .  .  }
  7808  .  .  .  .  .  .  .  .  .  .  NKeys: 0
  7809  .  .  .  .  .  .  .  .  .  .  EndLine: 1111
  7810  .  .  .  .  .  .  .  .  .  }
  7811  .  .  .  .  .  .  .  .  }
  7812  .  .  .  .  .  .  .  }
  7813  .  .  .  .  .  .  .  Else: nil
  7814  .  .  .  .  .  .  }
  7815  .  .  .  .  .  .  5: *syntax.ReturnStmt {
  7816  .  .  .  .  .  .  .  Results: body
  7817  .  .  .  .  .  .  }
  7818  .  .  .  .  .  }
  7819  .  .  .  .  .  Else: nil
  7820  .  .  .  .  }
  7821  .  .  .  .  2: *syntax.ReturnStmt {
  7822  .  .  .  .  .  Results: nil
  7823  .  .  .  .  }
  7824  .  .  .  }
  7825  .  .  .  Pragma: 0
  7826  .  .  .  EndLine: 1117
  7827  .  .  }
  7828  .  .  41: *syntax.FuncDecl {
  7829  .  .  .  Attr: map[]
  7830  .  .  .  Recv: *syntax.Field {
  7831  .  .  .  .  Name: p
  7832  .  .  .  .  Type: *syntax.Operation {
  7833  .  .  .  .  .  Op: *
  7834  .  .  .  .  .  X: parser
  7835  .  .  .  .  .  Y: nil
  7836  .  .  .  .  }
  7837  .  .  .  }
  7838  .  .  .  Name: funcResult
  7839  .  .  .  Type: *syntax.FuncType {
  7840  .  .  .  .  ParamList: nil
  7841  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  7842  .  .  .  .  .  0: *syntax.Field {
  7843  .  .  .  .  .  .  Name: nil
  7844  .  .  .  .  .  .  Type: *syntax.SliceType {
  7845  .  .  .  .  .  .  .  Elem: *syntax.Operation {
  7846  .  .  .  .  .  .  .  .  Op: *
  7847  .  .  .  .  .  .  .  .  X: Field
  7848  .  .  .  .  .  .  .  .  Y: nil
  7849  .  .  .  .  .  .  .  }
  7850  .  .  .  .  .  .  }
  7851  .  .  .  .  .  }
  7852  .  .  .  .  }
  7853  .  .  .  }
  7854  .  .  .  Body: []syntax.Stmt (4 entries) {
  7855  .  .  .  .  0: *syntax.IfStmt {
  7856  .  .  .  .  .  Init: nil
  7857  .  .  .  .  .  Cond: trace
  7858  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7859  .  .  .  .  .  .  0: *syntax.CallStmt {
  7860  .  .  .  .  .  .  .  Tok: defer
  7861  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  7862  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  7863  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7864  .  .  .  .  .  .  .  .  .  .  X: p
  7865  .  .  .  .  .  .  .  .  .  .  Sel: trace
  7866  .  .  .  .  .  .  .  .  .  }
  7867  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7868  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  7869  .  .  .  .  .  .  .  .  .  .  .  Value: "\"funcResult\""
  7870  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  7871  .  .  .  .  .  .  .  .  .  .  }
  7872  .  .  .  .  .  .  .  .  .  }
  7873  .  .  .  .  .  .  .  .  .  HasDots: false
  7874  .  .  .  .  .  .  .  .  }
  7875  .  .  .  .  .  .  .  .  ArgList: nil
  7876  .  .  .  .  .  .  .  .  HasDots: false
  7877  .  .  .  .  .  .  .  }
  7878  .  .  .  .  .  .  }
  7879  .  .  .  .  .  }
  7880  .  .  .  .  .  Else: nil
  7881  .  .  .  .  }
  7882  .  .  .  .  1: *syntax.IfStmt {
  7883  .  .  .  .  .  Init: nil
  7884  .  .  .  .  .  Cond: *syntax.Operation {
  7885  .  .  .  .  .  .  Op: ==
  7886  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  7887  .  .  .  .  .  .  .  X: p
  7888  .  .  .  .  .  .  .  Sel: tok
  7889  .  .  .  .  .  .  }
  7890  .  .  .  .  .  .  Y: _Lparen
  7891  .  .  .  .  .  }
  7892  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  7893  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  7894  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  7895  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7896  .  .  .  .  .  .  .  .  .  X: p
  7897  .  .  .  .  .  .  .  .  .  Sel: paramList
  7898  .  .  .  .  .  .  .  .  }
  7899  .  .  .  .  .  .  .  .  ArgList: nil
  7900  .  .  .  .  .  .  .  .  HasDots: false
  7901  .  .  .  .  .  .  .  }
  7902  .  .  .  .  .  .  }
  7903  .  .  .  .  .  }
  7904  .  .  .  .  .  Else: nil
  7905  .  .  .  .  }
  7906  .  .  .  .  2: *syntax.IfStmt {
  7907  .  .  .  .  .  Init: *syntax.AssignStmt {
  7908  .  .  .  .  .  .  Op: :
  7909  .  .  .  .  .  .  Lhs: result
  7910  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7911  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7912  .  .  .  .  .  .  .  .  X: p
  7913  .  .  .  .  .  .  .  .  Sel: tryType
  7914  .  .  .  .  .  .  .  }
  7915  .  .  .  .  .  .  .  ArgList: nil
  7916  .  .  .  .  .  .  .  HasDots: false
  7917  .  .  .  .  .  .  }
  7918  .  .  .  .  .  }
  7919  .  .  .  .  .  Cond: *syntax.Operation {
  7920  .  .  .  .  .  .  Op: !=
  7921  .  .  .  .  .  .  X: result
  7922  .  .  .  .  .  .  Y: nil
  7923  .  .  .  .  .  }
  7924  .  .  .  .  .  Then: []syntax.Stmt (4 entries) {
  7925  .  .  .  .  .  .  0: *syntax.AssignStmt {
  7926  .  .  .  .  .  .  .  Op: :
  7927  .  .  .  .  .  .  .  Lhs: f
  7928  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7929  .  .  .  .  .  .  .  .  Fun: new
  7930  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7931  .  .  .  .  .  .  .  .  .  0: Field
  7932  .  .  .  .  .  .  .  .  }
  7933  .  .  .  .  .  .  .  .  HasDots: false
  7934  .  .  .  .  .  .  .  }
  7935  .  .  .  .  .  .  }
  7936  .  .  .  .  .  .  1: *syntax.ExprStmt {
  7937  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7938  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7939  .  .  .  .  .  .  .  .  .  X: f
  7940  .  .  .  .  .  .  .  .  .  Sel: init
  7941  .  .  .  .  .  .  .  .  }
  7942  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7943  .  .  .  .  .  .  .  .  .  0: p
  7944  .  .  .  .  .  .  .  .  }
  7945  .  .  .  .  .  .  .  .  HasDots: false
  7946  .  .  .  .  .  .  .  }
  7947  .  .  .  .  .  .  }
  7948  .  .  .  .  .  .  2: *syntax.AssignStmt {
  7949  .  .  .  .  .  .  .  Op: <op-0>
  7950  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7951  .  .  .  .  .  .  .  .  X: f
  7952  .  .  .  .  .  .  .  .  Sel: Type
  7953  .  .  .  .  .  .  .  }
  7954  .  .  .  .  .  .  .  Rhs: result
  7955  .  .  .  .  .  .  }
  7956  .  .  .  .  .  .  3: *syntax.ReturnStmt {
  7957  .  .  .  .  .  .  .  Results: *syntax.CompositeLit {
  7958  .  .  .  .  .  .  .  .  Type: *syntax.SliceType {
  7959  .  .  .  .  .  .  .  .  .  Elem: *syntax.Operation {
  7960  .  .  .  .  .  .  .  .  .  .  Op: *
  7961  .  .  .  .  .  .  .  .  .  .  X: Field
  7962  .  .  .  .  .  .  .  .  .  .  Y: nil
  7963  .  .  .  .  .  .  .  .  .  }
  7964  .  .  .  .  .  .  .  .  }
  7965  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (1 entries) {
  7966  .  .  .  .  .  .  .  .  .  0: f
  7967  .  .  .  .  .  .  .  .  }
  7968  .  .  .  .  .  .  .  .  NKeys: 0
  7969  .  .  .  .  .  .  .  .  EndLine: 1133
  7970  .  .  .  .  .  .  .  }
  7971  .  .  .  .  .  .  }
  7972  .  .  .  .  .  }
  7973  .  .  .  .  .  Else: nil
  7974  .  .  .  .  }
  7975  .  .  .  .  3: *syntax.ReturnStmt {
  7976  .  .  .  .  .  Results: nil
  7977  .  .  .  .  }
  7978  .  .  .  }
  7979  .  .  .  Pragma: 0
  7980  .  .  .  EndLine: 1137
  7981  .  .  }
  7982  .  .  42: *syntax.FuncDecl {
  7983  .  .  .  Attr: map[]
  7984  .  .  .  Recv: *syntax.Field {
  7985  .  .  .  .  Name: p
  7986  .  .  .  .  Type: *syntax.Operation {
  7987  .  .  .  .  .  Op: *
  7988  .  .  .  .  .  X: parser
  7989  .  .  .  .  .  Y: nil
  7990  .  .  .  .  }
  7991  .  .  .  }
  7992  .  .  .  Name: addField
  7993  .  .  .  Type: *syntax.FuncType {
  7994  .  .  .  .  ParamList: []*syntax.Field (4 entries) {
  7995  .  .  .  .  .  0: *syntax.Field {
  7996  .  .  .  .  .  .  Name: styp
  7997  .  .  .  .  .  .  Type: *syntax.Operation {
  7998  .  .  .  .  .  .  .  Op: *
  7999  .  .  .  .  .  .  .  X: StructType
  8000  .  .  .  .  .  .  .  Y: nil
  8001  .  .  .  .  .  .  }
  8002  .  .  .  .  .  }
  8003  .  .  .  .  .  1: *syntax.Field {
  8004  .  .  .  .  .  .  Name: name
  8005  .  .  .  .  .  .  Type: *syntax.Operation {
  8006  .  .  .  .  .  .  .  Op: *
  8007  .  .  .  .  .  .  .  X: Name
  8008  .  .  .  .  .  .  .  Y: nil
  8009  .  .  .  .  .  .  }
  8010  .  .  .  .  .  }
  8011  .  .  .  .  .  2: *syntax.Field {
  8012  .  .  .  .  .  .  Name: typ
  8013  .  .  .  .  .  .  Type: Expr
  8014  .  .  .  .  .  }
  8015  .  .  .  .  .  3: *syntax.Field {
  8016  .  .  .  .  .  .  Name: tag
  8017  .  .  .  .  .  .  Type: *syntax.Operation {
  8018  .  .  .  .  .  .  .  Op: *
  8019  .  .  .  .  .  .  .  X: BasicLit
  8020  .  .  .  .  .  .  .  Y: nil
  8021  .  .  .  .  .  .  }
  8022  .  .  .  .  .  }
  8023  .  .  .  .  }
  8024  .  .  .  .  ResultList: nil
  8025  .  .  .  }
  8026  .  .  .  Body: []syntax.Stmt (8 entries) {
  8027  .  .  .  .  0: *syntax.IfStmt {
  8028  .  .  .  .  .  Init: nil
  8029  .  .  .  .  .  Cond: *syntax.Operation {
  8030  .  .  .  .  .  .  Op: !=
  8031  .  .  .  .  .  .  X: tag
  8032  .  .  .  .  .  .  Y: nil
  8033  .  .  .  .  .  }
  8034  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
  8035  .  .  .  .  .  .  0: *syntax.ForStmt {
  8036  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
  8037  .  .  .  .  .  .  .  .  Op: :
  8038  .  .  .  .  .  .  .  .  Lhs: i
  8039  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
  8040  .  .  .  .  .  .  .  .  .  Op: -
  8041  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8042  .  .  .  .  .  .  .  .  .  .  Fun: len
  8043  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8044  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  8045  .  .  .  .  .  .  .  .  .  .  .  .  X: styp
  8046  .  .  .  .  .  .  .  .  .  .  .  .  Sel: FieldList
  8047  .  .  .  .  .  .  .  .  .  .  .  }
  8048  .  .  .  .  .  .  .  .  .  .  }
  8049  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8050  .  .  .  .  .  .  .  .  .  }
  8051  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
  8052  .  .  .  .  .  .  .  .  .  .  Fun: len
  8053  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8054  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  8055  .  .  .  .  .  .  .  .  .  .  .  .  X: styp
  8056  .  .  .  .  .  .  .  .  .  .  .  .  Sel: TagList
  8057  .  .  .  .  .  .  .  .  .  .  .  }
  8058  .  .  .  .  .  .  .  .  .  .  }
  8059  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8060  .  .  .  .  .  .  .  .  .  }
  8061  .  .  .  .  .  .  .  .  }
  8062  .  .  .  .  .  .  .  }
  8063  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  8064  .  .  .  .  .  .  .  .  Op: >
  8065  .  .  .  .  .  .  .  .  X: i
  8066  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  8067  .  .  .  .  .  .  .  .  .  Value: "0"
  8068  .  .  .  .  .  .  .  .  .  Kind: 0
  8069  .  .  .  .  .  .  .  .  }
  8070  .  .  .  .  .  .  .  }
  8071  .  .  .  .  .  .  .  Post: *syntax.AssignStmt {
  8072  .  .  .  .  .  .  .  .  Op: -
  8073  .  .  .  .  .  .  .  .  Lhs: i
  8074  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  8075  .  .  .  .  .  .  .  }
  8076  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  8077  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  8078  .  .  .  .  .  .  .  .  .  Op: <op-0>
  8079  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8080  .  .  .  .  .  .  .  .  .  .  X: styp
  8081  .  .  .  .  .  .  .  .  .  .  Sel: TagList
  8082  .  .  .  .  .  .  .  .  .  }
  8083  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8084  .  .  .  .  .  .  .  .  .  .  Fun: append
  8085  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  8086  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  8087  .  .  .  .  .  .  .  .  .  .  .  .  X: styp
  8088  .  .  .  .  .  .  .  .  .  .  .  .  Sel: TagList
  8089  .  .  .  .  .  .  .  .  .  .  .  }
  8090  .  .  .  .  .  .  .  .  .  .  .  1: nil
  8091  .  .  .  .  .  .  .  .  .  .  }
  8092  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8093  .  .  .  .  .  .  .  .  .  }
  8094  .  .  .  .  .  .  .  .  }
  8095  .  .  .  .  .  .  .  }
  8096  .  .  .  .  .  .  }
  8097  .  .  .  .  .  .  1: *syntax.AssignStmt {
  8098  .  .  .  .  .  .  .  Op: <op-0>
  8099  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8100  .  .  .  .  .  .  .  .  X: styp
  8101  .  .  .  .  .  .  .  .  Sel: TagList
  8102  .  .  .  .  .  .  .  }
  8103  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8104  .  .  .  .  .  .  .  .  Fun: append
  8105  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  8106  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  8107  .  .  .  .  .  .  .  .  .  .  X: styp
  8108  .  .  .  .  .  .  .  .  .  .  Sel: TagList
  8109  .  .  .  .  .  .  .  .  .  }
  8110  .  .  .  .  .  .  .  .  .  1: tag
  8111  .  .  .  .  .  .  .  .  }
  8112  .  .  .  .  .  .  .  .  HasDots: false
  8113  .  .  .  .  .  .  .  }
  8114  .  .  .  .  .  .  }
  8115  .  .  .  .  .  }
  8116  .  .  .  .  .  Else: nil
  8117  .  .  .  .  }
  8118  .  .  .  .  1: *syntax.AssignStmt {
  8119  .  .  .  .  .  Op: :
  8120  .  .  .  .  .  Lhs: f
  8121  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8122  .  .  .  .  .  .  Fun: new
  8123  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8124  .  .  .  .  .  .  .  0: Field
  8125  .  .  .  .  .  .  }
  8126  .  .  .  .  .  .  HasDots: false
  8127  .  .  .  .  .  }
  8128  .  .  .  .  }
  8129  .  .  .  .  2: *syntax.ExprStmt {
  8130  .  .  .  .  .  X: *syntax.CallExpr {
  8131  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8132  .  .  .  .  .  .  .  X: f
  8133  .  .  .  .  .  .  .  Sel: init
  8134  .  .  .  .  .  .  }
  8135  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8136  .  .  .  .  .  .  .  0: p
  8137  .  .  .  .  .  .  }
  8138  .  .  .  .  .  .  HasDots: false
  8139  .  .  .  .  .  }
  8140  .  .  .  .  }
  8141  .  .  .  .  3: *syntax.AssignStmt {
  8142  .  .  .  .  .  Op: <op-0>
  8143  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8144  .  .  .  .  .  .  X: f
  8145  .  .  .  .  .  .  Sel: Name
  8146  .  .  .  .  .  }
  8147  .  .  .  .  .  Rhs: name
  8148  .  .  .  .  }
  8149  .  .  .  .  4: *syntax.AssignStmt {
  8150  .  .  .  .  .  Op: <op-0>
  8151  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8152  .  .  .  .  .  .  X: f
  8153  .  .  .  .  .  .  Sel: Type
  8154  .  .  .  .  .  }
  8155  .  .  .  .  .  Rhs: typ
  8156  .  .  .  .  }
  8157  .  .  .  .  5: *syntax.AssignStmt {
  8158  .  .  .  .  .  Op: <op-0>
  8159  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8160  .  .  .  .  .  .  X: styp
  8161  .  .  .  .  .  .  Sel: FieldList
  8162  .  .  .  .  .  }
  8163  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8164  .  .  .  .  .  .  Fun: append
  8165  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  8166  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  8167  .  .  .  .  .  .  .  .  X: styp
  8168  .  .  .  .  .  .  .  .  Sel: FieldList
  8169  .  .  .  .  .  .  .  }
  8170  .  .  .  .  .  .  .  1: f
  8171  .  .  .  .  .  .  }
  8172  .  .  .  .  .  .  HasDots: false
  8173  .  .  .  .  .  }
  8174  .  .  .  .  }
  8175  .  .  .  .  6: *syntax.IfStmt {
  8176  .  .  .  .  .  Init: nil
  8177  .  .  .  .  .  Cond: *syntax.Operation {
  8178  .  .  .  .  .  .  Op: &&
  8179  .  .  .  .  .  .  X: gcCompat
  8180  .  .  .  .  .  .  Y: *syntax.Operation {
  8181  .  .  .  .  .  .  .  Op: !=
  8182  .  .  .  .  .  .  .  X: name
  8183  .  .  .  .  .  .  .  Y: nil
  8184  .  .  .  .  .  .  }
  8185  .  .  .  .  .  }
  8186  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  8187  .  .  .  .  .  .  0: *syntax.AssignStmt {
  8188  .  .  .  .  .  .  .  Op: <op-0>
  8189  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8190  .  .  .  .  .  .  .  .  X: f
  8191  .  .  .  .  .  .  .  .  Sel: node
  8192  .  .  .  .  .  .  .  }
  8193  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  8194  .  .  .  .  .  .  .  .  X: name
  8195  .  .  .  .  .  .  .  .  Sel: node
  8196  .  .  .  .  .  .  .  }
  8197  .  .  .  .  .  .  }
  8198  .  .  .  .  .  }
  8199  .  .  .  .  .  Else: nil
  8200  .  .  .  .  }
  8201  .  .  .  .  7: *syntax.IfStmt {
  8202  .  .  .  .  .  Init: nil
  8203  .  .  .  .  .  Cond: *syntax.Operation {
  8204  .  .  .  .  .  .  Op: &&
  8205  .  .  .  .  .  .  X: *syntax.Operation {
  8206  .  .  .  .  .  .  .  Op: &&
  8207  .  .  .  .  .  .  .  X: debug
  8208  .  .  .  .  .  .  .  Y: *syntax.Operation {
  8209  .  .  .  .  .  .  .  .  Op: !=
  8210  .  .  .  .  .  .  .  .  X: tag
  8211  .  .  .  .  .  .  .  .  Y: nil
  8212  .  .  .  .  .  .  .  }
  8213  .  .  .  .  .  .  }
  8214  .  .  .  .  .  .  Y: *syntax.Operation {
  8215  .  .  .  .  .  .  .  Op: !=
  8216  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8217  .  .  .  .  .  .  .  .  Fun: len
  8218  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8219  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  8220  .  .  .  .  .  .  .  .  .  .  X: styp
  8221  .  .  .  .  .  .  .  .  .  .  Sel: FieldList
  8222  .  .  .  .  .  .  .  .  .  }
  8223  .  .  .  .  .  .  .  .  }
  8224  .  .  .  .  .  .  .  .  HasDots: false
  8225  .  .  .  .  .  .  .  }
  8226  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
  8227  .  .  .  .  .  .  .  .  Fun: len
  8228  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8229  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  8230  .  .  .  .  .  .  .  .  .  .  X: styp
  8231  .  .  .  .  .  .  .  .  .  .  Sel: TagList
  8232  .  .  .  .  .  .  .  .  .  }
  8233  .  .  .  .  .  .  .  .  }
  8234  .  .  .  .  .  .  .  .  HasDots: false
  8235  .  .  .  .  .  .  .  }
  8236  .  .  .  .  .  .  }
  8237  .  .  .  .  .  }
  8238  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  8239  .  .  .  .  .  .  0: *syntax.ExprStmt {
  8240  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8241  .  .  .  .  .  .  .  .  Fun: panic
  8242  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8243  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  8244  .  .  .  .  .  .  .  .  .  .  Value: "\"inconsistent struct field list\""
  8245  .  .  .  .  .  .  .  .  .  .  Kind: 4
  8246  .  .  .  .  .  .  .  .  .  }
  8247  .  .  .  .  .  .  .  .  }
  8248  .  .  .  .  .  .  .  .  HasDots: false
  8249  .  .  .  .  .  .  .  }
  8250  .  .  .  .  .  .  }
  8251  .  .  .  .  .  }
  8252  .  .  .  .  .  Else: nil
  8253  .  .  .  .  }
  8254  .  .  .  }
  8255  .  .  .  Pragma: 0
  8256  .  .  .  EndLine: 1160
  8257  .  .  }
  8258  .  .  43: *syntax.FuncDecl {
  8259  .  .  .  Attr: map[]
  8260  .  .  .  Recv: *syntax.Field {
  8261  .  .  .  .  Name: p
  8262  .  .  .  .  Type: *syntax.Operation {
  8263  .  .  .  .  .  Op: *
  8264  .  .  .  .  .  X: parser
  8265  .  .  .  .  .  Y: nil
  8266  .  .  .  .  }
  8267  .  .  .  }
  8268  .  .  .  Name: fieldDecl
  8269  .  .  .  Type: *syntax.FuncType {
  8270  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  8271  .  .  .  .  .  0: *syntax.Field {
  8272  .  .  .  .  .  .  Name: styp
  8273  .  .  .  .  .  .  Type: *syntax.Operation {
  8274  .  .  .  .  .  .  .  Op: *
  8275  .  .  .  .  .  .  .  X: StructType
  8276  .  .  .  .  .  .  .  Y: nil
  8277  .  .  .  .  .  .  }
  8278  .  .  .  .  .  }
  8279  .  .  .  .  }
  8280  .  .  .  .  ResultList: nil
  8281  .  .  .  }
  8282  .  .  .  Body: []syntax.Stmt (3 entries) {
  8283  .  .  .  .  0: *syntax.IfStmt {
  8284  .  .  .  .  .  Init: nil
  8285  .  .  .  .  .  Cond: trace
  8286  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  8287  .  .  .  .  .  .  0: *syntax.CallStmt {
  8288  .  .  .  .  .  .  .  Tok: defer
  8289  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  8290  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  8291  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8292  .  .  .  .  .  .  .  .  .  .  X: p
  8293  .  .  .  .  .  .  .  .  .  .  Sel: trace
  8294  .  .  .  .  .  .  .  .  .  }
  8295  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8296  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  8297  .  .  .  .  .  .  .  .  .  .  .  Value: "\"fieldDecl\""
  8298  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  8299  .  .  .  .  .  .  .  .  .  .  }
  8300  .  .  .  .  .  .  .  .  .  }
  8301  .  .  .  .  .  .  .  .  .  HasDots: false
  8302  .  .  .  .  .  .  .  .  }
  8303  .  .  .  .  .  .  .  .  ArgList: nil
  8304  .  .  .  .  .  .  .  .  HasDots: false
  8305  .  .  .  .  .  .  .  }
  8306  .  .  .  .  .  .  }
  8307  .  .  .  .  .  }
  8308  .  .  .  .  .  Else: nil
  8309  .  .  .  .  }
  8310  .  .  .  .  1: *syntax.DeclStmt {
  8311  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
  8312  .  .  .  .  .  .  0: *syntax.VarDecl {
  8313  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
  8314  .  .  .  .  .  .  .  .  0: name
  8315  .  .  .  .  .  .  .  }
  8316  .  .  .  .  .  .  .  Type: *syntax.Operation {
  8317  .  .  .  .  .  .  .  .  Op: *
  8318  .  .  .  .  .  .  .  .  X: Name
  8319  .  .  .  .  .  .  .  .  Y: nil
  8320  .  .  .  .  .  .  .  }
  8321  .  .  .  .  .  .  .  Values: nil
  8322  .  .  .  .  .  .  .  Group: nil
  8323  .  .  .  .  .  .  }
  8324  .  .  .  .  .  }
  8325  .  .  .  .  }
  8326  .  .  .  .  2: *syntax.SwitchStmt {
  8327  .  .  .  .  .  Init: nil
  8328  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  8329  .  .  .  .  .  .  X: p
  8330  .  .  .  .  .  .  Sel: tok
  8331  .  .  .  .  .  }
  8332  .  .  .  .  .  Body: []*syntax.CaseClause (4 entries) {
  8333  .  .  .  .  .  .  0: *syntax.CaseClause {
  8334  .  .  .  .  .  .  .  Cases: _Name
  8335  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
  8336  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  8337  .  .  .  .  .  .  .  .  .  Op: <op-0>
  8338  .  .  .  .  .  .  .  .  .  Lhs: name
  8339  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8340  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8341  .  .  .  .  .  .  .  .  .  .  .  X: p
  8342  .  .  .  .  .  .  .  .  .  .  .  Sel: name
  8343  .  .  .  .  .  .  .  .  .  .  }
  8344  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8345  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8346  .  .  .  .  .  .  .  .  .  }
  8347  .  .  .  .  .  .  .  .  }
  8348  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  8349  .  .  .  .  .  .  .  .  .  Init: nil
  8350  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  8351  .  .  .  .  .  .  .  .  .  .  Op: ||
  8352  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  8353  .  .  .  .  .  .  .  .  .  .  .  Op: ||
  8354  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  8355  .  .  .  .  .  .  .  .  .  .  .  .  Op: ||
  8356  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  8357  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  8358  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  8359  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8360  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  8361  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8362  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Dot
  8363  .  .  .  .  .  .  .  .  .  .  .  .  }
  8364  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  8365  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  8366  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  8367  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8368  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  8369  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8370  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Literal
  8371  .  .  .  .  .  .  .  .  .  .  .  .  }
  8372  .  .  .  .  .  .  .  .  .  .  .  }
  8373  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  8374  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  8375  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  8376  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8377  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  8378  .  .  .  .  .  .  .  .  .  .  .  .  }
  8379  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Semi
  8380  .  .  .  .  .  .  .  .  .  .  .  }
  8381  .  .  .  .  .  .  .  .  .  .  }
  8382  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  8383  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  8384  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  8385  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8386  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  8387  .  .  .  .  .  .  .  .  .  .  .  }
  8388  .  .  .  .  .  .  .  .  .  .  .  Y: _Rbrace
  8389  .  .  .  .  .  .  .  .  .  .  }
  8390  .  .  .  .  .  .  .  .  .  }
  8391  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (4 entries) {
  8392  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  8393  .  .  .  .  .  .  .  .  .  .  .  Op: :
  8394  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ
  8395  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8396  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8397  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8398  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName
  8399  .  .  .  .  .  .  .  .  .  .  .  .  }
  8400  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8401  .  .  .  .  .  .  .  .  .  .  .  .  .  0: name
  8402  .  .  .  .  .  .  .  .  .  .  .  .  }
  8403  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8404  .  .  .  .  .  .  .  .  .  .  .  }
  8405  .  .  .  .  .  .  .  .  .  .  }
  8406  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  8407  .  .  .  .  .  .  .  .  .  .  .  Op: :
  8408  .  .  .  .  .  .  .  .  .  .  .  Lhs: tag
  8409  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8410  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8411  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8412  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral
  8413  .  .  .  .  .  .  .  .  .  .  .  .  }
  8414  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8415  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8416  .  .  .  .  .  .  .  .  .  .  .  }
  8417  .  .  .  .  .  .  .  .  .  .  }
  8418  .  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  8419  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8420  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8421  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8422  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: addField
  8423  .  .  .  .  .  .  .  .  .  .  .  .  }
  8424  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
  8425  .  .  .  .  .  .  .  .  .  .  .  .  .  0: styp
  8426  .  .  .  .  .  .  .  .  .  .  .  .  .  1: nil
  8427  .  .  .  .  .  .  .  .  .  .  .  .  .  2: typ
  8428  .  .  .  .  .  .  .  .  .  .  .  .  .  3: tag
  8429  .  .  .  .  .  .  .  .  .  .  .  .  }
  8430  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8431  .  .  .  .  .  .  .  .  .  .  .  }
  8432  .  .  .  .  .  .  .  .  .  .  }
  8433  .  .  .  .  .  .  .  .  .  .  3: *syntax.ReturnStmt {
  8434  .  .  .  .  .  .  .  .  .  .  .  Results: nil
  8435  .  .  .  .  .  .  .  .  .  .  }
  8436  .  .  .  .  .  .  .  .  .  }
  8437  .  .  .  .  .  .  .  .  .  Else: nil
  8438  .  .  .  .  .  .  .  .  }
  8439  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  8440  .  .  .  .  .  .  .  .  .  Op: :
  8441  .  .  .  .  .  .  .  .  .  Lhs: names
  8442  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8443  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8444  .  .  .  .  .  .  .  .  .  .  .  X: p
  8445  .  .  .  .  .  .  .  .  .  .  .  Sel: nameList
  8446  .  .  .  .  .  .  .  .  .  .  }
  8447  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8448  .  .  .  .  .  .  .  .  .  .  .  0: name
  8449  .  .  .  .  .  .  .  .  .  .  }
  8450  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8451  .  .  .  .  .  .  .  .  .  }
  8452  .  .  .  .  .  .  .  .  }
  8453  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  8454  .  .  .  .  .  .  .  .  .  Op: :
  8455  .  .  .  .  .  .  .  .  .  Lhs: typ
  8456  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8457  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8458  .  .  .  .  .  .  .  .  .  .  .  X: p
  8459  .  .  .  .  .  .  .  .  .  .  .  Sel: type_
  8460  .  .  .  .  .  .  .  .  .  .  }
  8461  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8462  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8463  .  .  .  .  .  .  .  .  .  }
  8464  .  .  .  .  .  .  .  .  }
  8465  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  8466  .  .  .  .  .  .  .  .  .  Op: :
  8467  .  .  .  .  .  .  .  .  .  Lhs: tag
  8468  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8469  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8470  .  .  .  .  .  .  .  .  .  .  .  X: p
  8471  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral
  8472  .  .  .  .  .  .  .  .  .  .  }
  8473  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8474  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8475  .  .  .  .  .  .  .  .  .  }
  8476  .  .  .  .  .  .  .  .  }
  8477  .  .  .  .  .  .  .  .  5: *syntax.ForStmt {
  8478  .  .  .  .  .  .  .  .  .  Init: *syntax.RangeClause {
  8479  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
  8480  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  8481  .  .  .  .  .  .  .  .  .  .  .  .  0: _
  8482  .  .  .  .  .  .  .  .  .  .  .  .  1: name
  8483  .  .  .  .  .  .  .  .  .  .  .  }
  8484  .  .  .  .  .  .  .  .  .  .  }
  8485  .  .  .  .  .  .  .  .  .  .  Def: true
  8486  .  .  .  .  .  .  .  .  .  .  X: names
  8487  .  .  .  .  .  .  .  .  .  }
  8488  .  .  .  .  .  .  .  .  .  Cond: nil
  8489  .  .  .  .  .  .  .  .  .  Post: nil
  8490  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  8491  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  8492  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8493  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8494  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8495  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: addField
  8496  .  .  .  .  .  .  .  .  .  .  .  .  }
  8497  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
  8498  .  .  .  .  .  .  .  .  .  .  .  .  .  0: styp
  8499  .  .  .  .  .  .  .  .  .  .  .  .  .  1: name
  8500  .  .  .  .  .  .  .  .  .  .  .  .  .  2: typ
  8501  .  .  .  .  .  .  .  .  .  .  .  .  .  3: tag
  8502  .  .  .  .  .  .  .  .  .  .  .  .  }
  8503  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8504  .  .  .  .  .  .  .  .  .  .  .  }
  8505  .  .  .  .  .  .  .  .  .  .  }
  8506  .  .  .  .  .  .  .  .  .  }
  8507  .  .  .  .  .  .  .  .  }
  8508  .  .  .  .  .  .  .  }
  8509  .  .  .  .  .  .  }
  8510  .  .  .  .  .  .  1: *syntax.CaseClause {
  8511  .  .  .  .  .  .  .  Cases: _Lparen
  8512  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  8513  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  8514  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8515  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8516  .  .  .  .  .  .  .  .  .  .  .  X: p
  8517  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  8518  .  .  .  .  .  .  .  .  .  .  }
  8519  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8520  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8521  .  .  .  .  .  .  .  .  .  }
  8522  .  .  .  .  .  .  .  .  }
  8523  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  8524  .  .  .  .  .  .  .  .  .  Init: nil
  8525  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  8526  .  .  .  .  .  .  .  .  .  .  Op: ==
  8527  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  8528  .  .  .  .  .  .  .  .  .  .  .  X: p
  8529  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  8530  .  .  .  .  .  .  .  .  .  .  }
  8531  .  .  .  .  .  .  .  .  .  .  Y: _Star
  8532  .  .  .  .  .  .  .  .  .  }
  8533  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (6 entries) {
  8534  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  8535  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8536  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8537  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8538  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  8539  .  .  .  .  .  .  .  .  .  .  .  .  }
  8540  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8541  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8542  .  .  .  .  .  .  .  .  .  .  .  }
  8543  .  .  .  .  .  .  .  .  .  .  }
  8544  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  8545  .  .  .  .  .  .  .  .  .  .  .  Op: :
  8546  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ
  8547  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8548  .  .  .  .  .  .  .  .  .  .  .  .  Fun: indirect
  8549  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8550  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  8551  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8552  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8553  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName
  8554  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8555  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8556  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil
  8557  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8558  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8559  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8560  .  .  .  .  .  .  .  .  .  .  .  .  }
  8561  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8562  .  .  .  .  .  .  .  .  .  .  .  }
  8563  .  .  .  .  .  .  .  .  .  .  }
  8564  .  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  8565  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8566  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8567  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8568  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  8569  .  .  .  .  .  .  .  .  .  .  .  .  }
  8570  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8571  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen
  8572  .  .  .  .  .  .  .  .  .  .  .  .  }
  8573  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8574  .  .  .  .  .  .  .  .  .  .  .  }
  8575  .  .  .  .  .  .  .  .  .  .  }
  8576  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  8577  .  .  .  .  .  .  .  .  .  .  .  Op: :
  8578  .  .  .  .  .  .  .  .  .  .  .  Lhs: tag
  8579  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8580  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8581  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8582  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral
  8583  .  .  .  .  .  .  .  .  .  .  .  .  }
  8584  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8585  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8586  .  .  .  .  .  .  .  .  .  .  .  }
  8587  .  .  .  .  .  .  .  .  .  .  }
  8588  .  .  .  .  .  .  .  .  .  .  4: *syntax.ExprStmt {
  8589  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8590  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8591  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8592  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: addField
  8593  .  .  .  .  .  .  .  .  .  .  .  .  }
  8594  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
  8595  .  .  .  .  .  .  .  .  .  .  .  .  .  0: styp
  8596  .  .  .  .  .  .  .  .  .  .  .  .  .  1: nil
  8597  .  .  .  .  .  .  .  .  .  .  .  .  .  2: typ
  8598  .  .  .  .  .  .  .  .  .  .  .  .  .  3: tag
  8599  .  .  .  .  .  .  .  .  .  .  .  .  }
  8600  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8601  .  .  .  .  .  .  .  .  .  .  .  }
  8602  .  .  .  .  .  .  .  .  .  .  }
  8603  .  .  .  .  .  .  .  .  .  .  5: *syntax.ExprStmt {
  8604  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8605  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8606  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8607  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error
  8608  .  .  .  .  .  .  .  .  .  .  .  .  }
  8609  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8610  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  8611  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"cannot parenthesize embedded type\""
  8612  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  8613  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8614  .  .  .  .  .  .  .  .  .  .  .  .  }
  8615  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8616  .  .  .  .  .  .  .  .  .  .  .  }
  8617  .  .  .  .  .  .  .  .  .  .  }
  8618  .  .  .  .  .  .  .  .  .  }
  8619  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
  8620  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (5 entries) {
  8621  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  8622  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  8623  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ
  8624  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8625  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8626  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8627  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName
  8628  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8629  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8630  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil
  8631  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8632  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8633  .  .  .  .  .  .  .  .  .  .  .  .  }
  8634  .  .  .  .  .  .  .  .  .  .  .  }
  8635  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  8636  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8637  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8638  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8639  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  8640  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8641  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8642  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen
  8643  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8644  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8645  .  .  .  .  .  .  .  .  .  .  .  .  }
  8646  .  .  .  .  .  .  .  .  .  .  .  }
  8647  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  8648  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  8649  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: tag
  8650  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8651  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8652  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8653  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral
  8654  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8655  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8656  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8657  .  .  .  .  .  .  .  .  .  .  .  .  }
  8658  .  .  .  .  .  .  .  .  .  .  .  }
  8659  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
  8660  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8661  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8662  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8663  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: addField
  8664  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8665  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
  8666  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: styp
  8667  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: nil
  8668  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: typ
  8669  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: tag
  8670  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8671  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8672  .  .  .  .  .  .  .  .  .  .  .  .  }
  8673  .  .  .  .  .  .  .  .  .  .  .  }
  8674  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.ExprStmt {
  8675  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8676  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8677  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8678  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error
  8679  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8680  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8681  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  8682  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"cannot parenthesize embedded type\""
  8683  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  8684  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8685  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8686  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8687  .  .  .  .  .  .  .  .  .  .  .  .  }
  8688  .  .  .  .  .  .  .  .  .  .  .  }
  8689  .  .  .  .  .  .  .  .  .  .  }
  8690  .  .  .  .  .  .  .  .  .  }
  8691  .  .  .  .  .  .  .  .  }
  8692  .  .  .  .  .  .  .  }
  8693  .  .  .  .  .  .  }
  8694  .  .  .  .  .  .  2: *syntax.CaseClause {
  8695  .  .  .  .  .  .  .  Cases: _Star
  8696  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  8697  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  8698  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8699  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8700  .  .  .  .  .  .  .  .  .  .  .  X: p
  8701  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  8702  .  .  .  .  .  .  .  .  .  .  }
  8703  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8704  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8705  .  .  .  .  .  .  .  .  .  }
  8706  .  .  .  .  .  .  .  .  }
  8707  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  8708  .  .  .  .  .  .  .  .  .  Init: nil
  8709  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  8710  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8711  .  .  .  .  .  .  .  .  .  .  .  X: p
  8712  .  .  .  .  .  .  .  .  .  .  .  Sel: got
  8713  .  .  .  .  .  .  .  .  .  .  }
  8714  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8715  .  .  .  .  .  .  .  .  .  .  .  0: _Lparen
  8716  .  .  .  .  .  .  .  .  .  .  }
  8717  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8718  .  .  .  .  .  .  .  .  .  }
  8719  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (5 entries) {
  8720  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  8721  .  .  .  .  .  .  .  .  .  .  .  Op: :
  8722  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ
  8723  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8724  .  .  .  .  .  .  .  .  .  .  .  .  Fun: indirect
  8725  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8726  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  8727  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8728  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8729  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName
  8730  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8731  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8732  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil
  8733  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8734  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8735  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8736  .  .  .  .  .  .  .  .  .  .  .  .  }
  8737  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8738  .  .  .  .  .  .  .  .  .  .  .  }
  8739  .  .  .  .  .  .  .  .  .  .  }
  8740  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  8741  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8742  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8743  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8744  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  8745  .  .  .  .  .  .  .  .  .  .  .  .  }
  8746  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8747  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen
  8748  .  .  .  .  .  .  .  .  .  .  .  .  }
  8749  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8750  .  .  .  .  .  .  .  .  .  .  .  }
  8751  .  .  .  .  .  .  .  .  .  .  }
  8752  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  8753  .  .  .  .  .  .  .  .  .  .  .  Op: :
  8754  .  .  .  .  .  .  .  .  .  .  .  Lhs: tag
  8755  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8756  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8757  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8758  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral
  8759  .  .  .  .  .  .  .  .  .  .  .  .  }
  8760  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8761  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8762  .  .  .  .  .  .  .  .  .  .  .  }
  8763  .  .  .  .  .  .  .  .  .  .  }
  8764  .  .  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
  8765  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8766  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8767  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8768  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: addField
  8769  .  .  .  .  .  .  .  .  .  .  .  .  }
  8770  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
  8771  .  .  .  .  .  .  .  .  .  .  .  .  .  0: styp
  8772  .  .  .  .  .  .  .  .  .  .  .  .  .  1: nil
  8773  .  .  .  .  .  .  .  .  .  .  .  .  .  2: typ
  8774  .  .  .  .  .  .  .  .  .  .  .  .  .  3: tag
  8775  .  .  .  .  .  .  .  .  .  .  .  .  }
  8776  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8777  .  .  .  .  .  .  .  .  .  .  .  }
  8778  .  .  .  .  .  .  .  .  .  .  }
  8779  .  .  .  .  .  .  .  .  .  .  4: *syntax.ExprStmt {
  8780  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8781  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8782  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8783  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error
  8784  .  .  .  .  .  .  .  .  .  .  .  .  }
  8785  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8786  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  8787  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"cannot parenthesize embedded type\""
  8788  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  8789  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8790  .  .  .  .  .  .  .  .  .  .  .  .  }
  8791  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8792  .  .  .  .  .  .  .  .  .  .  .  }
  8793  .  .  .  .  .  .  .  .  .  .  }
  8794  .  .  .  .  .  .  .  .  .  }
  8795  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
  8796  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
  8797  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  8798  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  8799  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ
  8800  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8801  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: indirect
  8802  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8803  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  8804  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8805  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8806  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName
  8807  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8808  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8809  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil
  8810  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8811  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8812  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8813  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8814  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8815  .  .  .  .  .  .  .  .  .  .  .  .  }
  8816  .  .  .  .  .  .  .  .  .  .  .  }
  8817  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  8818  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  8819  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: tag
  8820  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8821  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8822  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8823  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral
  8824  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8825  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8826  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8827  .  .  .  .  .  .  .  .  .  .  .  .  }
  8828  .  .  .  .  .  .  .  .  .  .  .  }
  8829  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  8830  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8831  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8832  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  8833  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: addField
  8834  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8835  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
  8836  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: styp
  8837  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: nil
  8838  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: typ
  8839  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: tag
  8840  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8841  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8842  .  .  .  .  .  .  .  .  .  .  .  .  }
  8843  .  .  .  .  .  .  .  .  .  .  .  }
  8844  .  .  .  .  .  .  .  .  .  .  }
  8845  .  .  .  .  .  .  .  .  .  }
  8846  .  .  .  .  .  .  .  .  }
  8847  .  .  .  .  .  .  .  }
  8848  .  .  .  .  .  .  }
  8849  .  .  .  .  .  .  3: *syntax.CaseClause {
  8850  .  .  .  .  .  .  .  Cases: nil
  8851  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  8852  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  8853  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8854  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8855  .  .  .  .  .  .  .  .  .  .  .  X: p
  8856  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  8857  .  .  .  .  .  .  .  .  .  .  }
  8858  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8859  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  8860  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting field name or embedded type\""
  8861  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  8862  .  .  .  .  .  .  .  .  .  .  .  }
  8863  .  .  .  .  .  .  .  .  .  .  }
  8864  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8865  .  .  .  .  .  .  .  .  .  }
  8866  .  .  .  .  .  .  .  .  }
  8867  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  8868  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8869  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8870  .  .  .  .  .  .  .  .  .  .  .  X: p
  8871  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
  8872  .  .  .  .  .  .  .  .  .  .  }
  8873  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  8874  .  .  .  .  .  .  .  .  .  .  .  0: _Semi
  8875  .  .  .  .  .  .  .  .  .  .  .  1: _Rbrace
  8876  .  .  .  .  .  .  .  .  .  .  }
  8877  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8878  .  .  .  .  .  .  .  .  .  }
  8879  .  .  .  .  .  .  .  .  }
  8880  .  .  .  .  .  .  .  }
  8881  .  .  .  .  .  .  }
  8882  .  .  .  .  .  }
  8883  .  .  .  .  }
  8884  .  .  .  }
  8885  .  .  .  Pragma: 0
  8886  .  .  .  EndLine: 1232
  8887  .  .  }
  8888  .  .  44: *syntax.FuncDecl {
  8889  .  .  .  Attr: map[]
  8890  .  .  .  Recv: *syntax.Field {
  8891  .  .  .  .  Name: p
  8892  .  .  .  .  Type: *syntax.Operation {
  8893  .  .  .  .  .  Op: *
  8894  .  .  .  .  .  X: parser
  8895  .  .  .  .  .  Y: nil
  8896  .  .  .  .  }
  8897  .  .  .  }
  8898  .  .  .  Name: oliteral
  8899  .  .  .  Type: *syntax.FuncType {
  8900  .  .  .  .  ParamList: nil
  8901  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  8902  .  .  .  .  .  0: *syntax.Field {
  8903  .  .  .  .  .  .  Name: nil
  8904  .  .  .  .  .  .  Type: *syntax.Operation {
  8905  .  .  .  .  .  .  .  Op: *
  8906  .  .  .  .  .  .  .  X: BasicLit
  8907  .  .  .  .  .  .  .  Y: nil
  8908  .  .  .  .  .  .  }
  8909  .  .  .  .  .  }
  8910  .  .  .  .  }
  8911  .  .  .  }
  8912  .  .  .  Body: []syntax.Stmt (2 entries) {
  8913  .  .  .  .  0: *syntax.IfStmt {
  8914  .  .  .  .  .  Init: nil
  8915  .  .  .  .  .  Cond: *syntax.Operation {
  8916  .  .  .  .  .  .  Op: ==
  8917  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  8918  .  .  .  .  .  .  .  X: p
  8919  .  .  .  .  .  .  .  Sel: tok
  8920  .  .  .  .  .  .  }
  8921  .  .  .  .  .  .  Y: _Literal
  8922  .  .  .  .  .  }
  8923  .  .  .  .  .  Then: []syntax.Stmt (6 entries) {
  8924  .  .  .  .  .  .  0: *syntax.AssignStmt {
  8925  .  .  .  .  .  .  .  Op: :
  8926  .  .  .  .  .  .  .  Lhs: b
  8927  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8928  .  .  .  .  .  .  .  .  Fun: new
  8929  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8930  .  .  .  .  .  .  .  .  .  0: BasicLit
  8931  .  .  .  .  .  .  .  .  }
  8932  .  .  .  .  .  .  .  .  HasDots: false
  8933  .  .  .  .  .  .  .  }
  8934  .  .  .  .  .  .  }
  8935  .  .  .  .  .  .  1: *syntax.ExprStmt {
  8936  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8937  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8938  .  .  .  .  .  .  .  .  .  X: b
  8939  .  .  .  .  .  .  .  .  .  Sel: init
  8940  .  .  .  .  .  .  .  .  }
  8941  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8942  .  .  .  .  .  .  .  .  .  0: p
  8943  .  .  .  .  .  .  .  .  }
  8944  .  .  .  .  .  .  .  .  HasDots: false
  8945  .  .  .  .  .  .  .  }
  8946  .  .  .  .  .  .  }
  8947  .  .  .  .  .  .  2: *syntax.AssignStmt {
  8948  .  .  .  .  .  .  .  Op: <op-0>
  8949  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8950  .  .  .  .  .  .  .  .  X: b
  8951  .  .  .  .  .  .  .  .  Sel: Value
  8952  .  .  .  .  .  .  .  }
  8953  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  8954  .  .  .  .  .  .  .  .  X: p
  8955  .  .  .  .  .  .  .  .  Sel: lit
  8956  .  .  .  .  .  .  .  }
  8957  .  .  .  .  .  .  }
  8958  .  .  .  .  .  .  3: *syntax.AssignStmt {
  8959  .  .  .  .  .  .  .  Op: <op-0>
  8960  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8961  .  .  .  .  .  .  .  .  X: b
  8962  .  .  .  .  .  .  .  .  Sel: Kind
  8963  .  .  .  .  .  .  .  }
  8964  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  8965  .  .  .  .  .  .  .  .  X: p
  8966  .  .  .  .  .  .  .  .  Sel: kind
  8967  .  .  .  .  .  .  .  }
  8968  .  .  .  .  .  .  }
  8969  .  .  .  .  .  .  4: *syntax.ExprStmt {
  8970  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8971  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8972  .  .  .  .  .  .  .  .  .  X: p
  8973  .  .  .  .  .  .  .  .  .  Sel: next
  8974  .  .  .  .  .  .  .  .  }
  8975  .  .  .  .  .  .  .  .  ArgList: nil
  8976  .  .  .  .  .  .  .  .  HasDots: false
  8977  .  .  .  .  .  .  .  }
  8978  .  .  .  .  .  .  }
  8979  .  .  .  .  .  .  5: *syntax.ReturnStmt {
  8980  .  .  .  .  .  .  .  Results: b
  8981  .  .  .  .  .  .  }
  8982  .  .  .  .  .  }
  8983  .  .  .  .  .  Else: nil
  8984  .  .  .  .  }
  8985  .  .  .  .  1: *syntax.ReturnStmt {
  8986  .  .  .  .  .  Results: nil
  8987  .  .  .  .  }
  8988  .  .  .  }
  8989  .  .  .  Pragma: 0
  8990  .  .  .  EndLine: 1244
  8991  .  .  }
  8992  .  .  45: *syntax.FuncDecl {
  8993  .  .  .  Attr: map[]
  8994  .  .  .  Recv: *syntax.Field {
  8995  .  .  .  .  Name: p
  8996  .  .  .  .  Type: *syntax.Operation {
  8997  .  .  .  .  .  Op: *
  8998  .  .  .  .  .  X: parser
  8999  .  .  .  .  .  Y: nil
  9000  .  .  .  .  }
  9001  .  .  .  }
  9002  .  .  .  Name: methodDecl
  9003  .  .  .  Type: *syntax.FuncType {
  9004  .  .  .  .  ParamList: nil
  9005  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  9006  .  .  .  .  .  0: *syntax.Field {
  9007  .  .  .  .  .  .  Name: nil
  9008  .  .  .  .  .  .  Type: *syntax.Operation {
  9009  .  .  .  .  .  .  .  Op: *
  9010  .  .  .  .  .  .  .  X: Field
  9011  .  .  .  .  .  .  .  Y: nil
  9012  .  .  .  .  .  .  }
  9013  .  .  .  .  .  }
  9014  .  .  .  .  }
  9015  .  .  .  }
  9016  .  .  .  Body: []syntax.Stmt (2 entries) {
  9017  .  .  .  .  0: *syntax.IfStmt {
  9018  .  .  .  .  .  Init: nil
  9019  .  .  .  .  .  Cond: trace
  9020  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  9021  .  .  .  .  .  .  0: *syntax.CallStmt {
  9022  .  .  .  .  .  .  .  Tok: defer
  9023  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  9024  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  9025  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9026  .  .  .  .  .  .  .  .  .  .  X: p
  9027  .  .  .  .  .  .  .  .  .  .  Sel: trace
  9028  .  .  .  .  .  .  .  .  .  }
  9029  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9030  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9031  .  .  .  .  .  .  .  .  .  .  .  Value: "\"methodDecl\""
  9032  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9033  .  .  .  .  .  .  .  .  .  .  }
  9034  .  .  .  .  .  .  .  .  .  }
  9035  .  .  .  .  .  .  .  .  .  HasDots: false
  9036  .  .  .  .  .  .  .  .  }
  9037  .  .  .  .  .  .  .  .  ArgList: nil
  9038  .  .  .  .  .  .  .  .  HasDots: false
  9039  .  .  .  .  .  .  .  }
  9040  .  .  .  .  .  .  }
  9041  .  .  .  .  .  }
  9042  .  .  .  .  .  Else: nil
  9043  .  .  .  .  }
  9044  .  .  .  .  1: *syntax.SwitchStmt {
  9045  .  .  .  .  .  Init: nil
  9046  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  9047  .  .  .  .  .  .  X: p
  9048  .  .  .  .  .  .  Sel: tok
  9049  .  .  .  .  .  }
  9050  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
  9051  .  .  .  .  .  .  0: *syntax.CaseClause {
  9052  .  .  .  .  .  .  .  Cases: _Name
  9053  .  .  .  .  .  .  .  Body: []syntax.Stmt (10 entries) {
  9054  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9055  .  .  .  .  .  .  .  .  .  Op: :
  9056  .  .  .  .  .  .  .  .  .  Lhs: name
  9057  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9058  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9059  .  .  .  .  .  .  .  .  .  .  .  X: p
  9060  .  .  .  .  .  .  .  .  .  .  .  Sel: name
  9061  .  .  .  .  .  .  .  .  .  .  }
  9062  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9063  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9064  .  .  .  .  .  .  .  .  .  }
  9065  .  .  .  .  .  .  .  .  }
  9066  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  9067  .  .  .  .  .  .  .  .  .  Op: :
  9068  .  .  .  .  .  .  .  .  .  Lhs: hasNameList
  9069  .  .  .  .  .  .  .  .  .  Rhs: false
  9070  .  .  .  .  .  .  .  .  }
  9071  .  .  .  .  .  .  .  .  2: *syntax.ForStmt {
  9072  .  .  .  .  .  .  .  .  .  Init: nil
  9073  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  9074  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9075  .  .  .  .  .  .  .  .  .  .  .  X: p
  9076  .  .  .  .  .  .  .  .  .  .  .  Sel: got
  9077  .  .  .  .  .  .  .  .  .  .  }
  9078  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9079  .  .  .  .  .  .  .  .  .  .  .  0: _Comma
  9080  .  .  .  .  .  .  .  .  .  .  }
  9081  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9082  .  .  .  .  .  .  .  .  .  }
  9083  .  .  .  .  .  .  .  .  .  Post: nil
  9084  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  9085  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  9086  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9087  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9088  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  9089  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name
  9090  .  .  .  .  .  .  .  .  .  .  .  .  }
  9091  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9092  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9093  .  .  .  .  .  .  .  .  .  .  .  }
  9094  .  .  .  .  .  .  .  .  .  .  }
  9095  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  9096  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9097  .  .  .  .  .  .  .  .  .  .  .  Lhs: hasNameList
  9098  .  .  .  .  .  .  .  .  .  .  .  Rhs: true
  9099  .  .  .  .  .  .  .  .  .  .  }
  9100  .  .  .  .  .  .  .  .  .  }
  9101  .  .  .  .  .  .  .  .  }
  9102  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  9103  .  .  .  .  .  .  .  .  .  Init: nil
  9104  .  .  .  .  .  .  .  .  .  Cond: hasNameList
  9105  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  9106  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  9107  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9108  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9109  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  9110  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  9111  .  .  .  .  .  .  .  .  .  .  .  .  }
  9112  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9113  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9114  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"name list not allowed in interface type\""
  9115  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9116  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9117  .  .  .  .  .  .  .  .  .  .  .  .  }
  9118  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9119  .  .  .  .  .  .  .  .  .  .  .  }
  9120  .  .  .  .  .  .  .  .  .  .  }
  9121  .  .  .  .  .  .  .  .  .  }
  9122  .  .  .  .  .  .  .  .  .  Else: nil
  9123  .  .  .  .  .  .  .  .  }
  9124  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  9125  .  .  .  .  .  .  .  .  .  Op: :
  9126  .  .  .  .  .  .  .  .  .  Lhs: f
  9127  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9128  .  .  .  .  .  .  .  .  .  .  Fun: new
  9129  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9130  .  .  .  .  .  .  .  .  .  .  .  0: Field
  9131  .  .  .  .  .  .  .  .  .  .  }
  9132  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9133  .  .  .  .  .  .  .  .  .  }
  9134  .  .  .  .  .  .  .  .  }
  9135  .  .  .  .  .  .  .  .  5: *syntax.ExprStmt {
  9136  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9137  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9138  .  .  .  .  .  .  .  .  .  .  .  X: f
  9139  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  9140  .  .  .  .  .  .  .  .  .  .  }
  9141  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9142  .  .  .  .  .  .  .  .  .  .  .  0: p
  9143  .  .  .  .  .  .  .  .  .  .  }
  9144  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9145  .  .  .  .  .  .  .  .  .  }
  9146  .  .  .  .  .  .  .  .  }
  9147  .  .  .  .  .  .  .  .  6: *syntax.IfStmt {
  9148  .  .  .  .  .  .  .  .  .  Init: nil
  9149  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  9150  .  .  .  .  .  .  .  .  .  .  Op: !=
  9151  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9152  .  .  .  .  .  .  .  .  .  .  .  X: p
  9153  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
  9154  .  .  .  .  .  .  .  .  .  .  }
  9155  .  .  .  .  .  .  .  .  .  .  Y: _Lparen
  9156  .  .  .  .  .  .  .  .  .  }
  9157  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
  9158  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9159  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9160  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9161  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  9162  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
  9163  .  .  .  .  .  .  .  .  .  .  .  }
  9164  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9165  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9166  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  9167  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName
  9168  .  .  .  .  .  .  .  .  .  .  .  .  }
  9169  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9170  .  .  .  .  .  .  .  .  .  .  .  .  .  0: name
  9171  .  .  .  .  .  .  .  .  .  .  .  .  }
  9172  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9173  .  .  .  .  .  .  .  .  .  .  .  }
  9174  .  .  .  .  .  .  .  .  .  .  }
  9175  .  .  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
  9176  .  .  .  .  .  .  .  .  .  .  .  Results: f
  9177  .  .  .  .  .  .  .  .  .  .  }
  9178  .  .  .  .  .  .  .  .  .  }
  9179  .  .  .  .  .  .  .  .  .  Else: nil
  9180  .  .  .  .  .  .  .  .  }
  9181  .  .  .  .  .  .  .  .  7: *syntax.AssignStmt {
  9182  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9183  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9184  .  .  .  .  .  .  .  .  .  .  X: f
  9185  .  .  .  .  .  .  .  .  .  .  Sel: Name
  9186  .  .  .  .  .  .  .  .  .  }
  9187  .  .  .  .  .  .  .  .  .  Rhs: name
  9188  .  .  .  .  .  .  .  .  }
  9189  .  .  .  .  .  .  .  .  8: *syntax.AssignStmt {
  9190  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9191  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9192  .  .  .  .  .  .  .  .  .  .  X: f
  9193  .  .  .  .  .  .  .  .  .  .  Sel: Type
  9194  .  .  .  .  .  .  .  .  .  }
  9195  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9196  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9197  .  .  .  .  .  .  .  .  .  .  .  X: p
  9198  .  .  .  .  .  .  .  .  .  .  .  Sel: funcType
  9199  .  .  .  .  .  .  .  .  .  .  }
  9200  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9201  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9202  .  .  .  .  .  .  .  .  .  }
  9203  .  .  .  .  .  .  .  .  }
  9204  .  .  .  .  .  .  .  .  9: *syntax.ReturnStmt {
  9205  .  .  .  .  .  .  .  .  .  Results: f
  9206  .  .  .  .  .  .  .  .  }
  9207  .  .  .  .  .  .  .  }
  9208  .  .  .  .  .  .  }
  9209  .  .  .  .  .  .  1: *syntax.CaseClause {
  9210  .  .  .  .  .  .  .  Cases: _Lparen
  9211  .  .  .  .  .  .  .  Body: []syntax.Stmt (7 entries) {
  9212  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  9213  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9214  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9215  .  .  .  .  .  .  .  .  .  .  .  X: p
  9216  .  .  .  .  .  .  .  .  .  .  .  Sel: next
  9217  .  .  .  .  .  .  .  .  .  .  }
  9218  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9219  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9220  .  .  .  .  .  .  .  .  .  }
  9221  .  .  .  .  .  .  .  .  }
  9222  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  9223  .  .  .  .  .  .  .  .  .  Op: :
  9224  .  .  .  .  .  .  .  .  .  Lhs: f
  9225  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9226  .  .  .  .  .  .  .  .  .  .  Fun: new
  9227  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9228  .  .  .  .  .  .  .  .  .  .  .  0: Field
  9229  .  .  .  .  .  .  .  .  .  .  }
  9230  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9231  .  .  .  .  .  .  .  .  .  }
  9232  .  .  .  .  .  .  .  .  }
  9233  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  9234  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9235  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9236  .  .  .  .  .  .  .  .  .  .  .  X: f
  9237  .  .  .  .  .  .  .  .  .  .  .  Sel: init
  9238  .  .  .  .  .  .  .  .  .  .  }
  9239  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9240  .  .  .  .  .  .  .  .  .  .  .  0: p
  9241  .  .  .  .  .  .  .  .  .  .  }
  9242  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9243  .  .  .  .  .  .  .  .  .  }
  9244  .  .  .  .  .  .  .  .  }
  9245  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  9246  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9247  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9248  .  .  .  .  .  .  .  .  .  .  X: f
  9249  .  .  .  .  .  .  .  .  .  .  Sel: Type
  9250  .  .  .  .  .  .  .  .  .  }
  9251  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9252  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9253  .  .  .  .  .  .  .  .  .  .  .  X: p
  9254  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName
  9255  .  .  .  .  .  .  .  .  .  .  }
  9256  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9257  .  .  .  .  .  .  .  .  .  .  .  0: nil
  9258  .  .  .  .  .  .  .  .  .  .  }
  9259  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9260  .  .  .  .  .  .  .  .  .  }
  9261  .  .  .  .  .  .  .  .  }
  9262  .  .  .  .  .  .  .  .  4: *syntax.ExprStmt {
  9263  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9264  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9265  .  .  .  .  .  .  .  .  .  .  .  X: p
  9266  .  .  .  .  .  .  .  .  .  .  .  Sel: want
  9267  .  .  .  .  .  .  .  .  .  .  }
  9268  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9269  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen
  9270  .  .  .  .  .  .  .  .  .  .  }
  9271  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9272  .  .  .  .  .  .  .  .  .  }
  9273  .  .  .  .  .  .  .  .  }
  9274  .  .  .  .  .  .  .  .  5: *syntax.ExprStmt {
  9275  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9276  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9277  .  .  .  .  .  .  .  .  .  .  .  X: p
  9278  .  .  .  .  .  .  .  .  .  .  .  Sel: error
  9279  .  .  .  .  .  .  .  .  .  .  }
  9280  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9281  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9282  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"cannot parenthesize embedded type\""
  9283  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9284  .  .  .  .  .  .  .  .  .  .  .  }
  9285  .  .  .  .  .  .  .  .  .  .  }
  9286  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9287  .  .  .  .  .  .  .  .  .  }
  9288  .  .  .  .  .  .  .  .  }
  9289  .  .  .  .  .  .  .  .  6: *syntax.ReturnStmt {
  9290  .  .  .  .  .  .  .  .  .  Results: f
  9291  .  .  .  .  .  .  .  .  }
  9292  .  .  .  .  .  .  .  }
  9293  .  .  .  .  .  .  }
  9294  .  .  .  .  .  .  2: *syntax.CaseClause {
  9295  .  .  .  .  .  .  .  Cases: nil
  9296  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
  9297  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  9298  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9299  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9300  .  .  .  .  .  .  .  .  .  .  .  X: p
  9301  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  9302  .  .  .  .  .  .  .  .  .  .  }
  9303  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9304  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9305  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"\""
  9306  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9307  .  .  .  .  .  .  .  .  .  .  .  }
  9308  .  .  .  .  .  .  .  .  .  .  }
  9309  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9310  .  .  .  .  .  .  .  .  .  }
  9311  .  .  .  .  .  .  .  .  }
  9312  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  9313  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9314  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9315  .  .  .  .  .  .  .  .  .  .  .  X: p
  9316  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
  9317  .  .  .  .  .  .  .  .  .  .  }
  9318  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  9319  .  .  .  .  .  .  .  .  .  .  .  0: _Semi
  9320  .  .  .  .  .  .  .  .  .  .  .  1: _Rbrace
  9321  .  .  .  .  .  .  .  .  .  .  }
  9322  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9323  .  .  .  .  .  .  .  .  .  }
  9324  .  .  .  .  .  .  .  .  }
  9325  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
  9326  .  .  .  .  .  .  .  .  .  Results: nil
  9327  .  .  .  .  .  .  .  .  }
  9328  .  .  .  .  .  .  .  }
  9329  .  .  .  .  .  .  }
  9330  .  .  .  .  .  }
  9331  .  .  .  .  }
  9332  .  .  .  }
  9333  .  .  .  Pragma: 0
  9334  .  .  .  EndLine: 1295
  9335  .  .  }
  9336  .  .  46: *syntax.FuncDecl {
  9337  .  .  .  Attr: map[]
  9338  .  .  .  Recv: *syntax.Field {
  9339  .  .  .  .  Name: p
  9340  .  .  .  .  Type: *syntax.Operation {
  9341  .  .  .  .  .  Op: *
  9342  .  .  .  .  .  X: parser
  9343  .  .  .  .  .  Y: nil
  9344  .  .  .  .  }
  9345  .  .  .  }
  9346  .  .  .  Name: paramDecl
  9347  .  .  .  Type: *syntax.FuncType {
  9348  .  .  .  .  ParamList: nil
  9349  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  9350  .  .  .  .  .  0: *syntax.Field {
  9351  .  .  .  .  .  .  Name: nil
  9352  .  .  .  .  .  .  Type: *syntax.Operation {
  9353  .  .  .  .  .  .  .  Op: *
  9354  .  .  .  .  .  .  .  X: Field
  9355  .  .  .  .  .  .  .  Y: nil
  9356  .  .  .  .  .  .  }
  9357  .  .  .  .  .  }
  9358  .  .  .  .  }
  9359  .  .  .  }
  9360  .  .  .  Body: []syntax.Stmt (5 entries) {
  9361  .  .  .  .  0: *syntax.IfStmt {
  9362  .  .  .  .  .  Init: nil
  9363  .  .  .  .  .  Cond: trace
  9364  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  9365  .  .  .  .  .  .  0: *syntax.CallStmt {
  9366  .  .  .  .  .  .  .  Tok: defer
  9367  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  9368  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  9369  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9370  .  .  .  .  .  .  .  .  .  .  X: p
  9371  .  .  .  .  .  .  .  .  .  .  Sel: trace
  9372  .  .  .  .  .  .  .  .  .  }
  9373  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9374  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9375  .  .  .  .  .  .  .  .  .  .  .  Value: "\"paramDecl\""
  9376  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9377  .  .  .  .  .  .  .  .  .  .  }
  9378  .  .  .  .  .  .  .  .  .  }
  9379  .  .  .  .  .  .  .  .  .  HasDots: false
  9380  .  .  .  .  .  .  .  .  }
  9381  .  .  .  .  .  .  .  .  ArgList: nil
  9382  .  .  .  .  .  .  .  .  HasDots: false
  9383  .  .  .  .  .  .  .  }
  9384  .  .  .  .  .  .  }
  9385  .  .  .  .  .  }
  9386  .  .  .  .  .  Else: nil
  9387  .  .  .  .  }
  9388  .  .  .  .  1: *syntax.AssignStmt {
  9389  .  .  .  .  .  Op: :
  9390  .  .  .  .  .  Lhs: f
  9391  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9392  .  .  .  .  .  .  Fun: new
  9393  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9394  .  .  .  .  .  .  .  0: Field
  9395  .  .  .  .  .  .  }
  9396  .  .  .  .  .  .  HasDots: false
  9397  .  .  .  .  .  }
  9398  .  .  .  .  }
  9399  .  .  .  .  2: *syntax.ExprStmt {
  9400  .  .  .  .  .  X: *syntax.CallExpr {
  9401  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9402  .  .  .  .  .  .  .  X: f
  9403  .  .  .  .  .  .  .  Sel: init
  9404  .  .  .  .  .  .  }
  9405  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9406  .  .  .  .  .  .  .  0: p
  9407  .  .  .  .  .  .  }
  9408  .  .  .  .  .  .  HasDots: false
  9409  .  .  .  .  .  }
  9410  .  .  .  .  }
  9411  .  .  .  .  3: *syntax.SwitchStmt {
  9412  .  .  .  .  .  Init: nil
  9413  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  9414  .  .  .  .  .  .  X: p
  9415  .  .  .  .  .  .  Sel: tok
  9416  .  .  .  .  .  }
  9417  .  .  .  .  .  Body: []*syntax.CaseClause (4 entries) {
  9418  .  .  .  .  .  .  0: *syntax.CaseClause {
  9419  .  .  .  .  .  .  .  Cases: _Name
  9420  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  9421  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9422  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9423  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9424  .  .  .  .  .  .  .  .  .  .  X: f
  9425  .  .  .  .  .  .  .  .  .  .  Sel: Name
  9426  .  .  .  .  .  .  .  .  .  }
  9427  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9428  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9429  .  .  .  .  .  .  .  .  .  .  .  X: p
  9430  .  .  .  .  .  .  .  .  .  .  .  Sel: name
  9431  .  .  .  .  .  .  .  .  .  .  }
  9432  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9433  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9434  .  .  .  .  .  .  .  .  .  }
  9435  .  .  .  .  .  .  .  .  }
  9436  .  .  .  .  .  .  .  .  1: *syntax.SwitchStmt {
  9437  .  .  .  .  .  .  .  .  .  Init: nil
  9438  .  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  9439  .  .  .  .  .  .  .  .  .  .  X: p
  9440  .  .  .  .  .  .  .  .  .  .  Sel: tok
  9441  .  .  .  .  .  .  .  .  .  }
  9442  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
  9443  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  9444  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  9445  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (10 entries) {
  9446  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Name
  9447  .  .  .  .  .  .  .  .  .  .  .  .  .  1: _Star
  9448  .  .  .  .  .  .  .  .  .  .  .  .  .  2: _Arrow
  9449  .  .  .  .  .  .  .  .  .  .  .  .  .  3: _Func
  9450  .  .  .  .  .  .  .  .  .  .  .  .  .  4: _Lbrack
  9451  .  .  .  .  .  .  .  .  .  .  .  .  .  5: _Chan
  9452  .  .  .  .  .  .  .  .  .  .  .  .  .  6: _Map
  9453  .  .  .  .  .  .  .  .  .  .  .  .  .  7: _Struct
  9454  .  .  .  .  .  .  .  .  .  .  .  .  .  8: _Interface
  9455  .  .  .  .  .  .  .  .  .  .  .  .  .  9: _Lparen
  9456  .  .  .  .  .  .  .  .  .  .  .  .  }
  9457  .  .  .  .  .  .  .  .  .  .  .  }
  9458  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  9459  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9460  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9461  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9462  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  9463  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
  9464  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9465  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9466  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9467  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  9468  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_
  9469  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9470  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9471  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9472  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9473  .  .  .  .  .  .  .  .  .  .  .  .  }
  9474  .  .  .  .  .  .  .  .  .  .  .  }
  9475  .  .  .  .  .  .  .  .  .  .  }
  9476  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  9477  .  .  .  .  .  .  .  .  .  .  .  Cases: _DotDotDot
  9478  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  9479  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9480  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9481  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9482  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  9483  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
  9484  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9485  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9486  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9487  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  9488  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: dotsType
  9489  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9490  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9491  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9492  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9493  .  .  .  .  .  .  .  .  .  .  .  .  }
  9494  .  .  .  .  .  .  .  .  .  .  .  }
  9495  .  .  .  .  .  .  .  .  .  .  }
  9496  .  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  9497  .  .  .  .  .  .  .  .  .  .  .  Cases: _Dot
  9498  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  9499  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9500  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9501  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9502  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  9503  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
  9504  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9505  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9506  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9507  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
  9508  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: dotname
  9509  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9510  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9511  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  9512  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  9513  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name
  9514  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9515  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9516  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9517  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9518  .  .  .  .  .  .  .  .  .  .  .  .  }
  9519  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  9520  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9521  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9522  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f
  9523  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name
  9524  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9525  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: nil
  9526  .  .  .  .  .  .  .  .  .  .  .  .  }
  9527  .  .  .  .  .  .  .  .  .  .  .  }
  9528  .  .  .  .  .  .  .  .  .  .  }
  9529  .  .  .  .  .  .  .  .  .  }
  9530  .  .  .  .  .  .  .  .  }
  9531  .  .  .  .  .  .  .  }
  9532  .  .  .  .  .  .  }
  9533  .  .  .  .  .  .  1: *syntax.CaseClause {
  9534  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  9535  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (9 entries) {
  9536  .  .  .  .  .  .  .  .  .  0: _Arrow
  9537  .  .  .  .  .  .  .  .  .  1: _Star
  9538  .  .  .  .  .  .  .  .  .  2: _Func
  9539  .  .  .  .  .  .  .  .  .  3: _Lbrack
  9540  .  .  .  .  .  .  .  .  .  4: _Chan
  9541  .  .  .  .  .  .  .  .  .  5: _Map
  9542  .  .  .  .  .  .  .  .  .  6: _Struct
  9543  .  .  .  .  .  .  .  .  .  7: _Interface
  9544  .  .  .  .  .  .  .  .  .  8: _Lparen
  9545  .  .  .  .  .  .  .  .  }
  9546  .  .  .  .  .  .  .  }
  9547  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  9548  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9549  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9550  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9551  .  .  .  .  .  .  .  .  .  .  X: f
  9552  .  .  .  .  .  .  .  .  .  .  Sel: Type
  9553  .  .  .  .  .  .  .  .  .  }
  9554  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9555  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9556  .  .  .  .  .  .  .  .  .  .  .  X: p
  9557  .  .  .  .  .  .  .  .  .  .  .  Sel: type_
  9558  .  .  .  .  .  .  .  .  .  .  }
  9559  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9560  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9561  .  .  .  .  .  .  .  .  .  }
  9562  .  .  .  .  .  .  .  .  }
  9563  .  .  .  .  .  .  .  }
  9564  .  .  .  .  .  .  }
  9565  .  .  .  .  .  .  2: *syntax.CaseClause {
  9566  .  .  .  .  .  .  .  Cases: _DotDotDot
  9567  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  9568  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9569  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9570  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9571  .  .  .  .  .  .  .  .  .  .  X: f
  9572  .  .  .  .  .  .  .  .  .  .  Sel: Type
  9573  .  .  .  .  .  .  .  .  .  }
  9574  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9575  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9576  .  .  .  .  .  .  .  .  .  .  .  X: p
  9577  .  .  .  .  .  .  .  .  .  .  .  Sel: dotsType
  9578  .  .  .  .  .  .  .  .  .  .  }
  9579  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9580  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9581  .  .  .  .  .  .  .  .  .  }
  9582  .  .  .  .  .  .  .  .  }
  9583  .  .  .  .  .  .  .  }
  9584  .  .  .  .  .  .  }
  9585  .  .  .  .  .  .  3: *syntax.CaseClause {
  9586  .  .  .  .  .  .  .  Cases: nil
  9587  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
  9588  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  9589  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9590  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9591  .  .  .  .  .  .  .  .  .  .  .  X: p
  9592  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
  9593  .  .  .  .  .  .  .  .  .  .  }
  9594  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9595  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9596  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting )\""
  9597  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9598  .  .  .  .  .  .  .  .  .  .  .  }
  9599  .  .  .  .  .  .  .  .  .  .  }
  9600  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9601  .  .  .  .  .  .  .  .  .  }
  9602  .  .  .  .  .  .  .  .  }
  9603  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  9604  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9605  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9606  .  .  .  .  .  .  .  .  .  .  .  X: p
  9607  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
  9608  .  .  .  .  .  .  .  .  .  .  }
  9609  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  9610  .  .  .  .  .  .  .  .  .  .  .  0: _Comma
  9611  .  .  .  .  .  .  .  .  .  .  .  1: _Rparen
  9612  .  .  .  .  .  .  .  .  .  .  }
  9613  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9614  .  .  .  .  .  .  .  .  .  }
  9615  .  .  .  .  .  .  .  .  }
  9616  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
  9617  .  .  .  .  .  .  .  .  .  Results: nil
  9618  .  .  .  .  .  .  .  .  }
  9619  .  .  .  .  .  .  .  }
  9620  .  .  .  .  .  .  }
  9621  .  .  .  .  .  }
  9622  .  .  .  .  }
  9623  .  .  .  .  4: *syntax.ReturnStmt {
  9624  .  .  .  .  .  Results: f
  9625  .  .  .  .  }
  9626  .  .  .  }
  9627  .  .  .  Pragma: 0
  9628  .  .  .  EndLine: 1340
  9629  .  .  }
  9630  .  .  47: *syntax.FuncDecl {
  9631  .  .  .  Attr: map[]
  9632  .  .  .  Recv: *syntax.Field {
  9633  .  .  .  .  Name: p
  9634  .  .  .  .  Type: *syntax.Operation {
  9635  .  .  .  .  .  Op: *
  9636  .  .  .  .  .  X: parser
  9637  .  .  .  .  .  Y: nil
  9638  .  .  .  .  }
  9639  .  .  .  }
  9640  .  .  .  Name: dotsType
  9641  .  .  .  Type: *syntax.FuncType {
  9642  .  .  .  .  ParamList: nil
  9643  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  9644  .  .  .  .  .  0: *syntax.Field {
  9645  .  .  .  .  .  .  Name: nil
  9646  .  .  .  .  .  .  Type: *syntax.Operation {
  9647  .  .  .  .  .  .  .  Op: *
  9648  .  .  .  .  .  .  .  X: DotsType
  9649  .  .  .  .  .  .  .  Y: nil
  9650  .  .  .  .  .  .  }
  9651  .  .  .  .  .  }
  9652  .  .  .  .  }
  9653  .  .  .  }
  9654  .  .  .  Body: []syntax.Stmt (7 entries) {
  9655  .  .  .  .  0: *syntax.IfStmt {
  9656  .  .  .  .  .  Init: nil
  9657  .  .  .  .  .  Cond: trace
  9658  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  9659  .  .  .  .  .  .  0: *syntax.CallStmt {
  9660  .  .  .  .  .  .  .  Tok: defer
  9661  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  9662  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  9663  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9664  .  .  .  .  .  .  .  .  .  .  X: p
  9665  .  .  .  .  .  .  .  .  .  .  Sel: trace
  9666  .  .  .  .  .  .  .  .  .  }
  9667  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9668  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9669  .  .  .  .  .  .  .  .  .  .  .  Value: "\"dotsType\""
  9670  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9671  .  .  .  .  .  .  .  .  .  .  }
  9672  .  .  .  .  .  .  .  .  .  }
  9673  .  .  .  .  .  .  .  .  .  HasDots: false
  9674  .  .  .  .  .  .  .  .  }
  9675  .  .  .  .  .  .  .  .  ArgList: nil
  9676  .  .  .  .  .  .  .  .  HasDots: false
  9677  .  .  .  .  .  .  .  }
  9678  .  .  .  .  .  .  }
  9679  .  .  .  .  .  }
  9680  .  .  .  .  .  Else: nil
  9681  .  .  .  .  }
  9682  .  .  .  .  1: *syntax.AssignStmt {
  9683  .  .  .  .  .  Op: :
  9684  .  .  .  .  .  Lhs: t
  9685  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9686  .  .  .  .  .  .  Fun: new
  9687  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9688  .  .  .  .  .  .  .  0: DotsType
  9689  .  .  .  .  .  .  }
  9690  .  .  .  .  .  .  HasDots: false
  9691  .  .  .  .  .  }
  9692  .  .  .  .  }
  9693  .  .  .  .  2: *syntax.ExprStmt {
  9694  .  .  .  .  .  X: *syntax.CallExpr {
  9695  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9696  .  .  .  .  .  .  .  X: t
  9697  .  .  .  .  .  .  .  Sel: init
  9698  .  .  .  .  .  .  }
  9699  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9700  .  .  .  .  .  .  .  0: p
  9701  .  .  .  .  .  .  }
  9702  .  .  .  .  .  .  HasDots: false
  9703  .  .  .  .  .  }
  9704  .  .  .  .  }
  9705  .  .  .  .  3: *syntax.ExprStmt {
  9706  .  .  .  .  .  X: *syntax.CallExpr {
  9707  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9708  .  .  .  .  .  .  .  X: p
  9709  .  .  .  .  .  .  .  Sel: want
  9710  .  .  .  .  .  .  }
  9711  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9712  .  .  .  .  .  .  .  0: _DotDotDot
  9713  .  .  .  .  .  .  }
  9714  .  .  .  .  .  .  HasDots: false
  9715  .  .  .  .  .  }
  9716  .  .  .  .  }
  9717  .  .  .  .  4: *syntax.AssignStmt {
  9718  .  .  .  .  .  Op: <op-0>
  9719  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9720  .  .  .  .  .  .  X: t
  9721  .  .  .  .  .  .  Sel: Elem
  9722  .  .  .  .  .  }
  9723  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9724  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9725  .  .  .  .  .  .  .  X: p
  9726  .  .  .  .  .  .  .  Sel: tryType
  9727  .  .  .  .  .  .  }
  9728  .  .  .  .  .  .  ArgList: nil
  9729  .  .  .  .  .  .  HasDots: false
  9730  .  .  .  .  .  }
  9731  .  .  .  .  }
  9732  .  .  .  .  5: *syntax.IfStmt {
  9733  .  .  .  .  .  Init: nil
  9734  .  .  .  .  .  Cond: *syntax.Operation {
  9735  .  .  .  .  .  .  Op: ==
  9736  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9737  .  .  .  .  .  .  .  X: t
  9738  .  .  .  .  .  .  .  Sel: Elem
  9739  .  .  .  .  .  .  }
  9740  .  .  .  .  .  .  Y: nil
  9741  .  .  .  .  .  }
  9742  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  9743  .  .  .  .  .  .  0: *syntax.ExprStmt {
  9744  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9745  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9746  .  .  .  .  .  .  .  .  .  X: p
  9747  .  .  .  .  .  .  .  .  .  Sel: error
  9748  .  .  .  .  .  .  .  .  }
  9749  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9750  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9751  .  .  .  .  .  .  .  .  .  .  Value: "\"final argument in variadic function missing type\""
  9752  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9753  .  .  .  .  .  .  .  .  .  }
  9754  .  .  .  .  .  .  .  .  }
  9755  .  .  .  .  .  .  .  .  HasDots: false
  9756  .  .  .  .  .  .  .  }
  9757  .  .  .  .  .  .  }
  9758  .  .  .  .  .  }
  9759  .  .  .  .  .  Else: nil
  9760  .  .  .  .  }
  9761  .  .  .  .  6: *syntax.ReturnStmt {
  9762  .  .  .  .  .  Results: t
  9763  .  .  .  .  }
  9764  .  .  .  }
  9765  .  .  .  Pragma: 0
  9766  .  .  .  EndLine: 1358
  9767  .  .  }
  9768  .  .  48: *syntax.FuncDecl {
  9769  .  .  .  Attr: map[]
  9770  .  .  .  Recv: *syntax.Field {
  9771  .  .  .  .  Name: p
  9772  .  .  .  .  Type: *syntax.Operation {
  9773  .  .  .  .  .  Op: *
  9774  .  .  .  .  .  X: parser
  9775  .  .  .  .  .  Y: nil
  9776  .  .  .  .  }
  9777  .  .  .  }
  9778  .  .  .  Name: paramList
  9779  .  .  .  Type: *syntax.FuncType {
  9780  .  .  .  .  ParamList: nil
  9781  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  9782  .  .  .  .  .  0: *syntax.Field {
  9783  .  .  .  .  .  .  Name: list
  9784  .  .  .  .  .  .  Type: *syntax.SliceType {
  9785  .  .  .  .  .  .  .  Elem: *syntax.Operation {
  9786  .  .  .  .  .  .  .  .  Op: *
  9787  .  .  .  .  .  .  .  .  X: Field
  9788  .  .  .  .  .  .  .  .  Y: nil
  9789  .  .  .  .  .  .  .  }
  9790  .  .  .  .  .  .  }
  9791  .  .  .  .  .  }
  9792  .  .  .  .  }
  9793  .  .  .  }
  9794  .  .  .  Body: []syntax.Stmt (7 entries) {
  9795  .  .  .  .  0: *syntax.IfStmt {
  9796  .  .  .  .  .  Init: nil
  9797  .  .  .  .  .  Cond: trace
  9798  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  9799  .  .  .  .  .  .  0: *syntax.CallStmt {
  9800  .  .  .  .  .  .  .  Tok: defer
  9801  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  9802  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  9803  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9804  .  .  .  .  .  .  .  .  .  .  X: p
  9805  .  .  .  .  .  .  .  .  .  .  Sel: trace
  9806  .  .  .  .  .  .  .  .  .  }
  9807  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9808  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9809  .  .  .  .  .  .  .  .  .  .  .  Value: "\"paramList\""
  9810  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9811  .  .  .  .  .  .  .  .  .  .  }
  9812  .  .  .  .  .  .  .  .  .  }
  9813  .  .  .  .  .  .  .  .  .  HasDots: false
  9814  .  .  .  .  .  .  .  .  }
  9815  .  .  .  .  .  .  .  .  ArgList: nil
  9816  .  .  .  .  .  .  .  .  HasDots: false
  9817  .  .  .  .  .  .  .  }
  9818  .  .  .  .  .  .  }
  9819  .  .  .  .  .  }
  9820  .  .  .  .  .  Else: nil
  9821  .  .  .  .  }
  9822  .  .  .  .  1: *syntax.ExprStmt {
  9823  .  .  .  .  .  X: *syntax.CallExpr {
  9824  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9825  .  .  .  .  .  .  .  X: p
  9826  .  .  .  .  .  .  .  Sel: want
  9827  .  .  .  .  .  .  }
  9828  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9829  .  .  .  .  .  .  .  0: _Lparen
  9830  .  .  .  .  .  .  }
  9831  .  .  .  .  .  .  HasDots: false
  9832  .  .  .  .  .  }
  9833  .  .  .  .  }
  9834  .  .  .  .  2: *syntax.DeclStmt {
  9835  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
  9836  .  .  .  .  .  .  0: *syntax.VarDecl {
  9837  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
  9838  .  .  .  .  .  .  .  .  0: named
  9839  .  .  .  .  .  .  .  }
  9840  .  .  .  .  .  .  .  Type: int
  9841  .  .  .  .  .  .  .  Values: nil
  9842  .  .  .  .  .  .  .  Group: nil
  9843  .  .  .  .  .  .  }
  9844  .  .  .  .  .  }
  9845  .  .  .  .  }
  9846  .  .  .  .  3: *syntax.ForStmt {
  9847  .  .  .  .  .  Init: nil
  9848  .  .  .  .  .  Cond: *syntax.Operation {
  9849  .  .  .  .  .  .  Op: &&
  9850  .  .  .  .  .  .  X: *syntax.Operation {
  9851  .  .  .  .  .  .  .  Op: !=
  9852  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9853  .  .  .  .  .  .  .  .  X: p
  9854  .  .  .  .  .  .  .  .  Sel: tok
  9855  .  .  .  .  .  .  .  }
  9856  .  .  .  .  .  .  .  Y: _EOF
  9857  .  .  .  .  .  .  }
  9858  .  .  .  .  .  .  Y: *syntax.Operation {
  9859  .  .  .  .  .  .  .  Op: !=
  9860  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9861  .  .  .  .  .  .  .  .  X: p
  9862  .  .  .  .  .  .  .  .  Sel: tok
  9863  .  .  .  .  .  .  .  }
  9864  .  .  .  .  .  .  .  Y: _Rparen
  9865  .  .  .  .  .  .  }
  9866  .  .  .  .  .  }
  9867  .  .  .  .  .  Post: nil
  9868  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  9869  .  .  .  .  .  .  0: *syntax.IfStmt {
  9870  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
  9871  .  .  .  .  .  .  .  .  Op: :
  9872  .  .  .  .  .  .  .  .  Lhs: par
  9873  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9874  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9875  .  .  .  .  .  .  .  .  .  .  X: p
  9876  .  .  .  .  .  .  .  .  .  .  Sel: paramDecl
  9877  .  .  .  .  .  .  .  .  .  }
  9878  .  .  .  .  .  .  .  .  .  ArgList: nil
  9879  .  .  .  .  .  .  .  .  .  HasDots: false
  9880  .  .  .  .  .  .  .  .  }
  9881  .  .  .  .  .  .  .  }
  9882  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  9883  .  .  .  .  .  .  .  .  Op: !=
  9884  .  .  .  .  .  .  .  .  X: par
  9885  .  .  .  .  .  .  .  .  Y: nil
  9886  .  .  .  .  .  .  .  }
  9887  .  .  .  .  .  .  .  Then: []syntax.Stmt (3 entries) {
  9888  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
  9889  .  .  .  .  .  .  .  .  .  Init: nil
  9890  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  9891  .  .  .  .  .  .  .  .  .  .  Op: &&
  9892  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  9893  .  .  .  .  .  .  .  .  .  .  .  Op: &&
  9894  .  .  .  .  .  .  .  .  .  .  .  X: debug
  9895  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  9896  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  9897  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9898  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par
  9899  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name
  9900  .  .  .  .  .  .  .  .  .  .  .  .  }
  9901  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  9902  .  .  .  .  .  .  .  .  .  .  .  }
  9903  .  .  .  .  .  .  .  .  .  .  }
  9904  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  9905  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  9906  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9907  .  .  .  .  .  .  .  .  .  .  .  .  X: par
  9908  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
  9909  .  .  .  .  .  .  .  .  .  .  .  }
  9910  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  9911  .  .  .  .  .  .  .  .  .  .  }
  9912  .  .  .  .  .  .  .  .  .  }
  9913  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  9914  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  9915  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9916  .  .  .  .  .  .  .  .  .  .  .  .  Fun: panic
  9917  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9918  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9919  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"parameter without name or type\""
  9920  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9921  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9922  .  .  .  .  .  .  .  .  .  .  .  .  }
  9923  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9924  .  .  .  .  .  .  .  .  .  .  .  }
  9925  .  .  .  .  .  .  .  .  .  .  }
  9926  .  .  .  .  .  .  .  .  .  }
  9927  .  .  .  .  .  .  .  .  .  Else: nil
  9928  .  .  .  .  .  .  .  .  }
  9929  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  9930  .  .  .  .  .  .  .  .  .  Init: nil
  9931  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  9932  .  .  .  .  .  .  .  .  .  .  Op: &&
  9933  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  9934  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  9935  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9936  .  .  .  .  .  .  .  .  .  .  .  .  X: par
  9937  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name
  9938  .  .  .  .  .  .  .  .  .  .  .  }
  9939  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  9940  .  .  .  .  .  .  .  .  .  .  }
  9941  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  9942  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  9943  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9944  .  .  .  .  .  .  .  .  .  .  .  .  X: par
  9945  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
  9946  .  .  .  .  .  .  .  .  .  .  .  }
  9947  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  9948  .  .  .  .  .  .  .  .  .  .  }
  9949  .  .  .  .  .  .  .  .  .  }
  9950  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  9951  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9952  .  .  .  .  .  .  .  .  .  .  .  Op: +
  9953  .  .  .  .  .  .  .  .  .  .  .  Lhs: named
  9954  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
  9955  .  .  .  .  .  .  .  .  .  .  }
  9956  .  .  .  .  .  .  .  .  .  }
  9957  .  .  .  .  .  .  .  .  .  Else: nil
  9958  .  .  .  .  .  .  .  .  }
  9959  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  9960  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9961  .  .  .  .  .  .  .  .  .  Lhs: list
  9962  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9963  .  .  .  .  .  .  .  .  .  .  Fun: append
  9964  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  9965  .  .  .  .  .  .  .  .  .  .  .  0: list
  9966  .  .  .  .  .  .  .  .  .  .  .  1: par
  9967  .  .  .  .  .  .  .  .  .  .  }
  9968  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9969  .  .  .  .  .  .  .  .  .  }
  9970  .  .  .  .  .  .  .  .  }
  9971  .  .  .  .  .  .  .  }
  9972  .  .  .  .  .  .  .  Else: nil
  9973  .  .  .  .  .  .  }
  9974  .  .  .  .  .  .  1: *syntax.IfStmt {
  9975  .  .  .  .  .  .  .  Init: nil
  9976  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  9977  .  .  .  .  .  .  .  .  Op: !
  9978  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9979  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9980  .  .  .  .  .  .  .  .  .  .  X: p
  9981  .  .  .  .  .  .  .  .  .  .  Sel: ocomma
  9982  .  .  .  .  .  .  .  .  .  }
  9983  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9984  .  .  .  .  .  .  .  .  .  .  0: _Rparen
  9985  .  .  .  .  .  .  .  .  .  }
  9986  .  .  .  .  .  .  .  .  .  HasDots: false
  9987  .  .  .  .  .  .  .  .  }
  9988  .  .  .  .  .  .  .  .  Y: nil
  9989  .  .  .  .  .  .  .  }
  9990  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
  9991  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  9992  .  .  .  .  .  .  .  .  .  Tok: break
  9993  .  .  .  .  .  .  .  .  .  Label: nil
  9994  .  .  .  .  .  .  .  .  }
  9995  .  .  .  .  .  .  .  }
  9996  .  .  .  .  .  .  .  Else: nil
  9997  .  .  .  .  .  .  }
  9998  .  .  .  .  .  }
  9999  .  .  .  .  }
 10000  .  .  .  .  4: *syntax.IfStmt {
 10001  .  .  .  .  .  Init: nil
 10002  .  .  .  .  .  Cond: *syntax.Operation {
 10003  .  .  .  .  .  .  Op: ==
 10004  .  .  .  .  .  .  X: named
 10005  .  .  .  .  .  .  Y: *syntax.BasicLit {
 10006  .  .  .  .  .  .  .  Value: "0"
 10007  .  .  .  .  .  .  .  Kind: 0
 10008  .  .  .  .  .  .  }
 10009  .  .  .  .  .  }
 10010  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 10011  .  .  .  .  .  .  0: *syntax.ForStmt {
 10012  .  .  .  .  .  .  .  Init: *syntax.RangeClause {
 10013  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 10014  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 10015  .  .  .  .  .  .  .  .  .  .  0: _
 10016  .  .  .  .  .  .  .  .  .  .  1: par
 10017  .  .  .  .  .  .  .  .  .  }
 10018  .  .  .  .  .  .  .  .  }
 10019  .  .  .  .  .  .  .  .  Def: true
 10020  .  .  .  .  .  .  .  .  X: list
 10021  .  .  .  .  .  .  .  }
 10022  .  .  .  .  .  .  .  Cond: nil
 10023  .  .  .  .  .  .  .  Post: nil
 10024  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 10025  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 10026  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 10027  .  .  .  .  .  .  .  .  .  .  Op: :
 10028  .  .  .  .  .  .  .  .  .  .  Lhs: typ
 10029  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 10030  .  .  .  .  .  .  .  .  .  .  .  X: par
 10031  .  .  .  .  .  .  .  .  .  .  .  Sel: Name
 10032  .  .  .  .  .  .  .  .  .  .  }
 10033  .  .  .  .  .  .  .  .  .  }
 10034  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 10035  .  .  .  .  .  .  .  .  .  .  Op: !=
 10036  .  .  .  .  .  .  .  .  .  .  X: typ
 10037  .  .  .  .  .  .  .  .  .  .  Y: nil
 10038  .  .  .  .  .  .  .  .  .  }
 10039  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 10040  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10041  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10042  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10043  .  .  .  .  .  .  .  .  .  .  .  .  X: par
 10044  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
 10045  .  .  .  .  .  .  .  .  .  .  .  }
 10046  .  .  .  .  .  .  .  .  .  .  .  Rhs: typ
 10047  .  .  .  .  .  .  .  .  .  .  }
 10048  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 10049  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10050  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10051  .  .  .  .  .  .  .  .  .  .  .  .  X: par
 10052  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name
 10053  .  .  .  .  .  .  .  .  .  .  .  }
 10054  .  .  .  .  .  .  .  .  .  .  .  Rhs: nil
 10055  .  .  .  .  .  .  .  .  .  .  }
 10056  .  .  .  .  .  .  .  .  .  }
 10057  .  .  .  .  .  .  .  .  .  Else: nil
 10058  .  .  .  .  .  .  .  .  }
 10059  .  .  .  .  .  .  .  }
 10060  .  .  .  .  .  .  }
 10061  .  .  .  .  .  }
 10062  .  .  .  .  .  Else: *syntax.IfStmt {
 10063  .  .  .  .  .  .  Init: nil
 10064  .  .  .  .  .  .  Cond: *syntax.Operation {
 10065  .  .  .  .  .  .  .  Op: !=
 10066  .  .  .  .  .  .  .  X: named
 10067  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
 10068  .  .  .  .  .  .  .  .  Fun: len
 10069  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10070  .  .  .  .  .  .  .  .  .  0: list
 10071  .  .  .  .  .  .  .  .  }
 10072  .  .  .  .  .  .  .  .  HasDots: false
 10073  .  .  .  .  .  .  .  }
 10074  .  .  .  .  .  .  }
 10075  .  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 10076  .  .  .  .  .  .  .  0: *syntax.DeclStmt {
 10077  .  .  .  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
 10078  .  .  .  .  .  .  .  .  .  0: *syntax.VarDecl {
 10079  .  .  .  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
 10080  .  .  .  .  .  .  .  .  .  .  .  0: typ
 10081  .  .  .  .  .  .  .  .  .  .  }
 10082  .  .  .  .  .  .  .  .  .  .  Type: Expr
 10083  .  .  .  .  .  .  .  .  .  .  Values: nil
 10084  .  .  .  .  .  .  .  .  .  .  Group: nil
 10085  .  .  .  .  .  .  .  .  .  }
 10086  .  .  .  .  .  .  .  .  }
 10087  .  .  .  .  .  .  .  }
 10088  .  .  .  .  .  .  .  1: *syntax.ForStmt {
 10089  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 10090  .  .  .  .  .  .  .  .  .  Op: :
 10091  .  .  .  .  .  .  .  .  .  Lhs: i
 10092  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
 10093  .  .  .  .  .  .  .  .  .  .  Op: -
 10094  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10095  .  .  .  .  .  .  .  .  .  .  .  Fun: len
 10096  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10097  .  .  .  .  .  .  .  .  .  .  .  .  0: list
 10098  .  .  .  .  .  .  .  .  .  .  .  }
 10099  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10100  .  .  .  .  .  .  .  .  .  .  }
 10101  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
 10102  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
 10103  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
 10104  .  .  .  .  .  .  .  .  .  .  }
 10105  .  .  .  .  .  .  .  .  .  }
 10106  .  .  .  .  .  .  .  .  }
 10107  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 10108  .  .  .  .  .  .  .  .  .  Op: >=
 10109  .  .  .  .  .  .  .  .  .  X: i
 10110  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
 10111  .  .  .  .  .  .  .  .  .  .  Value: "0"
 10112  .  .  .  .  .  .  .  .  .  .  Kind: 0
 10113  .  .  .  .  .  .  .  .  .  }
 10114  .  .  .  .  .  .  .  .  }
 10115  .  .  .  .  .  .  .  .  Post: *syntax.AssignStmt {
 10116  .  .  .  .  .  .  .  .  .  Op: -
 10117  .  .  .  .  .  .  .  .  .  Lhs: i
 10118  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 4462)
 10119  .  .  .  .  .  .  .  .  }
 10120  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 10121  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 10122  .  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 10123  .  .  .  .  .  .  .  .  .  .  .  Op: :
 10124  .  .  .  .  .  .  .  .  .  .  .  Lhs: par
 10125  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.IndexExpr {
 10126  .  .  .  .  .  .  .  .  .  .  .  .  X: list
 10127  .  .  .  .  .  .  .  .  .  .  .  .  Index: i
 10128  .  .  .  .  .  .  .  .  .  .  .  }
 10129  .  .  .  .  .  .  .  .  .  .  }
 10130  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 10131  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 10132  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 10133  .  .  .  .  .  .  .  .  .  .  .  .  X: par
 10134  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
 10135  .  .  .  .  .  .  .  .  .  .  .  }
 10136  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 10137  .  .  .  .  .  .  .  .  .  .  }
 10138  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 10139  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10140  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10141  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ
 10142  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 10143  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par
 10144  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
 10145  .  .  .  .  .  .  .  .  .  .  .  .  }
 10146  .  .  .  .  .  .  .  .  .  .  .  }
 10147  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 10148  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 10149  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 10150  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 10151  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 10152  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par
 10153  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name
 10154  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10155  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 10156  .  .  .  .  .  .  .  .  .  .  .  .  }
 10157  .  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 10158  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10159  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10160  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ
 10161  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: nil
 10162  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10163  .  .  .  .  .  .  .  .  .  .  .  .  }
 10164  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
 10165  .  .  .  .  .  .  .  .  .  .  .  }
 10166  .  .  .  .  .  .  .  .  .  .  }
 10167  .  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
 10168  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 10169  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10170  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10171  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10172  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par
 10173  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type
 10174  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10175  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: typ
 10176  .  .  .  .  .  .  .  .  .  .  .  .  }
 10177  .  .  .  .  .  .  .  .  .  .  .  }
 10178  .  .  .  .  .  .  .  .  .  .  }
 10179  .  .  .  .  .  .  .  .  .  }
 10180  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 10181  .  .  .  .  .  .  .  .  .  .  Init: nil
 10182  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 10183  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 10184  .  .  .  .  .  .  .  .  .  .  .  X: typ
 10185  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 10186  .  .  .  .  .  .  .  .  .  .  }
 10187  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 10188  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10189  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10190  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10191  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10192  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
 10193  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10194  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10195  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10196  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"mixed named and unnamed function parameters\""
 10197  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10198  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10199  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10200  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10201  .  .  .  .  .  .  .  .  .  .  .  .  }
 10202  .  .  .  .  .  .  .  .  .  .  .  }
 10203  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BranchStmt {
 10204  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
 10205  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
 10206  .  .  .  .  .  .  .  .  .  .  .  }
 10207  .  .  .  .  .  .  .  .  .  .  }
 10208  .  .  .  .  .  .  .  .  .  .  Else: nil
 10209  .  .  .  .  .  .  .  .  .  }
 10210  .  .  .  .  .  .  .  .  }
 10211  .  .  .  .  .  .  .  }
 10212  .  .  .  .  .  .  }
 10213  .  .  .  .  .  .  Else: nil
 10214  .  .  .  .  .  }
 10215  .  .  .  .  }
 10216  .  .  .  .  5: *syntax.ExprStmt {
 10217  .  .  .  .  .  X: *syntax.CallExpr {
 10218  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10219  .  .  .  .  .  .  .  X: p
 10220  .  .  .  .  .  .  .  Sel: want
 10221  .  .  .  .  .  .  }
 10222  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10223  .  .  .  .  .  .  .  0: _Rparen
 10224  .  .  .  .  .  .  }
 10225  .  .  .  .  .  .  HasDots: false
 10226  .  .  .  .  .  }
 10227  .  .  .  .  }
 10228  .  .  .  .  6: *syntax.ReturnStmt {
 10229  .  .  .  .  .  Results: nil
 10230  .  .  .  .  }
 10231  .  .  .  }
 10232  .  .  .  Pragma: 0
 10233  .  .  .  EndLine: 1415
 10234  .  .  }
 10235  .  .  49: *syntax.VarDecl {
 10236  .  .  .  NameList: []*syntax.Name (1 entries) {
 10237  .  .  .  .  0: ImplicitOne
 10238  .  .  .  }
 10239  .  .  .  Type: nil
 10240  .  .  .  Values: *syntax.Operation {
 10241  .  .  .  .  Op: &
 10242  .  .  .  .  X: *syntax.CompositeLit {
 10243  .  .  .  .  .  Type: BasicLit
 10244  .  .  .  .  .  ElemList: []syntax.Expr (1 entries) {
 10245  .  .  .  .  .  .  0: *syntax.KeyValueExpr {
 10246  .  .  .  .  .  .  .  Key: Value
 10247  .  .  .  .  .  .  .  Value: *syntax.BasicLit {
 10248  .  .  .  .  .  .  .  .  Value: "\"1\""
 10249  .  .  .  .  .  .  .  .  Kind: 4
 10250  .  .  .  .  .  .  .  }
 10251  .  .  .  .  .  .  }
 10252  .  .  .  .  .  }
 10253  .  .  .  .  .  NKeys: 1
 10254  .  .  .  .  .  EndLine: 1422
 10255  .  .  .  .  }
 10256  .  .  .  .  Y: nil
 10257  .  .  .  }
 10258  .  .  .  Group: nil
 10259  .  .  }
 10260  .  .  50: *syntax.FuncDecl {
 10261  .  .  .  Attr: map[]
 10262  .  .  .  Recv: *syntax.Field {
 10263  .  .  .  .  Name: p
 10264  .  .  .  .  Type: *syntax.Operation {
 10265  .  .  .  .  .  Op: *
 10266  .  .  .  .  .  X: parser
 10267  .  .  .  .  .  Y: nil
 10268  .  .  .  .  }
 10269  .  .  .  }
 10270  .  .  .  Name: simpleStmt
 10271  .  .  .  Type: *syntax.FuncType {
 10272  .  .  .  .  ParamList: []*syntax.Field (2 entries) {
 10273  .  .  .  .  .  0: *syntax.Field {
 10274  .  .  .  .  .  .  Name: lhs
 10275  .  .  .  .  .  .  Type: Expr
 10276  .  .  .  .  .  }
 10277  .  .  .  .  .  1: *syntax.Field {
 10278  .  .  .  .  .  .  Name: rangeOk
 10279  .  .  .  .  .  .  Type: bool
 10280  .  .  .  .  .  }
 10281  .  .  .  .  }
 10282  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 10283  .  .  .  .  .  0: *syntax.Field {
 10284  .  .  .  .  .  .  Name: nil
 10285  .  .  .  .  .  .  Type: SimpleStmt
 10286  .  .  .  .  .  }
 10287  .  .  .  .  }
 10288  .  .  .  }
 10289  .  .  .  Body: []syntax.Stmt (5 entries) {
 10290  .  .  .  .  0: *syntax.IfStmt {
 10291  .  .  .  .  .  Init: nil
 10292  .  .  .  .  .  Cond: trace
 10293  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 10294  .  .  .  .  .  .  0: *syntax.CallStmt {
 10295  .  .  .  .  .  .  .  Tok: defer
 10296  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 10297  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 10298  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10299  .  .  .  .  .  .  .  .  .  .  X: p
 10300  .  .  .  .  .  .  .  .  .  .  Sel: trace
 10301  .  .  .  .  .  .  .  .  .  }
 10302  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10303  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10304  .  .  .  .  .  .  .  .  .  .  .  Value: "\"simpleStmt\""
 10305  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10306  .  .  .  .  .  .  .  .  .  .  }
 10307  .  .  .  .  .  .  .  .  .  }
 10308  .  .  .  .  .  .  .  .  .  HasDots: false
 10309  .  .  .  .  .  .  .  .  }
 10310  .  .  .  .  .  .  .  .  ArgList: nil
 10311  .  .  .  .  .  .  .  .  HasDots: false
 10312  .  .  .  .  .  .  .  }
 10313  .  .  .  .  .  .  }
 10314  .  .  .  .  .  }
 10315  .  .  .  .  .  Else: nil
 10316  .  .  .  .  }
 10317  .  .  .  .  1: *syntax.IfStmt {
 10318  .  .  .  .  .  Init: nil
 10319  .  .  .  .  .  Cond: *syntax.Operation {
 10320  .  .  .  .  .  .  Op: &&
 10321  .  .  .  .  .  .  X: rangeOk
 10322  .  .  .  .  .  .  Y: *syntax.CallExpr {
 10323  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10324  .  .  .  .  .  .  .  .  X: p
 10325  .  .  .  .  .  .  .  .  Sel: got
 10326  .  .  .  .  .  .  .  }
 10327  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10328  .  .  .  .  .  .  .  .  0: _Range
 10329  .  .  .  .  .  .  .  }
 10330  .  .  .  .  .  .  .  HasDots: false
 10331  .  .  .  .  .  .  }
 10332  .  .  .  .  .  }
 10333  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 10334  .  .  .  .  .  .  0: *syntax.IfStmt {
 10335  .  .  .  .  .  .  .  Init: nil
 10336  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 10337  .  .  .  .  .  .  .  .  Op: &&
 10338  .  .  .  .  .  .  .  .  X: debug
 10339  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 10340  .  .  .  .  .  .  .  .  .  Op: !=
 10341  .  .  .  .  .  .  .  .  .  X: lhs
 10342  .  .  .  .  .  .  .  .  .  Y: nil
 10343  .  .  .  .  .  .  .  .  }
 10344  .  .  .  .  .  .  .  }
 10345  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 10346  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10347  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10348  .  .  .  .  .  .  .  .  .  .  Fun: panic
 10349  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10350  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10351  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"invalid call of simpleStmt\""
 10352  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10353  .  .  .  .  .  .  .  .  .  .  .  }
 10354  .  .  .  .  .  .  .  .  .  .  }
 10355  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10356  .  .  .  .  .  .  .  .  .  }
 10357  .  .  .  .  .  .  .  .  }
 10358  .  .  .  .  .  .  .  }
 10359  .  .  .  .  .  .  .  Else: nil
 10360  .  .  .  .  .  .  }
 10361  .  .  .  .  .  .  1: *syntax.ReturnStmt {
 10362  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 10363  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10364  .  .  .  .  .  .  .  .  .  X: p
 10365  .  .  .  .  .  .  .  .  .  Sel: rangeClause
 10366  .  .  .  .  .  .  .  .  }
 10367  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 10368  .  .  .  .  .  .  .  .  .  0: nil
 10369  .  .  .  .  .  .  .  .  .  1: false
 10370  .  .  .  .  .  .  .  .  }
 10371  .  .  .  .  .  .  .  .  HasDots: false
 10372  .  .  .  .  .  .  .  }
 10373  .  .  .  .  .  .  }
 10374  .  .  .  .  .  }
 10375  .  .  .  .  .  Else: nil
 10376  .  .  .  .  }
 10377  .  .  .  .  2: *syntax.IfStmt {
 10378  .  .  .  .  .  Init: nil
 10379  .  .  .  .  .  Cond: *syntax.Operation {
 10380  .  .  .  .  .  .  Op: ==
 10381  .  .  .  .  .  .  X: lhs
 10382  .  .  .  .  .  .  Y: nil
 10383  .  .  .  .  .  }
 10384  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 10385  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10386  .  .  .  .  .  .  .  Op: <op-0>
 10387  .  .  .  .  .  .  .  Lhs: lhs
 10388  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10389  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10390  .  .  .  .  .  .  .  .  .  X: p
 10391  .  .  .  .  .  .  .  .  .  Sel: exprList
 10392  .  .  .  .  .  .  .  .  }
 10393  .  .  .  .  .  .  .  .  ArgList: nil
 10394  .  .  .  .  .  .  .  .  HasDots: false
 10395  .  .  .  .  .  .  .  }
 10396  .  .  .  .  .  .  }
 10397  .  .  .  .  .  }
 10398  .  .  .  .  .  Else: nil
 10399  .  .  .  .  }
 10400  .  .  .  .  3: *syntax.IfStmt {
 10401  .  .  .  .  .  Init: *syntax.AssignStmt {
 10402  .  .  .  .  .  .  Op: :
 10403  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 10404  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 10405  .  .  .  .  .  .  .  .  0: _
 10406  .  .  .  .  .  .  .  .  1: ok
 10407  .  .  .  .  .  .  .  }
 10408  .  .  .  .  .  .  }
 10409  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 10410  .  .  .  .  .  .  .  X: lhs
 10411  .  .  .  .  .  .  .  Type: *syntax.Operation {
 10412  .  .  .  .  .  .  .  .  Op: *
 10413  .  .  .  .  .  .  .  .  X: ListExpr
 10414  .  .  .  .  .  .  .  .  Y: nil
 10415  .  .  .  .  .  .  .  }
 10416  .  .  .  .  .  .  }
 10417  .  .  .  .  .  }
 10418  .  .  .  .  .  Cond: *syntax.Operation {
 10419  .  .  .  .  .  .  Op: &&
 10420  .  .  .  .  .  .  X: *syntax.Operation {
 10421  .  .  .  .  .  .  .  Op: &&
 10422  .  .  .  .  .  .  .  X: *syntax.Operation {
 10423  .  .  .  .  .  .  .  .  Op: !
 10424  .  .  .  .  .  .  .  .  X: ok
 10425  .  .  .  .  .  .  .  .  Y: nil
 10426  .  .  .  .  .  .  .  }
 10427  .  .  .  .  .  .  .  Y: *syntax.Operation {
 10428  .  .  .  .  .  .  .  .  Op: !=
 10429  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 10430  .  .  .  .  .  .  .  .  .  X: p
 10431  .  .  .  .  .  .  .  .  .  Sel: tok
 10432  .  .  .  .  .  .  .  .  }
 10433  .  .  .  .  .  .  .  .  Y: _Assign
 10434  .  .  .  .  .  .  .  }
 10435  .  .  .  .  .  .  }
 10436  .  .  .  .  .  .  Y: *syntax.Operation {
 10437  .  .  .  .  .  .  .  Op: !=
 10438  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 10439  .  .  .  .  .  .  .  .  X: p
 10440  .  .  .  .  .  .  .  .  Sel: tok
 10441  .  .  .  .  .  .  .  }
 10442  .  .  .  .  .  .  .  Y: _Define
 10443  .  .  .  .  .  .  }
 10444  .  .  .  .  .  }
 10445  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 10446  .  .  .  .  .  .  0: *syntax.SwitchStmt {
 10447  .  .  .  .  .  .  .  Init: nil
 10448  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 10449  .  .  .  .  .  .  .  .  X: p
 10450  .  .  .  .  .  .  .  .  Sel: tok
 10451  .  .  .  .  .  .  .  }
 10452  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (4 entries) {
 10453  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 10454  .  .  .  .  .  .  .  .  .  Cases: _AssignOp
 10455  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 10456  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10457  .  .  .  .  .  .  .  .  .  .  .  Op: :
 10458  .  .  .  .  .  .  .  .  .  .  .  Lhs: op
 10459  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 10460  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10461  .  .  .  .  .  .  .  .  .  .  .  .  Sel: op
 10462  .  .  .  .  .  .  .  .  .  .  .  }
 10463  .  .  .  .  .  .  .  .  .  .  }
 10464  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 10465  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10466  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10467  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10468  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 10469  .  .  .  .  .  .  .  .  .  .  .  .  }
 10470  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10471  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10472  .  .  .  .  .  .  .  .  .  .  .  }
 10473  .  .  .  .  .  .  .  .  .  .  }
 10474  .  .  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 10475  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 10476  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10477  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10478  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: newAssignStmt
 10479  .  .  .  .  .  .  .  .  .  .  .  .  }
 10480  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 10481  .  .  .  .  .  .  .  .  .  .  .  .  .  0: op
 10482  .  .  .  .  .  .  .  .  .  .  .  .  .  1: lhs
 10483  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.CallExpr {
 10484  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10485  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10486  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr
 10487  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10488  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10489  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10490  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10491  .  .  .  .  .  .  .  .  .  .  .  .  }
 10492  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10493  .  .  .  .  .  .  .  .  .  .  .  }
 10494  .  .  .  .  .  .  .  .  .  .  }
 10495  .  .  .  .  .  .  .  .  .  }
 10496  .  .  .  .  .  .  .  .  }
 10497  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 10498  .  .  .  .  .  .  .  .  .  Cases: _IncOp
 10499  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 10500  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10501  .  .  .  .  .  .  .  .  .  .  .  Op: :
 10502  .  .  .  .  .  .  .  .  .  .  .  Lhs: op
 10503  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 10504  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10505  .  .  .  .  .  .  .  .  .  .  .  .  Sel: op
 10506  .  .  .  .  .  .  .  .  .  .  .  }
 10507  .  .  .  .  .  .  .  .  .  .  }
 10508  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 10509  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10510  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10511  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10512  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 10513  .  .  .  .  .  .  .  .  .  .  .  .  }
 10514  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10515  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10516  .  .  .  .  .  .  .  .  .  .  .  }
 10517  .  .  .  .  .  .  .  .  .  .  }
 10518  .  .  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 10519  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 10520  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10521  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10522  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: newAssignStmt
 10523  .  .  .  .  .  .  .  .  .  .  .  .  }
 10524  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 10525  .  .  .  .  .  .  .  .  .  .  .  .  .  0: op
 10526  .  .  .  .  .  .  .  .  .  .  .  .  .  1: lhs
 10527  .  .  .  .  .  .  .  .  .  .  .  .  .  2: ImplicitOne
 10528  .  .  .  .  .  .  .  .  .  .  .  .  }
 10529  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10530  .  .  .  .  .  .  .  .  .  .  .  }
 10531  .  .  .  .  .  .  .  .  .  .  }
 10532  .  .  .  .  .  .  .  .  .  }
 10533  .  .  .  .  .  .  .  .  }
 10534  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 10535  .  .  .  .  .  .  .  .  .  Cases: _Arrow
 10536  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (7 entries) {
 10537  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10538  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10539  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10540  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10541  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 10542  .  .  .  .  .  .  .  .  .  .  .  .  }
 10543  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10544  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10545  .  .  .  .  .  .  .  .  .  .  .  }
 10546  .  .  .  .  .  .  .  .  .  .  }
 10547  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 10548  .  .  .  .  .  .  .  .  .  .  .  Op: :
 10549  .  .  .  .  .  .  .  .  .  .  .  Lhs: s
 10550  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10551  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new
 10552  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10553  .  .  .  .  .  .  .  .  .  .  .  .  .  0: SendStmt
 10554  .  .  .  .  .  .  .  .  .  .  .  .  }
 10555  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10556  .  .  .  .  .  .  .  .  .  .  .  }
 10557  .  .  .  .  .  .  .  .  .  .  }
 10558  .  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 10559  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10560  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10561  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s
 10562  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
 10563  .  .  .  .  .  .  .  .  .  .  .  .  }
 10564  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10565  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
 10566  .  .  .  .  .  .  .  .  .  .  .  .  }
 10567  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10568  .  .  .  .  .  .  .  .  .  .  .  }
 10569  .  .  .  .  .  .  .  .  .  .  }
 10570  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
 10571  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10572  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10573  .  .  .  .  .  .  .  .  .  .  .  .  X: s
 10574  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Chan
 10575  .  .  .  .  .  .  .  .  .  .  .  }
 10576  .  .  .  .  .  .  .  .  .  .  .  Rhs: lhs
 10577  .  .  .  .  .  .  .  .  .  .  }
 10578  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
 10579  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10580  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10581  .  .  .  .  .  .  .  .  .  .  .  .  X: s
 10582  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Value
 10583  .  .  .  .  .  .  .  .  .  .  .  }
 10584  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10585  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10586  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10587  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr
 10588  .  .  .  .  .  .  .  .  .  .  .  .  }
 10589  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10590  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10591  .  .  .  .  .  .  .  .  .  .  .  }
 10592  .  .  .  .  .  .  .  .  .  .  }
 10593  .  .  .  .  .  .  .  .  .  .  5: *syntax.IfStmt {
 10594  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 10595  .  .  .  .  .  .  .  .  .  .  .  Cond: gcCompat
 10596  .  .  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 10597  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10598  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10599  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10600  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s
 10601  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
 10602  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10603  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10604  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
 10605  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10606  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10607  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10608  .  .  .  .  .  .  .  .  .  .  .  .  }
 10609  .  .  .  .  .  .  .  .  .  .  .  }
 10610  .  .  .  .  .  .  .  .  .  .  .  Else: nil
 10611  .  .  .  .  .  .  .  .  .  .  }
 10612  .  .  .  .  .  .  .  .  .  .  6: *syntax.ReturnStmt {
 10613  .  .  .  .  .  .  .  .  .  .  .  Results: s
 10614  .  .  .  .  .  .  .  .  .  .  }
 10615  .  .  .  .  .  .  .  .  .  }
 10616  .  .  .  .  .  .  .  .  }
 10617  .  .  .  .  .  .  .  .  3: *syntax.CaseClause {
 10618  .  .  .  .  .  .  .  .  .  Cases: nil
 10619  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 10620  .  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 10621  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.Operation {
 10622  .  .  .  .  .  .  .  .  .  .  .  .  Op: &
 10623  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CompositeLit {
 10624  .  .  .  .  .  .  .  .  .  .  .  .  .  Type: ExprStmt
 10625  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (1 entries) {
 10626  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.KeyValueExpr {
 10627  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Key: X
 10628  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: lhs
 10629  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10630  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10631  .  .  .  .  .  .  .  .  .  .  .  .  .  NKeys: 1
 10632  .  .  .  .  .  .  .  .  .  .  .  .  .  EndLine: 1473
 10633  .  .  .  .  .  .  .  .  .  .  .  .  }
 10634  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 10635  .  .  .  .  .  .  .  .  .  .  .  }
 10636  .  .  .  .  .  .  .  .  .  .  }
 10637  .  .  .  .  .  .  .  .  .  }
 10638  .  .  .  .  .  .  .  .  }
 10639  .  .  .  .  .  .  .  }
 10640  .  .  .  .  .  .  }
 10641  .  .  .  .  .  }
 10642  .  .  .  .  .  Else: nil
 10643  .  .  .  .  }
 10644  .  .  .  .  4: *syntax.SwitchStmt {
 10645  .  .  .  .  .  Init: nil
 10646  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 10647  .  .  .  .  .  .  X: p
 10648  .  .  .  .  .  .  Sel: tok
 10649  .  .  .  .  .  }
 10650  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 10651  .  .  .  .  .  .  0: *syntax.CaseClause {
 10652  .  .  .  .  .  .  .  Cases: _Assign
 10653  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 10654  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10655  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10656  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10657  .  .  .  .  .  .  .  .  .  .  .  X: p
 10658  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 10659  .  .  .  .  .  .  .  .  .  .  }
 10660  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10661  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10662  .  .  .  .  .  .  .  .  .  }
 10663  .  .  .  .  .  .  .  .  }
 10664  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 10665  .  .  .  .  .  .  .  .  .  Init: nil
 10666  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 10667  .  .  .  .  .  .  .  .  .  .  Op: &&
 10668  .  .  .  .  .  .  .  .  .  .  X: rangeOk
 10669  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
 10670  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10671  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10672  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got
 10673  .  .  .  .  .  .  .  .  .  .  .  }
 10674  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10675  .  .  .  .  .  .  .  .  .  .  .  .  0: _Range
 10676  .  .  .  .  .  .  .  .  .  .  .  }
 10677  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10678  .  .  .  .  .  .  .  .  .  .  }
 10679  .  .  .  .  .  .  .  .  .  }
 10680  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 10681  .  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 10682  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 10683  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10684  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10685  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: rangeClause
 10686  .  .  .  .  .  .  .  .  .  .  .  .  }
 10687  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 10688  .  .  .  .  .  .  .  .  .  .  .  .  .  0: lhs
 10689  .  .  .  .  .  .  .  .  .  .  .  .  .  1: false
 10690  .  .  .  .  .  .  .  .  .  .  .  .  }
 10691  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10692  .  .  .  .  .  .  .  .  .  .  .  }
 10693  .  .  .  .  .  .  .  .  .  .  }
 10694  .  .  .  .  .  .  .  .  .  }
 10695  .  .  .  .  .  .  .  .  .  Else: nil
 10696  .  .  .  .  .  .  .  .  }
 10697  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 10698  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 10699  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10700  .  .  .  .  .  .  .  .  .  .  .  X: p
 10701  .  .  .  .  .  .  .  .  .  .  .  Sel: newAssignStmt
 10702  .  .  .  .  .  .  .  .  .  .  }
 10703  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 10704  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10705  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
 10706  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
 10707  .  .  .  .  .  .  .  .  .  .  .  }
 10708  .  .  .  .  .  .  .  .  .  .  .  1: lhs
 10709  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.CallExpr {
 10710  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10711  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10712  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList
 10713  .  .  .  .  .  .  .  .  .  .  .  .  }
 10714  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10715  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10716  .  .  .  .  .  .  .  .  .  .  .  }
 10717  .  .  .  .  .  .  .  .  .  .  }
 10718  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10719  .  .  .  .  .  .  .  .  .  }
 10720  .  .  .  .  .  .  .  .  }
 10721  .  .  .  .  .  .  .  }
 10722  .  .  .  .  .  .  }
 10723  .  .  .  .  .  .  1: *syntax.CaseClause {
 10724  .  .  .  .  .  .  .  Cases: _Define
 10725  .  .  .  .  .  .  .  Body: []syntax.Stmt (9 entries) {
 10726  .  .  .  .  .  .  .  .  0: *syntax.DeclStmt {
 10727  .  .  .  .  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
 10728  .  .  .  .  .  .  .  .  .  .  0: *syntax.VarDecl {
 10729  .  .  .  .  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
 10730  .  .  .  .  .  .  .  .  .  .  .  .  0: n
 10731  .  .  .  .  .  .  .  .  .  .  .  }
 10732  .  .  .  .  .  .  .  .  .  .  .  Type: node
 10733  .  .  .  .  .  .  .  .  .  .  .  Values: nil
 10734  .  .  .  .  .  .  .  .  .  .  .  Group: nil
 10735  .  .  .  .  .  .  .  .  .  .  }
 10736  .  .  .  .  .  .  .  .  .  }
 10737  .  .  .  .  .  .  .  .  }
 10738  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 10739  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10740  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10741  .  .  .  .  .  .  .  .  .  .  .  X: n
 10742  .  .  .  .  .  .  .  .  .  .  .  Sel: init
 10743  .  .  .  .  .  .  .  .  .  .  }
 10744  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10745  .  .  .  .  .  .  .  .  .  .  .  0: p
 10746  .  .  .  .  .  .  .  .  .  .  }
 10747  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10748  .  .  .  .  .  .  .  .  .  }
 10749  .  .  .  .  .  .  .  .  }
 10750  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 10751  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10752  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10753  .  .  .  .  .  .  .  .  .  .  .  X: p
 10754  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 10755  .  .  .  .  .  .  .  .  .  .  }
 10756  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10757  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10758  .  .  .  .  .  .  .  .  .  }
 10759  .  .  .  .  .  .  .  .  }
 10760  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
 10761  .  .  .  .  .  .  .  .  .  Init: nil
 10762  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 10763  .  .  .  .  .  .  .  .  .  .  Op: &&
 10764  .  .  .  .  .  .  .  .  .  .  X: rangeOk
 10765  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
 10766  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10767  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10768  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got
 10769  .  .  .  .  .  .  .  .  .  .  .  }
 10770  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10771  .  .  .  .  .  .  .  .  .  .  .  .  0: _Range
 10772  .  .  .  .  .  .  .  .  .  .  .  }
 10773  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10774  .  .  .  .  .  .  .  .  .  .  }
 10775  .  .  .  .  .  .  .  .  .  }
 10776  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 10777  .  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 10778  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 10779  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10780  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10781  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: rangeClause
 10782  .  .  .  .  .  .  .  .  .  .  .  .  }
 10783  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 10784  .  .  .  .  .  .  .  .  .  .  .  .  .  0: lhs
 10785  .  .  .  .  .  .  .  .  .  .  .  .  .  1: true
 10786  .  .  .  .  .  .  .  .  .  .  .  .  }
 10787  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10788  .  .  .  .  .  .  .  .  .  .  .  }
 10789  .  .  .  .  .  .  .  .  .  .  }
 10790  .  .  .  .  .  .  .  .  .  }
 10791  .  .  .  .  .  .  .  .  .  Else: nil
 10792  .  .  .  .  .  .  .  .  }
 10793  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
 10794  .  .  .  .  .  .  .  .  .  Op: :
 10795  .  .  .  .  .  .  .  .  .  Lhs: rhs
 10796  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10797  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10798  .  .  .  .  .  .  .  .  .  .  .  X: p
 10799  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList
 10800  .  .  .  .  .  .  .  .  .  .  }
 10801  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10802  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10803  .  .  .  .  .  .  .  .  .  }
 10804  .  .  .  .  .  .  .  .  }
 10805  .  .  .  .  .  .  .  .  5: *syntax.IfStmt {
 10806  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 10807  .  .  .  .  .  .  .  .  .  .  Op: :
 10808  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 10809  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 10810  .  .  .  .  .  .  .  .  .  .  .  .  0: x
 10811  .  .  .  .  .  .  .  .  .  .  .  .  1: ok
 10812  .  .  .  .  .  .  .  .  .  .  .  }
 10813  .  .  .  .  .  .  .  .  .  .  }
 10814  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 10815  .  .  .  .  .  .  .  .  .  .  .  X: rhs
 10816  .  .  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 10817  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
 10818  .  .  .  .  .  .  .  .  .  .  .  .  X: TypeSwitchGuard
 10819  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 10820  .  .  .  .  .  .  .  .  .  .  .  }
 10821  .  .  .  .  .  .  .  .  .  .  }
 10822  .  .  .  .  .  .  .  .  .  }
 10823  .  .  .  .  .  .  .  .  .  Cond: ok
 10824  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 10825  .  .  .  .  .  .  .  .  .  .  0: *syntax.SwitchStmt {
 10826  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 10827  .  .  .  .  .  .  .  .  .  .  .  Tag: *syntax.TypeSwitchGuard {
 10828  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: lhs
 10829  .  .  .  .  .  .  .  .  .  .  .  .  X: lhs
 10830  .  .  .  .  .  .  .  .  .  .  .  }
 10831  .  .  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 10832  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 10833  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.Operation {
 10834  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
 10835  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: Name
 10836  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 10837  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10838  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 10839  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10840  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10841  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10842  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x
 10843  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Lhs
 10844  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10845  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: lhs
 10846  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10847  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10848  .  .  .  .  .  .  .  .  .  .  .  .  }
 10849  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 10850  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.Operation {
 10851  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
 10852  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: ListExpr
 10853  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 10854  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10855  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 10856  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10857  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10858  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10859  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10860  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error
 10861  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10862  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10863  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
 10864  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10865  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt
 10866  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf
 10867  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10868  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 10869  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10870  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"argument count mismatch: %d = %d\""
 10871  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10872  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10873  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 10874  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: len
 10875  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10876  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 10877  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: lhs
 10878  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: ElemList
 10879  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10880  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10881  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10882  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10883  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.BasicLit {
 10884  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
 10885  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
 10886  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10887  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10888  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10889  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10890  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10891  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10892  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10893  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10894  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10895  .  .  .  .  .  .  .  .  .  .  .  .  }
 10896  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 10897  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: nil
 10898  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 10899  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10900  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10901  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10902  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 10903  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error
 10904  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10905  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10906  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
 10907  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10908  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt
 10909  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf
 10910  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10911  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 10912  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10913  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"invalid variable name %s in type switch\""
 10914  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10915  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10916  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: lhs
 10917  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10918  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10919  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10920  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10921  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10922  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10923  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10924  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10925  .  .  .  .  .  .  .  .  .  .  .  .  }
 10926  .  .  .  .  .  .  .  .  .  .  .  }
 10927  .  .  .  .  .  .  .  .  .  .  }
 10928  .  .  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
 10929  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.Operation {
 10930  .  .  .  .  .  .  .  .  .  .  .  .  Op: &
 10931  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CompositeLit {
 10932  .  .  .  .  .  .  .  .  .  .  .  .  .  Type: ExprStmt
 10933  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (1 entries) {
 10934  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.KeyValueExpr {
 10935  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Key: X
 10936  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: x
 10937  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10938  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10939  .  .  .  .  .  .  .  .  .  .  .  .  .  NKeys: 1
 10940  .  .  .  .  .  .  .  .  .  .  .  .  .  EndLine: 1513
 10941  .  .  .  .  .  .  .  .  .  .  .  .  }
 10942  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 10943  .  .  .  .  .  .  .  .  .  .  .  }
 10944  .  .  .  .  .  .  .  .  .  .  }
 10945  .  .  .  .  .  .  .  .  .  }
 10946  .  .  .  .  .  .  .  .  .  Else: nil
 10947  .  .  .  .  .  .  .  .  }
 10948  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
 10949  .  .  .  .  .  .  .  .  .  Op: :
 10950  .  .  .  .  .  .  .  .  .  Lhs: as
 10951  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10952  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10953  .  .  .  .  .  .  .  .  .  .  .  X: p
 10954  .  .  .  .  .  .  .  .  .  .  .  Sel: newAssignStmt
 10955  .  .  .  .  .  .  .  .  .  .  }
 10956  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 10957  .  .  .  .  .  .  .  .  .  .  .  0: Def
 10958  .  .  .  .  .  .  .  .  .  .  .  1: lhs
 10959  .  .  .  .  .  .  .  .  .  .  .  2: rhs
 10960  .  .  .  .  .  .  .  .  .  .  }
 10961  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10962  .  .  .  .  .  .  .  .  .  }
 10963  .  .  .  .  .  .  .  .  }
 10964  .  .  .  .  .  .  .  .  7: *syntax.IfStmt {
 10965  .  .  .  .  .  .  .  .  .  Init: nil
 10966  .  .  .  .  .  .  .  .  .  Cond: gcCompat
 10967  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 10968  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10969  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10970  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10971  .  .  .  .  .  .  .  .  .  .  .  .  X: as
 10972  .  .  .  .  .  .  .  .  .  .  .  .  Sel: node
 10973  .  .  .  .  .  .  .  .  .  .  .  }
 10974  .  .  .  .  .  .  .  .  .  .  .  Rhs: n
 10975  .  .  .  .  .  .  .  .  .  .  }
 10976  .  .  .  .  .  .  .  .  .  }
 10977  .  .  .  .  .  .  .  .  .  Else: nil
 10978  .  .  .  .  .  .  .  .  }
 10979  .  .  .  .  .  .  .  .  8: *syntax.ReturnStmt {
 10980  .  .  .  .  .  .  .  .  .  Results: as
 10981  .  .  .  .  .  .  .  .  }
 10982  .  .  .  .  .  .  .  }
 10983  .  .  .  .  .  .  }
 10984  .  .  .  .  .  .  2: *syntax.CaseClause {
 10985  .  .  .  .  .  .  .  Cases: nil
 10986  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 10987  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10988  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10989  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10990  .  .  .  .  .  .  .  .  .  .  .  X: p
 10991  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
 10992  .  .  .  .  .  .  .  .  .  .  }
 10993  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10994  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10995  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting := or = or comma\""
 10996  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10997  .  .  .  .  .  .  .  .  .  .  .  }
 10998  .  .  .  .  .  .  .  .  .  .  }
 10999  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11000  .  .  .  .  .  .  .  .  .  }
 11001  .  .  .  .  .  .  .  .  }
 11002  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 11003  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 11004  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11005  .  .  .  .  .  .  .  .  .  .  .  X: p
 11006  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
 11007  .  .  .  .  .  .  .  .  .  .  }
 11008  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 11009  .  .  .  .  .  .  .  .  .  .  .  0: _Semi
 11010  .  .  .  .  .  .  .  .  .  .  .  1: _Rbrace
 11011  .  .  .  .  .  .  .  .  .  .  }
 11012  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11013  .  .  .  .  .  .  .  .  .  }
 11014  .  .  .  .  .  .  .  .  }
 11015  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 11016  .  .  .  .  .  .  .  .  .  Results: nil
 11017  .  .  .  .  .  .  .  .  }
 11018  .  .  .  .  .  .  .  }
 11019  .  .  .  .  .  .  }
 11020  .  .  .  .  .  }
 11021  .  .  .  .  }
 11022  .  .  .  }
 11023  .  .  .  Pragma: 0
 11024  .  .  .  EndLine: 1527
 11025  .  .  }
 11026  .  .  51: *syntax.FuncDecl {
 11027  .  .  .  Attr: map[]
 11028  .  .  .  Recv: *syntax.Field {
 11029  .  .  .  .  Name: p
 11030  .  .  .  .  Type: *syntax.Operation {
 11031  .  .  .  .  .  Op: *
 11032  .  .  .  .  .  X: parser
 11033  .  .  .  .  .  Y: nil
 11034  .  .  .  .  }
 11035  .  .  .  }
 11036  .  .  .  Name: rangeClause
 11037  .  .  .  Type: *syntax.FuncType {
 11038  .  .  .  .  ParamList: []*syntax.Field (2 entries) {
 11039  .  .  .  .  .  0: *syntax.Field {
 11040  .  .  .  .  .  .  Name: lhs
 11041  .  .  .  .  .  .  Type: Expr
 11042  .  .  .  .  .  }
 11043  .  .  .  .  .  1: *syntax.Field {
 11044  .  .  .  .  .  .  Name: def
 11045  .  .  .  .  .  .  Type: bool
 11046  .  .  .  .  .  }
 11047  .  .  .  .  }
 11048  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 11049  .  .  .  .  .  0: *syntax.Field {
 11050  .  .  .  .  .  .  Name: nil
 11051  .  .  .  .  .  .  Type: *syntax.Operation {
 11052  .  .  .  .  .  .  .  Op: *
 11053  .  .  .  .  .  .  .  X: RangeClause
 11054  .  .  .  .  .  .  .  Y: nil
 11055  .  .  .  .  .  .  }
 11056  .  .  .  .  .  }
 11057  .  .  .  .  }
 11058  .  .  .  }
 11059  .  .  .  Body: []syntax.Stmt (7 entries) {
 11060  .  .  .  .  0: *syntax.AssignStmt {
 11061  .  .  .  .  .  Op: :
 11062  .  .  .  .  .  Lhs: r
 11063  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11064  .  .  .  .  .  .  Fun: new
 11065  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11066  .  .  .  .  .  .  .  0: RangeClause
 11067  .  .  .  .  .  .  }
 11068  .  .  .  .  .  .  HasDots: false
 11069  .  .  .  .  .  }
 11070  .  .  .  .  }
 11071  .  .  .  .  1: *syntax.ExprStmt {
 11072  .  .  .  .  .  X: *syntax.CallExpr {
 11073  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11074  .  .  .  .  .  .  .  X: r
 11075  .  .  .  .  .  .  .  Sel: init
 11076  .  .  .  .  .  .  }
 11077  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11078  .  .  .  .  .  .  .  0: p
 11079  .  .  .  .  .  .  }
 11080  .  .  .  .  .  .  HasDots: false
 11081  .  .  .  .  .  }
 11082  .  .  .  .  }
 11083  .  .  .  .  2: *syntax.AssignStmt {
 11084  .  .  .  .  .  Op: <op-0>
 11085  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11086  .  .  .  .  .  .  X: r
 11087  .  .  .  .  .  .  Sel: Lhs
 11088  .  .  .  .  .  }
 11089  .  .  .  .  .  Rhs: lhs
 11090  .  .  .  .  }
 11091  .  .  .  .  3: *syntax.AssignStmt {
 11092  .  .  .  .  .  Op: <op-0>
 11093  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11094  .  .  .  .  .  .  X: r
 11095  .  .  .  .  .  .  Sel: Def
 11096  .  .  .  .  .  }
 11097  .  .  .  .  .  Rhs: def
 11098  .  .  .  .  }
 11099  .  .  .  .  4: *syntax.AssignStmt {
 11100  .  .  .  .  .  Op: <op-0>
 11101  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11102  .  .  .  .  .  .  X: r
 11103  .  .  .  .  .  .  Sel: X
 11104  .  .  .  .  .  }
 11105  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11106  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11107  .  .  .  .  .  .  .  X: p
 11108  .  .  .  .  .  .  .  Sel: expr
 11109  .  .  .  .  .  .  }
 11110  .  .  .  .  .  .  ArgList: nil
 11111  .  .  .  .  .  .  HasDots: false
 11112  .  .  .  .  .  }
 11113  .  .  .  .  }
 11114  .  .  .  .  5: *syntax.IfStmt {
 11115  .  .  .  .  .  Init: nil
 11116  .  .  .  .  .  Cond: gcCompat
 11117  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 11118  .  .  .  .  .  .  0: *syntax.ExprStmt {
 11119  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 11120  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11121  .  .  .  .  .  .  .  .  .  X: r
 11122  .  .  .  .  .  .  .  .  .  Sel: init
 11123  .  .  .  .  .  .  .  .  }
 11124  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11125  .  .  .  .  .  .  .  .  .  0: p
 11126  .  .  .  .  .  .  .  .  }
 11127  .  .  .  .  .  .  .  .  HasDots: false
 11128  .  .  .  .  .  .  .  }
 11129  .  .  .  .  .  .  }
 11130  .  .  .  .  .  }
 11131  .  .  .  .  .  Else: nil
 11132  .  .  .  .  }
 11133  .  .  .  .  6: *syntax.ReturnStmt {
 11134  .  .  .  .  .  Results: r
 11135  .  .  .  .  }
 11136  .  .  .  }
 11137  .  .  .  Pragma: 0
 11138  .  .  .  EndLine: 1539
 11139  .  .  }
 11140  .  .  52: *syntax.FuncDecl {
 11141  .  .  .  Attr: map[]
 11142  .  .  .  Recv: *syntax.Field {
 11143  .  .  .  .  Name: p
 11144  .  .  .  .  Type: *syntax.Operation {
 11145  .  .  .  .  .  Op: *
 11146  .  .  .  .  .  X: parser
 11147  .  .  .  .  .  Y: nil
 11148  .  .  .  .  }
 11149  .  .  .  }
 11150  .  .  .  Name: newAssignStmt
 11151  .  .  .  Type: *syntax.FuncType {
 11152  .  .  .  .  ParamList: []*syntax.Field (3 entries) {
 11153  .  .  .  .  .  0: *syntax.Field {
 11154  .  .  .  .  .  .  Name: op
 11155  .  .  .  .  .  .  Type: Operator
 11156  .  .  .  .  .  }
 11157  .  .  .  .  .  1: *syntax.Field {
 11158  .  .  .  .  .  .  Name: lhs
 11159  .  .  .  .  .  .  Type: Expr
 11160  .  .  .  .  .  }
 11161  .  .  .  .  .  2: *syntax.Field {
 11162  .  .  .  .  .  .  Name: rhs
 11163  .  .  .  .  .  .  Type: Expr
 11164  .  .  .  .  .  }
 11165  .  .  .  .  }
 11166  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 11167  .  .  .  .  .  0: *syntax.Field {
 11168  .  .  .  .  .  .  Name: nil
 11169  .  .  .  .  .  .  Type: *syntax.Operation {
 11170  .  .  .  .  .  .  .  Op: *
 11171  .  .  .  .  .  .  .  X: AssignStmt
 11172  .  .  .  .  .  .  .  Y: nil
 11173  .  .  .  .  .  .  }
 11174  .  .  .  .  .  }
 11175  .  .  .  .  }
 11176  .  .  .  }
 11177  .  .  .  Body: []syntax.Stmt (6 entries) {
 11178  .  .  .  .  0: *syntax.AssignStmt {
 11179  .  .  .  .  .  Op: :
 11180  .  .  .  .  .  Lhs: a
 11181  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11182  .  .  .  .  .  .  Fun: new
 11183  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11184  .  .  .  .  .  .  .  0: AssignStmt
 11185  .  .  .  .  .  .  }
 11186  .  .  .  .  .  .  HasDots: false
 11187  .  .  .  .  .  }
 11188  .  .  .  .  }
 11189  .  .  .  .  1: *syntax.ExprStmt {
 11190  .  .  .  .  .  X: *syntax.CallExpr {
 11191  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11192  .  .  .  .  .  .  .  X: a
 11193  .  .  .  .  .  .  .  Sel: init
 11194  .  .  .  .  .  .  }
 11195  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11196  .  .  .  .  .  .  .  0: p
 11197  .  .  .  .  .  .  }
 11198  .  .  .  .  .  .  HasDots: false
 11199  .  .  .  .  .  }
 11200  .  .  .  .  }
 11201  .  .  .  .  2: *syntax.AssignStmt {
 11202  .  .  .  .  .  Op: <op-0>
 11203  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11204  .  .  .  .  .  .  X: a
 11205  .  .  .  .  .  .  Sel: Op
 11206  .  .  .  .  .  }
 11207  .  .  .  .  .  Rhs: op
 11208  .  .  .  .  }
 11209  .  .  .  .  3: *syntax.AssignStmt {
 11210  .  .  .  .  .  Op: <op-0>
 11211  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11212  .  .  .  .  .  .  X: a
 11213  .  .  .  .  .  .  Sel: Lhs
 11214  .  .  .  .  .  }
 11215  .  .  .  .  .  Rhs: lhs
 11216  .  .  .  .  }
 11217  .  .  .  .  4: *syntax.AssignStmt {
 11218  .  .  .  .  .  Op: <op-0>
 11219  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11220  .  .  .  .  .  .  X: a
 11221  .  .  .  .  .  .  Sel: Rhs
 11222  .  .  .  .  .  }
 11223  .  .  .  .  .  Rhs: rhs
 11224  .  .  .  .  }
 11225  .  .  .  .  5: *syntax.ReturnStmt {
 11226  .  .  .  .  .  Results: a
 11227  .  .  .  .  }
 11228  .  .  .  }
 11229  .  .  .  Pragma: 0
 11230  .  .  .  EndLine: 1548
 11231  .  .  }
 11232  .  .  53: *syntax.FuncDecl {
 11233  .  .  .  Attr: map[]
 11234  .  .  .  Recv: *syntax.Field {
 11235  .  .  .  .  Name: p
 11236  .  .  .  .  Type: *syntax.Operation {
 11237  .  .  .  .  .  Op: *
 11238  .  .  .  .  .  X: parser
 11239  .  .  .  .  .  Y: nil
 11240  .  .  .  .  }
 11241  .  .  .  }
 11242  .  .  .  Name: labeledStmt
 11243  .  .  .  Type: *syntax.FuncType {
 11244  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 11245  .  .  .  .  .  0: *syntax.Field {
 11246  .  .  .  .  .  .  Name: label
 11247  .  .  .  .  .  .  Type: *syntax.Operation {
 11248  .  .  .  .  .  .  .  Op: *
 11249  .  .  .  .  .  .  .  X: Name
 11250  .  .  .  .  .  .  .  Y: nil
 11251  .  .  .  .  .  .  }
 11252  .  .  .  .  .  }
 11253  .  .  .  .  }
 11254  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 11255  .  .  .  .  .  0: *syntax.Field {
 11256  .  .  .  .  .  .  Name: nil
 11257  .  .  .  .  .  .  Type: Stmt
 11258  .  .  .  .  .  }
 11259  .  .  .  .  }
 11260  .  .  .  }
 11261  .  .  .  Body: []syntax.Stmt (7 entries) {
 11262  .  .  .  .  0: *syntax.IfStmt {
 11263  .  .  .  .  .  Init: nil
 11264  .  .  .  .  .  Cond: trace
 11265  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 11266  .  .  .  .  .  .  0: *syntax.CallStmt {
 11267  .  .  .  .  .  .  .  Tok: defer
 11268  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 11269  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 11270  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11271  .  .  .  .  .  .  .  .  .  .  X: p
 11272  .  .  .  .  .  .  .  .  .  .  Sel: trace
 11273  .  .  .  .  .  .  .  .  .  }
 11274  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11275  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11276  .  .  .  .  .  .  .  .  .  .  .  Value: "\"labeledStmt\""
 11277  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11278  .  .  .  .  .  .  .  .  .  .  }
 11279  .  .  .  .  .  .  .  .  .  }
 11280  .  .  .  .  .  .  .  .  .  HasDots: false
 11281  .  .  .  .  .  .  .  .  }
 11282  .  .  .  .  .  .  .  .  ArgList: nil
 11283  .  .  .  .  .  .  .  .  HasDots: false
 11284  .  .  .  .  .  .  .  }
 11285  .  .  .  .  .  .  }
 11286  .  .  .  .  .  }
 11287  .  .  .  .  .  Else: nil
 11288  .  .  .  .  }
 11289  .  .  .  .  1: *syntax.AssignStmt {
 11290  .  .  .  .  .  Op: :
 11291  .  .  .  .  .  Lhs: s
 11292  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11293  .  .  .  .  .  .  Fun: new
 11294  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11295  .  .  .  .  .  .  .  0: LabeledStmt
 11296  .  .  .  .  .  .  }
 11297  .  .  .  .  .  .  HasDots: false
 11298  .  .  .  .  .  }
 11299  .  .  .  .  }
 11300  .  .  .  .  2: *syntax.ExprStmt {
 11301  .  .  .  .  .  X: *syntax.CallExpr {
 11302  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11303  .  .  .  .  .  .  .  X: s
 11304  .  .  .  .  .  .  .  Sel: init
 11305  .  .  .  .  .  .  }
 11306  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11307  .  .  .  .  .  .  .  0: p
 11308  .  .  .  .  .  .  }
 11309  .  .  .  .  .  .  HasDots: false
 11310  .  .  .  .  .  }
 11311  .  .  .  .  }
 11312  .  .  .  .  3: *syntax.AssignStmt {
 11313  .  .  .  .  .  Op: <op-0>
 11314  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11315  .  .  .  .  .  .  X: s
 11316  .  .  .  .  .  .  Sel: Label
 11317  .  .  .  .  .  }
 11318  .  .  .  .  .  Rhs: label
 11319  .  .  .  .  }
 11320  .  .  .  .  4: *syntax.ExprStmt {
 11321  .  .  .  .  .  X: *syntax.CallExpr {
 11322  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11323  .  .  .  .  .  .  .  X: p
 11324  .  .  .  .  .  .  .  Sel: want
 11325  .  .  .  .  .  .  }
 11326  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11327  .  .  .  .  .  .  .  0: _Colon
 11328  .  .  .  .  .  .  }
 11329  .  .  .  .  .  .  HasDots: false
 11330  .  .  .  .  .  }
 11331  .  .  .  .  }
 11332  .  .  .  .  5: *syntax.IfStmt {
 11333  .  .  .  .  .  Init: nil
 11334  .  .  .  .  .  Cond: *syntax.Operation {
 11335  .  .  .  .  .  .  Op: &&
 11336  .  .  .  .  .  .  X: *syntax.Operation {
 11337  .  .  .  .  .  .  .  Op: !=
 11338  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11339  .  .  .  .  .  .  .  .  X: p
 11340  .  .  .  .  .  .  .  .  Sel: tok
 11341  .  .  .  .  .  .  .  }
 11342  .  .  .  .  .  .  .  Y: _Rbrace
 11343  .  .  .  .  .  .  }
 11344  .  .  .  .  .  .  Y: *syntax.Operation {
 11345  .  .  .  .  .  .  .  Op: !=
 11346  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11347  .  .  .  .  .  .  .  .  X: p
 11348  .  .  .  .  .  .  .  .  Sel: tok
 11349  .  .  .  .  .  .  .  }
 11350  .  .  .  .  .  .  .  Y: _EOF
 11351  .  .  .  .  .  .  }
 11352  .  .  .  .  .  }
 11353  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 11354  .  .  .  .  .  .  0: *syntax.AssignStmt {
 11355  .  .  .  .  .  .  .  Op: <op-0>
 11356  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11357  .  .  .  .  .  .  .  .  X: s
 11358  .  .  .  .  .  .  .  .  Sel: Stmt
 11359  .  .  .  .  .  .  .  }
 11360  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11361  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11362  .  .  .  .  .  .  .  .  .  X: p
 11363  .  .  .  .  .  .  .  .  .  Sel: stmt
 11364  .  .  .  .  .  .  .  .  }
 11365  .  .  .  .  .  .  .  .  ArgList: nil
 11366  .  .  .  .  .  .  .  .  HasDots: false
 11367  .  .  .  .  .  .  .  }
 11368  .  .  .  .  .  .  }
 11369  .  .  .  .  .  .  1: *syntax.IfStmt {
 11370  .  .  .  .  .  .  .  Init: nil
 11371  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11372  .  .  .  .  .  .  .  .  Op: ==
 11373  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11374  .  .  .  .  .  .  .  .  .  X: s
 11375  .  .  .  .  .  .  .  .  .  Sel: Stmt
 11376  .  .  .  .  .  .  .  .  }
 11377  .  .  .  .  .  .  .  .  Y: missing_stmt
 11378  .  .  .  .  .  .  .  }
 11379  .  .  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 11380  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 11381  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 11382  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11383  .  .  .  .  .  .  .  .  .  .  .  X: p
 11384  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error_at
 11385  .  .  .  .  .  .  .  .  .  .  }
 11386  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 11387  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
 11388  .  .  .  .  .  .  .  .  .  .  .  .  Fun: int
 11389  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11390  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 11391  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: label
 11392  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos
 11393  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11394  .  .  .  .  .  .  .  .  .  .  .  .  }
 11395  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11396  .  .  .  .  .  .  .  .  .  .  .  }
 11397  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 11398  .  .  .  .  .  .  .  .  .  .  .  .  Fun: int
 11399  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11400  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 11401  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: label
 11402  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: line
 11403  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11404  .  .  .  .  .  .  .  .  .  .  .  .  }
 11405  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11406  .  .  .  .  .  .  .  .  .  .  .  }
 11407  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.BasicLit {
 11408  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"missing statement after label\""
 11409  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11410  .  .  .  .  .  .  .  .  .  .  .  }
 11411  .  .  .  .  .  .  .  .  .  .  }
 11412  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11413  .  .  .  .  .  .  .  .  .  }
 11414  .  .  .  .  .  .  .  .  }
 11415  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
 11416  .  .  .  .  .  .  .  .  .  Results: missing_stmt
 11417  .  .  .  .  .  .  .  .  }
 11418  .  .  .  .  .  .  .  }
 11419  .  .  .  .  .  .  .  Else: nil
 11420  .  .  .  .  .  .  }
 11421  .  .  .  .  .  }
 11422  .  .  .  .  .  Else: nil
 11423  .  .  .  .  }
 11424  .  .  .  .  6: *syntax.ReturnStmt {
 11425  .  .  .  .  .  Results: s
 11426  .  .  .  .  }
 11427  .  .  .  }
 11428  .  .  .  Pragma: 0
 11429  .  .  .  EndLine: 1572
 11430  .  .  }
 11431  .  .  54: *syntax.FuncDecl {
 11432  .  .  .  Attr: map[]
 11433  .  .  .  Recv: *syntax.Field {
 11434  .  .  .  .  Name: p
 11435  .  .  .  .  Type: *syntax.Operation {
 11436  .  .  .  .  .  Op: *
 11437  .  .  .  .  .  X: parser
 11438  .  .  .  .  .  Y: nil
 11439  .  .  .  .  }
 11440  .  .  .  }
 11441  .  .  .  Name: blockStmt
 11442  .  .  .  Type: *syntax.FuncType {
 11443  .  .  .  .  ParamList: nil
 11444  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 11445  .  .  .  .  .  0: *syntax.Field {
 11446  .  .  .  .  .  .  Name: nil
 11447  .  .  .  .  .  .  Type: *syntax.Operation {
 11448  .  .  .  .  .  .  .  Op: *
 11449  .  .  .  .  .  .  .  X: BlockStmt
 11450  .  .  .  .  .  .  .  Y: nil
 11451  .  .  .  .  .  .  }
 11452  .  .  .  .  .  }
 11453  .  .  .  .  }
 11454  .  .  .  }
 11455  .  .  .  Body: []syntax.Stmt (7 entries) {
 11456  .  .  .  .  0: *syntax.IfStmt {
 11457  .  .  .  .  .  Init: nil
 11458  .  .  .  .  .  Cond: trace
 11459  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 11460  .  .  .  .  .  .  0: *syntax.CallStmt {
 11461  .  .  .  .  .  .  .  Tok: defer
 11462  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 11463  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 11464  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11465  .  .  .  .  .  .  .  .  .  .  X: p
 11466  .  .  .  .  .  .  .  .  .  .  Sel: trace
 11467  .  .  .  .  .  .  .  .  .  }
 11468  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11469  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11470  .  .  .  .  .  .  .  .  .  .  .  Value: "\"blockStmt\""
 11471  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11472  .  .  .  .  .  .  .  .  .  .  }
 11473  .  .  .  .  .  .  .  .  .  }
 11474  .  .  .  .  .  .  .  .  .  HasDots: false
 11475  .  .  .  .  .  .  .  .  }
 11476  .  .  .  .  .  .  .  .  ArgList: nil
 11477  .  .  .  .  .  .  .  .  HasDots: false
 11478  .  .  .  .  .  .  .  }
 11479  .  .  .  .  .  .  }
 11480  .  .  .  .  .  }
 11481  .  .  .  .  .  Else: nil
 11482  .  .  .  .  }
 11483  .  .  .  .  1: *syntax.AssignStmt {
 11484  .  .  .  .  .  Op: :
 11485  .  .  .  .  .  Lhs: s
 11486  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11487  .  .  .  .  .  .  Fun: new
 11488  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11489  .  .  .  .  .  .  .  0: BlockStmt
 11490  .  .  .  .  .  .  }
 11491  .  .  .  .  .  .  HasDots: false
 11492  .  .  .  .  .  }
 11493  .  .  .  .  }
 11494  .  .  .  .  2: *syntax.ExprStmt {
 11495  .  .  .  .  .  X: *syntax.CallExpr {
 11496  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11497  .  .  .  .  .  .  .  X: s
 11498  .  .  .  .  .  .  .  Sel: init
 11499  .  .  .  .  .  .  }
 11500  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11501  .  .  .  .  .  .  .  0: p
 11502  .  .  .  .  .  .  }
 11503  .  .  .  .  .  .  HasDots: false
 11504  .  .  .  .  .  }
 11505  .  .  .  .  }
 11506  .  .  .  .  3: *syntax.ExprStmt {
 11507  .  .  .  .  .  X: *syntax.CallExpr {
 11508  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11509  .  .  .  .  .  .  .  X: p
 11510  .  .  .  .  .  .  .  Sel: want
 11511  .  .  .  .  .  .  }
 11512  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11513  .  .  .  .  .  .  .  0: _Lbrace
 11514  .  .  .  .  .  .  }
 11515  .  .  .  .  .  .  HasDots: false
 11516  .  .  .  .  .  }
 11517  .  .  .  .  }
 11518  .  .  .  .  4: *syntax.AssignStmt {
 11519  .  .  .  .  .  Op: <op-0>
 11520  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11521  .  .  .  .  .  .  X: s
 11522  .  .  .  .  .  .  Sel: Body
 11523  .  .  .  .  .  }
 11524  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11525  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11526  .  .  .  .  .  .  .  X: p
 11527  .  .  .  .  .  .  .  Sel: stmtList
 11528  .  .  .  .  .  .  }
 11529  .  .  .  .  .  .  ArgList: nil
 11530  .  .  .  .  .  .  HasDots: false
 11531  .  .  .  .  .  }
 11532  .  .  .  .  }
 11533  .  .  .  .  5: *syntax.ExprStmt {
 11534  .  .  .  .  .  X: *syntax.CallExpr {
 11535  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11536  .  .  .  .  .  .  .  X: p
 11537  .  .  .  .  .  .  .  Sel: want
 11538  .  .  .  .  .  .  }
 11539  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11540  .  .  .  .  .  .  .  0: _Rbrace
 11541  .  .  .  .  .  .  }
 11542  .  .  .  .  .  .  HasDots: false
 11543  .  .  .  .  .  }
 11544  .  .  .  .  }
 11545  .  .  .  .  6: *syntax.ReturnStmt {
 11546  .  .  .  .  .  Results: s
 11547  .  .  .  .  }
 11548  .  .  .  }
 11549  .  .  .  Pragma: 0
 11550  .  .  .  EndLine: 1586
 11551  .  .  }
 11552  .  .  55: *syntax.FuncDecl {
 11553  .  .  .  Attr: map[]
 11554  .  .  .  Recv: *syntax.Field {
 11555  .  .  .  .  Name: p
 11556  .  .  .  .  Type: *syntax.Operation {
 11557  .  .  .  .  .  Op: *
 11558  .  .  .  .  .  X: parser
 11559  .  .  .  .  .  Y: nil
 11560  .  .  .  .  }
 11561  .  .  .  }
 11562  .  .  .  Name: declStmt
 11563  .  .  .  Type: *syntax.FuncType {
 11564  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 11565  .  .  .  .  .  0: *syntax.Field {
 11566  .  .  .  .  .  .  Name: f
 11567  .  .  .  .  .  .  Type: *syntax.FuncType {
 11568  .  .  .  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 11569  .  .  .  .  .  .  .  .  0: *syntax.Field {
 11570  .  .  .  .  .  .  .  .  .  Name: nil
 11571  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 11572  .  .  .  .  .  .  .  .  .  .  Op: *
 11573  .  .  .  .  .  .  .  .  .  .  X: Group
 11574  .  .  .  .  .  .  .  .  .  .  Y: nil
 11575  .  .  .  .  .  .  .  .  .  }
 11576  .  .  .  .  .  .  .  .  }
 11577  .  .  .  .  .  .  .  }
 11578  .  .  .  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 11579  .  .  .  .  .  .  .  .  0: *syntax.Field {
 11580  .  .  .  .  .  .  .  .  .  Name: nil
 11581  .  .  .  .  .  .  .  .  .  Type: Decl
 11582  .  .  .  .  .  .  .  .  }
 11583  .  .  .  .  .  .  .  }
 11584  .  .  .  .  .  .  }
 11585  .  .  .  .  .  }
 11586  .  .  .  .  }
 11587  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 11588  .  .  .  .  .  0: *syntax.Field {
 11589  .  .  .  .  .  .  Name: nil
 11590  .  .  .  .  .  .  Type: *syntax.Operation {
 11591  .  .  .  .  .  .  .  Op: *
 11592  .  .  .  .  .  .  .  X: DeclStmt
 11593  .  .  .  .  .  .  .  Y: nil
 11594  .  .  .  .  .  .  }
 11595  .  .  .  .  .  }
 11596  .  .  .  .  }
 11597  .  .  .  }
 11598  .  .  .  Body: []syntax.Stmt (6 entries) {
 11599  .  .  .  .  0: *syntax.IfStmt {
 11600  .  .  .  .  .  Init: nil
 11601  .  .  .  .  .  Cond: trace
 11602  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 11603  .  .  .  .  .  .  0: *syntax.CallStmt {
 11604  .  .  .  .  .  .  .  Tok: defer
 11605  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 11606  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 11607  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11608  .  .  .  .  .  .  .  .  .  .  X: p
 11609  .  .  .  .  .  .  .  .  .  .  Sel: trace
 11610  .  .  .  .  .  .  .  .  .  }
 11611  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11612  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11613  .  .  .  .  .  .  .  .  .  .  .  Value: "\"declStmt\""
 11614  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11615  .  .  .  .  .  .  .  .  .  .  }
 11616  .  .  .  .  .  .  .  .  .  }
 11617  .  .  .  .  .  .  .  .  .  HasDots: false
 11618  .  .  .  .  .  .  .  .  }
 11619  .  .  .  .  .  .  .  .  ArgList: nil
 11620  .  .  .  .  .  .  .  .  HasDots: false
 11621  .  .  .  .  .  .  .  }
 11622  .  .  .  .  .  .  }
 11623  .  .  .  .  .  }
 11624  .  .  .  .  .  Else: nil
 11625  .  .  .  .  }
 11626  .  .  .  .  1: *syntax.AssignStmt {
 11627  .  .  .  .  .  Op: :
 11628  .  .  .  .  .  Lhs: s
 11629  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11630  .  .  .  .  .  .  Fun: new
 11631  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11632  .  .  .  .  .  .  .  0: DeclStmt
 11633  .  .  .  .  .  .  }
 11634  .  .  .  .  .  .  HasDots: false
 11635  .  .  .  .  .  }
 11636  .  .  .  .  }
 11637  .  .  .  .  2: *syntax.ExprStmt {
 11638  .  .  .  .  .  X: *syntax.CallExpr {
 11639  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11640  .  .  .  .  .  .  .  X: s
 11641  .  .  .  .  .  .  .  Sel: init
 11642  .  .  .  .  .  .  }
 11643  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11644  .  .  .  .  .  .  .  0: p
 11645  .  .  .  .  .  .  }
 11646  .  .  .  .  .  .  HasDots: false
 11647  .  .  .  .  .  }
 11648  .  .  .  .  }
 11649  .  .  .  .  3: *syntax.ExprStmt {
 11650  .  .  .  .  .  X: *syntax.CallExpr {
 11651  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11652  .  .  .  .  .  .  .  X: p
 11653  .  .  .  .  .  .  .  Sel: next
 11654  .  .  .  .  .  .  }
 11655  .  .  .  .  .  .  ArgList: nil
 11656  .  .  .  .  .  .  HasDots: false
 11657  .  .  .  .  .  }
 11658  .  .  .  .  }
 11659  .  .  .  .  4: *syntax.AssignStmt {
 11660  .  .  .  .  .  Op: <op-0>
 11661  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11662  .  .  .  .  .  .  X: s
 11663  .  .  .  .  .  .  Sel: DeclList
 11664  .  .  .  .  .  }
 11665  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11666  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11667  .  .  .  .  .  .  .  X: p
 11668  .  .  .  .  .  .  .  Sel: appendGroup
 11669  .  .  .  .  .  .  }
 11670  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 11671  .  .  .  .  .  .  .  0: nil
 11672  .  .  .  .  .  .  .  1: f
 11673  .  .  .  .  .  .  }
 11674  .  .  .  .  .  .  HasDots: false
 11675  .  .  .  .  .  }
 11676  .  .  .  .  }
 11677  .  .  .  .  5: *syntax.ReturnStmt {
 11678  .  .  .  .  .  Results: s
 11679  .  .  .  .  }
 11680  .  .  .  }
 11681  .  .  .  Pragma: 0
 11682  .  .  .  EndLine: 1600
 11683  .  .  }
 11684  .  .  56: *syntax.FuncDecl {
 11685  .  .  .  Attr: map[]
 11686  .  .  .  Recv: *syntax.Field {
 11687  .  .  .  .  Name: p
 11688  .  .  .  .  Type: *syntax.Operation {
 11689  .  .  .  .  .  Op: *
 11690  .  .  .  .  .  X: parser
 11691  .  .  .  .  .  Y: nil
 11692  .  .  .  .  }
 11693  .  .  .  }
 11694  .  .  .  Name: forStmt
 11695  .  .  .  Type: *syntax.FuncType {
 11696  .  .  .  .  ParamList: nil
 11697  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 11698  .  .  .  .  .  0: *syntax.Field {
 11699  .  .  .  .  .  .  Name: nil
 11700  .  .  .  .  .  .  Type: Stmt
 11701  .  .  .  .  .  }
 11702  .  .  .  .  }
 11703  .  .  .  }
 11704  .  .  .  Body: []syntax.Stmt (8 entries) {
 11705  .  .  .  .  0: *syntax.IfStmt {
 11706  .  .  .  .  .  Init: nil
 11707  .  .  .  .  .  Cond: trace
 11708  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 11709  .  .  .  .  .  .  0: *syntax.CallStmt {
 11710  .  .  .  .  .  .  .  Tok: defer
 11711  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 11712  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 11713  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11714  .  .  .  .  .  .  .  .  .  .  X: p
 11715  .  .  .  .  .  .  .  .  .  .  Sel: trace
 11716  .  .  .  .  .  .  .  .  .  }
 11717  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11718  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11719  .  .  .  .  .  .  .  .  .  .  .  Value: "\"forStmt\""
 11720  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11721  .  .  .  .  .  .  .  .  .  .  }
 11722  .  .  .  .  .  .  .  .  .  }
 11723  .  .  .  .  .  .  .  .  .  HasDots: false
 11724  .  .  .  .  .  .  .  .  }
 11725  .  .  .  .  .  .  .  .  ArgList: nil
 11726  .  .  .  .  .  .  .  .  HasDots: false
 11727  .  .  .  .  .  .  .  }
 11728  .  .  .  .  .  .  }
 11729  .  .  .  .  .  }
 11730  .  .  .  .  .  Else: nil
 11731  .  .  .  .  }
 11732  .  .  .  .  1: *syntax.AssignStmt {
 11733  .  .  .  .  .  Op: :
 11734  .  .  .  .  .  Lhs: s
 11735  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11736  .  .  .  .  .  .  Fun: new
 11737  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11738  .  .  .  .  .  .  .  0: ForStmt
 11739  .  .  .  .  .  .  }
 11740  .  .  .  .  .  .  HasDots: false
 11741  .  .  .  .  .  }
 11742  .  .  .  .  }
 11743  .  .  .  .  2: *syntax.ExprStmt {
 11744  .  .  .  .  .  X: *syntax.CallExpr {
 11745  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11746  .  .  .  .  .  .  .  X: s
 11747  .  .  .  .  .  .  .  Sel: init
 11748  .  .  .  .  .  .  }
 11749  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11750  .  .  .  .  .  .  .  0: p
 11751  .  .  .  .  .  .  }
 11752  .  .  .  .  .  .  HasDots: false
 11753  .  .  .  .  .  }
 11754  .  .  .  .  }
 11755  .  .  .  .  3: *syntax.ExprStmt {
 11756  .  .  .  .  .  X: *syntax.CallExpr {
 11757  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11758  .  .  .  .  .  .  .  X: p
 11759  .  .  .  .  .  .  .  Sel: want
 11760  .  .  .  .  .  .  }
 11761  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11762  .  .  .  .  .  .  .  0: _For
 11763  .  .  .  .  .  .  }
 11764  .  .  .  .  .  .  HasDots: false
 11765  .  .  .  .  .  }
 11766  .  .  .  .  }
 11767  .  .  .  .  4: *syntax.AssignStmt {
 11768  .  .  .  .  .  Op: <op-0>
 11769  .  .  .  .  .  Lhs: *syntax.ListExpr {
 11770  .  .  .  .  .  .  ElemList: []syntax.Expr (3 entries) {
 11771  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 11772  .  .  .  .  .  .  .  .  X: s
 11773  .  .  .  .  .  .  .  .  Sel: Init
 11774  .  .  .  .  .  .  .  }
 11775  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
 11776  .  .  .  .  .  .  .  .  X: s
 11777  .  .  .  .  .  .  .  .  Sel: Cond
 11778  .  .  .  .  .  .  .  }
 11779  .  .  .  .  .  .  .  2: *syntax.SelectorExpr {
 11780  .  .  .  .  .  .  .  .  X: s
 11781  .  .  .  .  .  .  .  .  Sel: Post
 11782  .  .  .  .  .  .  .  }
 11783  .  .  .  .  .  .  }
 11784  .  .  .  .  .  }
 11785  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11786  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11787  .  .  .  .  .  .  .  X: p
 11788  .  .  .  .  .  .  .  Sel: header
 11789  .  .  .  .  .  .  }
 11790  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11791  .  .  .  .  .  .  .  0: true
 11792  .  .  .  .  .  .  }
 11793  .  .  .  .  .  .  HasDots: false
 11794  .  .  .  .  .  }
 11795  .  .  .  .  }
 11796  .  .  .  .  5: *syntax.IfStmt {
 11797  .  .  .  .  .  Init: nil
 11798  .  .  .  .  .  Cond: gcCompat
 11799  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 11800  .  .  .  .  .  .  0: *syntax.ExprStmt {
 11801  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 11802  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11803  .  .  .  .  .  .  .  .  .  X: s
 11804  .  .  .  .  .  .  .  .  .  Sel: init
 11805  .  .  .  .  .  .  .  .  }
 11806  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11807  .  .  .  .  .  .  .  .  .  0: p
 11808  .  .  .  .  .  .  .  .  }
 11809  .  .  .  .  .  .  .  .  HasDots: false
 11810  .  .  .  .  .  .  .  }
 11811  .  .  .  .  .  .  }
 11812  .  .  .  .  .  }
 11813  .  .  .  .  .  Else: nil
 11814  .  .  .  .  }
 11815  .  .  .  .  6: *syntax.AssignStmt {
 11816  .  .  .  .  .  Op: <op-0>
 11817  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11818  .  .  .  .  .  .  X: s
 11819  .  .  .  .  .  .  Sel: Body
 11820  .  .  .  .  .  }
 11821  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11822  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11823  .  .  .  .  .  .  .  X: p
 11824  .  .  .  .  .  .  .  Sel: stmtBody
 11825  .  .  .  .  .  .  }
 11826  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11827  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11828  .  .  .  .  .  .  .  .  Value: "\"for clause\""
 11829  .  .  .  .  .  .  .  .  Kind: 4
 11830  .  .  .  .  .  .  .  }
 11831  .  .  .  .  .  .  }
 11832  .  .  .  .  .  .  HasDots: false
 11833  .  .  .  .  .  }
 11834  .  .  .  .  }
 11835  .  .  .  .  7: *syntax.ReturnStmt {
 11836  .  .  .  .  .  Results: s
 11837  .  .  .  .  }
 11838  .  .  .  }
 11839  .  .  .  Pragma: 0
 11840  .  .  .  EndLine: 1618
 11841  .  .  }
 11842  .  .  57: *syntax.FuncDecl {
 11843  .  .  .  Attr: map[]
 11844  .  .  .  Recv: *syntax.Field {
 11845  .  .  .  .  Name: p
 11846  .  .  .  .  Type: *syntax.Operation {
 11847  .  .  .  .  .  Op: *
 11848  .  .  .  .  .  X: parser
 11849  .  .  .  .  .  Y: nil
 11850  .  .  .  .  }
 11851  .  .  .  }
 11852  .  .  .  Name: stmtBody
 11853  .  .  .  Type: *syntax.FuncType {
 11854  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 11855  .  .  .  .  .  0: *syntax.Field {
 11856  .  .  .  .  .  .  Name: context
 11857  .  .  .  .  .  .  Type: string
 11858  .  .  .  .  .  }
 11859  .  .  .  .  }
 11860  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 11861  .  .  .  .  .  0: *syntax.Field {
 11862  .  .  .  .  .  .  Name: nil
 11863  .  .  .  .  .  .  Type: *syntax.SliceType {
 11864  .  .  .  .  .  .  .  Elem: Stmt
 11865  .  .  .  .  .  .  }
 11866  .  .  .  .  .  }
 11867  .  .  .  .  }
 11868  .  .  .  }
 11869  .  .  .  Body: []syntax.Stmt (5 entries) {
 11870  .  .  .  .  0: *syntax.IfStmt {
 11871  .  .  .  .  .  Init: nil
 11872  .  .  .  .  .  Cond: trace
 11873  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 11874  .  .  .  .  .  .  0: *syntax.CallStmt {
 11875  .  .  .  .  .  .  .  Tok: defer
 11876  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 11877  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 11878  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11879  .  .  .  .  .  .  .  .  .  .  X: p
 11880  .  .  .  .  .  .  .  .  .  .  Sel: trace
 11881  .  .  .  .  .  .  .  .  .  }
 11882  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11883  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11884  .  .  .  .  .  .  .  .  .  .  .  Value: "\"stmtBody\""
 11885  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11886  .  .  .  .  .  .  .  .  .  .  }
 11887  .  .  .  .  .  .  .  .  .  }
 11888  .  .  .  .  .  .  .  .  .  HasDots: false
 11889  .  .  .  .  .  .  .  .  }
 11890  .  .  .  .  .  .  .  .  ArgList: nil
 11891  .  .  .  .  .  .  .  .  HasDots: false
 11892  .  .  .  .  .  .  .  }
 11893  .  .  .  .  .  .  }
 11894  .  .  .  .  .  }
 11895  .  .  .  .  .  Else: nil
 11896  .  .  .  .  }
 11897  .  .  .  .  1: *syntax.IfStmt {
 11898  .  .  .  .  .  Init: nil
 11899  .  .  .  .  .  Cond: *syntax.Operation {
 11900  .  .  .  .  .  .  Op: !
 11901  .  .  .  .  .  .  X: *syntax.CallExpr {
 11902  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11903  .  .  .  .  .  .  .  .  X: p
 11904  .  .  .  .  .  .  .  .  Sel: got
 11905  .  .  .  .  .  .  .  }
 11906  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11907  .  .  .  .  .  .  .  .  0: _Lbrace
 11908  .  .  .  .  .  .  .  }
 11909  .  .  .  .  .  .  .  HasDots: false
 11910  .  .  .  .  .  .  }
 11911  .  .  .  .  .  .  Y: nil
 11912  .  .  .  .  .  }
 11913  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 11914  .  .  .  .  .  .  0: *syntax.ExprStmt {
 11915  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 11916  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11917  .  .  .  .  .  .  .  .  .  X: p
 11918  .  .  .  .  .  .  .  .  .  Sel: syntax_error
 11919  .  .  .  .  .  .  .  .  }
 11920  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11921  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
 11922  .  .  .  .  .  .  .  .  .  .  Op: +
 11923  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
 11924  .  .  .  .  .  .  .  .  .  .  .  Value: "\"missing { after \""
 11925  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11926  .  .  .  .  .  .  .  .  .  .  }
 11927  .  .  .  .  .  .  .  .  .  .  Y: context
 11928  .  .  .  .  .  .  .  .  .  }
 11929  .  .  .  .  .  .  .  .  }
 11930  .  .  .  .  .  .  .  .  HasDots: false
 11931  .  .  .  .  .  .  .  }
 11932  .  .  .  .  .  .  }
 11933  .  .  .  .  .  .  1: *syntax.ExprStmt {
 11934  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 11935  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11936  .  .  .  .  .  .  .  .  .  X: p
 11937  .  .  .  .  .  .  .  .  .  Sel: advance
 11938  .  .  .  .  .  .  .  .  }
 11939  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 11940  .  .  .  .  .  .  .  .  .  0: _Name
 11941  .  .  .  .  .  .  .  .  .  1: _Rbrace
 11942  .  .  .  .  .  .  .  .  }
 11943  .  .  .  .  .  .  .  .  HasDots: false
 11944  .  .  .  .  .  .  .  }
 11945  .  .  .  .  .  .  }
 11946  .  .  .  .  .  }
 11947  .  .  .  .  .  Else: nil
 11948  .  .  .  .  }
 11949  .  .  .  .  2: *syntax.AssignStmt {
 11950  .  .  .  .  .  Op: :
 11951  .  .  .  .  .  Lhs: body
 11952  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11953  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11954  .  .  .  .  .  .  .  X: p
 11955  .  .  .  .  .  .  .  Sel: stmtList
 11956  .  .  .  .  .  .  }
 11957  .  .  .  .  .  .  ArgList: nil
 11958  .  .  .  .  .  .  HasDots: false
 11959  .  .  .  .  .  }
 11960  .  .  .  .  }
 11961  .  .  .  .  3: *syntax.ExprStmt {
 11962  .  .  .  .  .  X: *syntax.CallExpr {
 11963  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11964  .  .  .  .  .  .  .  X: p
 11965  .  .  .  .  .  .  .  Sel: want
 11966  .  .  .  .  .  .  }
 11967  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11968  .  .  .  .  .  .  .  0: _Rbrace
 11969  .  .  .  .  .  .  }
 11970  .  .  .  .  .  .  HasDots: false
 11971  .  .  .  .  .  }
 11972  .  .  .  .  }
 11973  .  .  .  .  4: *syntax.ReturnStmt {
 11974  .  .  .  .  .  Results: body
 11975  .  .  .  .  }
 11976  .  .  .  }
 11977  .  .  .  Pragma: 0
 11978  .  .  .  EndLine: 1635
 11979  .  .  }
 11980  .  .  58: *syntax.VarDecl {
 11981  .  .  .  NameList: []*syntax.Name (1 entries) {
 11982  .  .  .  .  0: dummyCond
 11983  .  .  .  }
 11984  .  .  .  Type: nil
 11985  .  .  .  Values: *syntax.Operation {
 11986  .  .  .  .  Op: &
 11987  .  .  .  .  X: *syntax.CompositeLit {
 11988  .  .  .  .  .  Type: Name
 11989  .  .  .  .  .  ElemList: []syntax.Expr (1 entries) {
 11990  .  .  .  .  .  .  0: *syntax.KeyValueExpr {
 11991  .  .  .  .  .  .  .  Key: Value
 11992  .  .  .  .  .  .  .  Value: *syntax.BasicLit {
 11993  .  .  .  .  .  .  .  .  Value: "\"false\""
 11994  .  .  .  .  .  .  .  .  Kind: 4
 11995  .  .  .  .  .  .  .  }
 11996  .  .  .  .  .  .  }
 11997  .  .  .  .  .  }
 11998  .  .  .  .  .  NKeys: 1
 11999  .  .  .  .  .  EndLine: 1637
 12000  .  .  .  .  }
 12001  .  .  .  .  Y: nil
 12002  .  .  .  }
 12003  .  .  .  Group: nil
 12004  .  .  }
 12005  .  .  59: *syntax.FuncDecl {
 12006  .  .  .  Attr: map[]
 12007  .  .  .  Recv: *syntax.Field {
 12008  .  .  .  .  Name: p
 12009  .  .  .  .  Type: *syntax.Operation {
 12010  .  .  .  .  .  Op: *
 12011  .  .  .  .  .  X: parser
 12012  .  .  .  .  .  Y: nil
 12013  .  .  .  .  }
 12014  .  .  .  }
 12015  .  .  .  Name: header
 12016  .  .  .  Type: *syntax.FuncType {
 12017  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 12018  .  .  .  .  .  0: *syntax.Field {
 12019  .  .  .  .  .  .  Name: forStmt
 12020  .  .  .  .  .  .  Type: bool
 12021  .  .  .  .  .  }
 12022  .  .  .  .  }
 12023  .  .  .  .  ResultList: []*syntax.Field (3 entries) {
 12024  .  .  .  .  .  0: *syntax.Field {
 12025  .  .  .  .  .  .  Name: init
 12026  .  .  .  .  .  .  Type: SimpleStmt
 12027  .  .  .  .  .  }
 12028  .  .  .  .  .  1: *syntax.Field {
 12029  .  .  .  .  .  .  Name: cond
 12030  .  .  .  .  .  .  Type: Expr
 12031  .  .  .  .  .  }
 12032  .  .  .  .  .  2: *syntax.Field {
 12033  .  .  .  .  .  .  Name: post
 12034  .  .  .  .  .  .  Type: SimpleStmt
 12035  .  .  .  .  .  }
 12036  .  .  .  .  }
 12037  .  .  .  }
 12038  .  .  .  Body: []syntax.Stmt (9 entries) {
 12039  .  .  .  .  0: *syntax.IfStmt {
 12040  .  .  .  .  .  Init: nil
 12041  .  .  .  .  .  Cond: *syntax.Operation {
 12042  .  .  .  .  .  .  Op: ==
 12043  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12044  .  .  .  .  .  .  .  X: p
 12045  .  .  .  .  .  .  .  Sel: tok
 12046  .  .  .  .  .  .  }
 12047  .  .  .  .  .  .  Y: _Lbrace
 12048  .  .  .  .  .  }
 12049  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 12050  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 12051  .  .  .  .  .  .  .  Results: nil
 12052  .  .  .  .  .  .  }
 12053  .  .  .  .  .  }
 12054  .  .  .  .  .  Else: nil
 12055  .  .  .  .  }
 12056  .  .  .  .  1: *syntax.AssignStmt {
 12057  .  .  .  .  .  Op: :
 12058  .  .  .  .  .  Lhs: outer
 12059  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 12060  .  .  .  .  .  .  X: p
 12061  .  .  .  .  .  .  Sel: xnest
 12062  .  .  .  .  .  }
 12063  .  .  .  .  }
 12064  .  .  .  .  2: *syntax.AssignStmt {
 12065  .  .  .  .  .  Op: <op-0>
 12066  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12067  .  .  .  .  .  .  X: p
 12068  .  .  .  .  .  .  Sel: xnest
 12069  .  .  .  .  .  }
 12070  .  .  .  .  .  Rhs: *syntax.Operation {
 12071  .  .  .  .  .  .  Op: -
 12072  .  .  .  .  .  .  X: *syntax.BasicLit {
 12073  .  .  .  .  .  .  .  Value: "1"
 12074  .  .  .  .  .  .  .  Kind: 0
 12075  .  .  .  .  .  .  }
 12076  .  .  .  .  .  .  Y: nil
 12077  .  .  .  .  .  }
 12078  .  .  .  .  }
 12079  .  .  .  .  3: *syntax.IfStmt {
 12080  .  .  .  .  .  Init: nil
 12081  .  .  .  .  .  Cond: *syntax.Operation {
 12082  .  .  .  .  .  .  Op: !=
 12083  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12084  .  .  .  .  .  .  .  X: p
 12085  .  .  .  .  .  .  .  Sel: tok
 12086  .  .  .  .  .  .  }
 12087  .  .  .  .  .  .  Y: _Semi
 12088  .  .  .  .  .  }
 12089  .  .  .  .  .  Then: []syntax.Stmt (3 entries) {
 12090  .  .  .  .  .  .  0: *syntax.IfStmt {
 12091  .  .  .  .  .  .  .  Init: nil
 12092  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 12093  .  .  .  .  .  .  .  .  Op: &&
 12094  .  .  .  .  .  .  .  .  X: forStmt
 12095  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
 12096  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12097  .  .  .  .  .  .  .  .  .  .  X: p
 12098  .  .  .  .  .  .  .  .  .  .  Sel: got
 12099  .  .  .  .  .  .  .  .  .  }
 12100  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12101  .  .  .  .  .  .  .  .  .  .  0: _Var
 12102  .  .  .  .  .  .  .  .  .  }
 12103  .  .  .  .  .  .  .  .  .  HasDots: false
 12104  .  .  .  .  .  .  .  .  }
 12105  .  .  .  .  .  .  .  }
 12106  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 12107  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 12108  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12109  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12110  .  .  .  .  .  .  .  .  .  .  .  X: p
 12111  .  .  .  .  .  .  .  .  .  .  .  Sel: error
 12112  .  .  .  .  .  .  .  .  .  .  }
 12113  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12114  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 12115  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"var declaration not allowed in for initializer\""
 12116  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 12117  .  .  .  .  .  .  .  .  .  .  .  }
 12118  .  .  .  .  .  .  .  .  .  .  }
 12119  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12120  .  .  .  .  .  .  .  .  .  }
 12121  .  .  .  .  .  .  .  .  }
 12122  .  .  .  .  .  .  .  }
 12123  .  .  .  .  .  .  .  Else: nil
 12124  .  .  .  .  .  .  }
 12125  .  .  .  .  .  .  1: *syntax.AssignStmt {
 12126  .  .  .  .  .  .  .  Op: <op-0>
 12127  .  .  .  .  .  .  .  Lhs: init
 12128  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12129  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12130  .  .  .  .  .  .  .  .  .  X: p
 12131  .  .  .  .  .  .  .  .  .  Sel: simpleStmt
 12132  .  .  .  .  .  .  .  .  }
 12133  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12134  .  .  .  .  .  .  .  .  .  0: nil
 12135  .  .  .  .  .  .  .  .  .  1: forStmt
 12136  .  .  .  .  .  .  .  .  }
 12137  .  .  .  .  .  .  .  .  HasDots: false
 12138  .  .  .  .  .  .  .  }
 12139  .  .  .  .  .  .  }
 12140  .  .  .  .  .  .  2: *syntax.IfStmt {
 12141  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 12142  .  .  .  .  .  .  .  .  Op: :
 12143  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 12144  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 12145  .  .  .  .  .  .  .  .  .  .  0: _
 12146  .  .  .  .  .  .  .  .  .  .  1: ok
 12147  .  .  .  .  .  .  .  .  .  }
 12148  .  .  .  .  .  .  .  .  }
 12149  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 12150  .  .  .  .  .  .  .  .  .  X: init
 12151  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 12152  .  .  .  .  .  .  .  .  .  .  Op: *
 12153  .  .  .  .  .  .  .  .  .  .  X: RangeClause
 12154  .  .  .  .  .  .  .  .  .  .  Y: nil
 12155  .  .  .  .  .  .  .  .  .  }
 12156  .  .  .  .  .  .  .  .  }
 12157  .  .  .  .  .  .  .  }
 12158  .  .  .  .  .  .  .  Cond: ok
 12159  .  .  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 12160  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12161  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12162  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12163  .  .  .  .  .  .  .  .  .  .  X: p
 12164  .  .  .  .  .  .  .  .  .  .  Sel: xnest
 12165  .  .  .  .  .  .  .  .  .  }
 12166  .  .  .  .  .  .  .  .  .  Rhs: outer
 12167  .  .  .  .  .  .  .  .  }
 12168  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
 12169  .  .  .  .  .  .  .  .  .  Results: nil
 12170  .  .  .  .  .  .  .  .  }
 12171  .  .  .  .  .  .  .  }
 12172  .  .  .  .  .  .  .  Else: nil
 12173  .  .  .  .  .  .  }
 12174  .  .  .  .  .  }
 12175  .  .  .  .  .  Else: nil
 12176  .  .  .  .  }
 12177  .  .  .  .  4: *syntax.DeclStmt {
 12178  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
 12179  .  .  .  .  .  .  0: *syntax.VarDecl {
 12180  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
 12181  .  .  .  .  .  .  .  .  0: condStmt
 12182  .  .  .  .  .  .  .  }
 12183  .  .  .  .  .  .  .  Type: SimpleStmt
 12184  .  .  .  .  .  .  .  Values: nil
 12185  .  .  .  .  .  .  .  Group: nil
 12186  .  .  .  .  .  .  }
 12187  .  .  .  .  .  }
 12188  .  .  .  .  }
 12189  .  .  .  .  5: *syntax.IfStmt {
 12190  .  .  .  .  .  Init: nil
 12191  .  .  .  .  .  Cond: *syntax.CallExpr {
 12192  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12193  .  .  .  .  .  .  .  X: p
 12194  .  .  .  .  .  .  .  Sel: got
 12195  .  .  .  .  .  .  }
 12196  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12197  .  .  .  .  .  .  .  0: _Semi
 12198  .  .  .  .  .  .  }
 12199  .  .  .  .  .  .  HasDots: false
 12200  .  .  .  .  .  }
 12201  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 12202  .  .  .  .  .  .  0: *syntax.IfStmt {
 12203  .  .  .  .  .  .  .  Init: nil
 12204  .  .  .  .  .  .  .  Cond: forStmt
 12205  .  .  .  .  .  .  .  Then: []syntax.Stmt (3 entries) {
 12206  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 12207  .  .  .  .  .  .  .  .  .  Init: nil
 12208  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 12209  .  .  .  .  .  .  .  .  .  .  Op: !=
 12210  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12211  .  .  .  .  .  .  .  .  .  .  .  X: p
 12212  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
 12213  .  .  .  .  .  .  .  .  .  .  }
 12214  .  .  .  .  .  .  .  .  .  .  Y: _Semi
 12215  .  .  .  .  .  .  .  .  .  }
 12216  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 12217  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12218  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12219  .  .  .  .  .  .  .  .  .  .  .  Lhs: condStmt
 12220  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12221  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12222  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 12223  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt
 12224  .  .  .  .  .  .  .  .  .  .  .  .  }
 12225  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12226  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil
 12227  .  .  .  .  .  .  .  .  .  .  .  .  .  1: false
 12228  .  .  .  .  .  .  .  .  .  .  .  .  }
 12229  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12230  .  .  .  .  .  .  .  .  .  .  .  }
 12231  .  .  .  .  .  .  .  .  .  .  }
 12232  .  .  .  .  .  .  .  .  .  }
 12233  .  .  .  .  .  .  .  .  .  Else: nil
 12234  .  .  .  .  .  .  .  .  }
 12235  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 12236  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12237  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12238  .  .  .  .  .  .  .  .  .  .  .  X: p
 12239  .  .  .  .  .  .  .  .  .  .  .  Sel: want
 12240  .  .  .  .  .  .  .  .  .  .  }
 12241  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12242  .  .  .  .  .  .  .  .  .  .  .  0: _Semi
 12243  .  .  .  .  .  .  .  .  .  .  }
 12244  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12245  .  .  .  .  .  .  .  .  .  }
 12246  .  .  .  .  .  .  .  .  }
 12247  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
 12248  .  .  .  .  .  .  .  .  .  Init: nil
 12249  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 12250  .  .  .  .  .  .  .  .  .  .  Op: !=
 12251  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12252  .  .  .  .  .  .  .  .  .  .  .  X: p
 12253  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
 12254  .  .  .  .  .  .  .  .  .  .  }
 12255  .  .  .  .  .  .  .  .  .  .  Y: _Lbrace
 12256  .  .  .  .  .  .  .  .  .  }
 12257  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 12258  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12259  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12260  .  .  .  .  .  .  .  .  .  .  .  Lhs: post
 12261  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12262  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12263  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 12264  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt
 12265  .  .  .  .  .  .  .  .  .  .  .  .  }
 12266  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12267  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil
 12268  .  .  .  .  .  .  .  .  .  .  .  .  .  1: false
 12269  .  .  .  .  .  .  .  .  .  .  .  .  }
 12270  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12271  .  .  .  .  .  .  .  .  .  .  .  }
 12272  .  .  .  .  .  .  .  .  .  .  }
 12273  .  .  .  .  .  .  .  .  .  }
 12274  .  .  .  .  .  .  .  .  .  Else: nil
 12275  .  .  .  .  .  .  .  .  }
 12276  .  .  .  .  .  .  .  }
 12277  .  .  .  .  .  .  .  Else: *syntax.IfStmt {
 12278  .  .  .  .  .  .  .  .  Init: nil
 12279  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 12280  .  .  .  .  .  .  .  .  .  Op: !=
 12281  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12282  .  .  .  .  .  .  .  .  .  .  X: p
 12283  .  .  .  .  .  .  .  .  .  .  Sel: tok
 12284  .  .  .  .  .  .  .  .  .  }
 12285  .  .  .  .  .  .  .  .  .  Y: _Lbrace
 12286  .  .  .  .  .  .  .  .  }
 12287  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 12288  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12289  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12290  .  .  .  .  .  .  .  .  .  .  Lhs: condStmt
 12291  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12292  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12293  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 12294  .  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt
 12295  .  .  .  .  .  .  .  .  .  .  .  }
 12296  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12297  .  .  .  .  .  .  .  .  .  .  .  .  0: nil
 12298  .  .  .  .  .  .  .  .  .  .  .  .  1: false
 12299  .  .  .  .  .  .  .  .  .  .  .  }
 12300  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12301  .  .  .  .  .  .  .  .  .  .  }
 12302  .  .  .  .  .  .  .  .  .  }
 12303  .  .  .  .  .  .  .  .  }
 12304  .  .  .  .  .  .  .  .  Else: nil
 12305  .  .  .  .  .  .  .  }
 12306  .  .  .  .  .  .  }
 12307  .  .  .  .  .  }
 12308  .  .  .  .  .  Else: *syntax.BlockStmt {
 12309  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 12310  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12311  .  .  .  .  .  .  .  .  Op: <op-0>
 12312  .  .  .  .  .  .  .  .  Lhs: condStmt
 12313  .  .  .  .  .  .  .  .  Rhs: init
 12314  .  .  .  .  .  .  .  }
 12315  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 12316  .  .  .  .  .  .  .  .  Op: <op-0>
 12317  .  .  .  .  .  .  .  .  Lhs: init
 12318  .  .  .  .  .  .  .  .  Rhs: nil
 12319  .  .  .  .  .  .  .  }
 12320  .  .  .  .  .  .  }
 12321  .  .  .  .  .  }
 12322  .  .  .  .  }
 12323  .  .  .  .  6: *syntax.SwitchStmt {
 12324  .  .  .  .  .  Init: nil
 12325  .  .  .  .  .  Tag: *syntax.TypeSwitchGuard {
 12326  .  .  .  .  .  .  Lhs: s
 12327  .  .  .  .  .  .  X: condStmt
 12328  .  .  .  .  .  }
 12329  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 12330  .  .  .  .  .  .  0: *syntax.CaseClause {
 12331  .  .  .  .  .  .  .  Cases: nil
 12332  .  .  .  .  .  .  .  Body: nil
 12333  .  .  .  .  .  .  }
 12334  .  .  .  .  .  .  1: *syntax.CaseClause {
 12335  .  .  .  .  .  .  .  Cases: *syntax.Operation {
 12336  .  .  .  .  .  .  .  .  Op: *
 12337  .  .  .  .  .  .  .  .  X: ExprStmt
 12338  .  .  .  .  .  .  .  .  Y: nil
 12339  .  .  .  .  .  .  .  }
 12340  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 12341  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12342  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12343  .  .  .  .  .  .  .  .  .  Lhs: cond
 12344  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 12345  .  .  .  .  .  .  .  .  .  .  X: s
 12346  .  .  .  .  .  .  .  .  .  .  Sel: X
 12347  .  .  .  .  .  .  .  .  .  }
 12348  .  .  .  .  .  .  .  .  }
 12349  .  .  .  .  .  .  .  }
 12350  .  .  .  .  .  .  }
 12351  .  .  .  .  .  .  2: *syntax.CaseClause {
 12352  .  .  .  .  .  .  .  Cases: nil
 12353  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 12354  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 12355  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12356  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12357  .  .  .  .  .  .  .  .  .  .  .  X: p
 12358  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
 12359  .  .  .  .  .  .  .  .  .  .  }
 12360  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12361  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
 12362  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12363  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt
 12364  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf
 12365  .  .  .  .  .  .  .  .  .  .  .  .  }
 12366  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12367  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 12368  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"%s used as value\""
 12369  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 12370  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12371  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 12372  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: String
 12373  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12374  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: s
 12375  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12376  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12377  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12378  .  .  .  .  .  .  .  .  .  .  .  .  }
 12379  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12380  .  .  .  .  .  .  .  .  .  .  .  }
 12381  .  .  .  .  .  .  .  .  .  .  }
 12382  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12383  .  .  .  .  .  .  .  .  .  }
 12384  .  .  .  .  .  .  .  .  }
 12385  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 12386  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12387  .  .  .  .  .  .  .  .  .  Lhs: cond
 12388  .  .  .  .  .  .  .  .  .  Rhs: dummyCond
 12389  .  .  .  .  .  .  .  .  }
 12390  .  .  .  .  .  .  .  }
 12391  .  .  .  .  .  .  }
 12392  .  .  .  .  .  }
 12393  .  .  .  .  }
 12394  .  .  .  .  7: *syntax.AssignStmt {
 12395  .  .  .  .  .  Op: <op-0>
 12396  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12397  .  .  .  .  .  .  X: p
 12398  .  .  .  .  .  .  Sel: xnest
 12399  .  .  .  .  .  }
 12400  .  .  .  .  .  Rhs: outer
 12401  .  .  .  .  }
 12402  .  .  .  .  8: *syntax.ReturnStmt {
 12403  .  .  .  .  .  Results: nil
 12404  .  .  .  .  }
 12405  .  .  .  }
 12406  .  .  .  Pragma: 0
 12407  .  .  .  EndLine: 1691
 12408  .  .  }
 12409  .  .  60: *syntax.FuncDecl {
 12410  .  .  .  Attr: map[]
 12411  .  .  .  Recv: *syntax.Field {
 12412  .  .  .  .  Name: p
 12413  .  .  .  .  Type: *syntax.Operation {
 12414  .  .  .  .  .  Op: *
 12415  .  .  .  .  .  X: parser
 12416  .  .  .  .  .  Y: nil
 12417  .  .  .  .  }
 12418  .  .  .  }
 12419  .  .  .  Name: ifStmt
 12420  .  .  .  Type: *syntax.FuncType {
 12421  .  .  .  .  ParamList: nil
 12422  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 12423  .  .  .  .  .  0: *syntax.Field {
 12424  .  .  .  .  .  .  Name: nil
 12425  .  .  .  .  .  .  Type: *syntax.Operation {
 12426  .  .  .  .  .  .  .  Op: *
 12427  .  .  .  .  .  .  .  X: IfStmt
 12428  .  .  .  .  .  .  .  Y: nil
 12429  .  .  .  .  .  .  }
 12430  .  .  .  .  .  }
 12431  .  .  .  .  }
 12432  .  .  .  }
 12433  .  .  .  Body: []syntax.Stmt (10 entries) {
 12434  .  .  .  .  0: *syntax.IfStmt {
 12435  .  .  .  .  .  Init: nil
 12436  .  .  .  .  .  Cond: trace
 12437  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 12438  .  .  .  .  .  .  0: *syntax.CallStmt {
 12439  .  .  .  .  .  .  .  Tok: defer
 12440  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 12441  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 12442  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12443  .  .  .  .  .  .  .  .  .  .  X: p
 12444  .  .  .  .  .  .  .  .  .  .  Sel: trace
 12445  .  .  .  .  .  .  .  .  .  }
 12446  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12447  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 12448  .  .  .  .  .  .  .  .  .  .  .  Value: "\"ifStmt\""
 12449  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 12450  .  .  .  .  .  .  .  .  .  .  }
 12451  .  .  .  .  .  .  .  .  .  }
 12452  .  .  .  .  .  .  .  .  .  HasDots: false
 12453  .  .  .  .  .  .  .  .  }
 12454  .  .  .  .  .  .  .  .  ArgList: nil
 12455  .  .  .  .  .  .  .  .  HasDots: false
 12456  .  .  .  .  .  .  .  }
 12457  .  .  .  .  .  .  }
 12458  .  .  .  .  .  }
 12459  .  .  .  .  .  Else: nil
 12460  .  .  .  .  }
 12461  .  .  .  .  1: *syntax.AssignStmt {
 12462  .  .  .  .  .  Op: :
 12463  .  .  .  .  .  Lhs: s
 12464  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12465  .  .  .  .  .  .  Fun: new
 12466  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12467  .  .  .  .  .  .  .  0: IfStmt
 12468  .  .  .  .  .  .  }
 12469  .  .  .  .  .  .  HasDots: false
 12470  .  .  .  .  .  }
 12471  .  .  .  .  }
 12472  .  .  .  .  2: *syntax.ExprStmt {
 12473  .  .  .  .  .  X: *syntax.CallExpr {
 12474  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12475  .  .  .  .  .  .  .  X: s
 12476  .  .  .  .  .  .  .  Sel: init
 12477  .  .  .  .  .  .  }
 12478  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12479  .  .  .  .  .  .  .  0: p
 12480  .  .  .  .  .  .  }
 12481  .  .  .  .  .  .  HasDots: false
 12482  .  .  .  .  .  }
 12483  .  .  .  .  }
 12484  .  .  .  .  3: *syntax.ExprStmt {
 12485  .  .  .  .  .  X: *syntax.CallExpr {
 12486  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12487  .  .  .  .  .  .  .  X: p
 12488  .  .  .  .  .  .  .  Sel: want
 12489  .  .  .  .  .  .  }
 12490  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12491  .  .  .  .  .  .  .  0: _If
 12492  .  .  .  .  .  .  }
 12493  .  .  .  .  .  .  HasDots: false
 12494  .  .  .  .  .  }
 12495  .  .  .  .  }
 12496  .  .  .  .  4: *syntax.AssignStmt {
 12497  .  .  .  .  .  Op: <op-0>
 12498  .  .  .  .  .  Lhs: *syntax.ListExpr {
 12499  .  .  .  .  .  .  ElemList: []syntax.Expr (3 entries) {
 12500  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 12501  .  .  .  .  .  .  .  .  X: s
 12502  .  .  .  .  .  .  .  .  Sel: Init
 12503  .  .  .  .  .  .  .  }
 12504  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
 12505  .  .  .  .  .  .  .  .  X: s
 12506  .  .  .  .  .  .  .  .  Sel: Cond
 12507  .  .  .  .  .  .  .  }
 12508  .  .  .  .  .  .  .  2: _
 12509  .  .  .  .  .  .  }
 12510  .  .  .  .  .  }
 12511  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12512  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12513  .  .  .  .  .  .  .  X: p
 12514  .  .  .  .  .  .  .  Sel: header
 12515  .  .  .  .  .  .  }
 12516  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12517  .  .  .  .  .  .  .  0: false
 12518  .  .  .  .  .  .  }
 12519  .  .  .  .  .  .  HasDots: false
 12520  .  .  .  .  .  }
 12521  .  .  .  .  }
 12522  .  .  .  .  5: *syntax.IfStmt {
 12523  .  .  .  .  .  Init: nil
 12524  .  .  .  .  .  Cond: *syntax.Operation {
 12525  .  .  .  .  .  .  Op: ==
 12526  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12527  .  .  .  .  .  .  .  X: s
 12528  .  .  .  .  .  .  .  Sel: Cond
 12529  .  .  .  .  .  .  }
 12530  .  .  .  .  .  .  Y: nil
 12531  .  .  .  .  .  }
 12532  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 12533  .  .  .  .  .  .  0: *syntax.ExprStmt {
 12534  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12535  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12536  .  .  .  .  .  .  .  .  .  X: p
 12537  .  .  .  .  .  .  .  .  .  Sel: error
 12538  .  .  .  .  .  .  .  .  }
 12539  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12540  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 12541  .  .  .  .  .  .  .  .  .  .  Value: "\"missing condition in if statement\""
 12542  .  .  .  .  .  .  .  .  .  .  Kind: 4
 12543  .  .  .  .  .  .  .  .  .  }
 12544  .  .  .  .  .  .  .  .  }
 12545  .  .  .  .  .  .  .  .  HasDots: false
 12546  .  .  .  .  .  .  .  }
 12547  .  .  .  .  .  .  }
 12548  .  .  .  .  .  }
 12549  .  .  .  .  .  Else: nil
 12550  .  .  .  .  }
 12551  .  .  .  .  6: *syntax.IfStmt {
 12552  .  .  .  .  .  Init: nil
 12553  .  .  .  .  .  Cond: gcCompat
 12554  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 12555  .  .  .  .  .  .  0: *syntax.ExprStmt {
 12556  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12557  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12558  .  .  .  .  .  .  .  .  .  X: s
 12559  .  .  .  .  .  .  .  .  .  Sel: init
 12560  .  .  .  .  .  .  .  .  }
 12561  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12562  .  .  .  .  .  .  .  .  .  0: p
 12563  .  .  .  .  .  .  .  .  }
 12564  .  .  .  .  .  .  .  .  HasDots: false
 12565  .  .  .  .  .  .  .  }
 12566  .  .  .  .  .  .  }
 12567  .  .  .  .  .  }
 12568  .  .  .  .  .  Else: nil
 12569  .  .  .  .  }
 12570  .  .  .  .  7: *syntax.AssignStmt {
 12571  .  .  .  .  .  Op: <op-0>
 12572  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12573  .  .  .  .  .  .  X: s
 12574  .  .  .  .  .  .  Sel: Then
 12575  .  .  .  .  .  }
 12576  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12577  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12578  .  .  .  .  .  .  .  X: p
 12579  .  .  .  .  .  .  .  Sel: stmtBody
 12580  .  .  .  .  .  .  }
 12581  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12582  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 12583  .  .  .  .  .  .  .  .  Value: "\"if clause\""
 12584  .  .  .  .  .  .  .  .  Kind: 4
 12585  .  .  .  .  .  .  .  }
 12586  .  .  .  .  .  .  }
 12587  .  .  .  .  .  .  HasDots: false
 12588  .  .  .  .  .  }
 12589  .  .  .  .  }
 12590  .  .  .  .  8: *syntax.IfStmt {
 12591  .  .  .  .  .  Init: nil
 12592  .  .  .  .  .  Cond: *syntax.CallExpr {
 12593  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12594  .  .  .  .  .  .  .  X: p
 12595  .  .  .  .  .  .  .  Sel: got
 12596  .  .  .  .  .  .  }
 12597  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12598  .  .  .  .  .  .  .  0: _Else
 12599  .  .  .  .  .  .  }
 12600  .  .  .  .  .  .  HasDots: false
 12601  .  .  .  .  .  }
 12602  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 12603  .  .  .  .  .  .  0: *syntax.SwitchStmt {
 12604  .  .  .  .  .  .  .  Init: nil
 12605  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 12606  .  .  .  .  .  .  .  .  X: p
 12607  .  .  .  .  .  .  .  .  Sel: tok
 12608  .  .  .  .  .  .  .  }
 12609  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 12610  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 12611  .  .  .  .  .  .  .  .  .  Cases: _If
 12612  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 12613  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12614  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12615  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12616  .  .  .  .  .  .  .  .  .  .  .  .  X: s
 12617  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Else
 12618  .  .  .  .  .  .  .  .  .  .  .  }
 12619  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12620  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12621  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 12622  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: ifStmt
 12623  .  .  .  .  .  .  .  .  .  .  .  .  }
 12624  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12625  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12626  .  .  .  .  .  .  .  .  .  .  .  }
 12627  .  .  .  .  .  .  .  .  .  .  }
 12628  .  .  .  .  .  .  .  .  .  }
 12629  .  .  .  .  .  .  .  .  }
 12630  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 12631  .  .  .  .  .  .  .  .  .  Cases: _Lbrace
 12632  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 12633  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12634  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12635  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12636  .  .  .  .  .  .  .  .  .  .  .  .  X: s
 12637  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Else
 12638  .  .  .  .  .  .  .  .  .  .  .  }
 12639  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12640  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12641  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 12642  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: blockStmt
 12643  .  .  .  .  .  .  .  .  .  .  .  .  }
 12644  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12645  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12646  .  .  .  .  .  .  .  .  .  .  .  }
 12647  .  .  .  .  .  .  .  .  .  .  }
 12648  .  .  .  .  .  .  .  .  .  }
 12649  .  .  .  .  .  .  .  .  }
 12650  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 12651  .  .  .  .  .  .  .  .  .  Cases: nil
 12652  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 12653  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 12654  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12655  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12656  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 12657  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error
 12658  .  .  .  .  .  .  .  .  .  .  .  .  }
 12659  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12660  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 12661  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"else must be followed by if or statement block\""
 12662  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 12663  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12664  .  .  .  .  .  .  .  .  .  .  .  .  }
 12665  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12666  .  .  .  .  .  .  .  .  .  .  .  }
 12667  .  .  .  .  .  .  .  .  .  .  }
 12668  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 12669  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12670  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12671  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 12672  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
 12673  .  .  .  .  .  .  .  .  .  .  .  .  }
 12674  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12675  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Name
 12676  .  .  .  .  .  .  .  .  .  .  .  .  .  1: _Rbrace
 12677  .  .  .  .  .  .  .  .  .  .  .  .  }
 12678  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12679  .  .  .  .  .  .  .  .  .  .  .  }
 12680  .  .  .  .  .  .  .  .  .  .  }
 12681  .  .  .  .  .  .  .  .  .  }
 12682  .  .  .  .  .  .  .  .  }
 12683  .  .  .  .  .  .  .  }
 12684  .  .  .  .  .  .  }
 12685  .  .  .  .  .  }
 12686  .  .  .  .  .  Else: nil
 12687  .  .  .  .  }
 12688  .  .  .  .  9: *syntax.ReturnStmt {
 12689  .  .  .  .  .  Results: s
 12690  .  .  .  .  }
 12691  .  .  .  }
 12692  .  .  .  Pragma: 0
 12693  .  .  .  EndLine: 1726
 12694  .  .  }
 12695  .  .  61: *syntax.FuncDecl {
 12696  .  .  .  Attr: map[]
 12697  .  .  .  Recv: *syntax.Field {
 12698  .  .  .  .  Name: p
 12699  .  .  .  .  Type: *syntax.Operation {
 12700  .  .  .  .  .  Op: *
 12701  .  .  .  .  .  X: parser
 12702  .  .  .  .  .  Y: nil
 12703  .  .  .  .  }
 12704  .  .  .  }
 12705  .  .  .  Name: switchStmt
 12706  .  .  .  Type: *syntax.FuncType {
 12707  .  .  .  .  ParamList: nil
 12708  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 12709  .  .  .  .  .  0: *syntax.Field {
 12710  .  .  .  .  .  .  Name: nil
 12711  .  .  .  .  .  .  Type: *syntax.Operation {
 12712  .  .  .  .  .  .  .  Op: *
 12713  .  .  .  .  .  .  .  X: SwitchStmt
 12714  .  .  .  .  .  .  .  Y: nil
 12715  .  .  .  .  .  .  }
 12716  .  .  .  .  .  }
 12717  .  .  .  .  }
 12718  .  .  .  }
 12719  .  .  .  Body: []syntax.Stmt (9 entries) {
 12720  .  .  .  .  0: *syntax.IfStmt {
 12721  .  .  .  .  .  Init: nil
 12722  .  .  .  .  .  Cond: trace
 12723  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 12724  .  .  .  .  .  .  0: *syntax.CallStmt {
 12725  .  .  .  .  .  .  .  Tok: defer
 12726  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 12727  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 12728  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12729  .  .  .  .  .  .  .  .  .  .  X: p
 12730  .  .  .  .  .  .  .  .  .  .  Sel: trace
 12731  .  .  .  .  .  .  .  .  .  }
 12732  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12733  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 12734  .  .  .  .  .  .  .  .  .  .  .  Value: "\"switchStmt\""
 12735  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 12736  .  .  .  .  .  .  .  .  .  .  }
 12737  .  .  .  .  .  .  .  .  .  }
 12738  .  .  .  .  .  .  .  .  .  HasDots: false
 12739  .  .  .  .  .  .  .  .  }
 12740  .  .  .  .  .  .  .  .  ArgList: nil
 12741  .  .  .  .  .  .  .  .  HasDots: false
 12742  .  .  .  .  .  .  .  }
 12743  .  .  .  .  .  .  }
 12744  .  .  .  .  .  }
 12745  .  .  .  .  .  Else: nil
 12746  .  .  .  .  }
 12747  .  .  .  .  1: *syntax.ExprStmt {
 12748  .  .  .  .  .  X: *syntax.CallExpr {
 12749  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12750  .  .  .  .  .  .  .  X: p
 12751  .  .  .  .  .  .  .  Sel: want
 12752  .  .  .  .  .  .  }
 12753  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12754  .  .  .  .  .  .  .  0: _Switch
 12755  .  .  .  .  .  .  }
 12756  .  .  .  .  .  .  HasDots: false
 12757  .  .  .  .  .  }
 12758  .  .  .  .  }
 12759  .  .  .  .  2: *syntax.AssignStmt {
 12760  .  .  .  .  .  Op: :
 12761  .  .  .  .  .  Lhs: s
 12762  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12763  .  .  .  .  .  .  Fun: new
 12764  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12765  .  .  .  .  .  .  .  0: SwitchStmt
 12766  .  .  .  .  .  .  }
 12767  .  .  .  .  .  .  HasDots: false
 12768  .  .  .  .  .  }
 12769  .  .  .  .  }
 12770  .  .  .  .  3: *syntax.ExprStmt {
 12771  .  .  .  .  .  X: *syntax.CallExpr {
 12772  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12773  .  .  .  .  .  .  .  X: s
 12774  .  .  .  .  .  .  .  Sel: init
 12775  .  .  .  .  .  .  }
 12776  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12777  .  .  .  .  .  .  .  0: p
 12778  .  .  .  .  .  .  }
 12779  .  .  .  .  .  .  HasDots: false
 12780  .  .  .  .  .  }
 12781  .  .  .  .  }
 12782  .  .  .  .  4: *syntax.AssignStmt {
 12783  .  .  .  .  .  Op: <op-0>
 12784  .  .  .  .  .  Lhs: *syntax.ListExpr {
 12785  .  .  .  .  .  .  ElemList: []syntax.Expr (3 entries) {
 12786  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 12787  .  .  .  .  .  .  .  .  X: s
 12788  .  .  .  .  .  .  .  .  Sel: Init
 12789  .  .  .  .  .  .  .  }
 12790  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
 12791  .  .  .  .  .  .  .  .  X: s
 12792  .  .  .  .  .  .  .  .  Sel: Tag
 12793  .  .  .  .  .  .  .  }
 12794  .  .  .  .  .  .  .  2: _
 12795  .  .  .  .  .  .  }
 12796  .  .  .  .  .  }
 12797  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12798  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12799  .  .  .  .  .  .  .  X: p
 12800  .  .  .  .  .  .  .  Sel: header
 12801  .  .  .  .  .  .  }
 12802  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12803  .  .  .  .  .  .  .  0: false
 12804  .  .  .  .  .  .  }
 12805  .  .  .  .  .  .  HasDots: false
 12806  .  .  .  .  .  }
 12807  .  .  .  .  }
 12808  .  .  .  .  5: *syntax.IfStmt {
 12809  .  .  .  .  .  Init: nil
 12810  .  .  .  .  .  Cond: *syntax.Operation {
 12811  .  .  .  .  .  .  Op: !
 12812  .  .  .  .  .  .  X: *syntax.CallExpr {
 12813  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12814  .  .  .  .  .  .  .  .  X: p
 12815  .  .  .  .  .  .  .  .  Sel: got
 12816  .  .  .  .  .  .  .  }
 12817  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12818  .  .  .  .  .  .  .  .  0: _Lbrace
 12819  .  .  .  .  .  .  .  }
 12820  .  .  .  .  .  .  .  HasDots: false
 12821  .  .  .  .  .  .  }
 12822  .  .  .  .  .  .  Y: nil
 12823  .  .  .  .  .  }
 12824  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 12825  .  .  .  .  .  .  0: *syntax.ExprStmt {
 12826  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12827  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12828  .  .  .  .  .  .  .  .  .  X: p
 12829  .  .  .  .  .  .  .  .  .  Sel: syntax_error
 12830  .  .  .  .  .  .  .  .  }
 12831  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12832  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 12833  .  .  .  .  .  .  .  .  .  .  Value: "\"missing { after switch clause\""
 12834  .  .  .  .  .  .  .  .  .  .  Kind: 4
 12835  .  .  .  .  .  .  .  .  .  }
 12836  .  .  .  .  .  .  .  .  }
 12837  .  .  .  .  .  .  .  .  HasDots: false
 12838  .  .  .  .  .  .  .  }
 12839  .  .  .  .  .  .  }
 12840  .  .  .  .  .  .  1: *syntax.ExprStmt {
 12841  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12842  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12843  .  .  .  .  .  .  .  .  .  X: p
 12844  .  .  .  .  .  .  .  .  .  Sel: advance
 12845  .  .  .  .  .  .  .  .  }
 12846  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 12847  .  .  .  .  .  .  .  .  .  0: _Case
 12848  .  .  .  .  .  .  .  .  .  1: _Default
 12849  .  .  .  .  .  .  .  .  .  2: _Rbrace
 12850  .  .  .  .  .  .  .  .  }
 12851  .  .  .  .  .  .  .  .  HasDots: false
 12852  .  .  .  .  .  .  .  }
 12853  .  .  .  .  .  .  }
 12854  .  .  .  .  .  }
 12855  .  .  .  .  .  Else: nil
 12856  .  .  .  .  }
 12857  .  .  .  .  6: *syntax.ForStmt {
 12858  .  .  .  .  .  Init: nil
 12859  .  .  .  .  .  Cond: *syntax.Operation {
 12860  .  .  .  .  .  .  Op: &&
 12861  .  .  .  .  .  .  X: *syntax.Operation {
 12862  .  .  .  .  .  .  .  Op: !=
 12863  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12864  .  .  .  .  .  .  .  .  X: p
 12865  .  .  .  .  .  .  .  .  Sel: tok
 12866  .  .  .  .  .  .  .  }
 12867  .  .  .  .  .  .  .  Y: _EOF
 12868  .  .  .  .  .  .  }
 12869  .  .  .  .  .  .  Y: *syntax.Operation {
 12870  .  .  .  .  .  .  .  Op: !=
 12871  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12872  .  .  .  .  .  .  .  .  X: p
 12873  .  .  .  .  .  .  .  .  Sel: tok
 12874  .  .  .  .  .  .  .  }
 12875  .  .  .  .  .  .  .  Y: _Rbrace
 12876  .  .  .  .  .  .  }
 12877  .  .  .  .  .  }
 12878  .  .  .  .  .  Post: nil
 12879  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 12880  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12881  .  .  .  .  .  .  .  Op: <op-0>
 12882  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12883  .  .  .  .  .  .  .  .  X: s
 12884  .  .  .  .  .  .  .  .  Sel: Body
 12885  .  .  .  .  .  .  .  }
 12886  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12887  .  .  .  .  .  .  .  .  Fun: append
 12888  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12889  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 12890  .  .  .  .  .  .  .  .  .  .  X: s
 12891  .  .  .  .  .  .  .  .  .  .  Sel: Body
 12892  .  .  .  .  .  .  .  .  .  }
 12893  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 12894  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12895  .  .  .  .  .  .  .  .  .  .  .  X: p
 12896  .  .  .  .  .  .  .  .  .  .  .  Sel: caseClause
 12897  .  .  .  .  .  .  .  .  .  .  }
 12898  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12899  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12900  .  .  .  .  .  .  .  .  .  }
 12901  .  .  .  .  .  .  .  .  }
 12902  .  .  .  .  .  .  .  .  HasDots: false
 12903  .  .  .  .  .  .  .  }
 12904  .  .  .  .  .  .  }
 12905  .  .  .  .  .  }
 12906  .  .  .  .  }
 12907  .  .  .  .  7: *syntax.ExprStmt {
 12908  .  .  .  .  .  X: *syntax.CallExpr {
 12909  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12910  .  .  .  .  .  .  .  X: p
 12911  .  .  .  .  .  .  .  Sel: want
 12912  .  .  .  .  .  .  }
 12913  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12914  .  .  .  .  .  .  .  0: _Rbrace
 12915  .  .  .  .  .  .  }
 12916  .  .  .  .  .  .  HasDots: false
 12917  .  .  .  .  .  }
 12918  .  .  .  .  }
 12919  .  .  .  .  8: *syntax.ReturnStmt {
 12920  .  .  .  .  .  Results: s
 12921  .  .  .  .  }
 12922  .  .  .  }
 12923  .  .  .  Pragma: 0
 12924  .  .  .  EndLine: 1749
 12925  .  .  }
 12926  .  .  62: *syntax.FuncDecl {
 12927  .  .  .  Attr: map[]
 12928  .  .  .  Recv: *syntax.Field {
 12929  .  .  .  .  Name: p
 12930  .  .  .  .  Type: *syntax.Operation {
 12931  .  .  .  .  .  Op: *
 12932  .  .  .  .  .  X: parser
 12933  .  .  .  .  .  Y: nil
 12934  .  .  .  .  }
 12935  .  .  .  }
 12936  .  .  .  Name: selectStmt
 12937  .  .  .  Type: *syntax.FuncType {
 12938  .  .  .  .  ParamList: nil
 12939  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 12940  .  .  .  .  .  0: *syntax.Field {
 12941  .  .  .  .  .  .  Name: nil
 12942  .  .  .  .  .  .  Type: *syntax.Operation {
 12943  .  .  .  .  .  .  .  Op: *
 12944  .  .  .  .  .  .  .  X: SelectStmt
 12945  .  .  .  .  .  .  .  Y: nil
 12946  .  .  .  .  .  .  }
 12947  .  .  .  .  .  }
 12948  .  .  .  .  }
 12949  .  .  .  }
 12950  .  .  .  Body: []syntax.Stmt (8 entries) {
 12951  .  .  .  .  0: *syntax.IfStmt {
 12952  .  .  .  .  .  Init: nil
 12953  .  .  .  .  .  Cond: trace
 12954  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 12955  .  .  .  .  .  .  0: *syntax.CallStmt {
 12956  .  .  .  .  .  .  .  Tok: defer
 12957  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 12958  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 12959  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12960  .  .  .  .  .  .  .  .  .  .  X: p
 12961  .  .  .  .  .  .  .  .  .  .  Sel: trace
 12962  .  .  .  .  .  .  .  .  .  }
 12963  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12964  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 12965  .  .  .  .  .  .  .  .  .  .  .  Value: "\"selectStmt\""
 12966  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 12967  .  .  .  .  .  .  .  .  .  .  }
 12968  .  .  .  .  .  .  .  .  .  }
 12969  .  .  .  .  .  .  .  .  .  HasDots: false
 12970  .  .  .  .  .  .  .  .  }
 12971  .  .  .  .  .  .  .  .  ArgList: nil
 12972  .  .  .  .  .  .  .  .  HasDots: false
 12973  .  .  .  .  .  .  .  }
 12974  .  .  .  .  .  .  }
 12975  .  .  .  .  .  }
 12976  .  .  .  .  .  Else: nil
 12977  .  .  .  .  }
 12978  .  .  .  .  1: *syntax.ExprStmt {
 12979  .  .  .  .  .  X: *syntax.CallExpr {
 12980  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12981  .  .  .  .  .  .  .  X: p
 12982  .  .  .  .  .  .  .  Sel: want
 12983  .  .  .  .  .  .  }
 12984  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12985  .  .  .  .  .  .  .  0: _Select
 12986  .  .  .  .  .  .  }
 12987  .  .  .  .  .  .  HasDots: false
 12988  .  .  .  .  .  }
 12989  .  .  .  .  }
 12990  .  .  .  .  2: *syntax.AssignStmt {
 12991  .  .  .  .  .  Op: :
 12992  .  .  .  .  .  Lhs: s
 12993  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12994  .  .  .  .  .  .  Fun: new
 12995  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12996  .  .  .  .  .  .  .  0: SelectStmt
 12997  .  .  .  .  .  .  }
 12998  .  .  .  .  .  .  HasDots: false
 12999  .  .  .  .  .  }
 13000  .  .  .  .  }
 13001  .  .  .  .  3: *syntax.ExprStmt {
 13002  .  .  .  .  .  X: *syntax.CallExpr {
 13003  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13004  .  .  .  .  .  .  .  X: s
 13005  .  .  .  .  .  .  .  Sel: init
 13006  .  .  .  .  .  .  }
 13007  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13008  .  .  .  .  .  .  .  0: p
 13009  .  .  .  .  .  .  }
 13010  .  .  .  .  .  .  HasDots: false
 13011  .  .  .  .  .  }
 13012  .  .  .  .  }
 13013  .  .  .  .  4: *syntax.IfStmt {
 13014  .  .  .  .  .  Init: nil
 13015  .  .  .  .  .  Cond: *syntax.Operation {
 13016  .  .  .  .  .  .  Op: !
 13017  .  .  .  .  .  .  X: *syntax.CallExpr {
 13018  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13019  .  .  .  .  .  .  .  .  X: p
 13020  .  .  .  .  .  .  .  .  Sel: got
 13021  .  .  .  .  .  .  .  }
 13022  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13023  .  .  .  .  .  .  .  .  0: _Lbrace
 13024  .  .  .  .  .  .  .  }
 13025  .  .  .  .  .  .  .  HasDots: false
 13026  .  .  .  .  .  .  }
 13027  .  .  .  .  .  .  Y: nil
 13028  .  .  .  .  .  }
 13029  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 13030  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13031  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13032  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13033  .  .  .  .  .  .  .  .  .  X: p
 13034  .  .  .  .  .  .  .  .  .  Sel: syntax_error
 13035  .  .  .  .  .  .  .  .  }
 13036  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13037  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 13038  .  .  .  .  .  .  .  .  .  .  Value: "\"missing { after select clause\""
 13039  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13040  .  .  .  .  .  .  .  .  .  }
 13041  .  .  .  .  .  .  .  .  }
 13042  .  .  .  .  .  .  .  .  HasDots: false
 13043  .  .  .  .  .  .  .  }
 13044  .  .  .  .  .  .  }
 13045  .  .  .  .  .  .  1: *syntax.ExprStmt {
 13046  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13047  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13048  .  .  .  .  .  .  .  .  .  X: p
 13049  .  .  .  .  .  .  .  .  .  Sel: advance
 13050  .  .  .  .  .  .  .  .  }
 13051  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 13052  .  .  .  .  .  .  .  .  .  0: _Case
 13053  .  .  .  .  .  .  .  .  .  1: _Default
 13054  .  .  .  .  .  .  .  .  .  2: _Rbrace
 13055  .  .  .  .  .  .  .  .  }
 13056  .  .  .  .  .  .  .  .  HasDots: false
 13057  .  .  .  .  .  .  .  }
 13058  .  .  .  .  .  .  }
 13059  .  .  .  .  .  }
 13060  .  .  .  .  .  Else: nil
 13061  .  .  .  .  }
 13062  .  .  .  .  5: *syntax.ForStmt {
 13063  .  .  .  .  .  Init: nil
 13064  .  .  .  .  .  Cond: *syntax.Operation {
 13065  .  .  .  .  .  .  Op: &&
 13066  .  .  .  .  .  .  X: *syntax.Operation {
 13067  .  .  .  .  .  .  .  Op: !=
 13068  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 13069  .  .  .  .  .  .  .  .  X: p
 13070  .  .  .  .  .  .  .  .  Sel: tok
 13071  .  .  .  .  .  .  .  }
 13072  .  .  .  .  .  .  .  Y: _EOF
 13073  .  .  .  .  .  .  }
 13074  .  .  .  .  .  .  Y: *syntax.Operation {
 13075  .  .  .  .  .  .  .  Op: !=
 13076  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 13077  .  .  .  .  .  .  .  .  X: p
 13078  .  .  .  .  .  .  .  .  Sel: tok
 13079  .  .  .  .  .  .  .  }
 13080  .  .  .  .  .  .  .  Y: _Rbrace
 13081  .  .  .  .  .  .  }
 13082  .  .  .  .  .  }
 13083  .  .  .  .  .  Post: nil
 13084  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13085  .  .  .  .  .  .  0: *syntax.AssignStmt {
 13086  .  .  .  .  .  .  .  Op: <op-0>
 13087  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13088  .  .  .  .  .  .  .  .  X: s
 13089  .  .  .  .  .  .  .  .  Sel: Body
 13090  .  .  .  .  .  .  .  }
 13091  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13092  .  .  .  .  .  .  .  .  Fun: append
 13093  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 13094  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 13095  .  .  .  .  .  .  .  .  .  .  X: s
 13096  .  .  .  .  .  .  .  .  .  .  Sel: Body
 13097  .  .  .  .  .  .  .  .  .  }
 13098  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 13099  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13100  .  .  .  .  .  .  .  .  .  .  .  X: p
 13101  .  .  .  .  .  .  .  .  .  .  .  Sel: commClause
 13102  .  .  .  .  .  .  .  .  .  .  }
 13103  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13104  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13105  .  .  .  .  .  .  .  .  .  }
 13106  .  .  .  .  .  .  .  .  }
 13107  .  .  .  .  .  .  .  .  HasDots: false
 13108  .  .  .  .  .  .  .  }
 13109  .  .  .  .  .  .  }
 13110  .  .  .  .  .  }
 13111  .  .  .  .  }
 13112  .  .  .  .  6: *syntax.ExprStmt {
 13113  .  .  .  .  .  X: *syntax.CallExpr {
 13114  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13115  .  .  .  .  .  .  .  X: p
 13116  .  .  .  .  .  .  .  Sel: want
 13117  .  .  .  .  .  .  }
 13118  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13119  .  .  .  .  .  .  .  0: _Rbrace
 13120  .  .  .  .  .  .  }
 13121  .  .  .  .  .  .  HasDots: false
 13122  .  .  .  .  .  }
 13123  .  .  .  .  }
 13124  .  .  .  .  7: *syntax.ReturnStmt {
 13125  .  .  .  .  .  Results: s
 13126  .  .  .  .  }
 13127  .  .  .  }
 13128  .  .  .  Pragma: 0
 13129  .  .  .  EndLine: 1770
 13130  .  .  }
 13131  .  .  63: *syntax.FuncDecl {
 13132  .  .  .  Attr: map[]
 13133  .  .  .  Recv: *syntax.Field {
 13134  .  .  .  .  Name: p
 13135  .  .  .  .  Type: *syntax.Operation {
 13136  .  .  .  .  .  Op: *
 13137  .  .  .  .  .  X: parser
 13138  .  .  .  .  .  Y: nil
 13139  .  .  .  .  }
 13140  .  .  .  }
 13141  .  .  .  Name: caseClause
 13142  .  .  .  Type: *syntax.FuncType {
 13143  .  .  .  .  ParamList: nil
 13144  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 13145  .  .  .  .  .  0: *syntax.Field {
 13146  .  .  .  .  .  .  Name: nil
 13147  .  .  .  .  .  .  Type: *syntax.Operation {
 13148  .  .  .  .  .  .  .  Op: *
 13149  .  .  .  .  .  .  .  X: CaseClause
 13150  .  .  .  .  .  .  .  Y: nil
 13151  .  .  .  .  .  .  }
 13152  .  .  .  .  .  }
 13153  .  .  .  .  }
 13154  .  .  .  }
 13155  .  .  .  Body: []syntax.Stmt (8 entries) {
 13156  .  .  .  .  0: *syntax.IfStmt {
 13157  .  .  .  .  .  Init: nil
 13158  .  .  .  .  .  Cond: trace
 13159  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 13160  .  .  .  .  .  .  0: *syntax.CallStmt {
 13161  .  .  .  .  .  .  .  Tok: defer
 13162  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 13163  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 13164  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13165  .  .  .  .  .  .  .  .  .  .  X: p
 13166  .  .  .  .  .  .  .  .  .  .  Sel: trace
 13167  .  .  .  .  .  .  .  .  .  }
 13168  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13169  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 13170  .  .  .  .  .  .  .  .  .  .  .  Value: "\"caseClause\""
 13171  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13172  .  .  .  .  .  .  .  .  .  .  }
 13173  .  .  .  .  .  .  .  .  .  }
 13174  .  .  .  .  .  .  .  .  .  HasDots: false
 13175  .  .  .  .  .  .  .  .  }
 13176  .  .  .  .  .  .  .  .  ArgList: nil
 13177  .  .  .  .  .  .  .  .  HasDots: false
 13178  .  .  .  .  .  .  .  }
 13179  .  .  .  .  .  .  }
 13180  .  .  .  .  .  }
 13181  .  .  .  .  .  Else: nil
 13182  .  .  .  .  }
 13183  .  .  .  .  1: *syntax.AssignStmt {
 13184  .  .  .  .  .  Op: :
 13185  .  .  .  .  .  Lhs: c
 13186  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13187  .  .  .  .  .  .  Fun: new
 13188  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13189  .  .  .  .  .  .  .  0: CaseClause
 13190  .  .  .  .  .  .  }
 13191  .  .  .  .  .  .  HasDots: false
 13192  .  .  .  .  .  }
 13193  .  .  .  .  }
 13194  .  .  .  .  2: *syntax.ExprStmt {
 13195  .  .  .  .  .  X: *syntax.CallExpr {
 13196  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13197  .  .  .  .  .  .  .  X: c
 13198  .  .  .  .  .  .  .  Sel: init
 13199  .  .  .  .  .  .  }
 13200  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13201  .  .  .  .  .  .  .  0: p
 13202  .  .  .  .  .  .  }
 13203  .  .  .  .  .  .  HasDots: false
 13204  .  .  .  .  .  }
 13205  .  .  .  .  }
 13206  .  .  .  .  3: *syntax.SwitchStmt {
 13207  .  .  .  .  .  Init: nil
 13208  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 13209  .  .  .  .  .  .  X: p
 13210  .  .  .  .  .  .  Sel: tok
 13211  .  .  .  .  .  }
 13212  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 13213  .  .  .  .  .  .  0: *syntax.CaseClause {
 13214  .  .  .  .  .  .  .  Cases: _Case
 13215  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 13216  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13217  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13218  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13219  .  .  .  .  .  .  .  .  .  .  .  X: p
 13220  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 13221  .  .  .  .  .  .  .  .  .  .  }
 13222  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13223  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13224  .  .  .  .  .  .  .  .  .  }
 13225  .  .  .  .  .  .  .  .  }
 13226  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 13227  .  .  .  .  .  .  .  .  .  Op: <op-0>
 13228  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13229  .  .  .  .  .  .  .  .  .  .  X: c
 13230  .  .  .  .  .  .  .  .  .  .  Sel: Cases
 13231  .  .  .  .  .  .  .  .  .  }
 13232  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13233  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13234  .  .  .  .  .  .  .  .  .  .  .  X: p
 13235  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList
 13236  .  .  .  .  .  .  .  .  .  .  }
 13237  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13238  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13239  .  .  .  .  .  .  .  .  .  }
 13240  .  .  .  .  .  .  .  .  }
 13241  .  .  .  .  .  .  .  }
 13242  .  .  .  .  .  .  }
 13243  .  .  .  .  .  .  1: *syntax.CaseClause {
 13244  .  .  .  .  .  .  .  Cases: _Default
 13245  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13246  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13247  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13248  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13249  .  .  .  .  .  .  .  .  .  .  .  X: p
 13250  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 13251  .  .  .  .  .  .  .  .  .  .  }
 13252  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13253  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13254  .  .  .  .  .  .  .  .  .  }
 13255  .  .  .  .  .  .  .  .  }
 13256  .  .  .  .  .  .  .  }
 13257  .  .  .  .  .  .  }
 13258  .  .  .  .  .  .  2: *syntax.CaseClause {
 13259  .  .  .  .  .  .  .  Cases: nil
 13260  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 13261  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13262  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13263  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13264  .  .  .  .  .  .  .  .  .  .  .  X: p
 13265  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
 13266  .  .  .  .  .  .  .  .  .  .  }
 13267  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13268  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 13269  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting case or default or }\""
 13270  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13271  .  .  .  .  .  .  .  .  .  .  .  }
 13272  .  .  .  .  .  .  .  .  .  .  }
 13273  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13274  .  .  .  .  .  .  .  .  .  }
 13275  .  .  .  .  .  .  .  .  }
 13276  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 13277  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13278  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13279  .  .  .  .  .  .  .  .  .  .  .  X: p
 13280  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
 13281  .  .  .  .  .  .  .  .  .  .  }
 13282  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 13283  .  .  .  .  .  .  .  .  .  .  .  0: _Case
 13284  .  .  .  .  .  .  .  .  .  .  .  1: _Default
 13285  .  .  .  .  .  .  .  .  .  .  .  2: _Rbrace
 13286  .  .  .  .  .  .  .  .  .  .  }
 13287  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13288  .  .  .  .  .  .  .  .  .  }
 13289  .  .  .  .  .  .  .  .  }
 13290  .  .  .  .  .  .  .  }
 13291  .  .  .  .  .  .  }
 13292  .  .  .  .  .  }
 13293  .  .  .  .  }
 13294  .  .  .  .  4: *syntax.IfStmt {
 13295  .  .  .  .  .  Init: nil
 13296  .  .  .  .  .  Cond: gcCompat
 13297  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 13298  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13299  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13300  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13301  .  .  .  .  .  .  .  .  .  X: c
 13302  .  .  .  .  .  .  .  .  .  Sel: init
 13303  .  .  .  .  .  .  .  .  }
 13304  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13305  .  .  .  .  .  .  .  .  .  0: p
 13306  .  .  .  .  .  .  .  .  }
 13307  .  .  .  .  .  .  .  .  HasDots: false
 13308  .  .  .  .  .  .  .  }
 13309  .  .  .  .  .  .  }
 13310  .  .  .  .  .  }
 13311  .  .  .  .  .  Else: nil
 13312  .  .  .  .  }
 13313  .  .  .  .  5: *syntax.ExprStmt {
 13314  .  .  .  .  .  X: *syntax.CallExpr {
 13315  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13316  .  .  .  .  .  .  .  X: p
 13317  .  .  .  .  .  .  .  Sel: want
 13318  .  .  .  .  .  .  }
 13319  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13320  .  .  .  .  .  .  .  0: _Colon
 13321  .  .  .  .  .  .  }
 13322  .  .  .  .  .  .  HasDots: false
 13323  .  .  .  .  .  }
 13324  .  .  .  .  }
 13325  .  .  .  .  6: *syntax.AssignStmt {
 13326  .  .  .  .  .  Op: <op-0>
 13327  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13328  .  .  .  .  .  .  X: c
 13329  .  .  .  .  .  .  Sel: Body
 13330  .  .  .  .  .  }
 13331  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13332  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13333  .  .  .  .  .  .  .  X: p
 13334  .  .  .  .  .  .  .  Sel: stmtList
 13335  .  .  .  .  .  .  }
 13336  .  .  .  .  .  .  ArgList: nil
 13337  .  .  .  .  .  .  HasDots: false
 13338  .  .  .  .  .  }
 13339  .  .  .  .  }
 13340  .  .  .  .  7: *syntax.ReturnStmt {
 13341  .  .  .  .  .  Results: c
 13342  .  .  .  .  }
 13343  .  .  .  }
 13344  .  .  .  Pragma: 0
 13345  .  .  .  EndLine: 1800
 13346  .  .  }
 13347  .  .  64: *syntax.FuncDecl {
 13348  .  .  .  Attr: map[]
 13349  .  .  .  Recv: *syntax.Field {
 13350  .  .  .  .  Name: p
 13351  .  .  .  .  Type: *syntax.Operation {
 13352  .  .  .  .  .  Op: *
 13353  .  .  .  .  .  X: parser
 13354  .  .  .  .  .  Y: nil
 13355  .  .  .  .  }
 13356  .  .  .  }
 13357  .  .  .  Name: commClause
 13358  .  .  .  Type: *syntax.FuncType {
 13359  .  .  .  .  ParamList: nil
 13360  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 13361  .  .  .  .  .  0: *syntax.Field {
 13362  .  .  .  .  .  .  Name: nil
 13363  .  .  .  .  .  .  Type: *syntax.Operation {
 13364  .  .  .  .  .  .  .  Op: *
 13365  .  .  .  .  .  .  .  X: CommClause
 13366  .  .  .  .  .  .  .  Y: nil
 13367  .  .  .  .  .  .  }
 13368  .  .  .  .  .  }
 13369  .  .  .  .  }
 13370  .  .  .  }
 13371  .  .  .  Body: []syntax.Stmt (8 entries) {
 13372  .  .  .  .  0: *syntax.IfStmt {
 13373  .  .  .  .  .  Init: nil
 13374  .  .  .  .  .  Cond: trace
 13375  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 13376  .  .  .  .  .  .  0: *syntax.CallStmt {
 13377  .  .  .  .  .  .  .  Tok: defer
 13378  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 13379  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 13380  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13381  .  .  .  .  .  .  .  .  .  .  X: p
 13382  .  .  .  .  .  .  .  .  .  .  Sel: trace
 13383  .  .  .  .  .  .  .  .  .  }
 13384  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13385  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 13386  .  .  .  .  .  .  .  .  .  .  .  Value: "\"commClause\""
 13387  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13388  .  .  .  .  .  .  .  .  .  .  }
 13389  .  .  .  .  .  .  .  .  .  }
 13390  .  .  .  .  .  .  .  .  .  HasDots: false
 13391  .  .  .  .  .  .  .  .  }
 13392  .  .  .  .  .  .  .  .  ArgList: nil
 13393  .  .  .  .  .  .  .  .  HasDots: false
 13394  .  .  .  .  .  .  .  }
 13395  .  .  .  .  .  .  }
 13396  .  .  .  .  .  }
 13397  .  .  .  .  .  Else: nil
 13398  .  .  .  .  }
 13399  .  .  .  .  1: *syntax.AssignStmt {
 13400  .  .  .  .  .  Op: :
 13401  .  .  .  .  .  Lhs: c
 13402  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13403  .  .  .  .  .  .  Fun: new
 13404  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13405  .  .  .  .  .  .  .  0: CommClause
 13406  .  .  .  .  .  .  }
 13407  .  .  .  .  .  .  HasDots: false
 13408  .  .  .  .  .  }
 13409  .  .  .  .  }
 13410  .  .  .  .  2: *syntax.ExprStmt {
 13411  .  .  .  .  .  X: *syntax.CallExpr {
 13412  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13413  .  .  .  .  .  .  .  X: c
 13414  .  .  .  .  .  .  .  Sel: init
 13415  .  .  .  .  .  .  }
 13416  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13417  .  .  .  .  .  .  .  0: p
 13418  .  .  .  .  .  .  }
 13419  .  .  .  .  .  .  HasDots: false
 13420  .  .  .  .  .  }
 13421  .  .  .  .  }
 13422  .  .  .  .  3: *syntax.SwitchStmt {
 13423  .  .  .  .  .  Init: nil
 13424  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 13425  .  .  .  .  .  .  X: p
 13426  .  .  .  .  .  .  Sel: tok
 13427  .  .  .  .  .  }
 13428  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 13429  .  .  .  .  .  .  0: *syntax.CaseClause {
 13430  .  .  .  .  .  .  .  Cases: _Case
 13431  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 13432  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13433  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13434  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13435  .  .  .  .  .  .  .  .  .  .  .  X: p
 13436  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 13437  .  .  .  .  .  .  .  .  .  .  }
 13438  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13439  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13440  .  .  .  .  .  .  .  .  .  }
 13441  .  .  .  .  .  .  .  .  }
 13442  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 13443  .  .  .  .  .  .  .  .  .  Op: <op-0>
 13444  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13445  .  .  .  .  .  .  .  .  .  .  X: c
 13446  .  .  .  .  .  .  .  .  .  .  Sel: Comm
 13447  .  .  .  .  .  .  .  .  .  }
 13448  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13449  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13450  .  .  .  .  .  .  .  .  .  .  .  X: p
 13451  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt
 13452  .  .  .  .  .  .  .  .  .  .  }
 13453  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 13454  .  .  .  .  .  .  .  .  .  .  .  0: nil
 13455  .  .  .  .  .  .  .  .  .  .  .  1: false
 13456  .  .  .  .  .  .  .  .  .  .  }
 13457  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13458  .  .  .  .  .  .  .  .  .  }
 13459  .  .  .  .  .  .  .  .  }
 13460  .  .  .  .  .  .  .  }
 13461  .  .  .  .  .  .  }
 13462  .  .  .  .  .  .  1: *syntax.CaseClause {
 13463  .  .  .  .  .  .  .  Cases: _Default
 13464  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13465  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13466  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13467  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13468  .  .  .  .  .  .  .  .  .  .  .  X: p
 13469  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 13470  .  .  .  .  .  .  .  .  .  .  }
 13471  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13472  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13473  .  .  .  .  .  .  .  .  .  }
 13474  .  .  .  .  .  .  .  .  }
 13475  .  .  .  .  .  .  .  }
 13476  .  .  .  .  .  .  }
 13477  .  .  .  .  .  .  2: *syntax.CaseClause {
 13478  .  .  .  .  .  .  .  Cases: nil
 13479  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 13480  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13481  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13482  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13483  .  .  .  .  .  .  .  .  .  .  .  X: p
 13484  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
 13485  .  .  .  .  .  .  .  .  .  .  }
 13486  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13487  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 13488  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting case or default or }\""
 13489  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13490  .  .  .  .  .  .  .  .  .  .  .  }
 13491  .  .  .  .  .  .  .  .  .  .  }
 13492  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13493  .  .  .  .  .  .  .  .  .  }
 13494  .  .  .  .  .  .  .  .  }
 13495  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 13496  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13497  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13498  .  .  .  .  .  .  .  .  .  .  .  X: p
 13499  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
 13500  .  .  .  .  .  .  .  .  .  .  }
 13501  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 13502  .  .  .  .  .  .  .  .  .  .  .  0: _Case
 13503  .  .  .  .  .  .  .  .  .  .  .  1: _Default
 13504  .  .  .  .  .  .  .  .  .  .  .  2: _Rbrace
 13505  .  .  .  .  .  .  .  .  .  .  }
 13506  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13507  .  .  .  .  .  .  .  .  .  }
 13508  .  .  .  .  .  .  .  .  }
 13509  .  .  .  .  .  .  .  }
 13510  .  .  .  .  .  .  }
 13511  .  .  .  .  .  }
 13512  .  .  .  .  }
 13513  .  .  .  .  4: *syntax.IfStmt {
 13514  .  .  .  .  .  Init: nil
 13515  .  .  .  .  .  Cond: gcCompat
 13516  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 13517  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13518  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13519  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13520  .  .  .  .  .  .  .  .  .  X: c
 13521  .  .  .  .  .  .  .  .  .  Sel: init
 13522  .  .  .  .  .  .  .  .  }
 13523  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13524  .  .  .  .  .  .  .  .  .  0: p
 13525  .  .  .  .  .  .  .  .  }
 13526  .  .  .  .  .  .  .  .  HasDots: false
 13527  .  .  .  .  .  .  .  }
 13528  .  .  .  .  .  .  }
 13529  .  .  .  .  .  }
 13530  .  .  .  .  .  Else: nil
 13531  .  .  .  .  }
 13532  .  .  .  .  5: *syntax.ExprStmt {
 13533  .  .  .  .  .  X: *syntax.CallExpr {
 13534  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13535  .  .  .  .  .  .  .  X: p
 13536  .  .  .  .  .  .  .  Sel: want
 13537  .  .  .  .  .  .  }
 13538  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13539  .  .  .  .  .  .  .  0: _Colon
 13540  .  .  .  .  .  .  }
 13541  .  .  .  .  .  .  HasDots: false
 13542  .  .  .  .  .  }
 13543  .  .  .  .  }
 13544  .  .  .  .  6: *syntax.AssignStmt {
 13545  .  .  .  .  .  Op: <op-0>
 13546  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13547  .  .  .  .  .  .  X: c
 13548  .  .  .  .  .  .  Sel: Body
 13549  .  .  .  .  .  }
 13550  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13551  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13552  .  .  .  .  .  .  .  X: p
 13553  .  .  .  .  .  .  .  Sel: stmtList
 13554  .  .  .  .  .  .  }
 13555  .  .  .  .  .  .  ArgList: nil
 13556  .  .  .  .  .  .  HasDots: false
 13557  .  .  .  .  .  }
 13558  .  .  .  .  }
 13559  .  .  .  .  7: *syntax.ReturnStmt {
 13560  .  .  .  .  .  Results: c
 13561  .  .  .  .  }
 13562  .  .  .  }
 13563  .  .  .  Pragma: 0
 13564  .  .  .  EndLine: 1842
 13565  .  .  }
 13566  .  .  65: *syntax.VarDecl {
 13567  .  .  .  NameList: []*syntax.Name (1 entries) {
 13568  .  .  .  .  0: missing_stmt
 13569  .  .  .  }
 13570  .  .  .  Type: Stmt
 13571  .  .  .  Values: *syntax.CallExpr {
 13572  .  .  .  .  Fun: new
 13573  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13574  .  .  .  .  .  0: EmptyStmt
 13575  .  .  .  .  }
 13576  .  .  .  .  HasDots: false
 13577  .  .  .  }
 13578  .  .  .  Group: nil
 13579  .  .  }
 13580  .  .  66: *syntax.FuncDecl {
 13581  .  .  .  Attr: map[]
 13582  .  .  .  Recv: *syntax.Field {
 13583  .  .  .  .  Name: p
 13584  .  .  .  .  Type: *syntax.Operation {
 13585  .  .  .  .  .  Op: *
 13586  .  .  .  .  .  X: parser
 13587  .  .  .  .  .  Y: nil
 13588  .  .  .  .  }
 13589  .  .  .  }
 13590  .  .  .  Name: stmt
 13591  .  .  .  Type: *syntax.FuncType {
 13592  .  .  .  .  ParamList: nil
 13593  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 13594  .  .  .  .  .  0: *syntax.Field {
 13595  .  .  .  .  .  .  Name: nil
 13596  .  .  .  .  .  .  Type: Stmt
 13597  .  .  .  .  .  }
 13598  .  .  .  .  }
 13599  .  .  .  }
 13600  .  .  .  Body: []syntax.Stmt (4 entries) {
 13601  .  .  .  .  0: *syntax.IfStmt {
 13602  .  .  .  .  .  Init: nil
 13603  .  .  .  .  .  Cond: trace
 13604  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 13605  .  .  .  .  .  .  0: *syntax.CallStmt {
 13606  .  .  .  .  .  .  .  Tok: defer
 13607  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 13608  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 13609  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13610  .  .  .  .  .  .  .  .  .  .  X: p
 13611  .  .  .  .  .  .  .  .  .  .  Sel: trace
 13612  .  .  .  .  .  .  .  .  .  }
 13613  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13614  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
 13615  .  .  .  .  .  .  .  .  .  .  .  Op: +
 13616  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
 13617  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"stmt \""
 13618  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13619  .  .  .  .  .  .  .  .  .  .  .  }
 13620  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
 13621  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13622  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 13623  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 13624  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
 13625  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13626  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: String
 13627  .  .  .  .  .  .  .  .  .  .  .  .  }
 13628  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13629  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13630  .  .  .  .  .  .  .  .  .  .  .  }
 13631  .  .  .  .  .  .  .  .  .  .  }
 13632  .  .  .  .  .  .  .  .  .  }
 13633  .  .  .  .  .  .  .  .  .  HasDots: false
 13634  .  .  .  .  .  .  .  .  }
 13635  .  .  .  .  .  .  .  .  ArgList: nil
 13636  .  .  .  .  .  .  .  .  HasDots: false
 13637  .  .  .  .  .  .  .  }
 13638  .  .  .  .  .  .  }
 13639  .  .  .  .  .  }
 13640  .  .  .  .  .  Else: nil
 13641  .  .  .  .  }
 13642  .  .  .  .  1: *syntax.IfStmt {
 13643  .  .  .  .  .  Init: nil
 13644  .  .  .  .  .  Cond: *syntax.Operation {
 13645  .  .  .  .  .  .  Op: ==
 13646  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 13647  .  .  .  .  .  .  .  X: p
 13648  .  .  .  .  .  .  .  Sel: tok
 13649  .  .  .  .  .  .  }
 13650  .  .  .  .  .  .  Y: _Name
 13651  .  .  .  .  .  }
 13652  .  .  .  .  .  Then: []syntax.Stmt (3 entries) {
 13653  .  .  .  .  .  .  0: *syntax.AssignStmt {
 13654  .  .  .  .  .  .  .  Op: :
 13655  .  .  .  .  .  .  .  Lhs: lhs
 13656  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13657  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13658  .  .  .  .  .  .  .  .  .  X: p
 13659  .  .  .  .  .  .  .  .  .  Sel: exprList
 13660  .  .  .  .  .  .  .  .  }
 13661  .  .  .  .  .  .  .  .  ArgList: nil
 13662  .  .  .  .  .  .  .  .  HasDots: false
 13663  .  .  .  .  .  .  .  }
 13664  .  .  .  .  .  .  }
 13665  .  .  .  .  .  .  1: *syntax.IfStmt {
 13666  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 13667  .  .  .  .  .  .  .  .  Op: :
 13668  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 13669  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 13670  .  .  .  .  .  .  .  .  .  .  0: label
 13671  .  .  .  .  .  .  .  .  .  .  1: ok
 13672  .  .  .  .  .  .  .  .  .  }
 13673  .  .  .  .  .  .  .  .  }
 13674  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 13675  .  .  .  .  .  .  .  .  .  X: lhs
 13676  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 13677  .  .  .  .  .  .  .  .  .  .  Op: *
 13678  .  .  .  .  .  .  .  .  .  .  X: Name
 13679  .  .  .  .  .  .  .  .  .  .  Y: nil
 13680  .  .  .  .  .  .  .  .  .  }
 13681  .  .  .  .  .  .  .  .  }
 13682  .  .  .  .  .  .  .  }
 13683  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 13684  .  .  .  .  .  .  .  .  Op: &&
 13685  .  .  .  .  .  .  .  .  X: ok
 13686  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 13687  .  .  .  .  .  .  .  .  .  Op: ==
 13688  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 13689  .  .  .  .  .  .  .  .  .  .  X: p
 13690  .  .  .  .  .  .  .  .  .  .  Sel: tok
 13691  .  .  .  .  .  .  .  .  .  }
 13692  .  .  .  .  .  .  .  .  .  Y: _Colon
 13693  .  .  .  .  .  .  .  .  }
 13694  .  .  .  .  .  .  .  }
 13695  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 13696  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 13697  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 13698  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13699  .  .  .  .  .  .  .  .  .  .  .  X: p
 13700  .  .  .  .  .  .  .  .  .  .  .  Sel: labeledStmt
 13701  .  .  .  .  .  .  .  .  .  .  }
 13702  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13703  .  .  .  .  .  .  .  .  .  .  .  0: label
 13704  .  .  .  .  .  .  .  .  .  .  }
 13705  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13706  .  .  .  .  .  .  .  .  .  }
 13707  .  .  .  .  .  .  .  .  }
 13708  .  .  .  .  .  .  .  }
 13709  .  .  .  .  .  .  .  Else: nil
 13710  .  .  .  .  .  .  }
 13711  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 13712  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 13713  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13714  .  .  .  .  .  .  .  .  .  X: p
 13715  .  .  .  .  .  .  .  .  .  Sel: simpleStmt
 13716  .  .  .  .  .  .  .  .  }
 13717  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 13718  .  .  .  .  .  .  .  .  .  0: lhs
 13719  .  .  .  .  .  .  .  .  .  1: false
 13720  .  .  .  .  .  .  .  .  }
 13721  .  .  .  .  .  .  .  .  HasDots: false
 13722  .  .  .  .  .  .  .  }
 13723  .  .  .  .  .  .  }
 13724  .  .  .  .  .  }
 13725  .  .  .  .  .  Else: nil
 13726  .  .  .  .  }
 13727  .  .  .  .  2: *syntax.SwitchStmt {
 13728  .  .  .  .  .  Init: nil
 13729  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 13730  .  .  .  .  .  .  X: p
 13731  .  .  .  .  .  .  Sel: tok
 13732  .  .  .  .  .  }
 13733  .  .  .  .  .  Body: []*syntax.CaseClause (16 entries) {
 13734  .  .  .  .  .  .  0: *syntax.CaseClause {
 13735  .  .  .  .  .  .  .  Cases: _Lbrace
 13736  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13737  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 13738  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 13739  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13740  .  .  .  .  .  .  .  .  .  .  .  X: p
 13741  .  .  .  .  .  .  .  .  .  .  .  Sel: blockStmt
 13742  .  .  .  .  .  .  .  .  .  .  }
 13743  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13744  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13745  .  .  .  .  .  .  .  .  .  }
 13746  .  .  .  .  .  .  .  .  }
 13747  .  .  .  .  .  .  .  }
 13748  .  .  .  .  .  .  }
 13749  .  .  .  .  .  .  1: *syntax.CaseClause {
 13750  .  .  .  .  .  .  .  Cases: _Var
 13751  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13752  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 13753  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 13754  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13755  .  .  .  .  .  .  .  .  .  .  .  X: p
 13756  .  .  .  .  .  .  .  .  .  .  .  Sel: declStmt
 13757  .  .  .  .  .  .  .  .  .  .  }
 13758  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13759  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 13760  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 13761  .  .  .  .  .  .  .  .  .  .  .  .  Sel: varDecl
 13762  .  .  .  .  .  .  .  .  .  .  .  }
 13763  .  .  .  .  .  .  .  .  .  .  }
 13764  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13765  .  .  .  .  .  .  .  .  .  }
 13766  .  .  .  .  .  .  .  .  }
 13767  .  .  .  .  .  .  .  }
 13768  .  .  .  .  .  .  }
 13769  .  .  .  .  .  .  2: *syntax.CaseClause {
 13770  .  .  .  .  .  .  .  Cases: _Const
 13771  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13772  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 13773  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 13774  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13775  .  .  .  .  .  .  .  .  .  .  .  X: p
 13776  .  .  .  .  .  .  .  .  .  .  .  Sel: declStmt
 13777  .  .  .  .  .  .  .  .  .  .  }
 13778  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13779  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 13780  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 13781  .  .  .  .  .  .  .  .  .  .  .  .  Sel: constDecl
 13782  .  .  .  .  .  .  .  .  .  .  .  }
 13783  .  .  .  .  .  .  .  .  .  .  }
 13784  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13785  .  .  .  .  .  .  .  .  .  }
 13786  .  .  .  .  .  .  .  .  }
 13787  .  .  .  .  .  .  .  }
 13788  .  .  .  .  .  .  }
 13789  .  .  .  .  .  .  3: *syntax.CaseClause {
 13790  .  .  .  .  .  .  .  Cases: _Type
 13791  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13792  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 13793  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 13794  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13795  .  .  .  .  .  .  .  .  .  .  .  X: p
 13796  .  .  .  .  .  .  .  .  .  .  .  Sel: declStmt
 13797  .  .  .  .  .  .  .  .  .  .  }
 13798  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13799  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 13800  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 13801  .  .  .  .  .  .  .  .  .  .  .  .  Sel: typeDecl
 13802  .  .  .  .  .  .  .  .  .  .  .  }
 13803  .  .  .  .  .  .  .  .  .  .  }
 13804  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13805  .  .  .  .  .  .  .  .  .  }
 13806  .  .  .  .  .  .  .  .  }
 13807  .  .  .  .  .  .  .  }
 13808  .  .  .  .  .  .  }
 13809  .  .  .  .  .  .  4: *syntax.CaseClause {
 13810  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 13811  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 13812  .  .  .  .  .  .  .  .  .  0: _Operator
 13813  .  .  .  .  .  .  .  .  .  1: _Star
 13814  .  .  .  .  .  .  .  .  }
 13815  .  .  .  .  .  .  .  }
 13816  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13817  .  .  .  .  .  .  .  .  0: *syntax.SwitchStmt {
 13818  .  .  .  .  .  .  .  .  .  Init: nil
 13819  .  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 13820  .  .  .  .  .  .  .  .  .  .  X: p
 13821  .  .  .  .  .  .  .  .  .  .  Sel: op
 13822  .  .  .  .  .  .  .  .  .  }
 13823  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (1 entries) {
 13824  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 13825  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 13826  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (6 entries) {
 13827  .  .  .  .  .  .  .  .  .  .  .  .  .  0: Add
 13828  .  .  .  .  .  .  .  .  .  .  .  .  .  1: Sub
 13829  .  .  .  .  .  .  .  .  .  .  .  .  .  2: Mul
 13830  .  .  .  .  .  .  .  .  .  .  .  .  .  3: And
 13831  .  .  .  .  .  .  .  .  .  .  .  .  .  4: Xor
 13832  .  .  .  .  .  .  .  .  .  .  .  .  .  5: Not
 13833  .  .  .  .  .  .  .  .  .  .  .  .  }
 13834  .  .  .  .  .  .  .  .  .  .  .  }
 13835  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13836  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 13837  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 13838  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13839  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 13840  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt
 13841  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13842  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 13843  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil
 13844  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: false
 13845  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13846  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13847  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13848  .  .  .  .  .  .  .  .  .  .  .  .  }
 13849  .  .  .  .  .  .  .  .  .  .  .  }
 13850  .  .  .  .  .  .  .  .  .  .  }
 13851  .  .  .  .  .  .  .  .  .  }
 13852  .  .  .  .  .  .  .  .  }
 13853  .  .  .  .  .  .  .  }
 13854  .  .  .  .  .  .  }
 13855  .  .  .  .  .  .  5: *syntax.CaseClause {
 13856  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 13857  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (9 entries) {
 13858  .  .  .  .  .  .  .  .  .  0: _Literal
 13859  .  .  .  .  .  .  .  .  .  1: _Func
 13860  .  .  .  .  .  .  .  .  .  2: _Lparen
 13861  .  .  .  .  .  .  .  .  .  3: _Lbrack
 13862  .  .  .  .  .  .  .  .  .  4: _Struct
 13863  .  .  .  .  .  .  .  .  .  5: _Map
 13864  .  .  .  .  .  .  .  .  .  6: _Chan
 13865  .  .  .  .  .  .  .  .  .  7: _Interface
 13866  .  .  .  .  .  .  .  .  .  8: _Arrow
 13867  .  .  .  .  .  .  .  .  }
 13868  .  .  .  .  .  .  .  }
 13869  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13870  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 13871  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 13872  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13873  .  .  .  .  .  .  .  .  .  .  .  X: p
 13874  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt
 13875  .  .  .  .  .  .  .  .  .  .  }
 13876  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 13877  .  .  .  .  .  .  .  .  .  .  .  0: nil
 13878  .  .  .  .  .  .  .  .  .  .  .  1: false
 13879  .  .  .  .  .  .  .  .  .  .  }
 13880  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13881  .  .  .  .  .  .  .  .  .  }
 13882  .  .  .  .  .  .  .  .  }
 13883  .  .  .  .  .  .  .  }
 13884  .  .  .  .  .  .  }
 13885  .  .  .  .  .  .  6: *syntax.CaseClause {
 13886  .  .  .  .  .  .  .  Cases: _For
 13887  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13888  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 13889  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 13890  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13891  .  .  .  .  .  .  .  .  .  .  .  X: p
 13892  .  .  .  .  .  .  .  .  .  .  .  Sel: forStmt
 13893  .  .  .  .  .  .  .  .  .  .  }
 13894  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13895  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13896  .  .  .  .  .  .  .  .  .  }
 13897  .  .  .  .  .  .  .  .  }
 13898  .  .  .  .  .  .  .  }
 13899  .  .  .  .  .  .  }
 13900  .  .  .  .  .  .  7: *syntax.CaseClause {
 13901  .  .  .  .  .  .  .  Cases: _Switch
 13902  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13903  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 13904  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 13905  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13906  .  .  .  .  .  .  .  .  .  .  .  X: p
 13907  .  .  .  .  .  .  .  .  .  .  .  Sel: switchStmt
 13908  .  .  .  .  .  .  .  .  .  .  }
 13909  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13910  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13911  .  .  .  .  .  .  .  .  .  }
 13912  .  .  .  .  .  .  .  .  }
 13913  .  .  .  .  .  .  .  }
 13914  .  .  .  .  .  .  }
 13915  .  .  .  .  .  .  8: *syntax.CaseClause {
 13916  .  .  .  .  .  .  .  Cases: _Select
 13917  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13918  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 13919  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 13920  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13921  .  .  .  .  .  .  .  .  .  .  .  X: p
 13922  .  .  .  .  .  .  .  .  .  .  .  Sel: selectStmt
 13923  .  .  .  .  .  .  .  .  .  .  }
 13924  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13925  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13926  .  .  .  .  .  .  .  .  .  }
 13927  .  .  .  .  .  .  .  .  }
 13928  .  .  .  .  .  .  .  }
 13929  .  .  .  .  .  .  }
 13930  .  .  .  .  .  .  9: *syntax.CaseClause {
 13931  .  .  .  .  .  .  .  Cases: _If
 13932  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 13933  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 13934  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 13935  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13936  .  .  .  .  .  .  .  .  .  .  .  X: p
 13937  .  .  .  .  .  .  .  .  .  .  .  Sel: ifStmt
 13938  .  .  .  .  .  .  .  .  .  .  }
 13939  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13940  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13941  .  .  .  .  .  .  .  .  .  }
 13942  .  .  .  .  .  .  .  .  }
 13943  .  .  .  .  .  .  .  }
 13944  .  .  .  .  .  .  }
 13945  .  .  .  .  .  .  10: *syntax.CaseClause {
 13946  .  .  .  .  .  .  .  Cases: _Fallthrough
 13947  .  .  .  .  .  .  .  Body: []syntax.Stmt (5 entries) {
 13948  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13949  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13950  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13951  .  .  .  .  .  .  .  .  .  .  .  X: p
 13952  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 13953  .  .  .  .  .  .  .  .  .  .  }
 13954  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13955  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13956  .  .  .  .  .  .  .  .  .  }
 13957  .  .  .  .  .  .  .  .  }
 13958  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 13959  .  .  .  .  .  .  .  .  .  Op: :
 13960  .  .  .  .  .  .  .  .  .  Lhs: s
 13961  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13962  .  .  .  .  .  .  .  .  .  .  Fun: new
 13963  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13964  .  .  .  .  .  .  .  .  .  .  .  0: BranchStmt
 13965  .  .  .  .  .  .  .  .  .  .  }
 13966  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13967  .  .  .  .  .  .  .  .  .  }
 13968  .  .  .  .  .  .  .  .  }
 13969  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 13970  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13971  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13972  .  .  .  .  .  .  .  .  .  .  .  X: s
 13973  .  .  .  .  .  .  .  .  .  .  .  Sel: init
 13974  .  .  .  .  .  .  .  .  .  .  }
 13975  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13976  .  .  .  .  .  .  .  .  .  .  .  0: p
 13977  .  .  .  .  .  .  .  .  .  .  }
 13978  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13979  .  .  .  .  .  .  .  .  .  }
 13980  .  .  .  .  .  .  .  .  }
 13981  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
 13982  .  .  .  .  .  .  .  .  .  Op: <op-0>
 13983  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13984  .  .  .  .  .  .  .  .  .  .  X: s
 13985  .  .  .  .  .  .  .  .  .  .  Sel: Tok
 13986  .  .  .  .  .  .  .  .  .  }
 13987  .  .  .  .  .  .  .  .  .  Rhs: _Fallthrough
 13988  .  .  .  .  .  .  .  .  }
 13989  .  .  .  .  .  .  .  .  4: *syntax.ReturnStmt {
 13990  .  .  .  .  .  .  .  .  .  Results: s
 13991  .  .  .  .  .  .  .  .  }
 13992  .  .  .  .  .  .  .  }
 13993  .  .  .  .  .  .  }
 13994  .  .  .  .  .  .  11: *syntax.CaseClause {
 13995  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 13996  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 13997  .  .  .  .  .  .  .  .  .  0: _Break
 13998  .  .  .  .  .  .  .  .  .  1: _Continue
 13999  .  .  .  .  .  .  .  .  }
 14000  .  .  .  .  .  .  .  }
 14001  .  .  .  .  .  .  .  Body: []syntax.Stmt (7 entries) {
 14002  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14003  .  .  .  .  .  .  .  .  .  Op: :
 14004  .  .  .  .  .  .  .  .  .  Lhs: tok
 14005  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 14006  .  .  .  .  .  .  .  .  .  .  X: p
 14007  .  .  .  .  .  .  .  .  .  .  Sel: tok
 14008  .  .  .  .  .  .  .  .  .  }
 14009  .  .  .  .  .  .  .  .  }
 14010  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 14011  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14012  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14013  .  .  .  .  .  .  .  .  .  .  .  X: p
 14014  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 14015  .  .  .  .  .  .  .  .  .  .  }
 14016  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14017  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14018  .  .  .  .  .  .  .  .  .  }
 14019  .  .  .  .  .  .  .  .  }
 14020  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 14021  .  .  .  .  .  .  .  .  .  Op: :
 14022  .  .  .  .  .  .  .  .  .  Lhs: s
 14023  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14024  .  .  .  .  .  .  .  .  .  .  Fun: new
 14025  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14026  .  .  .  .  .  .  .  .  .  .  .  0: BranchStmt
 14027  .  .  .  .  .  .  .  .  .  .  }
 14028  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14029  .  .  .  .  .  .  .  .  .  }
 14030  .  .  .  .  .  .  .  .  }
 14031  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
 14032  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14033  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14034  .  .  .  .  .  .  .  .  .  .  .  X: s
 14035  .  .  .  .  .  .  .  .  .  .  .  Sel: init
 14036  .  .  .  .  .  .  .  .  .  .  }
 14037  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14038  .  .  .  .  .  .  .  .  .  .  .  0: p
 14039  .  .  .  .  .  .  .  .  .  .  }
 14040  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14041  .  .  .  .  .  .  .  .  .  }
 14042  .  .  .  .  .  .  .  .  }
 14043  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
 14044  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14045  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14046  .  .  .  .  .  .  .  .  .  .  X: s
 14047  .  .  .  .  .  .  .  .  .  .  Sel: Tok
 14048  .  .  .  .  .  .  .  .  .  }
 14049  .  .  .  .  .  .  .  .  .  Rhs: tok
 14050  .  .  .  .  .  .  .  .  }
 14051  .  .  .  .  .  .  .  .  5: *syntax.IfStmt {
 14052  .  .  .  .  .  .  .  .  .  Init: nil
 14053  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14054  .  .  .  .  .  .  .  .  .  .  Op: ==
 14055  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14056  .  .  .  .  .  .  .  .  .  .  .  X: p
 14057  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
 14058  .  .  .  .  .  .  .  .  .  .  }
 14059  .  .  .  .  .  .  .  .  .  .  Y: _Name
 14060  .  .  .  .  .  .  .  .  .  }
 14061  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 14062  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14063  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14064  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14065  .  .  .  .  .  .  .  .  .  .  .  .  X: s
 14066  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Label
 14067  .  .  .  .  .  .  .  .  .  .  .  }
 14068  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14069  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14070  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 14071  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name
 14072  .  .  .  .  .  .  .  .  .  .  .  .  }
 14073  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14074  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14075  .  .  .  .  .  .  .  .  .  .  .  }
 14076  .  .  .  .  .  .  .  .  .  .  }
 14077  .  .  .  .  .  .  .  .  .  }
 14078  .  .  .  .  .  .  .  .  .  Else: nil
 14079  .  .  .  .  .  .  .  .  }
 14080  .  .  .  .  .  .  .  .  6: *syntax.ReturnStmt {
 14081  .  .  .  .  .  .  .  .  .  Results: s
 14082  .  .  .  .  .  .  .  .  }
 14083  .  .  .  .  .  .  .  }
 14084  .  .  .  .  .  .  }
 14085  .  .  .  .  .  .  12: *syntax.CaseClause {
 14086  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 14087  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 14088  .  .  .  .  .  .  .  .  .  0: _Go
 14089  .  .  .  .  .  .  .  .  .  1: _Defer
 14090  .  .  .  .  .  .  .  .  }
 14091  .  .  .  .  .  .  .  }
 14092  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 14093  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 14094  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 14095  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14096  .  .  .  .  .  .  .  .  .  .  .  X: p
 14097  .  .  .  .  .  .  .  .  .  .  .  Sel: callStmt
 14098  .  .  .  .  .  .  .  .  .  .  }
 14099  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14100  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14101  .  .  .  .  .  .  .  .  .  }
 14102  .  .  .  .  .  .  .  .  }
 14103  .  .  .  .  .  .  .  }
 14104  .  .  .  .  .  .  }
 14105  .  .  .  .  .  .  13: *syntax.CaseClause {
 14106  .  .  .  .  .  .  .  Cases: _Goto
 14107  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
 14108  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14109  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14110  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14111  .  .  .  .  .  .  .  .  .  .  .  X: p
 14112  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 14113  .  .  .  .  .  .  .  .  .  .  }
 14114  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14115  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14116  .  .  .  .  .  .  .  .  .  }
 14117  .  .  .  .  .  .  .  .  }
 14118  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 14119  .  .  .  .  .  .  .  .  .  Op: :
 14120  .  .  .  .  .  .  .  .  .  Lhs: s
 14121  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14122  .  .  .  .  .  .  .  .  .  .  Fun: new
 14123  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14124  .  .  .  .  .  .  .  .  .  .  .  0: BranchStmt
 14125  .  .  .  .  .  .  .  .  .  .  }
 14126  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14127  .  .  .  .  .  .  .  .  .  }
 14128  .  .  .  .  .  .  .  .  }
 14129  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 14130  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14131  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14132  .  .  .  .  .  .  .  .  .  .  .  X: s
 14133  .  .  .  .  .  .  .  .  .  .  .  Sel: init
 14134  .  .  .  .  .  .  .  .  .  .  }
 14135  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14136  .  .  .  .  .  .  .  .  .  .  .  0: p
 14137  .  .  .  .  .  .  .  .  .  .  }
 14138  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14139  .  .  .  .  .  .  .  .  .  }
 14140  .  .  .  .  .  .  .  .  }
 14141  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
 14142  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14143  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14144  .  .  .  .  .  .  .  .  .  .  X: s
 14145  .  .  .  .  .  .  .  .  .  .  Sel: Tok
 14146  .  .  .  .  .  .  .  .  .  }
 14147  .  .  .  .  .  .  .  .  .  Rhs: _Goto
 14148  .  .  .  .  .  .  .  .  }
 14149  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
 14150  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14151  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14152  .  .  .  .  .  .  .  .  .  .  X: s
 14153  .  .  .  .  .  .  .  .  .  .  Sel: Label
 14154  .  .  .  .  .  .  .  .  .  }
 14155  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14156  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14157  .  .  .  .  .  .  .  .  .  .  .  X: p
 14158  .  .  .  .  .  .  .  .  .  .  .  Sel: name
 14159  .  .  .  .  .  .  .  .  .  .  }
 14160  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14161  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14162  .  .  .  .  .  .  .  .  .  }
 14163  .  .  .  .  .  .  .  .  }
 14164  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
 14165  .  .  .  .  .  .  .  .  .  Results: s
 14166  .  .  .  .  .  .  .  .  }
 14167  .  .  .  .  .  .  .  }
 14168  .  .  .  .  .  .  }
 14169  .  .  .  .  .  .  14: *syntax.CaseClause {
 14170  .  .  .  .  .  .  .  Cases: _Return
 14171  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
 14172  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14173  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14174  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14175  .  .  .  .  .  .  .  .  .  .  .  X: p
 14176  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 14177  .  .  .  .  .  .  .  .  .  .  }
 14178  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14179  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14180  .  .  .  .  .  .  .  .  .  }
 14181  .  .  .  .  .  .  .  .  }
 14182  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 14183  .  .  .  .  .  .  .  .  .  Op: :
 14184  .  .  .  .  .  .  .  .  .  Lhs: s
 14185  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14186  .  .  .  .  .  .  .  .  .  .  Fun: new
 14187  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14188  .  .  .  .  .  .  .  .  .  .  .  0: ReturnStmt
 14189  .  .  .  .  .  .  .  .  .  .  }
 14190  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14191  .  .  .  .  .  .  .  .  .  }
 14192  .  .  .  .  .  .  .  .  }
 14193  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 14194  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14195  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14196  .  .  .  .  .  .  .  .  .  .  .  X: s
 14197  .  .  .  .  .  .  .  .  .  .  .  Sel: init
 14198  .  .  .  .  .  .  .  .  .  .  }
 14199  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14200  .  .  .  .  .  .  .  .  .  .  .  0: p
 14201  .  .  .  .  .  .  .  .  .  .  }
 14202  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14203  .  .  .  .  .  .  .  .  .  }
 14204  .  .  .  .  .  .  .  .  }
 14205  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
 14206  .  .  .  .  .  .  .  .  .  Init: nil
 14207  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14208  .  .  .  .  .  .  .  .  .  .  Op: &&
 14209  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 14210  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 14211  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14212  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 14213  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
 14214  .  .  .  .  .  .  .  .  .  .  .  }
 14215  .  .  .  .  .  .  .  .  .  .  .  Y: _Semi
 14216  .  .  .  .  .  .  .  .  .  .  }
 14217  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 14218  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 14219  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14220  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 14221  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok
 14222  .  .  .  .  .  .  .  .  .  .  .  }
 14223  .  .  .  .  .  .  .  .  .  .  .  Y: _Rbrace
 14224  .  .  .  .  .  .  .  .  .  .  }
 14225  .  .  .  .  .  .  .  .  .  }
 14226  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 14227  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14228  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14229  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14230  .  .  .  .  .  .  .  .  .  .  .  .  X: s
 14231  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Results
 14232  .  .  .  .  .  .  .  .  .  .  .  }
 14233  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14234  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14235  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 14236  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList
 14237  .  .  .  .  .  .  .  .  .  .  .  .  }
 14238  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14239  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14240  .  .  .  .  .  .  .  .  .  .  .  }
 14241  .  .  .  .  .  .  .  .  .  .  }
 14242  .  .  .  .  .  .  .  .  .  }
 14243  .  .  .  .  .  .  .  .  .  Else: nil
 14244  .  .  .  .  .  .  .  .  }
 14245  .  .  .  .  .  .  .  .  4: *syntax.IfStmt {
 14246  .  .  .  .  .  .  .  .  .  Init: nil
 14247  .  .  .  .  .  .  .  .  .  Cond: gcCompat
 14248  .  .  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 14249  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14250  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14251  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14252  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s
 14253  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: init
 14254  .  .  .  .  .  .  .  .  .  .  .  .  }
 14255  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14256  .  .  .  .  .  .  .  .  .  .  .  .  .  0: p
 14257  .  .  .  .  .  .  .  .  .  .  .  .  }
 14258  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14259  .  .  .  .  .  .  .  .  .  .  .  }
 14260  .  .  .  .  .  .  .  .  .  .  }
 14261  .  .  .  .  .  .  .  .  .  }
 14262  .  .  .  .  .  .  .  .  .  Else: nil
 14263  .  .  .  .  .  .  .  .  }
 14264  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
 14265  .  .  .  .  .  .  .  .  .  Results: s
 14266  .  .  .  .  .  .  .  .  }
 14267  .  .  .  .  .  .  .  }
 14268  .  .  .  .  .  .  }
 14269  .  .  .  .  .  .  15: *syntax.CaseClause {
 14270  .  .  .  .  .  .  .  Cases: _Semi
 14271  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 14272  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14273  .  .  .  .  .  .  .  .  .  Op: :
 14274  .  .  .  .  .  .  .  .  .  Lhs: s
 14275  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14276  .  .  .  .  .  .  .  .  .  .  Fun: new
 14277  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14278  .  .  .  .  .  .  .  .  .  .  .  0: EmptyStmt
 14279  .  .  .  .  .  .  .  .  .  .  }
 14280  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14281  .  .  .  .  .  .  .  .  .  }
 14282  .  .  .  .  .  .  .  .  }
 14283  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 14284  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14285  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14286  .  .  .  .  .  .  .  .  .  .  .  X: s
 14287  .  .  .  .  .  .  .  .  .  .  .  Sel: init
 14288  .  .  .  .  .  .  .  .  .  .  }
 14289  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14290  .  .  .  .  .  .  .  .  .  .  .  0: p
 14291  .  .  .  .  .  .  .  .  .  .  }
 14292  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14293  .  .  .  .  .  .  .  .  .  }
 14294  .  .  .  .  .  .  .  .  }
 14295  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 14296  .  .  .  .  .  .  .  .  .  Results: s
 14297  .  .  .  .  .  .  .  .  }
 14298  .  .  .  .  .  .  .  }
 14299  .  .  .  .  .  .  }
 14300  .  .  .  .  .  }
 14301  .  .  .  .  }
 14302  .  .  .  .  3: *syntax.ReturnStmt {
 14303  .  .  .  .  .  Results: missing_stmt
 14304  .  .  .  .  }
 14305  .  .  .  }
 14306  .  .  .  Pragma: 0
 14307  .  .  .  EndLine: 1960
 14308  .  .  }
 14309  .  .  67: *syntax.FuncDecl {
 14310  .  .  .  Attr: map[]
 14311  .  .  .  Recv: *syntax.Field {
 14312  .  .  .  .  Name: p
 14313  .  .  .  .  Type: *syntax.Operation {
 14314  .  .  .  .  .  Op: *
 14315  .  .  .  .  .  X: parser
 14316  .  .  .  .  .  Y: nil
 14317  .  .  .  .  }
 14318  .  .  .  }
 14319  .  .  .  Name: stmtList
 14320  .  .  .  Type: *syntax.FuncType {
 14321  .  .  .  .  ParamList: nil
 14322  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 14323  .  .  .  .  .  0: *syntax.Field {
 14324  .  .  .  .  .  .  Name: l
 14325  .  .  .  .  .  .  Type: *syntax.SliceType {
 14326  .  .  .  .  .  .  .  Elem: Stmt
 14327  .  .  .  .  .  .  }
 14328  .  .  .  .  .  }
 14329  .  .  .  .  }
 14330  .  .  .  }
 14331  .  .  .  Body: []syntax.Stmt (3 entries) {
 14332  .  .  .  .  0: *syntax.IfStmt {
 14333  .  .  .  .  .  Init: nil
 14334  .  .  .  .  .  Cond: trace
 14335  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 14336  .  .  .  .  .  .  0: *syntax.CallStmt {
 14337  .  .  .  .  .  .  .  Tok: defer
 14338  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 14339  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 14340  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14341  .  .  .  .  .  .  .  .  .  .  X: p
 14342  .  .  .  .  .  .  .  .  .  .  Sel: trace
 14343  .  .  .  .  .  .  .  .  .  }
 14344  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14345  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14346  .  .  .  .  .  .  .  .  .  .  .  Value: "\"stmtList\""
 14347  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14348  .  .  .  .  .  .  .  .  .  .  }
 14349  .  .  .  .  .  .  .  .  .  }
 14350  .  .  .  .  .  .  .  .  .  HasDots: false
 14351  .  .  .  .  .  .  .  .  }
 14352  .  .  .  .  .  .  .  .  ArgList: nil
 14353  .  .  .  .  .  .  .  .  HasDots: false
 14354  .  .  .  .  .  .  .  }
 14355  .  .  .  .  .  .  }
 14356  .  .  .  .  .  }
 14357  .  .  .  .  .  Else: nil
 14358  .  .  .  .  }
 14359  .  .  .  .  1: *syntax.ForStmt {
 14360  .  .  .  .  .  Init: nil
 14361  .  .  .  .  .  Cond: *syntax.Operation {
 14362  .  .  .  .  .  .  Op: &&
 14363  .  .  .  .  .  .  X: *syntax.Operation {
 14364  .  .  .  .  .  .  .  Op: &&
 14365  .  .  .  .  .  .  .  X: *syntax.Operation {
 14366  .  .  .  .  .  .  .  .  Op: &&
 14367  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 14368  .  .  .  .  .  .  .  .  .  Op: !=
 14369  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14370  .  .  .  .  .  .  .  .  .  .  X: p
 14371  .  .  .  .  .  .  .  .  .  .  Sel: tok
 14372  .  .  .  .  .  .  .  .  .  }
 14373  .  .  .  .  .  .  .  .  .  Y: _EOF
 14374  .  .  .  .  .  .  .  .  }
 14375  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 14376  .  .  .  .  .  .  .  .  .  Op: !=
 14377  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14378  .  .  .  .  .  .  .  .  .  .  X: p
 14379  .  .  .  .  .  .  .  .  .  .  Sel: tok
 14380  .  .  .  .  .  .  .  .  .  }
 14381  .  .  .  .  .  .  .  .  .  Y: _Rbrace
 14382  .  .  .  .  .  .  .  .  }
 14383  .  .  .  .  .  .  .  }
 14384  .  .  .  .  .  .  .  Y: *syntax.Operation {
 14385  .  .  .  .  .  .  .  .  Op: !=
 14386  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14387  .  .  .  .  .  .  .  .  .  X: p
 14388  .  .  .  .  .  .  .  .  .  Sel: tok
 14389  .  .  .  .  .  .  .  .  }
 14390  .  .  .  .  .  .  .  .  Y: _Case
 14391  .  .  .  .  .  .  .  }
 14392  .  .  .  .  .  .  }
 14393  .  .  .  .  .  .  Y: *syntax.Operation {
 14394  .  .  .  .  .  .  .  Op: !=
 14395  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14396  .  .  .  .  .  .  .  .  X: p
 14397  .  .  .  .  .  .  .  .  Sel: tok
 14398  .  .  .  .  .  .  .  }
 14399  .  .  .  .  .  .  .  Y: _Default
 14400  .  .  .  .  .  .  }
 14401  .  .  .  .  .  }
 14402  .  .  .  .  .  Post: nil
 14403  .  .  .  .  .  Body: []syntax.Stmt (5 entries) {
 14404  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14405  .  .  .  .  .  .  .  Op: :
 14406  .  .  .  .  .  .  .  Lhs: s
 14407  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14408  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14409  .  .  .  .  .  .  .  .  .  X: p
 14410  .  .  .  .  .  .  .  .  .  Sel: stmt
 14411  .  .  .  .  .  .  .  .  }
 14412  .  .  .  .  .  .  .  .  ArgList: nil
 14413  .  .  .  .  .  .  .  .  HasDots: false
 14414  .  .  .  .  .  .  .  }
 14415  .  .  .  .  .  .  }
 14416  .  .  .  .  .  .  1: *syntax.IfStmt {
 14417  .  .  .  .  .  .  .  Init: nil
 14418  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14419  .  .  .  .  .  .  .  .  Op: ==
 14420  .  .  .  .  .  .  .  .  X: s
 14421  .  .  .  .  .  .  .  .  Y: missing_stmt
 14422  .  .  .  .  .  .  .  }
 14423  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 14424  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
 14425  .  .  .  .  .  .  .  .  .  Tok: break
 14426  .  .  .  .  .  .  .  .  .  Label: nil
 14427  .  .  .  .  .  .  .  .  }
 14428  .  .  .  .  .  .  .  }
 14429  .  .  .  .  .  .  .  Else: nil
 14430  .  .  .  .  .  .  }
 14431  .  .  .  .  .  .  2: *syntax.AssignStmt {
 14432  .  .  .  .  .  .  .  Op: <op-0>
 14433  .  .  .  .  .  .  .  Lhs: l
 14434  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14435  .  .  .  .  .  .  .  .  Fun: append
 14436  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14437  .  .  .  .  .  .  .  .  .  0: l
 14438  .  .  .  .  .  .  .  .  .  1: s
 14439  .  .  .  .  .  .  .  .  }
 14440  .  .  .  .  .  .  .  .  HasDots: false
 14441  .  .  .  .  .  .  .  }
 14442  .  .  .  .  .  .  }
 14443  .  .  .  .  .  .  3: *syntax.IfStmt {
 14444  .  .  .  .  .  .  .  Init: nil
 14445  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14446  .  .  .  .  .  .  .  .  Op: ||
 14447  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 14448  .  .  .  .  .  .  .  .  .  Op: ==
 14449  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14450  .  .  .  .  .  .  .  .  .  .  X: p
 14451  .  .  .  .  .  .  .  .  .  .  Sel: tok
 14452  .  .  .  .  .  .  .  .  .  }
 14453  .  .  .  .  .  .  .  .  .  Y: _Rparen
 14454  .  .  .  .  .  .  .  .  }
 14455  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 14456  .  .  .  .  .  .  .  .  .  Op: ==
 14457  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14458  .  .  .  .  .  .  .  .  .  .  X: p
 14459  .  .  .  .  .  .  .  .  .  .  Sel: tok
 14460  .  .  .  .  .  .  .  .  .  }
 14461  .  .  .  .  .  .  .  .  .  Y: _Rbrace
 14462  .  .  .  .  .  .  .  .  }
 14463  .  .  .  .  .  .  .  }
 14464  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 14465  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
 14466  .  .  .  .  .  .  .  .  .  Tok: continue
 14467  .  .  .  .  .  .  .  .  .  Label: nil
 14468  .  .  .  .  .  .  .  .  }
 14469  .  .  .  .  .  .  .  }
 14470  .  .  .  .  .  .  .  Else: nil
 14471  .  .  .  .  .  .  }
 14472  .  .  .  .  .  .  4: *syntax.IfStmt {
 14473  .  .  .  .  .  .  .  Init: nil
 14474  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14475  .  .  .  .  .  .  .  .  Op: !
 14476  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14477  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14478  .  .  .  .  .  .  .  .  .  .  X: p
 14479  .  .  .  .  .  .  .  .  .  .  Sel: got
 14480  .  .  .  .  .  .  .  .  .  }
 14481  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14482  .  .  .  .  .  .  .  .  .  .  0: _Semi
 14483  .  .  .  .  .  .  .  .  .  }
 14484  .  .  .  .  .  .  .  .  .  HasDots: false
 14485  .  .  .  .  .  .  .  .  }
 14486  .  .  .  .  .  .  .  .  Y: nil
 14487  .  .  .  .  .  .  .  }
 14488  .  .  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 14489  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14490  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14491  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14492  .  .  .  .  .  .  .  .  .  .  .  X: p
 14493  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
 14494  .  .  .  .  .  .  .  .  .  .  }
 14495  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14496  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14497  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"at end of statement\""
 14498  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14499  .  .  .  .  .  .  .  .  .  .  .  }
 14500  .  .  .  .  .  .  .  .  .  .  }
 14501  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14502  .  .  .  .  .  .  .  .  .  }
 14503  .  .  .  .  .  .  .  .  }
 14504  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 14505  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14506  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14507  .  .  .  .  .  .  .  .  .  .  .  X: p
 14508  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
 14509  .  .  .  .  .  .  .  .  .  .  }
 14510  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14511  .  .  .  .  .  .  .  .  .  .  .  0: _Semi
 14512  .  .  .  .  .  .  .  .  .  .  .  1: _Rbrace
 14513  .  .  .  .  .  .  .  .  .  .  }
 14514  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14515  .  .  .  .  .  .  .  .  .  }
 14516  .  .  .  .  .  .  .  .  }
 14517  .  .  .  .  .  .  .  }
 14518  .  .  .  .  .  .  .  Else: nil
 14519  .  .  .  .  .  .  }
 14520  .  .  .  .  .  }
 14521  .  .  .  .  }
 14522  .  .  .  .  2: *syntax.ReturnStmt {
 14523  .  .  .  .  .  Results: nil
 14524  .  .  .  .  }
 14525  .  .  .  }
 14526  .  .  .  Pragma: 0
 14527  .  .  .  EndLine: 1985
 14528  .  .  }
 14529  .  .  68: *syntax.FuncDecl {
 14530  .  .  .  Attr: map[]
 14531  .  .  .  Recv: *syntax.Field {
 14532  .  .  .  .  Name: p
 14533  .  .  .  .  Type: *syntax.Operation {
 14534  .  .  .  .  .  Op: *
 14535  .  .  .  .  .  X: parser
 14536  .  .  .  .  .  Y: nil
 14537  .  .  .  .  }
 14538  .  .  .  }
 14539  .  .  .  Name: call
 14540  .  .  .  Type: *syntax.FuncType {
 14541  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 14542  .  .  .  .  .  0: *syntax.Field {
 14543  .  .  .  .  .  .  Name: fun
 14544  .  .  .  .  .  .  Type: Expr
 14545  .  .  .  .  .  }
 14546  .  .  .  .  }
 14547  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 14548  .  .  .  .  .  0: *syntax.Field {
 14549  .  .  .  .  .  .  Name: nil
 14550  .  .  .  .  .  .  Type: *syntax.Operation {
 14551  .  .  .  .  .  .  .  Op: *
 14552  .  .  .  .  .  .  .  X: CallExpr
 14553  .  .  .  .  .  .  .  Y: nil
 14554  .  .  .  .  .  .  }
 14555  .  .  .  .  .  }
 14556  .  .  .  .  }
 14557  .  .  .  }
 14558  .  .  .  Body: []syntax.Stmt (11 entries) {
 14559  .  .  .  .  0: *syntax.IfStmt {
 14560  .  .  .  .  .  Init: nil
 14561  .  .  .  .  .  Cond: trace
 14562  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 14563  .  .  .  .  .  .  0: *syntax.CallStmt {
 14564  .  .  .  .  .  .  .  Tok: defer
 14565  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 14566  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 14567  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14568  .  .  .  .  .  .  .  .  .  .  X: p
 14569  .  .  .  .  .  .  .  .  .  .  Sel: trace
 14570  .  .  .  .  .  .  .  .  .  }
 14571  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14572  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14573  .  .  .  .  .  .  .  .  .  .  .  Value: "\"call\""
 14574  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14575  .  .  .  .  .  .  .  .  .  .  }
 14576  .  .  .  .  .  .  .  .  .  }
 14577  .  .  .  .  .  .  .  .  .  HasDots: false
 14578  .  .  .  .  .  .  .  .  }
 14579  .  .  .  .  .  .  .  .  ArgList: nil
 14580  .  .  .  .  .  .  .  .  HasDots: false
 14581  .  .  .  .  .  .  .  }
 14582  .  .  .  .  .  .  }
 14583  .  .  .  .  .  }
 14584  .  .  .  .  .  Else: nil
 14585  .  .  .  .  }
 14586  .  .  .  .  1: *syntax.AssignStmt {
 14587  .  .  .  .  .  Op: :
 14588  .  .  .  .  .  Lhs: c
 14589  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14590  .  .  .  .  .  .  Fun: new
 14591  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14592  .  .  .  .  .  .  .  0: CallExpr
 14593  .  .  .  .  .  .  }
 14594  .  .  .  .  .  .  HasDots: false
 14595  .  .  .  .  .  }
 14596  .  .  .  .  }
 14597  .  .  .  .  2: *syntax.ExprStmt {
 14598  .  .  .  .  .  X: *syntax.CallExpr {
 14599  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14600  .  .  .  .  .  .  .  X: c
 14601  .  .  .  .  .  .  .  Sel: init
 14602  .  .  .  .  .  .  }
 14603  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14604  .  .  .  .  .  .  .  0: p
 14605  .  .  .  .  .  .  }
 14606  .  .  .  .  .  .  HasDots: false
 14607  .  .  .  .  .  }
 14608  .  .  .  .  }
 14609  .  .  .  .  3: *syntax.AssignStmt {
 14610  .  .  .  .  .  Op: <op-0>
 14611  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14612  .  .  .  .  .  .  X: c
 14613  .  .  .  .  .  .  Sel: Fun
 14614  .  .  .  .  .  }
 14615  .  .  .  .  .  Rhs: fun
 14616  .  .  .  .  }
 14617  .  .  .  .  4: *syntax.ExprStmt {
 14618  .  .  .  .  .  X: *syntax.CallExpr {
 14619  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14620  .  .  .  .  .  .  .  X: p
 14621  .  .  .  .  .  .  .  Sel: want
 14622  .  .  .  .  .  .  }
 14623  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14624  .  .  .  .  .  .  .  0: _Lparen
 14625  .  .  .  .  .  .  }
 14626  .  .  .  .  .  .  HasDots: false
 14627  .  .  .  .  .  }
 14628  .  .  .  .  }
 14629  .  .  .  .  5: *syntax.AssignStmt {
 14630  .  .  .  .  .  Op: +
 14631  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14632  .  .  .  .  .  .  X: p
 14633  .  .  .  .  .  .  Sel: xnest
 14634  .  .  .  .  .  }
 14635  .  .  .  .  .  Rhs: *(Node @ 4462)
 14636  .  .  .  .  }
 14637  .  .  .  .  6: *syntax.ForStmt {
 14638  .  .  .  .  .  Init: nil
 14639  .  .  .  .  .  Cond: *syntax.Operation {
 14640  .  .  .  .  .  .  Op: &&
 14641  .  .  .  .  .  .  X: *syntax.Operation {
 14642  .  .  .  .  .  .  .  Op: !=
 14643  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14644  .  .  .  .  .  .  .  .  X: p
 14645  .  .  .  .  .  .  .  .  Sel: tok
 14646  .  .  .  .  .  .  .  }
 14647  .  .  .  .  .  .  .  Y: _EOF
 14648  .  .  .  .  .  .  }
 14649  .  .  .  .  .  .  Y: *syntax.Operation {
 14650  .  .  .  .  .  .  .  Op: !=
 14651  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14652  .  .  .  .  .  .  .  .  X: p
 14653  .  .  .  .  .  .  .  .  Sel: tok
 14654  .  .  .  .  .  .  .  }
 14655  .  .  .  .  .  .  .  Y: _Rparen
 14656  .  .  .  .  .  .  }
 14657  .  .  .  .  .  }
 14658  .  .  .  .  .  Post: nil
 14659  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 14660  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14661  .  .  .  .  .  .  .  Op: <op-0>
 14662  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14663  .  .  .  .  .  .  .  .  X: c
 14664  .  .  .  .  .  .  .  .  Sel: ArgList
 14665  .  .  .  .  .  .  .  }
 14666  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14667  .  .  .  .  .  .  .  .  Fun: append
 14668  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14669  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 14670  .  .  .  .  .  .  .  .  .  .  X: c
 14671  .  .  .  .  .  .  .  .  .  .  Sel: ArgList
 14672  .  .  .  .  .  .  .  .  .  }
 14673  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 14674  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14675  .  .  .  .  .  .  .  .  .  .  .  X: p
 14676  .  .  .  .  .  .  .  .  .  .  .  Sel: expr
 14677  .  .  .  .  .  .  .  .  .  .  }
 14678  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14679  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14680  .  .  .  .  .  .  .  .  .  }
 14681  .  .  .  .  .  .  .  .  }
 14682  .  .  .  .  .  .  .  .  HasDots: false
 14683  .  .  .  .  .  .  .  }
 14684  .  .  .  .  .  .  }
 14685  .  .  .  .  .  .  1: *syntax.AssignStmt {
 14686  .  .  .  .  .  .  .  Op: <op-0>
 14687  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14688  .  .  .  .  .  .  .  .  X: c
 14689  .  .  .  .  .  .  .  .  Sel: HasDots
 14690  .  .  .  .  .  .  .  }
 14691  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14692  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14693  .  .  .  .  .  .  .  .  .  X: p
 14694  .  .  .  .  .  .  .  .  .  Sel: got
 14695  .  .  .  .  .  .  .  .  }
 14696  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14697  .  .  .  .  .  .  .  .  .  0: _DotDotDot
 14698  .  .  .  .  .  .  .  .  }
 14699  .  .  .  .  .  .  .  .  HasDots: false
 14700  .  .  .  .  .  .  .  }
 14701  .  .  .  .  .  .  }
 14702  .  .  .  .  .  .  2: *syntax.IfStmt {
 14703  .  .  .  .  .  .  .  Init: nil
 14704  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14705  .  .  .  .  .  .  .  .  Op: ||
 14706  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 14707  .  .  .  .  .  .  .  .  .  Op: !
 14708  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14709  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14710  .  .  .  .  .  .  .  .  .  .  .  X: p
 14711  .  .  .  .  .  .  .  .  .  .  .  Sel: ocomma
 14712  .  .  .  .  .  .  .  .  .  .  }
 14713  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14714  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen
 14715  .  .  .  .  .  .  .  .  .  .  }
 14716  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14717  .  .  .  .  .  .  .  .  .  }
 14718  .  .  .  .  .  .  .  .  .  Y: nil
 14719  .  .  .  .  .  .  .  .  }
 14720  .  .  .  .  .  .  .  .  Y: *syntax.SelectorExpr {
 14721  .  .  .  .  .  .  .  .  .  X: c
 14722  .  .  .  .  .  .  .  .  .  Sel: HasDots
 14723  .  .  .  .  .  .  .  .  }
 14724  .  .  .  .  .  .  .  }
 14725  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 14726  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
 14727  .  .  .  .  .  .  .  .  .  Tok: break
 14728  .  .  .  .  .  .  .  .  .  Label: nil
 14729  .  .  .  .  .  .  .  .  }
 14730  .  .  .  .  .  .  .  }
 14731  .  .  .  .  .  .  .  Else: nil
 14732  .  .  .  .  .  .  }
 14733  .  .  .  .  .  }
 14734  .  .  .  .  }
 14735  .  .  .  .  7: *syntax.AssignStmt {
 14736  .  .  .  .  .  Op: -
 14737  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14738  .  .  .  .  .  .  X: p
 14739  .  .  .  .  .  .  Sel: xnest
 14740  .  .  .  .  .  }
 14741  .  .  .  .  .  Rhs: *(Node @ 4462)
 14742  .  .  .  .  }
 14743  .  .  .  .  8: *syntax.IfStmt {
 14744  .  .  .  .  .  Init: nil
 14745  .  .  .  .  .  Cond: gcCompat
 14746  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 14747  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14748  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14749  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14750  .  .  .  .  .  .  .  .  .  X: c
 14751  .  .  .  .  .  .  .  .  .  Sel: init
 14752  .  .  .  .  .  .  .  .  }
 14753  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14754  .  .  .  .  .  .  .  .  .  0: p
 14755  .  .  .  .  .  .  .  .  }
 14756  .  .  .  .  .  .  .  .  HasDots: false
 14757  .  .  .  .  .  .  .  }
 14758  .  .  .  .  .  .  }
 14759  .  .  .  .  .  }
 14760  .  .  .  .  .  Else: nil
 14761  .  .  .  .  }
 14762  .  .  .  .  9: *syntax.ExprStmt {
 14763  .  .  .  .  .  X: *syntax.CallExpr {
 14764  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14765  .  .  .  .  .  .  .  X: p
 14766  .  .  .  .  .  .  .  Sel: want
 14767  .  .  .  .  .  .  }
 14768  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14769  .  .  .  .  .  .  .  0: _Rparen
 14770  .  .  .  .  .  .  }
 14771  .  .  .  .  .  .  HasDots: false
 14772  .  .  .  .  .  }
 14773  .  .  .  .  }
 14774  .  .  .  .  10: *syntax.ReturnStmt {
 14775  .  .  .  .  .  Results: c
 14776  .  .  .  .  }
 14777  .  .  .  }
 14778  .  .  .  Pragma: 0
 14779  .  .  .  EndLine: 2017
 14780  .  .  }
 14781  .  .  69: *syntax.FuncDecl {
 14782  .  .  .  Attr: map[]
 14783  .  .  .  Recv: *syntax.Field {
 14784  .  .  .  .  Name: p
 14785  .  .  .  .  Type: *syntax.Operation {
 14786  .  .  .  .  .  Op: *
 14787  .  .  .  .  .  X: parser
 14788  .  .  .  .  .  Y: nil
 14789  .  .  .  .  }
 14790  .  .  .  }
 14791  .  .  .  Name: name
 14792  .  .  .  Type: *syntax.FuncType {
 14793  .  .  .  .  ParamList: nil
 14794  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 14795  .  .  .  .  .  0: *syntax.Field {
 14796  .  .  .  .  .  .  Name: nil
 14797  .  .  .  .  .  .  Type: *syntax.Operation {
 14798  .  .  .  .  .  .  .  Op: *
 14799  .  .  .  .  .  .  .  X: Name
 14800  .  .  .  .  .  .  .  Y: nil
 14801  .  .  .  .  .  .  }
 14802  .  .  .  .  .  }
 14803  .  .  .  .  }
 14804  .  .  .  }
 14805  .  .  .  Body: []syntax.Stmt (4 entries) {
 14806  .  .  .  .  0: *syntax.AssignStmt {
 14807  .  .  .  .  .  Op: :
 14808  .  .  .  .  .  Lhs: n
 14809  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14810  .  .  .  .  .  .  Fun: new
 14811  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14812  .  .  .  .  .  .  .  0: Name
 14813  .  .  .  .  .  .  }
 14814  .  .  .  .  .  .  HasDots: false
 14815  .  .  .  .  .  }
 14816  .  .  .  .  }
 14817  .  .  .  .  1: *syntax.ExprStmt {
 14818  .  .  .  .  .  X: *syntax.CallExpr {
 14819  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14820  .  .  .  .  .  .  .  X: n
 14821  .  .  .  .  .  .  .  Sel: init
 14822  .  .  .  .  .  .  }
 14823  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14824  .  .  .  .  .  .  .  0: p
 14825  .  .  .  .  .  .  }
 14826  .  .  .  .  .  .  HasDots: false
 14827  .  .  .  .  .  }
 14828  .  .  .  .  }
 14829  .  .  .  .  2: *syntax.IfStmt {
 14830  .  .  .  .  .  Init: nil
 14831  .  .  .  .  .  Cond: *syntax.Operation {
 14832  .  .  .  .  .  .  Op: ==
 14833  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14834  .  .  .  .  .  .  .  X: p
 14835  .  .  .  .  .  .  .  Sel: tok
 14836  .  .  .  .  .  .  }
 14837  .  .  .  .  .  .  Y: _Name
 14838  .  .  .  .  .  }
 14839  .  .  .  .  .  Then: []syntax.Stmt (2 entries) {
 14840  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14841  .  .  .  .  .  .  .  Op: <op-0>
 14842  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14843  .  .  .  .  .  .  .  .  X: n
 14844  .  .  .  .  .  .  .  .  Sel: Value
 14845  .  .  .  .  .  .  .  }
 14846  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 14847  .  .  .  .  .  .  .  .  X: p
 14848  .  .  .  .  .  .  .  .  Sel: lit
 14849  .  .  .  .  .  .  .  }
 14850  .  .  .  .  .  .  }
 14851  .  .  .  .  .  .  1: *syntax.ExprStmt {
 14852  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14853  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14854  .  .  .  .  .  .  .  .  .  X: p
 14855  .  .  .  .  .  .  .  .  .  Sel: next
 14856  .  .  .  .  .  .  .  .  }
 14857  .  .  .  .  .  .  .  .  ArgList: nil
 14858  .  .  .  .  .  .  .  .  HasDots: false
 14859  .  .  .  .  .  .  .  }
 14860  .  .  .  .  .  .  }
 14861  .  .  .  .  .  }
 14862  .  .  .  .  .  Else: *syntax.BlockStmt {
 14863  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 14864  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14865  .  .  .  .  .  .  .  .  Op: <op-0>
 14866  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14867  .  .  .  .  .  .  .  .  .  X: n
 14868  .  .  .  .  .  .  .  .  .  Sel: Value
 14869  .  .  .  .  .  .  .  .  }
 14870  .  .  .  .  .  .  .  .  Rhs: *syntax.BasicLit {
 14871  .  .  .  .  .  .  .  .  .  Value: "\"_\""
 14872  .  .  .  .  .  .  .  .  .  Kind: 4
 14873  .  .  .  .  .  .  .  .  }
 14874  .  .  .  .  .  .  .  }
 14875  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 14876  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14877  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14878  .  .  .  .  .  .  .  .  .  .  X: p
 14879  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
 14880  .  .  .  .  .  .  .  .  .  }
 14881  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14882  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14883  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting name\""
 14884  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14885  .  .  .  .  .  .  .  .  .  .  }
 14886  .  .  .  .  .  .  .  .  .  }
 14887  .  .  .  .  .  .  .  .  .  HasDots: false
 14888  .  .  .  .  .  .  .  .  }
 14889  .  .  .  .  .  .  .  }
 14890  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 14891  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14892  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14893  .  .  .  .  .  .  .  .  .  .  X: p
 14894  .  .  .  .  .  .  .  .  .  .  Sel: advance
 14895  .  .  .  .  .  .  .  .  .  }
 14896  .  .  .  .  .  .  .  .  .  ArgList: nil
 14897  .  .  .  .  .  .  .  .  .  HasDots: false
 14898  .  .  .  .  .  .  .  .  }
 14899  .  .  .  .  .  .  .  }
 14900  .  .  .  .  .  .  }
 14901  .  .  .  .  .  }
 14902  .  .  .  .  }
 14903  .  .  .  .  3: *syntax.ReturnStmt {
 14904  .  .  .  .  .  Results: n
 14905  .  .  .  .  }
 14906  .  .  .  }
 14907  .  .  .  Pragma: 0
 14908  .  .  .  EndLine: 2038
 14909  .  .  }
 14910  .  .  70: *syntax.FuncDecl {
 14911  .  .  .  Attr: map[]
 14912  .  .  .  Recv: *syntax.Field {
 14913  .  .  .  .  Name: p
 14914  .  .  .  .  Type: *syntax.Operation {
 14915  .  .  .  .  .  Op: *
 14916  .  .  .  .  .  X: parser
 14917  .  .  .  .  .  Y: nil
 14918  .  .  .  .  }
 14919  .  .  .  }
 14920  .  .  .  Name: nameList
 14921  .  .  .  Type: *syntax.FuncType {
 14922  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 14923  .  .  .  .  .  0: *syntax.Field {
 14924  .  .  .  .  .  .  Name: first
 14925  .  .  .  .  .  .  Type: *syntax.Operation {
 14926  .  .  .  .  .  .  .  Op: *
 14927  .  .  .  .  .  .  .  X: Name
 14928  .  .  .  .  .  .  .  Y: nil
 14929  .  .  .  .  .  .  }
 14930  .  .  .  .  .  }
 14931  .  .  .  .  }
 14932  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 14933  .  .  .  .  .  0: *syntax.Field {
 14934  .  .  .  .  .  .  Name: nil
 14935  .  .  .  .  .  .  Type: *syntax.SliceType {
 14936  .  .  .  .  .  .  .  Elem: *syntax.Operation {
 14937  .  .  .  .  .  .  .  .  Op: *
 14938  .  .  .  .  .  .  .  .  X: Name
 14939  .  .  .  .  .  .  .  .  Y: nil
 14940  .  .  .  .  .  .  .  }
 14941  .  .  .  .  .  .  }
 14942  .  .  .  .  .  }
 14943  .  .  .  .  }
 14944  .  .  .  }
 14945  .  .  .  Body: []syntax.Stmt (5 entries) {
 14946  .  .  .  .  0: *syntax.IfStmt {
 14947  .  .  .  .  .  Init: nil
 14948  .  .  .  .  .  Cond: trace
 14949  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 14950  .  .  .  .  .  .  0: *syntax.CallStmt {
 14951  .  .  .  .  .  .  .  Tok: defer
 14952  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 14953  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 14954  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14955  .  .  .  .  .  .  .  .  .  .  X: p
 14956  .  .  .  .  .  .  .  .  .  .  Sel: trace
 14957  .  .  .  .  .  .  .  .  .  }
 14958  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14959  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14960  .  .  .  .  .  .  .  .  .  .  .  Value: "\"nameList\""
 14961  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14962  .  .  .  .  .  .  .  .  .  .  }
 14963  .  .  .  .  .  .  .  .  .  }
 14964  .  .  .  .  .  .  .  .  .  HasDots: false
 14965  .  .  .  .  .  .  .  .  }
 14966  .  .  .  .  .  .  .  .  ArgList: nil
 14967  .  .  .  .  .  .  .  .  HasDots: false
 14968  .  .  .  .  .  .  .  }
 14969  .  .  .  .  .  .  }
 14970  .  .  .  .  .  }
 14971  .  .  .  .  .  Else: nil
 14972  .  .  .  .  }
 14973  .  .  .  .  1: *syntax.IfStmt {
 14974  .  .  .  .  .  Init: nil
 14975  .  .  .  .  .  Cond: *syntax.Operation {
 14976  .  .  .  .  .  .  Op: &&
 14977  .  .  .  .  .  .  X: debug
 14978  .  .  .  .  .  .  Y: *syntax.Operation {
 14979  .  .  .  .  .  .  .  Op: ==
 14980  .  .  .  .  .  .  .  X: first
 14981  .  .  .  .  .  .  .  Y: nil
 14982  .  .  .  .  .  .  }
 14983  .  .  .  .  .  }
 14984  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 14985  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14986  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14987  .  .  .  .  .  .  .  .  Fun: panic
 14988  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14989  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14990  .  .  .  .  .  .  .  .  .  .  Value: "\"first name not provided\""
 14991  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14992  .  .  .  .  .  .  .  .  .  }
 14993  .  .  .  .  .  .  .  .  }
 14994  .  .  .  .  .  .  .  .  HasDots: false
 14995  .  .  .  .  .  .  .  }
 14996  .  .  .  .  .  .  }
 14997  .  .  .  .  .  }
 14998  .  .  .  .  .  Else: nil
 14999  .  .  .  .  }
 15000  .  .  .  .  2: *syntax.AssignStmt {
 15001  .  .  .  .  .  Op: :
 15002  .  .  .  .  .  Lhs: l
 15003  .  .  .  .  .  Rhs: *syntax.CompositeLit {
 15004  .  .  .  .  .  .  Type: *syntax.SliceType {
 15005  .  .  .  .  .  .  .  Elem: *syntax.Operation {
 15006  .  .  .  .  .  .  .  .  Op: *
 15007  .  .  .  .  .  .  .  .  X: Name
 15008  .  .  .  .  .  .  .  .  Y: nil
 15009  .  .  .  .  .  .  .  }
 15010  .  .  .  .  .  .  }
 15011  .  .  .  .  .  .  ElemList: []syntax.Expr (1 entries) {
 15012  .  .  .  .  .  .  .  0: first
 15013  .  .  .  .  .  .  }
 15014  .  .  .  .  .  .  NKeys: 0
 15015  .  .  .  .  .  .  EndLine: 2051
 15016  .  .  .  .  .  }
 15017  .  .  .  .  }
 15018  .  .  .  .  3: *syntax.ForStmt {
 15019  .  .  .  .  .  Init: nil
 15020  .  .  .  .  .  Cond: *syntax.CallExpr {
 15021  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15022  .  .  .  .  .  .  .  X: p
 15023  .  .  .  .  .  .  .  Sel: got
 15024  .  .  .  .  .  .  }
 15025  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15026  .  .  .  .  .  .  .  0: _Comma
 15027  .  .  .  .  .  .  }
 15028  .  .  .  .  .  .  HasDots: false
 15029  .  .  .  .  .  }
 15030  .  .  .  .  .  Post: nil
 15031  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15032  .  .  .  .  .  .  0: *syntax.AssignStmt {
 15033  .  .  .  .  .  .  .  Op: <op-0>
 15034  .  .  .  .  .  .  .  Lhs: l
 15035  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15036  .  .  .  .  .  .  .  .  Fun: append
 15037  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 15038  .  .  .  .  .  .  .  .  .  0: l
 15039  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 15040  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15041  .  .  .  .  .  .  .  .  .  .  .  X: p
 15042  .  .  .  .  .  .  .  .  .  .  .  Sel: name
 15043  .  .  .  .  .  .  .  .  .  .  }
 15044  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15045  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15046  .  .  .  .  .  .  .  .  .  }
 15047  .  .  .  .  .  .  .  .  }
 15048  .  .  .  .  .  .  .  .  HasDots: false
 15049  .  .  .  .  .  .  .  }
 15050  .  .  .  .  .  .  }
 15051  .  .  .  .  .  }
 15052  .  .  .  .  }
 15053  .  .  .  .  4: *syntax.ReturnStmt {
 15054  .  .  .  .  .  Results: l
 15055  .  .  .  .  }
 15056  .  .  .  }
 15057  .  .  .  Pragma: 0
 15058  .  .  .  EndLine: 2057
 15059  .  .  }
 15060  .  .  71: *syntax.FuncDecl {
 15061  .  .  .  Attr: map[]
 15062  .  .  .  Recv: *syntax.Field {
 15063  .  .  .  .  Name: p
 15064  .  .  .  .  Type: *syntax.Operation {
 15065  .  .  .  .  .  Op: *
 15066  .  .  .  .  .  X: parser
 15067  .  .  .  .  .  Y: nil
 15068  .  .  .  .  }
 15069  .  .  .  }
 15070  .  .  .  Name: qualifiedName
 15071  .  .  .  Type: *syntax.FuncType {
 15072  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 15073  .  .  .  .  .  0: *syntax.Field {
 15074  .  .  .  .  .  .  Name: name
 15075  .  .  .  .  .  .  Type: *syntax.Operation {
 15076  .  .  .  .  .  .  .  Op: *
 15077  .  .  .  .  .  .  .  X: Name
 15078  .  .  .  .  .  .  .  Y: nil
 15079  .  .  .  .  .  .  }
 15080  .  .  .  .  .  }
 15081  .  .  .  .  }
 15082  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 15083  .  .  .  .  .  0: *syntax.Field {
 15084  .  .  .  .  .  .  Name: nil
 15085  .  .  .  .  .  .  Type: Expr
 15086  .  .  .  .  .  }
 15087  .  .  .  .  }
 15088  .  .  .  }
 15089  .  .  .  Body: []syntax.Stmt (3 entries) {
 15090  .  .  .  .  0: *syntax.IfStmt {
 15091  .  .  .  .  .  Init: nil
 15092  .  .  .  .  .  Cond: trace
 15093  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 15094  .  .  .  .  .  .  0: *syntax.CallStmt {
 15095  .  .  .  .  .  .  .  Tok: defer
 15096  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 15097  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 15098  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15099  .  .  .  .  .  .  .  .  .  .  X: p
 15100  .  .  .  .  .  .  .  .  .  .  Sel: trace
 15101  .  .  .  .  .  .  .  .  .  }
 15102  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15103  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 15104  .  .  .  .  .  .  .  .  .  .  .  Value: "\"qualifiedName\""
 15105  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 15106  .  .  .  .  .  .  .  .  .  .  }
 15107  .  .  .  .  .  .  .  .  .  }
 15108  .  .  .  .  .  .  .  .  .  HasDots: false
 15109  .  .  .  .  .  .  .  .  }
 15110  .  .  .  .  .  .  .  .  ArgList: nil
 15111  .  .  .  .  .  .  .  .  HasDots: false
 15112  .  .  .  .  .  .  .  }
 15113  .  .  .  .  .  .  }
 15114  .  .  .  .  .  }
 15115  .  .  .  .  .  Else: nil
 15116  .  .  .  .  }
 15117  .  .  .  .  1: *syntax.SwitchStmt {
 15118  .  .  .  .  .  Init: nil
 15119  .  .  .  .  .  Tag: nil
 15120  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 15121  .  .  .  .  .  .  0: *syntax.CaseClause {
 15122  .  .  .  .  .  .  .  Cases: *syntax.Operation {
 15123  .  .  .  .  .  .  .  .  Op: !=
 15124  .  .  .  .  .  .  .  .  X: name
 15125  .  .  .  .  .  .  .  .  Y: nil
 15126  .  .  .  .  .  .  .  }
 15127  .  .  .  .  .  .  .  Body: nil
 15128  .  .  .  .  .  .  }
 15129  .  .  .  .  .  .  1: *syntax.CaseClause {
 15130  .  .  .  .  .  .  .  Cases: *syntax.Operation {
 15131  .  .  .  .  .  .  .  .  Op: ==
 15132  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 15133  .  .  .  .  .  .  .  .  .  X: p
 15134  .  .  .  .  .  .  .  .  .  Sel: tok
 15135  .  .  .  .  .  .  .  .  }
 15136  .  .  .  .  .  .  .  .  Y: _Name
 15137  .  .  .  .  .  .  .  }
 15138  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15139  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 15140  .  .  .  .  .  .  .  .  .  Op: <op-0>
 15141  .  .  .  .  .  .  .  .  .  Lhs: name
 15142  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15143  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15144  .  .  .  .  .  .  .  .  .  .  .  X: p
 15145  .  .  .  .  .  .  .  .  .  .  .  Sel: name
 15146  .  .  .  .  .  .  .  .  .  .  }
 15147  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15148  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15149  .  .  .  .  .  .  .  .  .  }
 15150  .  .  .  .  .  .  .  .  }
 15151  .  .  .  .  .  .  .  }
 15152  .  .  .  .  .  .  }
 15153  .  .  .  .  .  .  2: *syntax.CaseClause {
 15154  .  .  .  .  .  .  .  Cases: nil
 15155  .  .  .  .  .  .  .  Body: []syntax.Stmt (4 entries) {
 15156  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 15157  .  .  .  .  .  .  .  .  .  Op: <op-0>
 15158  .  .  .  .  .  .  .  .  .  Lhs: name
 15159  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15160  .  .  .  .  .  .  .  .  .  .  Fun: new
 15161  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15162  .  .  .  .  .  .  .  .  .  .  .  0: Name
 15163  .  .  .  .  .  .  .  .  .  .  }
 15164  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15165  .  .  .  .  .  .  .  .  .  }
 15166  .  .  .  .  .  .  .  .  }
 15167  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 15168  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15169  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15170  .  .  .  .  .  .  .  .  .  .  .  X: name
 15171  .  .  .  .  .  .  .  .  .  .  .  Sel: init
 15172  .  .  .  .  .  .  .  .  .  .  }
 15173  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15174  .  .  .  .  .  .  .  .  .  .  .  0: p
 15175  .  .  .  .  .  .  .  .  .  .  }
 15176  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15177  .  .  .  .  .  .  .  .  .  }
 15178  .  .  .  .  .  .  .  .  }
 15179  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 15180  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15181  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15182  .  .  .  .  .  .  .  .  .  .  .  X: p
 15183  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error
 15184  .  .  .  .  .  .  .  .  .  .  }
 15185  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15186  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 15187  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting name\""
 15188  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 15189  .  .  .  .  .  .  .  .  .  .  .  }
 15190  .  .  .  .  .  .  .  .  .  .  }
 15191  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15192  .  .  .  .  .  .  .  .  .  }
 15193  .  .  .  .  .  .  .  .  }
 15194  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
 15195  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15196  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15197  .  .  .  .  .  .  .  .  .  .  .  X: p
 15198  .  .  .  .  .  .  .  .  .  .  .  Sel: advance
 15199  .  .  .  .  .  .  .  .  .  .  }
 15200  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 15201  .  .  .  .  .  .  .  .  .  .  .  0: _Dot
 15202  .  .  .  .  .  .  .  .  .  .  .  1: _Semi
 15203  .  .  .  .  .  .  .  .  .  .  .  2: _Rbrace
 15204  .  .  .  .  .  .  .  .  .  .  }
 15205  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15206  .  .  .  .  .  .  .  .  .  }
 15207  .  .  .  .  .  .  .  .  }
 15208  .  .  .  .  .  .  .  }
 15209  .  .  .  .  .  .  }
 15210  .  .  .  .  .  }
 15211  .  .  .  .  }
 15212  .  .  .  .  2: *syntax.ReturnStmt {
 15213  .  .  .  .  .  Results: *syntax.CallExpr {
 15214  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15215  .  .  .  .  .  .  .  X: p
 15216  .  .  .  .  .  .  .  Sel: dotname
 15217  .  .  .  .  .  .  }
 15218  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15219  .  .  .  .  .  .  .  0: name
 15220  .  .  .  .  .  .  }
 15221  .  .  .  .  .  .  HasDots: false
 15222  .  .  .  .  .  }
 15223  .  .  .  .  }
 15224  .  .  .  }
 15225  .  .  .  Pragma: 0
 15226  .  .  .  EndLine: 2078
 15227  .  .  }
 15228  .  .  72: *syntax.FuncDecl {
 15229  .  .  .  Attr: map[]
 15230  .  .  .  Recv: *syntax.Field {
 15231  .  .  .  .  Name: p
 15232  .  .  .  .  Type: *syntax.Operation {
 15233  .  .  .  .  .  Op: *
 15234  .  .  .  .  .  X: parser
 15235  .  .  .  .  .  Y: nil
 15236  .  .  .  .  }
 15237  .  .  .  }
 15238  .  .  .  Name: exprList
 15239  .  .  .  Type: *syntax.FuncType {
 15240  .  .  .  .  ParamList: nil
 15241  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 15242  .  .  .  .  .  0: *syntax.Field {
 15243  .  .  .  .  .  .  Name: nil
 15244  .  .  .  .  .  .  Type: Expr
 15245  .  .  .  .  .  }
 15246  .  .  .  .  }
 15247  .  .  .  }
 15248  .  .  .  Body: []syntax.Stmt (4 entries) {
 15249  .  .  .  .  0: *syntax.IfStmt {
 15250  .  .  .  .  .  Init: nil
 15251  .  .  .  .  .  Cond: trace
 15252  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 15253  .  .  .  .  .  .  0: *syntax.CallStmt {
 15254  .  .  .  .  .  .  .  Tok: defer
 15255  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 15256  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 15257  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15258  .  .  .  .  .  .  .  .  .  .  X: p
 15259  .  .  .  .  .  .  .  .  .  .  Sel: trace
 15260  .  .  .  .  .  .  .  .  .  }
 15261  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15262  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 15263  .  .  .  .  .  .  .  .  .  .  .  Value: "\"exprList\""
 15264  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 15265  .  .  .  .  .  .  .  .  .  .  }
 15266  .  .  .  .  .  .  .  .  .  }
 15267  .  .  .  .  .  .  .  .  .  HasDots: false
 15268  .  .  .  .  .  .  .  .  }
 15269  .  .  .  .  .  .  .  .  ArgList: nil
 15270  .  .  .  .  .  .  .  .  HasDots: false
 15271  .  .  .  .  .  .  .  }
 15272  .  .  .  .  .  .  }
 15273  .  .  .  .  .  }
 15274  .  .  .  .  .  Else: nil
 15275  .  .  .  .  }
 15276  .  .  .  .  1: *syntax.AssignStmt {
 15277  .  .  .  .  .  Op: :
 15278  .  .  .  .  .  Lhs: x
 15279  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15280  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15281  .  .  .  .  .  .  .  X: p
 15282  .  .  .  .  .  .  .  Sel: expr
 15283  .  .  .  .  .  .  }
 15284  .  .  .  .  .  .  ArgList: nil
 15285  .  .  .  .  .  .  HasDots: false
 15286  .  .  .  .  .  }
 15287  .  .  .  .  }
 15288  .  .  .  .  2: *syntax.IfStmt {
 15289  .  .  .  .  .  Init: nil
 15290  .  .  .  .  .  Cond: *syntax.CallExpr {
 15291  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15292  .  .  .  .  .  .  .  X: p
 15293  .  .  .  .  .  .  .  Sel: got
 15294  .  .  .  .  .  .  }
 15295  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15296  .  .  .  .  .  .  .  0: _Comma
 15297  .  .  .  .  .  .  }
 15298  .  .  .  .  .  .  HasDots: false
 15299  .  .  .  .  .  }
 15300  .  .  .  .  .  Then: []syntax.Stmt (6 entries) {
 15301  .  .  .  .  .  .  0: *syntax.AssignStmt {
 15302  .  .  .  .  .  .  .  Op: :
 15303  .  .  .  .  .  .  .  Lhs: list
 15304  .  .  .  .  .  .  .  Rhs: *syntax.CompositeLit {
 15305  .  .  .  .  .  .  .  .  Type: *syntax.SliceType {
 15306  .  .  .  .  .  .  .  .  .  Elem: Expr
 15307  .  .  .  .  .  .  .  .  }
 15308  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 15309  .  .  .  .  .  .  .  .  .  0: x
 15310  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 15311  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15312  .  .  .  .  .  .  .  .  .  .  .  X: p
 15313  .  .  .  .  .  .  .  .  .  .  .  Sel: expr
 15314  .  .  .  .  .  .  .  .  .  .  }
 15315  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15316  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15317  .  .  .  .  .  .  .  .  .  }
 15318  .  .  .  .  .  .  .  .  }
 15319  .  .  .  .  .  .  .  .  NKeys: 0
 15320  .  .  .  .  .  .  .  .  EndLine: 2088
 15321  .  .  .  .  .  .  .  }
 15322  .  .  .  .  .  .  }
 15323  .  .  .  .  .  .  1: *syntax.ForStmt {
 15324  .  .  .  .  .  .  .  Init: nil
 15325  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
 15326  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15327  .  .  .  .  .  .  .  .  .  X: p
 15328  .  .  .  .  .  .  .  .  .  Sel: got
 15329  .  .  .  .  .  .  .  .  }
 15330  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15331  .  .  .  .  .  .  .  .  .  0: _Comma
 15332  .  .  .  .  .  .  .  .  }
 15333  .  .  .  .  .  .  .  .  HasDots: false
 15334  .  .  .  .  .  .  .  }
 15335  .  .  .  .  .  .  .  Post: nil
 15336  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15337  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 15338  .  .  .  .  .  .  .  .  .  Op: <op-0>
 15339  .  .  .  .  .  .  .  .  .  Lhs: list
 15340  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15341  .  .  .  .  .  .  .  .  .  .  Fun: append
 15342  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 15343  .  .  .  .  .  .  .  .  .  .  .  0: list
 15344  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 15345  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15346  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p
 15347  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr
 15348  .  .  .  .  .  .  .  .  .  .  .  .  }
 15349  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15350  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15351  .  .  .  .  .  .  .  .  .  .  .  }
 15352  .  .  .  .  .  .  .  .  .  .  }
 15353  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15354  .  .  .  .  .  .  .  .  .  }
 15355  .  .  .  .  .  .  .  .  }
 15356  .  .  .  .  .  .  .  }
 15357  .  .  .  .  .  .  }
 15358  .  .  .  .  .  .  2: *syntax.AssignStmt {
 15359  .  .  .  .  .  .  .  Op: :
 15360  .  .  .  .  .  .  .  Lhs: t
 15361  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15362  .  .  .  .  .  .  .  .  Fun: new
 15363  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15364  .  .  .  .  .  .  .  .  .  0: ListExpr
 15365  .  .  .  .  .  .  .  .  }
 15366  .  .  .  .  .  .  .  .  HasDots: false
 15367  .  .  .  .  .  .  .  }
 15368  .  .  .  .  .  .  }
 15369  .  .  .  .  .  .  3: *syntax.ExprStmt {
 15370  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15371  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15372  .  .  .  .  .  .  .  .  .  X: t
 15373  .  .  .  .  .  .  .  .  .  Sel: init
 15374  .  .  .  .  .  .  .  .  }
 15375  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15376  .  .  .  .  .  .  .  .  .  0: p
 15377  .  .  .  .  .  .  .  .  }
 15378  .  .  .  .  .  .  .  .  HasDots: false
 15379  .  .  .  .  .  .  .  }
 15380  .  .  .  .  .  .  }
 15381  .  .  .  .  .  .  4: *syntax.AssignStmt {
 15382  .  .  .  .  .  .  .  Op: <op-0>
 15383  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 15384  .  .  .  .  .  .  .  .  X: t
 15385  .  .  .  .  .  .  .  .  Sel: ElemList
 15386  .  .  .  .  .  .  .  }
 15387  .  .  .  .  .  .  .  Rhs: list
 15388  .  .  .  .  .  .  }
 15389  .  .  .  .  .  .  5: *syntax.AssignStmt {
 15390  .  .  .  .  .  .  .  Op: <op-0>
 15391  .  .  .  .  .  .  .  Lhs: x
 15392  .  .  .  .  .  .  .  Rhs: t
 15393  .  .  .  .  .  .  }
 15394  .  .  .  .  .  }
 15395  .  .  .  .  .  Else: nil
 15396  .  .  .  .  }
 15397  .  .  .  .  3: *syntax.ReturnStmt {
 15398  .  .  .  .  .  Results: x
 15399  .  .  .  .  }
 15400  .  .  .  }
 15401  .  .  .  Pragma: 0
 15402  .  .  .  EndLine: 2098
 15403  .  .  }
 15404  .  .  73: *syntax.FuncDecl {
 15405  .  .  .  Attr: map[]
 15406  .  .  .  Recv: *syntax.Field {
 15407  .  .  .  .  Name: p
 15408  .  .  .  .  Type: *syntax.Operation {
 15409  .  .  .  .  .  Op: *
 15410  .  .  .  .  .  X: parser
 15411  .  .  .  .  .  Y: nil
 15412  .  .  .  .  }
 15413  .  .  .  }
 15414  .  .  .  Name: osemi
 15415  .  .  .  Type: *syntax.FuncType {
 15416  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 15417  .  .  .  .  .  0: *syntax.Field {
 15418  .  .  .  .  .  .  Name: follow
 15419  .  .  .  .  .  .  Type: token
 15420  .  .  .  .  .  }
 15421  .  .  .  .  }
 15422  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 15423  .  .  .  .  .  0: *syntax.Field {
 15424  .  .  .  .  .  .  Name: nil
 15425  .  .  .  .  .  .  Type: bool
 15426  .  .  .  .  .  }
 15427  .  .  .  .  }
 15428  .  .  .  }
 15429  .  .  .  Body: []syntax.Stmt (4 entries) {
 15430  .  .  .  .  0: *syntax.SwitchStmt {
 15431  .  .  .  .  .  Init: nil
 15432  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 15433  .  .  .  .  .  .  X: p
 15434  .  .  .  .  .  .  Sel: tok
 15435  .  .  .  .  .  }
 15436  .  .  .  .  .  Body: []*syntax.CaseClause (2 entries) {
 15437  .  .  .  .  .  .  0: *syntax.CaseClause {
 15438  .  .  .  .  .  .  .  Cases: _Semi
 15439  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 15440  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 15441  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15442  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15443  .  .  .  .  .  .  .  .  .  .  .  X: p
 15444  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 15445  .  .  .  .  .  .  .  .  .  .  }
 15446  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15447  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15448  .  .  .  .  .  .  .  .  .  }
 15449  .  .  .  .  .  .  .  .  }
 15450  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
 15451  .  .  .  .  .  .  .  .  .  Results: true
 15452  .  .  .  .  .  .  .  .  }
 15453  .  .  .  .  .  .  .  }
 15454  .  .  .  .  .  .  }
 15455  .  .  .  .  .  .  1: *syntax.CaseClause {
 15456  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 15457  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 15458  .  .  .  .  .  .  .  .  .  0: _Rparen
 15459  .  .  .  .  .  .  .  .  .  1: _Rbrace
 15460  .  .  .  .  .  .  .  .  }
 15461  .  .  .  .  .  .  .  }
 15462  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15463  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 15464  .  .  .  .  .  .  .  .  .  Results: true
 15465  .  .  .  .  .  .  .  .  }
 15466  .  .  .  .  .  .  .  }
 15467  .  .  .  .  .  .  }
 15468  .  .  .  .  .  }
 15469  .  .  .  .  }
 15470  .  .  .  .  1: *syntax.ExprStmt {
 15471  .  .  .  .  .  X: *syntax.CallExpr {
 15472  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15473  .  .  .  .  .  .  .  X: p
 15474  .  .  .  .  .  .  .  Sel: syntax_error
 15475  .  .  .  .  .  .  }
 15476  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15477  .  .  .  .  .  .  .  0: *syntax.Operation {
 15478  .  .  .  .  .  .  .  .  Op: +
 15479  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
 15480  .  .  .  .  .  .  .  .  .  Value: "\"expecting semicolon, newline, or \""
 15481  .  .  .  .  .  .  .  .  .  Kind: 4
 15482  .  .  .  .  .  .  .  .  }
 15483  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
 15484  .  .  .  .  .  .  .  .  .  Fun: tokstring
 15485  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15486  .  .  .  .  .  .  .  .  .  .  0: follow
 15487  .  .  .  .  .  .  .  .  .  }
 15488  .  .  .  .  .  .  .  .  .  HasDots: false
 15489  .  .  .  .  .  .  .  .  }
 15490  .  .  .  .  .  .  .  }
 15491  .  .  .  .  .  .  }
 15492  .  .  .  .  .  .  HasDots: false
 15493  .  .  .  .  .  }
 15494  .  .  .  .  }
 15495  .  .  .  .  2: *syntax.ExprStmt {
 15496  .  .  .  .  .  X: *syntax.CallExpr {
 15497  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15498  .  .  .  .  .  .  .  X: p
 15499  .  .  .  .  .  .  .  Sel: advance
 15500  .  .  .  .  .  .  }
 15501  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15502  .  .  .  .  .  .  .  0: follow
 15503  .  .  .  .  .  .  }
 15504  .  .  .  .  .  .  HasDots: false
 15505  .  .  .  .  .  }
 15506  .  .  .  .  }
 15507  .  .  .  .  3: *syntax.ReturnStmt {
 15508  .  .  .  .  .  Results: false
 15509  .  .  .  .  }
 15510  .  .  .  }
 15511  .  .  .  Pragma: 0
 15512  .  .  .  EndLine: 2115
 15513  .  .  }
 15514  .  .  74: *syntax.FuncDecl {
 15515  .  .  .  Attr: map[]
 15516  .  .  .  Recv: *syntax.Field {
 15517  .  .  .  .  Name: p
 15518  .  .  .  .  Type: *syntax.Operation {
 15519  .  .  .  .  .  Op: *
 15520  .  .  .  .  .  X: parser
 15521  .  .  .  .  .  Y: nil
 15522  .  .  .  .  }
 15523  .  .  .  }
 15524  .  .  .  Name: ocomma
 15525  .  .  .  Type: *syntax.FuncType {
 15526  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 15527  .  .  .  .  .  0: *syntax.Field {
 15528  .  .  .  .  .  .  Name: follow
 15529  .  .  .  .  .  .  Type: token
 15530  .  .  .  .  .  }
 15531  .  .  .  .  }
 15532  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 15533  .  .  .  .  .  0: *syntax.Field {
 15534  .  .  .  .  .  .  Name: nil
 15535  .  .  .  .  .  .  Type: bool
 15536  .  .  .  .  .  }
 15537  .  .  .  .  }
 15538  .  .  .  }
 15539  .  .  .  Body: []syntax.Stmt (4 entries) {
 15540  .  .  .  .  0: *syntax.SwitchStmt {
 15541  .  .  .  .  .  Init: nil
 15542  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 15543  .  .  .  .  .  .  X: p
 15544  .  .  .  .  .  .  Sel: tok
 15545  .  .  .  .  .  }
 15546  .  .  .  .  .  Body: []*syntax.CaseClause (2 entries) {
 15547  .  .  .  .  .  .  0: *syntax.CaseClause {
 15548  .  .  .  .  .  .  .  Cases: _Comma
 15549  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 15550  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 15551  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15552  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15553  .  .  .  .  .  .  .  .  .  .  .  X: p
 15554  .  .  .  .  .  .  .  .  .  .  .  Sel: next
 15555  .  .  .  .  .  .  .  .  .  .  }
 15556  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15557  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15558  .  .  .  .  .  .  .  .  .  }
 15559  .  .  .  .  .  .  .  .  }
 15560  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
 15561  .  .  .  .  .  .  .  .  .  Results: true
 15562  .  .  .  .  .  .  .  .  }
 15563  .  .  .  .  .  .  .  }
 15564  .  .  .  .  .  .  }
 15565  .  .  .  .  .  .  1: *syntax.CaseClause {
 15566  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 15567  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 15568  .  .  .  .  .  .  .  .  .  0: _Rparen
 15569  .  .  .  .  .  .  .  .  .  1: _Rbrace
 15570  .  .  .  .  .  .  .  .  }
 15571  .  .  .  .  .  .  .  }
 15572  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15573  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 15574  .  .  .  .  .  .  .  .  .  Results: true
 15575  .  .  .  .  .  .  .  .  }
 15576  .  .  .  .  .  .  .  }
 15577  .  .  .  .  .  .  }
 15578  .  .  .  .  .  }
 15579  .  .  .  .  }
 15580  .  .  .  .  1: *syntax.ExprStmt {
 15581  .  .  .  .  .  X: *syntax.CallExpr {
 15582  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15583  .  .  .  .  .  .  .  X: p
 15584  .  .  .  .  .  .  .  Sel: syntax_error
 15585  .  .  .  .  .  .  }
 15586  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15587  .  .  .  .  .  .  .  0: *syntax.Operation {
 15588  .  .  .  .  .  .  .  .  Op: +
 15589  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
 15590  .  .  .  .  .  .  .  .  .  Value: "\"expecting comma or \""
 15591  .  .  .  .  .  .  .  .  .  Kind: 4
 15592  .  .  .  .  .  .  .  .  }
 15593  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
 15594  .  .  .  .  .  .  .  .  .  Fun: tokstring
 15595  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15596  .  .  .  .  .  .  .  .  .  .  0: follow
 15597  .  .  .  .  .  .  .  .  .  }
 15598  .  .  .  .  .  .  .  .  .  HasDots: false
 15599  .  .  .  .  .  .  .  .  }
 15600  .  .  .  .  .  .  .  }
 15601  .  .  .  .  .  .  }
 15602  .  .  .  .  .  .  HasDots: false
 15603  .  .  .  .  .  }
 15604  .  .  .  .  }
 15605  .  .  .  .  2: *syntax.ExprStmt {
 15606  .  .  .  .  .  X: *syntax.CallExpr {
 15607  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15608  .  .  .  .  .  .  .  X: p
 15609  .  .  .  .  .  .  .  Sel: advance
 15610  .  .  .  .  .  .  }
 15611  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15612  .  .  .  .  .  .  .  0: follow
 15613  .  .  .  .  .  .  }
 15614  .  .  .  .  .  .  HasDots: false
 15615  .  .  .  .  .  }
 15616  .  .  .  .  }
 15617  .  .  .  .  3: *syntax.ReturnStmt {
 15618  .  .  .  .  .  Results: false
 15619  .  .  .  .  }
 15620  .  .  .  }
 15621  .  .  .  Pragma: 0
 15622  .  .  .  EndLine: 2132
 15623  .  .  }
 15624  .  .  75: *syntax.FuncDecl {
 15625  .  .  .  Attr: map[]
 15626  .  .  .  Recv: nil
 15627  .  .  .  Name: unparen
 15628  .  .  .  Type: *syntax.FuncType {
 15629  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 15630  .  .  .  .  .  0: *syntax.Field {
 15631  .  .  .  .  .  .  Name: x
 15632  .  .  .  .  .  .  Type: Expr
 15633  .  .  .  .  .  }
 15634  .  .  .  .  }
 15635  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 15636  .  .  .  .  .  0: *syntax.Field {
 15637  .  .  .  .  .  .  Name: nil
 15638  .  .  .  .  .  .  Type: Expr
 15639  .  .  .  .  .  }
 15640  .  .  .  .  }
 15641  .  .  .  }
 15642  .  .  .  Body: []syntax.Stmt (2 entries) {
 15643  .  .  .  .  0: *syntax.ForStmt {
 15644  .  .  .  .  .  Init: nil
 15645  .  .  .  .  .  Cond: nil
 15646  .  .  .  .  .  Post: nil
 15647  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 15648  .  .  .  .  .  .  0: *syntax.AssignStmt {
 15649  .  .  .  .  .  .  .  Op: :
 15650  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 15651  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 15652  .  .  .  .  .  .  .  .  .  0: p
 15653  .  .  .  .  .  .  .  .  .  1: ok
 15654  .  .  .  .  .  .  .  .  }
 15655  .  .  .  .  .  .  .  }
 15656  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 15657  .  .  .  .  .  .  .  .  X: x
 15658  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 15659  .  .  .  .  .  .  .  .  .  Op: *
 15660  .  .  .  .  .  .  .  .  .  X: ParenExpr
 15661  .  .  .  .  .  .  .  .  .  Y: nil
 15662  .  .  .  .  .  .  .  .  }
 15663  .  .  .  .  .  .  .  }
 15664  .  .  .  .  .  .  }
 15665  .  .  .  .  .  .  1: *syntax.IfStmt {
 15666  .  .  .  .  .  .  .  Init: nil
 15667  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 15668  .  .  .  .  .  .  .  .  Op: !
 15669  .  .  .  .  .  .  .  .  X: ok
 15670  .  .  .  .  .  .  .  .  Y: nil
 15671  .  .  .  .  .  .  .  }
 15672  .  .  .  .  .  .  .  Then: []syntax.Stmt (1 entries) {
 15673  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
 15674  .  .  .  .  .  .  .  .  .  Tok: break
 15675  .  .  .  .  .  .  .  .  .  Label: nil
 15676  .  .  .  .  .  .  .  .  }
 15677  .  .  .  .  .  .  .  }
 15678  .  .  .  .  .  .  .  Else: nil
 15679  .  .  .  .  .  .  }
 15680  .  .  .  .  .  .  2: *syntax.AssignStmt {
 15681  .  .  .  .  .  .  .  Op: <op-0>
 15682  .  .  .  .  .  .  .  Lhs: x
 15683  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 15684  .  .  .  .  .  .  .  .  X: p
 15685  .  .  .  .  .  .  .  .  Sel: X
 15686  .  .  .  .  .  .  .  }
 15687  .  .  .  .  .  .  }
 15688  .  .  .  .  .  }
 15689  .  .  .  .  }
 15690  .  .  .  .  1: *syntax.ReturnStmt {
 15691  .  .  .  .  .  Results: x
 15692  .  .  .  .  }
 15693  .  .  .  }
 15694  .  .  .  Pragma: 0
 15695  .  .  .  EndLine: 2144
 15696  .  .  }
 15697  .  }
 15698  .  Lines: 2145
 15699  }
parsed 1118872 lines (3060 files) in 987.943625ms (1132526 lines/s)
allocated 258.946Mb (262.106Mb/s)
--- FAIL: TestStdLib (0.99s)
	parser_test.go:57: 29: syntax error: unexpected (, expecting semicolon, newline, or }
package syntax

import (
	"fmt"
	"io"
	"strings"
)

const debug = false
const trace = false
const gcCompat = true

type parser struct {
	scanner
	fnest int
	xnest int
	indent []byte
}

func (p *parser) init(src io.Reader, errh ErrorHandler, pragh PragmaHandler) {
	p.scanner.init(src, errh, pragh)
	p.fnest = 0
	p.xnest = 0
	p.indent = nil
}

func (p *parser) got(tok token) bool {
	if p.tok == tok {
		p.next()
		return true
	}
	return false
}

func (p *parser) want(tok token) {
	if !p.got(tok) {
		p.syntax_error("expecting " + tok.String())
		p.advance()
	}
}

func (p *parser) syntax_error(msg string) {
	p.syntax_error_at(p.pos, p.line, msg)
}

func (p *parser) syntax_error_at(pos, line int, msg string) {
	if trace {
		defer p.trace("syntax_error (" + msg + ")")()
	}
	if p.tok == _EOF && p.first != nil {
		return
	}
	switch {
	case msg == "":
	case strings.HasPrefix(msg, "in"), strings.HasPrefix(msg, "at"), strings.HasPrefix(msg, "after"):
		msg = " " + msg
	case strings.HasPrefix(msg, "expecting"):
		msg = ", " + msg
	default:
		p.error_at(pos, line, "syntax error: " + msg)
		return
	}
	var tok string
	switch p.tok {
	case _Name:
		tok = p.lit
	case _Literal:
		tok = "literal " + p.lit
	case _Operator:
		tok = p.op.String()
	case _AssignOp:
		tok = p.op.String() + "="
	case _IncOp:
		tok = p.op.String()
		tok += tok
	default:
		tok = tokstring(p.tok)
	}
	p.error_at(pos, line, "syntax error: unexpected " + tok + msg)
}

const stopset uint64 = 1 << _Break | 1 << _Const | 1 << _Continue | 1 << _Defer | 1 << _Fallthrough | 1 << _For | 1 << _Func | 1 << _Go | 1 << _Goto | 1 << _If | 1 << _Return | 1 << _Select | 1 << _Switch | 1 << _Type | 1 << _Var

func (p *parser) advance(followlist ...token) {
	if len(followlist) == 0 {
		p.next()
		return
	}
	var followset uint64 = 1 << _EOF
	for _, tok := range followlist {
		followset |= 1 << tok
	}
	for !(contains(followset, p.tok) || p.fnest > 0 && contains(stopset, p.tok)) {
		p.next()
	}
}

func tokstring(tok token) string {
	switch tok {
	case _EOF:
		return "EOF"
	case _Comma:
		return "comma"
	case _Semi:
		return "semicolon or newline"
	}
	return tok.String()
}

func (p *parser) trace(msg string) func() {
	fmt.Printf("%5d: %s%s (\n", p.line, p.indent, msg)
	const tab = ". "
	p.indent = append(p.indent, tab...)
	return func() {
		p.indent = p.indent[:len(p.indent) - len(tab)]
		if x := recover(); x != nil {
			panic(x)
		}
		fmt.Printf("%5d: %s)\n", p.line, p.indent)
	}
}

func (p *parser) file() *File {
	if trace {
		defer p.trace("file")()
	}
	f := new(File)
	f.init(p)
	if !p.got(_Package) {
		p.syntax_error("package statement must be first")
		return nil
	}
	f.PkgName = p.name()
	p.want(_Semi)
	if p.first != nil {
		return nil
	}
	for p.got(_Import) {
		f.DeclList = p.appendGroup(f.DeclList, p.importDecl)
		p.want(_Semi)
	}
	for p.tok != _EOF {
		switch p.tok {
		case _Const:
			p.next()
			f.DeclList = p.appendGroup(f.DeclList, p.constDecl)
		case _Type:
			p.next()
			f.DeclList = p.appendGroup(f.DeclList, p.typeDecl)
		case _Var:
			p.next()
			f.DeclList = p.appendGroup(f.DeclList, p.varDecl)
		case _Func:
			p.next()
			f.DeclList = append(f.DeclList, p.funcDecl())
		default:
			if p.tok == _Lbrace && len(f.DeclList) > 0 && emptyFuncDecl(f.DeclList[len(f.DeclList) - 1]) {
				p.syntax_error("unexpected semicolon or newline before {")
			} else {
				p.syntax_error("non-declaration statement outside function body")
			}
			p.advance(_Const, _Type, _Var, _Func)
			continue
		}
		p.pragma = 0
		if p.tok != _EOF && !p.got(_Semi) {
			p.syntax_error("after top level declaration")
			p.advance(_Const, _Type, _Var, _Func)
		}
	}
	f.Lines = p.source.line
	return f
}

func emptyFuncDecl(dcl Decl) bool {
	f, ok := dcl.(*FuncDecl)
	return ok && f.Body == nil
}

func (p *parser) appendGroup(list []Decl, f func(*Group) Decl) []Decl {
	if p.got(_Lparen) {
		g := new(Group)
		for p.tok != _EOF && p.tok != _Rparen {
			list = append(list, f(g))
			if !p.osemi(_Rparen) {
				break
			}
		}
		p.want(_Rparen)
		return list
	}
	return append(list, f(nil))
}

func (p *parser) importDecl(group *Group) Decl {
	if trace {
		defer p.trace("importDecl")()
	}
	d := new(ImportDecl)
	d.init(p)
	switch p.tok {
	case _Name:
		d.LocalPkgName = p.name()
	case _Dot:
		n := new(Name)
		n.init(p)
		n.Value = "."
		d.LocalPkgName = n
		p.next()
	}
	if p.tok == _Literal && (gcCompat || p.kind == StringLit) {
		d.Path = p.oliteral()
	} else {
		p.syntax_error("missing import path; require quoted string")
		p.advance(_Semi, _Rparen)
	}
	d.Group = group
	return d
}

func (p *parser) constDecl(group *Group) Decl {
	if trace {
		defer p.trace("constDecl")()
	}
	d := new(ConstDecl)
	d.init(p)
	d.NameList = p.nameList(p.name())
	if p.tok != _EOF && p.tok != _Semi && p.tok != _Rparen {
		d.Type = p.tryType()
		if p.got(_Assign) {
			d.Values = p.exprList()
		}
	}
	d.Group = group
	return d
}

func (p *parser) typeDecl(group *Group) Decl {
	if trace {
		defer p.trace("typeDecl")()
	}
	d := new(TypeDecl)
	d.init(p)
	d.Name = p.name()
	d.Type = p.tryType()
	if d.Type == nil {
		p.syntax_error("in type declaration")
		p.advance(_Semi, _Rparen)
	}
	d.Group = group
	d.Pragma = p.pragma
	return d
}

func (p *parser) varDecl(group *Group) Decl {
	if trace {
		defer p.trace("varDecl")()
	}
	d := new(VarDecl)
	d.init(p)
	d.NameList = p.nameList(p.name())
	if p.got(_Assign) {
		d.Values = p.exprList()
	} else {
		d.Type = p.type_()
		if p.got(_Assign) {
			d.Values = p.exprList()
		}
	}
	d.Group = group
	if gcCompat {
		d.init(p)
	}
	return d
}

func (p *parser) funcDecl() *FuncDecl {
	if trace {
		defer p.trace("funcDecl")()
	}
	f := new(FuncDecl)
	f.init(p)
	badRecv := false
	if p.tok == _Lparen {
		rcvr := p.paramList()
		switch len(rcvr) {
		case 0:
			p.error("method has no receiver")
			badRecv = true
		case 1:
			f.Recv = rcvr[0]
		default:
			p.error("method has multiple receivers")
			badRecv = true
		}
	}
	if p.tok != _Name {
		p.syntax_error("expecting name or (")
		p.advance(_Lbrace, _Semi)
		return nil
	}
	f.Name = p.name()
	f.Type = p.funcType()
	if gcCompat {
		f.node = f.Type.node
	}
	f.Body = p.funcBody()
	f.Pragma = p.pragma
	f.EndLine = uint32(p.line)
	if badRecv {
		return nil
	}
	return f
}

func (p *parser) expr() Expr {
	if trace {
		defer p.trace("expr")()
	}
	return p.binaryExpr(0)
}

func (p *parser) binaryExpr(prec int) Expr {
	x := p.unaryExpr()
	for (p.tok == _Operator || p.tok == _Star) && p.prec > prec {
		t := new(Operation)
		t.init(p)
		t.Op = p.op
		t.X = x
		tprec := p.prec
		p.next()
		t.Y = p.binaryExpr(tprec)
		if gcCompat {
			t.init(p)
		}
		x = t
	}
	return x
}

func (p *parser) unaryExpr() Expr {
	if trace {
		defer p.trace("unaryExpr")()
	}
	switch p.tok {
	case _Operator, _Star:
		switch p.op {
		case Mul, Add, Sub, Not, Xor:
			x := new(Operation)
			x.init(p)
			x.Op = p.op
			p.next()
			x.X = p.unaryExpr()
			if gcCompat {
				x.init(p)
			}
			return x
		case And:
			p.next()
			x := new(Operation)
			x.init(p)
			x.Op = And
			x.X = unparen(p.unaryExpr())
			return x
		}
	case _Arrow:
		p.next()
		x := p.unaryExpr()
		if _, ok := x.(*ChanType); ok {
			dir := SendOnly
			t := x
			for dir == SendOnly {
				c, ok := t.(*ChanType)
				if !ok {
					break
				}
				dir = c.Dir
				if dir == RecvOnly {
					p.syntax_error("unexpected <-, expecting chan")
				}
				c.Dir = RecvOnly
				t = c.Elem
			}
			if dir == SendOnly {
				p.syntax_error(fmt.Sprintf("unexpected %s, expecting chan", String(t)))
			}
			return x
		}
		return &Operation{
			Op: Recv,
			X: x,
		}
	}
	return p.pexpr(true)
}

func (p *parser) callStmt() *CallStmt {
	if trace {
		defer p.trace("callStmt")()
	}
	s := new(CallStmt)
	s.init(p)
	s.Tok = p.tok
	p.next()
	x := p.pexpr(p.tok == _Lparen)
	switch x := x.(type) {
	case *CallExpr:
		s.Call = x
		if gcCompat {
			s.node = x.node
		}
	case *ParenExpr:
		p.error(fmt.Sprintf("expression in %s must not be parenthesized", s.Tok))
	default:
		p.error(fmt.Sprintf("expression in %s must be function call", s.Tok))
	}
	return s
}

func (p *parser) operand(keep_parens bool) Expr {
	if trace {
		defer p.trace("operand " + p.tok.String())()
	}
	switch p.tok {
	case _Name:
		return p.name()
	case _Literal:
		return p.oliteral()
	case _Lparen:
		p.next()
		p.xnest++
		x := p.expr()
		p.xnest--
		p.want(_Rparen)
		if p.tok == _Lbrace {
			keep_parens = true
		}
		if keep_parens {
			x = &ParenExpr{
				X: x,
			}
		}
		return x
	case _Func:
		p.next()
		t := p.funcType()
		if p.tok == _Lbrace {
			p.fnest++
			p.xnest++
			f := new(FuncLit)
			f.init(p)
			f.Type = t
			f.Body = p.funcBody()
			f.EndLine = uint32(p.line)
			p.xnest--
			p.fnest--
			return f
		}
		return t
	case _Lbrack, _Chan, _Map, _Struct, _Interface:
		return p.type_()
	case _Lbrace:
		p.syntax_error("missing operand")
		return nil
	default:
		p.syntax_error("expecting expression")
		p.advance()
		return nil
	}
}

func (p *parser) pexpr(keep_parens bool) Expr {
	if trace {
		defer p.trace("pexpr")()
	}
	x := p.operand(keep_parens)
loop:
	for {
		switch p.tok {
		case _Dot:
			p.next()
			switch p.tok {
			case _Name:
				t := new(SelectorExpr)
				t.init(p)
				t.X = x
				t.Sel = p.name()
				x = t
			case _Lparen:
				p.next()
				if p.got(_Type) {
					t := new(TypeSwitchGuard)
					t.init(p)
					t.X = x
					x = t
				} else {
					t := new(AssertExpr)
					t.init(p)
					t.X = x
					t.Type = p.expr()
					x = t
				}
				p.want(_Rparen)
			default:
				p.syntax_error("expecting name or (")
				p.advance(_Semi, _Rparen)
			}
			if gcCompat {
				x.init(p)
			}
		case _Lbrack:
			p.next()
			p.xnest++
			var i Expr
			if p.tok != _Colon {
				i = p.expr()
				if p.got(_Rbrack) {
					t := new(IndexExpr)
					t.init(p)
					t.X = x
					t.Index = i
					x = t
					p.xnest--
					break
				}
			}
			t := new(SliceExpr)
			t.init(p)
			t.X = x
			t.Index[0] = i
			p.want(_Colon)
			if p.tok != _Colon && p.tok != _Rbrack {
				t.Index[1] = p.expr()
			}
			if p.got(_Colon) {
				t.Full = true
				if t.Index[1] == nil {
					p.error("middle index required in 3-index slice")
				}
				if p.tok != _Rbrack {
					t.Index[2] = p.expr()
				} else {
					p.error("final index required in 3-index slice")
				}
			}
			p.want(_Rbrack)
			x = t
			p.xnest--
		case _Lparen:
			x = p.call(x)
		case _Lbrace:
			t := unparen(x)
			complit_ok := false
			switch t.(type) {
			case *Name, *SelectorExpr:
				if p.xnest >= 0 {
					complit_ok = true
				}
			case *ArrayType, *SliceType, *StructType, *MapType:
				complit_ok = true
			}
			if !complit_ok {
				break loop
			}
			if t != x {
				p.syntax_error("cannot parenthesize type in composite literal")
			}
			n := p.complitexpr()
			n.Type = x
			x = n
		default:
			break loop
		}
	}
	return x
}

func (p *parser) bare_complitexpr() Expr {
	if trace {
		defer p.trace("bare_complitexpr")()
	}
	if p.tok == _Lbrace {
		return p.complitexpr()
	}
	return p.expr()
}

func (p *parser) complitexpr() *CompositeLit {
	if trace {
		defer p.trace("complitexpr")()
	}
	x := new(CompositeLit)
	x.init(p)
	p.want(_Lbrace)
	p.xnest++
	for p.tok != _EOF && p.tok != _Rbrace {
		e := p.bare_complitexpr()
		if p.got(_Colon) {
			l := new(KeyValueExpr)
			l.init(p)
			l.Key = e
			l.Value = p.bare_complitexpr()
			if gcCompat {
				l.init(p)
			}
			e = l
			x.NKeys++
		}
		x.ElemList = append(x.ElemList, e)
		if !p.ocomma(_Rbrace) {
			break
		}
	}
	x.EndLine = uint32(p.line)
	p.xnest--
	p.want(_Rbrace)
	return x
}

func (p *parser) type_() Expr {
	if trace {
		defer p.trace("type_")()
	}
	if typ := p.tryType(); typ != nil {
		return typ
	}
	p.syntax_error("")
	p.advance()
	return nil
}

func indirect(typ Expr) Expr {
	return &Operation{
		Op: Mul,
		X: typ,
	}
}

func (p *parser) tryType() Expr {
	if trace {
		defer p.trace("tryType")()
	}
	switch p.tok {
	case _Star:
		p.next()
		return indirect(p.type_())
	case _Arrow:
		p.next()
		p.want(_Chan)
		t := new(ChanType)
		t.init(p)
		t.Dir = RecvOnly
		t.Elem = p.chanElem()
		return t
	case _Func:
		p.next()
		return p.funcType()
	case _Lbrack:
		p.next()
		p.xnest++
		if p.got(_Rbrack) {
			p.xnest--
			t := new(SliceType)
			t.init(p)
			t.Elem = p.type_()
			return t
		}
		t := new(ArrayType)
		t.init(p)
		if !p.got(_DotDotDot) {
			t.Len = p.expr()
		}
		p.want(_Rbrack)
		p.xnest--
		t.Elem = p.type_()
		return t
	case _Chan:
		p.next()
		t := new(ChanType)
		t.init(p)
		if p.got(_Arrow) {
			t.Dir = SendOnly
		}
		t.Elem = p.chanElem()
		return t
	case _Map:
		p.next()
		p.want(_Lbrack)
		t := new(MapType)
		t.init(p)
		t.Key = p.type_()
		p.want(_Rbrack)
		t.Value = p.type_()
		return t
	case _Struct:
		return p.structType()
	case _Interface:
		return p.interfaceType()
	case _Name:
		return p.dotname(p.name())
	case _Lparen:
		p.next()
		t := p.type_()
		p.want(_Rparen)
		return t
	}
	return nil
}

func (p *parser) funcType() *FuncType {
	if trace {
		defer p.trace("funcType")()
	}
	typ := new(FuncType)
	typ.init(p)
	typ.ParamList = p.paramList()
	typ.ResultList = p.funcResult()
	if gcCompat {
		typ.init(p)
	}
	return typ
}

func (p *parser) chanElem() Expr {
	if trace {
		defer p.trace("chanElem")()
	}
	if typ := p.tryType(); typ != nil {
		return typ
	}
	p.syntax_error("missing channel element type")
	return nil
}

func (p *parser) dotname(name *Name) Expr {
	if trace {
		defer p.trace("dotname")()
	}
	if p.got(_Dot) {
		s := new(SelectorExpr)
		s.init(p)
		s.X = name
		s.Sel = p.name()
		return s
	}
	return name
}

func (p *parser) structType() *StructType {
	if trace {
		defer p.trace("structType")()
	}
	typ := new(StructType)
	typ.init(p)
	p.want(_Struct)
	p.want(_Lbrace)
	for p.tok != _EOF && p.tok != _Rbrace {
		p.fieldDecl(typ)
		if !p.osemi(_Rbrace) {
			break
		}
	}
	if gcCompat {
		typ.init(p)
	}
	p.want(_Rbrace)
	return typ
}

func (p *parser) interfaceType() *InterfaceType {
	if trace {
		defer p.trace("interfaceType")()
	}
	typ := new(InterfaceType)
	typ.init(p)
	p.want(_Interface)
	p.want(_Lbrace)
	for p.tok != _EOF && p.tok != _Rbrace {
		if m := p.methodDecl(); m != nil {
			typ.MethodList = append(typ.MethodList, m)
		}
		if !p.osemi(_Rbrace) {
			break
		}
	}
	if gcCompat {
		typ.init(p)
	}
	p.want(_Rbrace)
	return typ
}

func (p *parser) funcBody() []Stmt {
	if trace {
		defer p.trace("funcBody")()
	}
	if p.got(_Lbrace) {
		p.fnest++
		body := p.stmtList()
		p.fnest--
		p.want(_Rbrace)
		if body == nil {
			body = []Stmt{new(EmptyStmt)}
		}
		return body
	}
	return nil
}

func (p *parser) funcResult() []*Field {
	if trace {
		defer p.trace("funcResult")()
	}
	if p.tok == _Lparen {
		return p.paramList()
	}
	if result := p.tryType(); result != nil {
		f := new(Field)
		f.init(p)
		f.Type = result
		return []*Field{f}
	}
	return nil
}

func (p *parser) addField(styp *StructType, name *Name, typ Expr, tag *BasicLit) {
	if tag != nil {
		for i := len(styp.FieldList) - len(styp.TagList); i > 0; i-- {
			styp.TagList = append(styp.TagList, nil)
		}
		styp.TagList = append(styp.TagList, tag)
	}
	f := new(Field)
	f.init(p)
	f.Name = name
	f.Type = typ
	styp.FieldList = append(styp.FieldList, f)
	if gcCompat && name != nil {
		f.node = name.node
	}
	if debug && tag != nil && len(styp.FieldList) != len(styp.TagList) {
		panic("inconsistent struct field list")
	}
}

func (p *parser) fieldDecl(styp *StructType) {
	if trace {
		defer p.trace("fieldDecl")()
	}
	var name *Name
	switch p.tok {
	case _Name:
		name = p.name()
		if p.tok == _Dot || p.tok == _Literal || p.tok == _Semi || p.tok == _Rbrace {
			typ := p.qualifiedName(name)
			tag := p.oliteral()
			p.addField(styp, nil, typ, tag)
			return
		}
		names := p.nameList(name)
		typ := p.type_()
		tag := p.oliteral()
		for _, name := range names {
			p.addField(styp, name, typ, tag)
		}
	case _Lparen:
		p.next()
		if p.tok == _Star {
			p.next()
			typ := indirect(p.qualifiedName(nil))
			p.want(_Rparen)
			tag := p.oliteral()
			p.addField(styp, nil, typ, tag)
			p.error("cannot parenthesize embedded type")
		} else {
			typ := p.qualifiedName(nil)
			p.want(_Rparen)
			tag := p.oliteral()
			p.addField(styp, nil, typ, tag)
			p.error("cannot parenthesize embedded type")
		}
	case _Star:
		p.next()
		if p.got(_Lparen) {
			typ := indirect(p.qualifiedName(nil))
			p.want(_Rparen)
			tag := p.oliteral()
			p.addField(styp, nil, typ, tag)
			p.error("cannot parenthesize embedded type")
		} else {
			typ := indirect(p.qualifiedName(nil))
			tag := p.oliteral()
			p.addField(styp, nil, typ, tag)
		}
	default:
		p.syntax_error("expecting field name or embedded type")
		p.advance(_Semi, _Rbrace)
	}
}

func (p *parser) oliteral() *BasicLit {
	if p.tok == _Literal {
		b := new(BasicLit)
		b.init(p)
		b.Value = p.lit
		b.Kind = p.kind
		p.next()
		return b
	}
	return nil
}

func (p *parser) methodDecl() *Field {
	if trace {
		defer p.trace("methodDecl")()
	}
	switch p.tok {
	case _Name:
		name := p.name()
		hasNameList := false
		for p.got(_Comma) {
			p.name()
			hasNameList = true
		}
		if hasNameList {
			p.syntax_error("name list not allowed in interface type")
		}
		f := new(Field)
		f.init(p)
		if p.tok != _Lparen {
			f.Type = p.qualifiedName(name)
			return f
		}
		f.Name = name
		f.Type = p.funcType()
		return f
	case _Lparen:
		p.next()
		f := new(Field)
		f.init(p)
		f.Type = p.qualifiedName(nil)
		p.want(_Rparen)
		p.error("cannot parenthesize embedded type")
		return f
	default:
		p.syntax_error("")
		p.advance(_Semi, _Rbrace)
		return nil
	}
}

func (p *parser) paramDecl() *Field {
	if trace {
		defer p.trace("paramDecl")()
	}
	f := new(Field)
	f.init(p)
	switch p.tok {
	case _Name:
		f.Name = p.name()
		switch p.tok {
		case _Name, _Star, _Arrow, _Func, _Lbrack, _Chan, _Map, _Struct, _Interface, _Lparen:
			f.Type = p.type_()
		case _DotDotDot:
			f.Type = p.dotsType()
		case _Dot:
			f.Type = p.dotname(f.Name)
			f.Name = nil
		}
	case _Arrow, _Star, _Func, _Lbrack, _Chan, _Map, _Struct, _Interface, _Lparen:
		f.Type = p.type_()
	case _DotDotDot:
		f.Type = p.dotsType()
	default:
		p.syntax_error("expecting )")
		p.advance(_Comma, _Rparen)
		return nil
	}
	return f
}

func (p *parser) dotsType() *DotsType {
	if trace {
		defer p.trace("dotsType")()
	}
	t := new(DotsType)
	t.init(p)
	p.want(_DotDotDot)
	t.Elem = p.tryType()
	if t.Elem == nil {
		p.error("final argument in variadic function missing type")
	}
	return t
}

func (p *parser) paramList() (list []*Field) {
	if trace {
		defer p.trace("paramList")()
	}
	p.want(_Lparen)
	var named int
	for p.tok != _EOF && p.tok != _Rparen {
		if par := p.paramDecl(); par != nil {
			if debug && par.Name == nil && par.Type == nil {
				panic("parameter without name or type")
			}
			if par.Name != nil && par.Type != nil {
				named++
			}
			list = append(list, par)
		}
		if !p.ocomma(_Rparen) {
			break
		}
	}
	if named == 0 {
		for _, par := range list {
			if typ := par.Name; typ != nil {
				par.Type = typ
				par.Name = nil
			}
		}
	} else if named != len(list) {
		var typ Expr
		for i := len(list) - 1; i >= 0; i-- {
			if par := list[i]; par.Type != nil {
				typ = par.Type
				if par.Name == nil {
					typ = nil
				}
			} else {
				par.Type = typ
			}
			if typ == nil {
				p.syntax_error("mixed named and unnamed function parameters")
				break
			}
		}
	}
	p.want(_Rparen)
	return
}

var ImplicitOne = &BasicLit{
	Value: "1",
}

func (p *parser) simpleStmt(lhs Expr, rangeOk bool) SimpleStmt {
	if trace {
		defer p.trace("simpleStmt")()
	}
	if rangeOk && p.got(_Range) {
		if debug && lhs != nil {
			panic("invalid call of simpleStmt")
		}
		return p.rangeClause(nil, false)
	}
	if lhs == nil {
		lhs = p.exprList()
	}
	if _, ok := lhs.(*ListExpr); !ok && p.tok != _Assign && p.tok != _Define {
		switch p.tok {
		case _AssignOp:
			op := p.op
			p.next()
			return p.newAssignStmt(op, lhs, p.expr())
		case _IncOp:
			op := p.op
			p.next()
			return p.newAssignStmt(op, lhs, ImplicitOne)
		case _Arrow:
			p.next()
			s := new(SendStmt)
			s.init(p)
			s.Chan = lhs
			s.Value = p.expr()
			if gcCompat {
				s.init(p)
			}
			return s
		default:
			return &ExprStmt{
				X: lhs,
			}
		}
	}
	switch p.tok {
	case _Assign:
		p.next()
		if rangeOk && p.got(_Range) {
			return p.rangeClause(lhs, false)
		}
		return p.newAssignStmt(0, lhs, p.exprList())
	case _Define:
		var n node
		n.init(p)
		p.next()
		if rangeOk && p.got(_Range) {
			return p.rangeClause(lhs, true)
		}
		rhs := p.exprList()
		if x, ok := rhs.(*TypeSwitchGuard); ok {
			switch lhs := lhs.(type) {
			case *Name:
				x.Lhs = lhs
			case *ListExpr:
				p.error(fmt.Sprintf("argument count mismatch: %d = %d", len(lhs.ElemList), 1))
			default:
				p.error(fmt.Sprintf("invalid variable name %s in type switch", lhs))
			}
			return &ExprStmt{
				X: x,
			}
		}
		as := p.newAssignStmt(Def, lhs, rhs)
		if gcCompat {
			as.node = n
		}
		return as
	default:
		p.syntax_error("expecting := or = or comma")
		p.advance(_Semi, _Rbrace)
		return nil
	}
}

func (p *parser) rangeClause(lhs Expr, def bool) *RangeClause {
	r := new(RangeClause)
	r.init(p)
	r.Lhs = lhs
	r.Def = def
	r.X = p.expr()
	if gcCompat {
		r.init(p)
	}
	return r
}

func (p *parser) newAssignStmt(op Operator, lhs, rhs Expr) *AssignStmt {
	a := new(AssignStmt)
	a.init(p)
	a.Op = op
	a.Lhs = lhs
	a.Rhs = rhs
	return a
}

func (p *parser) labeledStmt(label *Name) Stmt {
	if trace {
		defer p.trace("labeledStmt")()
	}
	s := new(LabeledStmt)
	s.init(p)
	s.Label = label
	p.want(_Colon)
	if p.tok != _Rbrace && p.tok != _EOF {
		s.Stmt = p.stmt()
		if s.Stmt == missing_stmt {
			p.syntax_error_at(int(label.pos), int(label.line), "missing statement after label")
			return missing_stmt
		}
	}
	return s
}

func (p *parser) blockStmt() *BlockStmt {
	if trace {
		defer p.trace("blockStmt")()
	}
	s := new(BlockStmt)
	s.init(p)
	p.want(_Lbrace)
	s.Body = p.stmtList()
	p.want(_Rbrace)
	return s
}

func (p *parser) declStmt(f func(*Group) Decl) *DeclStmt {
	if trace {
		defer p.trace("declStmt")()
	}
	s := new(DeclStmt)
	s.init(p)
	p.next()
	s.DeclList = p.appendGroup(nil, f)
	return s
}

func (p *parser) forStmt() Stmt {
	if trace {
		defer p.trace("forStmt")()
	}
	s := new(ForStmt)
	s.init(p)
	p.want(_For)
	s.Init, s.Cond, s.Post = p.header(true)
	if gcCompat {
		s.init(p)
	}
	s.Body = p.stmtBody("for clause")
	return s
}

func (p *parser) stmtBody(context string) []Stmt {
	if trace {
		defer p.trace("stmtBody")()
	}
	if !p.got(_Lbrace) {
		p.syntax_error("missing { after " + context)
		p.advance(_Name, _Rbrace)
	}
	body := p.stmtList()
	p.want(_Rbrace)
	return body
}

var dummyCond = &Name{
	Value: "false",
}

func (p *parser) header(forStmt bool) (init SimpleStmt, cond Expr, post SimpleStmt) {
	if p.tok == _Lbrace {
		return
	}
	outer := p.xnest
	p.xnest = -1
	if p.tok != _Semi {
		if forStmt && p.got(_Var) {
			p.error("var declaration not allowed in for initializer")
		}
		init = p.simpleStmt(nil, forStmt)
		if _, ok := init.(*RangeClause); ok {
			p.xnest = outer
			return
		}
	}
	var condStmt SimpleStmt
	if p.got(_Semi) {
		if forStmt {
			if p.tok != _Semi {
				condStmt = p.simpleStmt(nil, false)
			}
			p.want(_Semi)
			if p.tok != _Lbrace {
				post = p.simpleStmt(nil, false)
			}
		} else if p.tok != _Lbrace {
			condStmt = p.simpleStmt(nil, false)
		}
	} else {
		condStmt = init
		init = nil
	}
	switch s := condStmt.(type) {
	case nil:
	case *ExprStmt:
		cond = s.X
	default:
		p.syntax_error(fmt.Sprintf("%s used as value", String(s)))
		cond = dummyCond
	}
	p.xnest = outer
	return
}

func (p *parser) ifStmt() *IfStmt {
	if trace {
		defer p.trace("ifStmt")()
	}
	s := new(IfStmt)
	s.init(p)
	p.want(_If)
	s.Init, s.Cond, _ = p.header(false)
	if s.Cond == nil {
		p.error("missing condition in if statement")
	}
	if gcCompat {
		s.init(p)
	}
	s.Then = p.stmtBody("if clause")
	if p.got(_Else) {
		switch p.tok {
		case _If:
			s.Else = p.ifStmt()
		case _Lbrace:
			s.Else = p.blockStmt()
		default:
			p.error("else must be followed by if or statement block")
			p.advance(_Name, _Rbrace)
		}
	}
	return s
}

func (p *parser) switchStmt() *SwitchStmt {
	if trace {
		defer p.trace("switchStmt")()
	}
	p.want(_Switch)
	s := new(SwitchStmt)
	s.init(p)
	s.Init, s.Tag, _ = p.header(false)
	if !p.got(_Lbrace) {
		p.syntax_error("missing { after switch clause")
		p.advance(_Case, _Default, _Rbrace)
	}
	for p.tok != _EOF && p.tok != _Rbrace {
		s.Body = append(s.Body, p.caseClause())
	}
	p.want(_Rbrace)
	return s
}

func (p *parser) selectStmt() *SelectStmt {
	if trace {
		defer p.trace("selectStmt")()
	}
	p.want(_Select)
	s := new(SelectStmt)
	s.init(p)
	if !p.got(_Lbrace) {
		p.syntax_error("missing { after select clause")
		p.advance(_Case, _Default, _Rbrace)
	}
	for p.tok != _EOF && p.tok != _Rbrace {
		s.Body = append(s.Body, p.commClause())
	}
	p.want(_Rbrace)
	return s
}

func (p *parser) caseClause() *CaseClause {
	if trace {
		defer p.trace("caseClause")()
	}
	c := new(CaseClause)
	c.init(p)
	switch p.tok {
	case _Case:
		p.next()
		c.Cases = p.exprList()
	case _Default:
		p.next()
	default:
		p.syntax_error("expecting case or default or }")
		p.advance(_Case, _Default, _Rbrace)
	}
	if gcCompat {
		c.init(p)
	}
	p.want(_Colon)
	c.Body = p.stmtList()
	return c
}

func (p *parser) commClause() *CommClause {
	if trace {
		defer p.trace("commClause")()
	}
	c := new(CommClause)
	c.init(p)
	switch p.tok {
	case _Case:
		p.next()
		c.Comm = p.simpleStmt(nil, false)
	case _Default:
		p.next()
	default:
		p.syntax_error("expecting case or default or }")
		p.advance(_Case, _Default, _Rbrace)
	}
	if gcCompat {
		c.init(p)
	}
	p.want(_Colon)
	c.Body = p.stmtList()
	return c
}

var missing_stmt Stmt = new(EmptyStmt)

func (p *parser) stmt() Stmt {
	if trace {
		defer p.trace("stmt " + p.tok.String())()
	}
	if p.tok == _Name {
		lhs := p.exprList()
		if label, ok := lhs.(*Name); ok && p.tok == _Colon {
			return p.labeledStmt(label)
		}
		return p.simpleStmt(lhs, false)
	}
	switch p.tok {
	case _Lbrace:
		return p.blockStmt()
	case _Var:
		return p.declStmt(p.varDecl)
	case _Const:
		return p.declStmt(p.constDecl)
	case _Type:
		return p.declStmt(p.typeDecl)
	case _Operator, _Star:
		switch p.op {
		case Add, Sub, Mul, And, Xor, Not:
			return p.simpleStmt(nil, false)
		}
	case _Literal, _Func, _Lparen, _Lbrack, _Struct, _Map, _Chan, _Interface, _Arrow:
		return p.simpleStmt(nil, false)
	case _For:
		return p.forStmt()
	case _Switch:
		return p.switchStmt()
	case _Select:
		return p.selectStmt()
	case _If:
		return p.ifStmt()
	case _Fallthrough:
		p.next()
		s := new(BranchStmt)
		s.init(p)
		s.Tok = _Fallthrough
		return s
	case _Break, _Continue:
		tok := p.tok
		p.next()
		s := new(BranchStmt)
		s.init(p)
		s.Tok = tok
		if p.tok == _Name {
			s.Label = p.name()
		}
		return s
	case _Go, _Defer:
		return p.callStmt()
	case _Goto:
		p.next()
		s := new(BranchStmt)
		s.init(p)
		s.Tok = _Goto
		s.Label = p.name()
		return s
	case _Return:
		p.next()
		s := new(ReturnStmt)
		s.init(p)
		if p.tok != _Semi && p.tok != _Rbrace {
			s.Results = p.exprList()
		}
		if gcCompat {
			s.init(p)
		}
		return s
	case _Semi:
		s := new(EmptyStmt)
		s.init(p)
		return s
	}
	return missing_stmt
}

func (p *parser) stmtList() (l []Stmt) {
	if trace {
		defer p.trace("stmtList")()
	}
	for p.tok != _EOF && p.tok != _Rbrace && p.tok != _Case && p.tok != _Default {
		s := p.stmt()
		if s == missing_stmt {
			break
		}
		l = append(l, s)
		if p.tok == _Rparen || p.tok == _Rbrace {
			continue
		}
		if !p.got(_Semi) {
			p.syntax_error("at end of statement")
			p.advance(_Semi, _Rbrace)
		}
	}
	return
}

func (p *parser) call(fun Expr) *CallExpr {
	if trace {
		defer p.trace("call")()
	}
	c := new(CallExpr)
	c.init(p)
	c.Fun = fun
	p.want(_Lparen)
	p.xnest++
	for p.tok != _EOF && p.tok != _Rparen {
		c.ArgList = append(c.ArgList, p.expr())
		c.HasDots = p.got(_DotDotDot)
		if !p.ocomma(_Rparen) || c.HasDots {
			break
		}
	}
	p.xnest--
	if gcCompat {
		c.init(p)
	}
	p.want(_Rparen)
	return c
}

func (p *parser) name() *Name {
	n := new(Name)
	n.init(p)
	if p.tok == _Name {
		n.Value = p.lit
		p.next()
	} else {
		n.Value = "_"
		p.syntax_error("expecting name")
		p.advance()
	}
	return n
}

func (p *parser) nameList(first *Name) []*Name {
	if trace {
		defer p.trace("nameList")()
	}
	if debug && first == nil {
		panic("first name not provided")
	}
	l := []*Name{first}
	for p.got(_Comma) {
		l = append(l, p.name())
	}
	return l
}

func (p *parser) qualifiedName(name *Name) Expr {
	if trace {
		defer p.trace("qualifiedName")()
	}
	switch {
	case name != nil:
	case p.tok == _Name:
		name = p.name()
	default:
		name = new(Name)
		name.init(p)
		p.syntax_error("expecting name")
		p.advance(_Dot, _Semi, _Rbrace)
	}
	return p.dotname(name)
}

func (p *parser) exprList() Expr {
	if trace {
		defer p.trace("exprList")()
	}
	x := p.expr()
	if p.got(_Comma) {
		list := []Expr{x, p.expr()}
		for p.got(_Comma) {
			list = append(list, p.expr())
		}
		t := new(ListExpr)
		t.init(p)
		t.ElemList = list
		x = t
	}
	return x
}

func (p *parser) osemi(follow token) bool {
	switch p.tok {
	case _Semi:
		p.next()
		return true
	case _Rparen, _Rbrace:
		return true
	}
	p.syntax_error("expecting semicolon, newline, or " + tokstring(follow))
	p.advance(follow)
	return false
}

func (p *parser) ocomma(follow token) bool {
	switch p.tok {
	case _Comma:
		p.next()
		return true
	case _Rparen, _Rbrace:
		return true
	}
	p.syntax_error("expecting comma or " + tokstring(follow))
	p.advance(follow)
	return false
}

func unparen(x Expr) Expr {
	for {
		p, ok := x.(*ParenExpr)
		if !ok {
			break
		}
		x = p.X
	}
	return x
}
5 package
5 name => syntax
5 ;
7 import
7 (
8 literal
8 ;
9 literal
9 ;
10 literal
10 ;
11 )
11 ;
13 const
13 name => debug
13 =
13 name => false
13 ;
14 const
14 name => trace
14 =
14 name => false
14 ;
19 const
19 name => gcCompat
19 =
19 name => true
19 ;
21 type
21 name => parser
21 struct
21 {
22 name => scanner
22 ;
24 name => fnest
24 name => int
24 ;
25 name => xnest
25 name => int
25 ;
26 name => indent
26 [
26 ]
26 name => byte
26 ;
27 }
27 ;
29 func
29 (
29 name => p
29 *
29 name => parser
29 )
29 name => init
29 (
29 name => src
29 name => io
29 .
29 name => Reader
29 ,
29 name => errh
29 name => ErrorHandler
29 ,
29 name => pragh
29 name => PragmaHandler
29 )
29 {
30 name => p
30 .
30 name => scanner
30 .
30 name => init
30 (
30 name => src
30 ,
30 name => errh
30 ,
30 name => pragh
30 )
30 ;
32 name => p
32 .
32 name => fnest
32 =
32 literal
32 ;
33 name => p
33 .
33 name => xnest
33 =
33 literal
33 ;
34 name => p
34 .
34 name => indent
34 =
34 name => nil
34 ;
35 }
35 ;
37 func
37 (
37 name => p
37 *
37 name => parser
37 )
37 name => got
37 (
37 name => tok
37 name => token
37 )
37 name => bool
37 {
38 if
38 name => p
38 .
38 name => tok
38 op => == 3
38 name => tok
38 {
39 name => p
39 .
39 name => next
39 (
39 )
39 ;
40 return
40 name => true
40 ;
41 }
41 ;
42 return
42 name => false
42 ;
43 }
43 ;
45 func
45 (
45 name => p
45 *
45 name => parser
45 )
45 name => want
45 (
45 name => tok
45 name => token
45 )
45 {
46 if
46 op => ! 0
46 name => p
46 .
46 name => got
46 (
46 name => tok
46 )
46 {
47 name => p
47 .
47 name => syntax_error
47 (
47 literal
47 op => + 4
47 name => tok
47 .
47 name => String
47 (
47 )
47 )
47 ;
48 name => p
48 .
48 name => advance
48 (
48 )
48 ;
49 }
49 ;
50 }
50 ;
56 func
56 (
56 name => p
56 *
56 name => parser
56 )
56 name => syntax_error
56 (
56 name => msg
56 name => string
56 )
56 {
57 name => p
57 .
57 name => syntax_error_at
57 (
57 name => p
57 .
57 name => pos
57 ,
57 name => p
57 .
57 name => line
57 ,
57 name => msg
57 )
57 ;
58 }
58 ;
61 func
61 (
61 name => p
61 *
61 name => parser
61 )
61 name => syntax_error_at
61 (
61 name => pos
61 ,
61 name => line
61 name => int
61 ,
61 name => msg
61 name => string
61 )
61 {
62 if
62 name => trace
62 {
63 defer
63 name => p
63 .
63 name => trace
63 (
63 literal
63 op => + 4
63 name => msg
63 op => + 4
63 literal
63 )
63 (
63 )
63 ;
64 }
64 ;
66 if
66 name => p
66 .
66 name => tok
66 op => == 3
66 name => _EOF
66 op => && 2
66 name => p
66 .
66 name => first
66 op => != 3
66 name => nil
66 {
67 return
67 ;
68 }
68 ;
71 switch
71 {
72 case
72 name => msg
72 op => == 3
72 literal
72 :
74 case
74 name => strings
74 .
74 name => HasPrefix
74 (
74 name => msg
74 ,
74 literal
74 )
74 ,
74 name => strings
74 .
74 name => HasPrefix
74 (
74 name => msg
74 ,
74 literal
74 )
74 ,
74 name => strings
74 .
74 name => HasPrefix
74 (
74 name => msg
74 ,
74 literal
74 )
74 :
75 name => msg
75 =
75 literal
75 op => + 4
75 name => msg
75 ;
76 case
76 name => strings
76 .
76 name => HasPrefix
76 (
76 name => msg
76 ,
76 literal
76 )
76 :
77 name => msg
77 =
77 literal
77 op => + 4
77 name => msg
77 ;
78 default
78 :
80 name => p
80 .
80 name => error_at
80 (
80 name => pos
80 ,
80 name => line
80 ,
80 literal
80 op => + 4
80 name => msg
80 )
80 ;
81 return
81 ;
82 }
82 ;
85 var
85 name => tok
85 name => string
85 ;
86 switch
86 name => p
86 .
86 name => tok
86 {
87 case
87 name => _Name
87 :
88 name => tok
88 =
88 name => p
88 .
88 name => lit
88 ;
89 case
89 name => _Literal
89 :
90 name => tok
90 =
90 literal
90 op => + 4
90 name => p
90 .
90 name => lit
90 ;
91 case
91 name => _Operator
91 :
92 name => tok
92 =
92 name => p
92 .
92 name => op
92 .
92 name => String
92 (
92 )
92 ;
93 case
93 name => _AssignOp
93 :
94 name => tok
94 =
94 name => p
94 .
94 name => op
94 .
94 name => String
94 (
94 )
94 op => + 4
94 literal
94 ;
95 case
95 name => _IncOp
95 :
96 name => tok
96 =
96 name => p
96 .
96 name => op
96 .
96 name => String
96 (
96 )
96 ;
97 name => tok
97 op=
97 name => tok
97 ;
98 default
98 :
99 name => tok
99 =
99 name => tokstring
99 (
99 name => p
99 .
99 name => tok
99 )
99 ;
100 }
100 ;
102 name => p
102 .
102 name => error_at
102 (
102 name => pos
102 ,
102 name => line
102 ,
102 literal
102 op => + 4
102 name => tok
102 op => + 4
102 name => msg
102 )
102 ;
103 }
103 ;
108 const
108 name => stopset
108 name => uint64
108 =
108 literal
108 op => << 5
108 name => _Break
108 op => | 4
109 literal
109 op => << 5
109 name => _Const
109 op => | 4
110 literal
110 op => << 5
110 name => _Continue
110 op => | 4
111 literal
111 op => << 5
111 name => _Defer
111 op => | 4
112 literal
112 op => << 5
112 name => _Fallthrough
112 op => | 4
113 literal
113 op => << 5
113 name => _For
113 op => | 4
114 literal
114 op => << 5
114 name => _Func
114 op => | 4
115 literal
115 op => << 5
115 name => _Go
115 op => | 4
116 literal
116 op => << 5
116 name => _Goto
116 op => | 4
117 literal
117 op => << 5
117 name => _If
117 op => | 4
118 literal
118 op => << 5
118 name => _Return
118 op => | 4
119 literal
119 op => << 5
119 name => _Select
119 op => | 4
120 literal
120 op => << 5
120 name => _Switch
120 op => | 4
121 literal
121 op => << 5
121 name => _Type
121 op => | 4
122 literal
122 op => << 5
122 name => _Var
122 ;
128 func
128 (
128 name => p
128 *
128 name => parser
128 )
128 name => advance
128 (
128 name => followlist
128 ...
128 name => token
128 )
128 {
129 if
129 name => len
129 (
129 name => followlist
129 )
129 op => == 3
129 literal
129 {
130 name => p
130 .
130 name => next
130 (
130 )
130 ;
131 return
131 ;
132 }
132 ;
136 var
136 name => followset
136 name => uint64
136 =
136 literal
136 op => << 5
136 name => _EOF
136 ;
137 for
137 name => _
137 ,
137 name => tok
137 :=
137 range
137 name => followlist
137 {
138 name => followset
138 op=
138 literal
138 op => << 5
138 name => tok
138 ;
139 }
139 ;
141 for
141 op => ! 0
141 (
141 name => contains
141 (
141 name => followset
141 ,
141 name => p
141 .
141 name => tok
141 )
141 op => || 1
141 name => p
141 .
141 name => fnest
141 op => > 3
141 literal
141 op => && 2
141 name => contains
141 (
141 name => stopset
141 ,
141 name => p
141 .
141 name => tok
141 )
141 )
141 {
142 name => p
142 .
142 name => next
142 (
142 )
142 ;
143 }
143 ;
144 }
144 ;
146 func
146 name => tokstring
146 (
146 name => tok
146 name => token
146 )
146 name => string
146 {
147 switch
147 name => tok
147 {
148 case
148 name => _EOF
148 :
149 return
149 literal
149 ;
150 case
150 name => _Comma
150 :
151 return
151 literal
151 ;
152 case
152 name => _Semi
152 :
153 return
153 literal
153 ;
154 }
154 ;
155 return
155 name => tok
155 .
155 name => String
155 (
155 )
155 ;
156 }
156 ;
159 func
159 (
159 name => p
159 *
159 name => parser
159 )
159 name => trace
159 (
159 name => msg
159 name => string
159 )
159 func
159 (
159 )
159 {
160 name => fmt
160 .
160 name => Printf
160 (
160 literal
160 ,
160 name => p
160 .
160 name => line
160 ,
160 name => p
160 .
160 name => indent
160 ,
160 name => msg
160 )
160 ;
161 const
161 name => tab
161 =
161 literal
161 ;
162 name => p
162 .
162 name => indent
162 =
162 name => append
162 (
162 name => p
162 .
162 name => indent
162 ,
162 name => tab
162 ...
162 )
162 ;
163 return
163 func
163 (
163 )
163 {
164 name => p
164 .
164 name => indent
164 =
164 name => p
164 .
164 name => indent
164 [
164 :
164 name => len
164 (
164 name => p
164 .
164 name => indent
164 )
164 op => - 4
164 name => len
164 (
164 name => tab
164 )
164 ]
164 ;
165 if
165 name => x
165 :=
165 name => recover
165 (
165 )
165 ;
165 name => x
165 op => != 3
165 name => nil
165 {
166 name => panic
166 (
166 name => x
166 )
166 ;
167 }
167 ;
168 name => fmt
168 .
168 name => Printf
168 (
168 literal
168 ,
168 name => p
168 .
168 name => line
168 ,
168 name => p
168 .
168 name => indent
168 )
168 ;
169 }
169 ;
170 }
170 ;
180 func
180 (
180 name => p
180 *
180 name => parser
180 )
180 name => file
180 (
180 )
180 *
180 name => File
180 {
181 if
181 name => trace
181 {
182 defer
182 name => p
182 .
182 name => trace
182 (
182 literal
182 )
182 (
182 )
182 ;
183 }
183 ;
185 name => f
185 :=
185 name => new
185 (
185 name => File
185 )
185 ;
186 name => f
186 .
186 name => init
186 (
186 name => p
186 )
186 ;
189 if
189 op => ! 0
189 name => p
189 .
189 name => got
189 (
189 name => _Package
189 )
189 {
190 name => p
190 .
190 name => syntax_error
190 (
190 literal
190 )
190 ;
191 return
191 name => nil
191 ;
192 }
192 ;
193 name => f
193 .
193 name => PkgName
193 =
193 name => p
193 .
193 name => name
193 (
193 )
193 ;
194 name => p
194 .
194 name => want
194 (
194 name => _Semi
194 )
194 ;
197 if
197 name => p
197 .
197 name => first
197 op => != 3
197 name => nil
197 {
198 return
198 name => nil
198 ;
199 }
199 ;
202 for
202 name => p
202 .
202 name => got
202 (
202 name => _Import
202 )
202 {
203 name => f
203 .
203 name => DeclList
203 =
203 name => p
203 .
203 name => appendGroup
203 (
203 name => f
203 .
203 name => DeclList
203 ,
203 name => p
203 .
203 name => importDecl
203 )
203 ;
204 name => p
204 .
204 name => want
204 (
204 name => _Semi
204 )
204 ;
205 }
205 ;
208 for
208 name => p
208 .
208 name => tok
208 op => != 3
208 name => _EOF
208 {
209 switch
209 name => p
209 .
209 name => tok
209 {
210 case
210 name => _Const
210 :
211 name => p
211 .
211 name => next
211 (
211 )
211 ;
212 name => f
212 .
212 name => DeclList
212 =
212 name => p
212 .
212 name => appendGroup
212 (
212 name => f
212 .
212 name => DeclList
212 ,
212 name => p
212 .
212 name => constDecl
212 )
212 ;
214 case
214 name => _Type
214 :
215 name => p
215 .
215 name => next
215 (
215 )
215 ;
216 name => f
216 .
216 name => DeclList
216 =
216 name => p
216 .
216 name => appendGroup
216 (
216 name => f
216 .
216 name => DeclList
216 ,
216 name => p
216 .
216 name => typeDecl
216 )
216 ;
218 case
218 name => _Var
218 :
219 name => p
219 .
219 name => next
219 (
219 )
219 ;
220 name => f
220 .
220 name => DeclList
220 =
220 name => p
220 .
220 name => appendGroup
220 (
220 name => f
220 .
220 name => DeclList
220 ,
220 name => p
220 .
220 name => varDecl
220 )
220 ;
222 case
222 name => _Func
222 :
223 name => p
223 .
223 name => next
223 (
223 )
223 ;
224 name => f
224 .
224 name => DeclList
224 =
224 name => append
224 (
224 name => f
224 .
224 name => DeclList
224 ,
224 name => p
224 .
224 name => funcDecl
224 (
224 )
224 )
224 ;
226 default
226 :
227 if
227 name => p
227 .
227 name => tok
227 op => == 3
227 name => _Lbrace
227 op => && 2
227 name => len
227 (
227 name => f
227 .
227 name => DeclList
227 )
227 op => > 3
227 literal
227 op => && 2
227 name => emptyFuncDecl
227 (
227 name => f
227 .
227 name => DeclList
227 [
227 name => len
227 (
227 name => f
227 .
227 name => DeclList
227 )
227 op => - 4
227 literal
227 ]
227 )
227 {
229 name => p
229 .
229 name => syntax_error
229 (
229 literal
229 )
229 ;
230 }
230 else
230 {
231 name => p
231 .
231 name => syntax_error
231 (
231 literal
231 )
231 ;
232 }
232 ;
233 name => p
233 .
233 name => advance
233 (
233 name => _Const
233 ,
233 name => _Type
233 ,
233 name => _Var
233 ,
233 name => _Func
233 )
233 ;
234 continue
234 ;
235 }
235 ;
239 name => p
239 .
239 name => pragma
239 =
239 literal
239 ;
241 if
241 name => p
241 .
241 name => tok
241 op => != 3
241 name => _EOF
241 op => && 2
241 op => ! 0
241 name => p
241 .
241 name => got
241 (
241 name => _Semi
241 )
241 {
242 name => p
242 .
242 name => syntax_error
242 (
242 literal
242 )
242 ;
243 name => p
243 .
243 name => advance
243 (
243 name => _Const
243 ,
243 name => _Type
243 ,
243 name => _Var
243 ,
243 name => _Func
243 )
243 ;
244 }
244 ;
245 }
245 ;
248 name => f
248 .
248 name => Lines
248 =
248 name => p
248 .
248 name => source
248 .
248 name => line
248 ;
250 return
250 name => f
250 ;
251 }
251 ;
253 func
253 name => emptyFuncDecl
253 (
253 name => dcl
253 name => Decl
253 )
253 name => bool
253 {
254 name => f
254 ,
254 name => ok
254 :=
254 name => dcl
254 .
254 (
254 *
254 name => FuncDecl
254 )
254 ;
255 return
255 name => ok
255 op => && 2
255 name => f
255 .
255 name => Body
255 op => == 3
255 name => nil
255 ;
256 }
256 ;
262 func
262 (
262 name => p
262 *
262 name => parser
262 )
262 name => appendGroup
262 (
262 name => list
262 [
262 ]
262 name => Decl
262 ,
262 name => f
262 func
262 (
262 *
262 name => Group
262 )
262 name => Decl
262 )
262 [
262 ]
262 name => Decl
262 {
263 if
263 name => p
263 .
263 name => got
263 (
263 name => _Lparen
263 )
263 {
264 name => g
264 :=
264 name => new
264 (
264 name => Group
264 )
264 ;
265 for
265 name => p
265 .
265 name => tok
265 op => != 3
265 name => _EOF
265 op => && 2
265 name => p
265 .
265 name => tok
265 op => != 3
265 name => _Rparen
265 {
266 name => list
266 =
266 name => append
266 (
266 name => list
266 ,
266 name => f
266 (
266 name => g
266 )
266 )
266 ;
267 if
267 op => ! 0
267 name => p
267 .
267 name => osemi
267 (
267 name => _Rparen
267 )
267 {
268 break
268 ;
269 }
269 ;
270 }
270 ;
271 name => p
271 .
271 name => want
271 (
271 name => _Rparen
271 )
271 ;
272 return
272 name => list
272 ;
273 }
273 ;
275 return
275 name => append
275 (
275 name => list
275 ,
275 name => f
275 (
275 name => nil
275 )
275 )
275 ;
276 }
276 ;
278 func
278 (
278 name => p
278 *
278 name => parser
278 )
278 name => importDecl
278 (
278 name => group
278 *
278 name => Group
278 )
278 name => Decl
278 {
279 if
279 name => trace
279 {
280 defer
280 name => p
280 .
280 name => trace
280 (
280 literal
280 )
280 (
280 )
280 ;
281 }
281 ;
283 name => d
283 :=
283 name => new
283 (
283 name => ImportDecl
283 )
283 ;
284 name => d
284 .
284 name => init
284 (
284 name => p
284 )
284 ;
286 switch
286 name => p
286 .
286 name => tok
286 {
287 case
287 name => _Name
287 :
288 name => d
288 .
288 name => LocalPkgName
288 =
288 name => p
288 .
288 name => name
288 (
288 )
288 ;
289 case
289 name => _Dot
289 :
290 name => n
290 :=
290 name => new
290 (
290 name => Name
290 )
290 ;
291 name => n
291 .
291 name => init
291 (
291 name => p
291 )
291 ;
292 name => n
292 .
292 name => Value
292 =
292 literal
292 ;
293 name => d
293 .
293 name => LocalPkgName
293 =
293 name => n
293 ;
294 name => p
294 .
294 name => next
294 (
294 )
294 ;
295 }
295 ;
296 if
296 name => p
296 .
296 name => tok
296 op => == 3
296 name => _Literal
296 op => && 2
296 (
296 name => gcCompat
296 op => || 1
296 name => p
296 .
296 name => kind
296 op => == 3
296 name => StringLit
296 )
296 {
297 name => d
297 .
297 name => Path
297 =
297 name => p
297 .
297 name => oliteral
297 (
297 )
297 ;
298 }
298 else
298 {
299 name => p
299 .
299 name => syntax_error
299 (
299 literal
299 )
299 ;
300 name => p
300 .
300 name => advance
300 (
300 name => _Semi
300 ,
300 name => _Rparen
300 )
300 ;
301 }
301 ;
302 name => d
302 .
302 name => Group
302 =
302 name => group
302 ;
304 return
304 name => d
304 ;
305 }
305 ;
308 func
308 (
308 name => p
308 *
308 name => parser
308 )
308 name => constDecl
308 (
308 name => group
308 *
308 name => Group
308 )
308 name => Decl
308 {
309 if
309 name => trace
309 {
310 defer
310 name => p
310 .
310 name => trace
310 (
310 literal
310 )
310 (
310 )
310 ;
311 }
311 ;
313 name => d
313 :=
313 name => new
313 (
313 name => ConstDecl
313 )
313 ;
314 name => d
314 .
314 name => init
314 (
314 name => p
314 )
314 ;
316 name => d
316 .
316 name => NameList
316 =
316 name => p
316 .
316 name => nameList
316 (
316 name => p
316 .
316 name => name
316 (
316 )
316 )
316 ;
317 if
317 name => p
317 .
317 name => tok
317 op => != 3
317 name => _EOF
317 op => && 2
317 name => p
317 .
317 name => tok
317 op => != 3
317 name => _Semi
317 op => && 2
317 name => p
317 .
317 name => tok
317 op => != 3
317 name => _Rparen
317 {
318 name => d
318 .
318 name => Type
318 =
318 name => p
318 .
318 name => tryType
318 (
318 )
318 ;
319 if
319 name => p
319 .
319 name => got
319 (
319 name => _Assign
319 )
319 {
320 name => d
320 .
320 name => Values
320 =
320 name => p
320 .
320 name => exprList
320 (
320 )
320 ;
321 }
321 ;
322 }
322 ;
323 name => d
323 .
323 name => Group
323 =
323 name => group
323 ;
325 return
325 name => d
325 ;
326 }
326 ;
329 func
329 (
329 name => p
329 *
329 name => parser
329 )
329 name => typeDecl
329 (
329 name => group
329 *
329 name => Group
329 )
329 name => Decl
329 {
330 if
330 name => trace
330 {
331 defer
331 name => p
331 .
331 name => trace
331 (
331 literal
331 )
331 (
331 )
331 ;
332 }
332 ;
334 name => d
334 :=
334 name => new
334 (
334 name => TypeDecl
334 )
334 ;
335 name => d
335 .
335 name => init
335 (
335 name => p
335 )
335 ;
337 name => d
337 .
337 name => Name
337 =
337 name => p
337 .
337 name => name
337 (
337 )
337 ;
338 name => d
338 .
338 name => Type
338 =
338 name => p
338 .
338 name => tryType
338 (
338 )
338 ;
339 if
339 name => d
339 .
339 name => Type
339 op => == 3
339 name => nil
339 {
340 name => p
340 .
340 name => syntax_error
340 (
340 literal
340 )
340 ;
341 name => p
341 .
341 name => advance
341 (
341 name => _Semi
341 ,
341 name => _Rparen
341 )
341 ;
342 }
342 ;
343 name => d
343 .
343 name => Group
343 =
343 name => group
343 ;
344 name => d
344 .
344 name => Pragma
344 =
344 name => p
344 .
344 name => pragma
344 ;
346 return
346 name => d
346 ;
347 }
347 ;
350 func
350 (
350 name => p
350 *
350 name => parser
350 )
350 name => varDecl
350 (
350 name => group
350 *
350 name => Group
350 )
350 name => Decl
350 {
351 if
351 name => trace
351 {
352 defer
352 name => p
352 .
352 name => trace
352 (
352 literal
352 )
352 (
352 )
352 ;
353 }
353 ;
355 name => d
355 :=
355 name => new
355 (
355 name => VarDecl
355 )
355 ;
356 name => d
356 .
356 name => init
356 (
356 name => p
356 )
356 ;
358 name => d
358 .
358 name => NameList
358 =
358 name => p
358 .
358 name => nameList
358 (
358 name => p
358 .
358 name => name
358 (
358 )
358 )
358 ;
359 if
359 name => p
359 .
359 name => got
359 (
359 name => _Assign
359 )
359 {
360 name => d
360 .
360 name => Values
360 =
360 name => p
360 .
360 name => exprList
360 (
360 )
360 ;
361 }
361 else
361 {
362 name => d
362 .
362 name => Type
362 =
362 name => p
362 .
362 name => type_
362 (
362 )
362 ;
363 if
363 name => p
363 .
363 name => got
363 (
363 name => _Assign
363 )
363 {
364 name => d
364 .
364 name => Values
364 =
364 name => p
364 .
364 name => exprList
364 (
364 )
364 ;
365 }
365 ;
366 }
366 ;
367 name => d
367 .
367 name => Group
367 =
367 name => group
367 ;
368 if
368 name => gcCompat
368 {
369 name => d
369 .
369 name => init
369 (
369 name => p
369 )
369 ;
370 }
370 ;
372 return
372 name => d
372 ;
373 }
373 ;
380 func
380 (
380 name => p
380 *
380 name => parser
380 )
380 name => funcDecl
380 (
380 )
380 *
380 name => FuncDecl
380 {
381 if
381 name => trace
381 {
382 defer
382 name => p
382 .
382 name => trace
382 (
382 literal
382 )
382 (
382 )
382 ;
383 }
383 ;
385 name => f
385 :=
385 name => new
385 (
385 name => FuncDecl
385 )
385 ;
386 name => f
386 .
386 name => init
386 (
386 name => p
386 )
386 ;
388 name => badRecv
388 :=
388 name => false
388 ;
389 if
389 name => p
389 .
389 name => tok
389 op => == 3
389 name => _Lparen
389 {
390 name => rcvr
390 :=
390 name => p
390 .
390 name => paramList
390 (
390 )
390 ;
391 switch
391 name => len
391 (
391 name => rcvr
391 )
391 {
392 case
392 literal
392 :
393 name => p
393 .
393 name => error
393 (
393 literal
393 )
393 ;
394 name => badRecv
394 =
394 name => true
394 ;
395 case
395 literal
395 :
396 name => f
396 .
396 name => Recv
396 =
396 name => rcvr
396 [
396 literal
396 ]
396 ;
397 default
397 :
398 name => p
398 .
398 name => error
398 (
398 literal
398 )
398 ;
399 name => badRecv
399 =
399 name => true
399 ;
400 }
400 ;
401 }
401 ;
403 if
403 name => p
403 .
403 name => tok
403 op => != 3
403 name => _Name
403 {
404 name => p
404 .
404 name => syntax_error
404 (
404 literal
404 )
404 ;
405 name => p
405 .
405 name => advance
405 (
405 name => _Lbrace
405 ,
405 name => _Semi
405 )
405 ;
406 return
406 name => nil
406 ;
407 }
407 ;
423 name => f
423 .
423 name => Name
423 =
423 name => p
423 .
423 name => name
423 (
423 )
423 ;
424 name => f
424 .
424 name => Type
424 =
424 name => p
424 .
424 name => funcType
424 (
424 )
424 ;
425 if
425 name => gcCompat
425 {
426 name => f
426 .
426 name => node
426 =
426 name => f
426 .
426 name => Type
426 .
426 name => node
426 ;
427 }
427 ;
428 name => f
428 .
428 name => Body
428 =
428 name => p
428 .
428 name => funcBody
428 (
428 )
428 ;
430 name => f
430 .
430 name => Pragma
430 =
430 name => p
430 .
430 name => pragma
430 ;
431 name => f
431 .
431 name => EndLine
431 =
431 name => uint32
431 (
431 name => p
431 .
431 name => line
431 )
431 ;
438 if
438 name => badRecv
438 {
439 return
439 name => nil
439 ;
440 }
440 ;
441 return
441 name => f
441 ;
442 }
442 ;
447 func
447 (
447 name => p
447 *
447 name => parser
447 )
447 name => expr
447 (
447 )
447 name => Expr
447 {
448 if
448 name => trace
448 {
449 defer
449 name => p
449 .
449 name => trace
449 (
449 literal
449 )
449 (
449 )
449 ;
450 }
450 ;
452 return
452 name => p
452 .
452 name => binaryExpr
452 (
452 literal
452 )
452 ;
453 }
453 ;
456 func
456 (
456 name => p
456 *
456 name => parser
456 )
456 name => binaryExpr
456 (
456 name => prec
456 name => int
456 )
456 name => Expr
456 {
459 name => x
459 :=
459 name => p
459 .
459 name => unaryExpr
459 (
459 )
459 ;
460 for
460 (
460 name => p
460 .
460 name => tok
460 op => == 3
460 name => _Operator
460 op => || 1
460 name => p
460 .
460 name => tok
460 op => == 3
460 name => _Star
460 )
460 op => && 2
460 name => p
460 .
460 name => prec
460 op => > 3
460 name => prec
460 {
461 name => t
461 :=
461 name => new
461 (
461 name => Operation
461 )
461 ;
462 name => t
462 .
462 name => init
462 (
462 name => p
462 )
462 ;
463 name => t
463 .
463 name => Op
463 =
463 name => p
463 .
463 name => op
463 ;
464 name => t
464 .
464 name => X
464 =
464 name => x
464 ;
465 name => tprec
465 :=
465 name => p
465 .
465 name => prec
465 ;
466 name => p
466 .
466 name => next
466 (
466 )
466 ;
467 name => t
467 .
467 name => Y
467 =
467 name => p
467 .
467 name => binaryExpr
467 (
467 name => tprec
467 )
467 ;
468 if
468 name => gcCompat
468 {
469 name => t
469 .
469 name => init
469 (
469 name => p
469 )
469 ;
470 }
470 ;
471 name => x
471 =
471 name => t
471 ;
472 }
472 ;
473 return
473 name => x
473 ;
474 }
474 ;
477 func
477 (
477 name => p
477 *
477 name => parser
477 )
477 name => unaryExpr
477 (
477 )
477 name => Expr
477 {
478 if
478 name => trace
478 {
479 defer
479 name => p
479 .
479 name => trace
479 (
479 literal
479 )
479 (
479 )
479 ;
480 }
480 ;
482 switch
482 name => p
482 .
482 name => tok
482 {
483 case
483 name => _Operator
483 ,
483 name => _Star
483 :
484 switch
484 name => p
484 .
484 name => op
484 {
485 case
485 name => Mul
485 ,
485 name => Add
485 ,
485 name => Sub
485 ,
485 name => Not
485 ,
485 name => Xor
485 :
486 name => x
486 :=
486 name => new
486 (
486 name => Operation
486 )
486 ;
487 name => x
487 .
487 name => init
487 (
487 name => p
487 )
487 ;
488 name => x
488 .
488 name => Op
488 =
488 name => p
488 .
488 name => op
488 ;
489 name => p
489 .
489 name => next
489 (
489 )
489 ;
490 name => x
490 .
490 name => X
490 =
490 name => p
490 .
490 name => unaryExpr
490 (
490 )
490 ;
491 if
491 name => gcCompat
491 {
492 name => x
492 .
492 name => init
492 (
492 name => p
492 )
492 ;
493 }
493 ;
494 return
494 name => x
494 ;
496 case
496 name => And
496 :
497 name => p
497 .
497 name => next
497 (
497 )
497 ;
498 name => x
498 :=
498 name => new
498 (
498 name => Operation
498 )
498 ;
499 name => x
499 .
499 name => init
499 (
499 name => p
499 )
499 ;
500 name => x
500 .
500 name => Op
500 =
500 name => And
500 ;
503 name => x
503 .
503 name => X
503 =
503 name => unparen
503 (
503 name => p
503 .
503 name => unaryExpr
503 (
503 )
503 )
503 ;
504 return
504 name => x
504 ;
505 }
505 ;
507 case
507 name => _Arrow
507 :
509 name => p
509 .
509 name => next
509 (
509 )
509 ;
515 name => x
515 :=
515 name => p
515 .
515 name => unaryExpr
515 (
515 )
515 ;
528 if
528 name => _
528 ,
528 name => ok
528 :=
528 name => x
528 .
528 (
528 *
528 name => ChanType
528 )
528 ;
528 name => ok
528 {
530 name => dir
530 :=
530 name => SendOnly
530 ;
531 name => t
531 :=
531 name => x
531 ;
532 for
532 name => dir
532 op => == 3
532 name => SendOnly
532 {
533 name => c
533 ,
533 name => ok
533 :=
533 name => t
533 .
533 (
533 *
533 name => ChanType
533 )
533 ;
534 if
534 op => ! 0
534 name => ok
534 {
535 break
535 ;
536 }
536 ;
537 name => dir
537 =
537 name => c
537 .
537 name => Dir
537 ;
538 if
538 name => dir
538 op => == 3
538 name => RecvOnly
538 {
541 name => p
541 .
541 name => syntax_error
541 (
541 literal
541 )
541 ;
543 }
543 ;
544 name => c
544 .
544 name => Dir
544 =
544 name => RecvOnly
544 ;
545 name => t
545 =
545 name => c
545 .
545 name => Elem
545 ;
546 }
546 ;
547 if
547 name => dir
547 op => == 3
547 name => SendOnly
547 {
550 name => p
550 .
550 name => syntax_error
550 (
550 name => fmt
550 .
550 name => Sprintf
550 (
550 literal
550 ,
550 name => String
550 (
550 name => t
550 )
550 )
550 )
550 ;
552 }
552 ;
553 return
553 name => x
553 ;
554 }
554 ;
557 return
557 op => & 5
557 name => Operation
557 {
557 name => Op
557 :
557 name => Recv
557 ,
557 name => X
557 :
557 name => x
557 }
557 ;
558 }
558 ;
563 return
563 name => p
563 .
563 name => pexpr
563 (
563 name => true
563 )
563 ;
564 }
564 ;
567 func
567 (
567 name => p
567 *
567 name => parser
567 )
567 name => callStmt
567 (
567 )
567 *
567 name => CallStmt
567 {
568 if
568 name => trace
568 {
569 defer
569 name => p
569 .
569 name => trace
569 (
569 literal
569 )
569 (
569 )
569 ;
570 }
570 ;
572 name => s
572 :=
572 name => new
572 (
572 name => CallStmt
572 )
572 ;
573 name => s
573 .
573 name => init
573 (
573 name => p
573 )
573 ;
574 name => s
574 .
574 name => Tok
574 =
574 name => p
574 .
574 name => tok
574 ;
575 name => p
575 .
575 name => next
575 (
575 )
575 ;
577 name => x
577 :=
577 name => p
577 .
577 name => pexpr
577 (
577 name => p
577 .
577 name => tok
577 op => == 3
577 name => _Lparen
577 )
577 ;
578 switch
578 name => x
578 :=
578 name => x
578 .
578 (
578 type
578 )
578 {
579 case
579 *
579 name => CallExpr
579 :
580 name => s
580 .
580 name => Call
580 =
580 name => x
580 ;
581 if
581 name => gcCompat
581 {
582 name => s
582 .
582 name => node
582 =
582 name => x
582 .
582 name => node
582 ;
583 }
583 ;
584 case
584 *
584 name => ParenExpr
584 :
585 name => p
585 .
585 name => error
585 (
585 name => fmt
585 .
585 name => Sprintf
585 (
585 literal
585 ,
585 name => s
585 .
585 name => Tok
585 )
585 )
585 ;
587 default
587 :
588 name => p
588 .
588 name => error
588 (
588 name => fmt
588 .
588 name => Sprintf
588 (
588 literal
588 ,
588 name => s
588 .
588 name => Tok
588 )
588 )
588 ;
590 }
590 ;
592 return
592 name => s
592 ;
593 }
593 ;
599 func
599 (
599 name => p
599 *
599 name => parser
599 )
599 name => operand
599 (
599 name => keep_parens
599 name => bool
599 )
599 name => Expr
599 {
600 if
600 name => trace
600 {
601 defer
601 name => p
601 .
601 name => trace
601 (
601 literal
601 op => + 4
601 name => p
601 .
601 name => tok
601 .
601 name => String
601 (
601 )
601 )
601 (
601 )
601 ;
602 }
602 ;
604 switch
604 name => p
604 .
604 name => tok
604 {
605 case
605 name => _Name
605 :
606 return
606 name => p
606 .
606 name => name
606 (
606 )
606 ;
608 case
608 name => _Literal
608 :
609 return
609 name => p
609 .
609 name => oliteral
609 (
609 )
609 ;
611 case
611 name => _Lparen
611 :
612 name => p
612 .
612 name => next
612 (
612 )
612 ;
613 name => p
613 .
613 name => xnest
613 opop
613 ;
614 name => x
614 :=
614 name => p
614 .
614 name => expr
614 (
614 )
614 ;
615 name => p
615 .
615 name => xnest
615 opop
615 ;
616 name => p
616 .
616 name => want
616 (
616 name => _Rparen
616 )
616 ;
632 if
632 name => p
632 .
632 name => tok
632 op => == 3
632 name => _Lbrace
632 {
633 name => keep_parens
633 =
633 name => true
633 ;
634 }
634 ;
639 if
639 name => keep_parens
639 {
640 name => x
640 =
640 op => & 5
640 name => ParenExpr
640 {
640 name => X
640 :
640 name => x
640 }
640 ;
641 }
641 ;
642 return
642 name => x
642 ;
644 case
644 name => _Func
644 :
645 name => p
645 .
645 name => next
645 (
645 )
645 ;
646 name => t
646 :=
646 name => p
646 .
646 name => funcType
646 (
646 )
646 ;
647 if
647 name => p
647 .
647 name => tok
647 op => == 3
647 name => _Lbrace
647 {
648 name => p
648 .
648 name => fnest
648 opop
648 ;
649 name => p
649 .
649 name => xnest
649 opop
649 ;
650 name => f
650 :=
650 name => new
650 (
650 name => FuncLit
650 )
650 ;
651 name => f
651 .
651 name => init
651 (
651 name => p
651 )
651 ;
652 name => f
652 .
652 name => Type
652 =
652 name => t
652 ;
653 name => f
653 .
653 name => Body
653 =
653 name => p
653 .
653 name => funcBody
653 (
653 )
653 ;
654 name => f
654 .
654 name => EndLine
654 =
654 name => uint32
654 (
654 name => p
654 .
654 name => line
654 )
654 ;
655 name => p
655 .
655 name => xnest
655 opop
655 ;
656 name => p
656 .
656 name => fnest
656 opop
656 ;
657 return
657 name => f
657 ;
658 }
658 ;
659 return
659 name => t
659 ;
661 case
661 name => _Lbrack
661 ,
661 name => _Chan
661 ,
661 name => _Map
661 ,
661 name => _Struct
661 ,
661 name => _Interface
661 :
662 return
662 name => p
662 .
662 name => type_
662 (
662 )
662 ;
664 case
664 name => _Lbrace
664 :
666 name => p
666 .
666 name => syntax_error
666 (
666 literal
666 )
666 ;
668 return
668 name => nil
668 ;
670 default
670 :
671 name => p
671 .
671 name => syntax_error
671 (
671 literal
671 )
671 ;
672 name => p
672 .
672 name => advance
672 (
672 )
672 ;
673 return
673 name => nil
673 ;
674 }
674 ;
680 }
680 ;
698 func
698 (
698 name => p
698 *
698 name => parser
698 )
698 name => pexpr
698 (
698 name => keep_parens
698 name => bool
698 )
698 name => Expr
698 {
699 if
699 name => trace
699 {
700 defer
700 name => p
700 .
700 name => trace
700 (
700 literal
700 )
700 (
700 )
700 ;
701 }
701 ;
703 name => x
703 :=
703 name => p
703 .
703 name => operand
703 (
703 name => keep_parens
703 )
703 ;
705 name => loop
705 :
706 for
706 {
707 switch
707 name => p
707 .
707 name => tok
707 {
708 case
708 name => _Dot
708 :
709 name => p
709 .
709 name => next
709 (
709 )
709 ;
710 switch
710 name => p
710 .
710 name => tok
710 {
711 case
711 name => _Name
711 :
713 name => t
713 :=
713 name => new
713 (
713 name => SelectorExpr
713 )
713 ;
714 name => t
714 .
714 name => init
714 (
714 name => p
714 )
714 ;
715 name => t
715 .
715 name => X
715 =
715 name => x
715 ;
716 name => t
716 .
716 name => Sel
716 =
716 name => p
716 .
716 name => name
716 (
716 )
716 ;
717 name => x
717 =
717 name => t
717 ;
719 case
719 name => _Lparen
719 :
720 name => p
720 .
720 name => next
720 (
720 )
720 ;
721 if
721 name => p
721 .
721 name => got
721 (
721 name => _Type
721 )
721 {
722 name => t
722 :=
722 name => new
722 (
722 name => TypeSwitchGuard
722 )
722 ;
723 name => t
723 .
723 name => init
723 (
723 name => p
723 )
723 ;
724 name => t
724 .
724 name => X
724 =
724 name => x
724 ;
725 name => x
725 =
725 name => t
725 ;
726 }
726 else
726 {
727 name => t
727 :=
727 name => new
727 (
727 name => AssertExpr
727 )
727 ;
728 name => t
728 .
728 name => init
728 (
728 name => p
728 )
728 ;
729 name => t
729 .
729 name => X
729 =
729 name => x
729 ;
730 name => t
730 .
730 name => Type
730 =
730 name => p
730 .
730 name => expr
730 (
730 )
730 ;
731 name => x
731 =
731 name => t
731 ;
732 }
732 ;
733 name => p
733 .
733 name => want
733 (
733 name => _Rparen
733 )
733 ;
735 default
735 :
736 name => p
736 .
736 name => syntax_error
736 (
736 literal
736 )
736 ;
737 name => p
737 .
737 name => advance
737 (
737 name => _Semi
737 ,
737 name => _Rparen
737 )
737 ;
738 }
738 ;
739 if
739 name => gcCompat
739 {
740 name => x
740 .
740 name => init
740 (
740 name => p
740 )
740 ;
741 }
741 ;
743 case
743 name => _Lbrack
743 :
744 name => p
744 .
744 name => next
744 (
744 )
744 ;
745 name => p
745 .
745 name => xnest
745 opop
745 ;
747 var
747 name => i
747 name => Expr
747 ;
748 if
748 name => p
748 .
748 name => tok
748 op => != 3
748 name => _Colon
748 {
749 name => i
749 =
749 name => p
749 .
749 name => expr
749 (
749 )
749 ;
750 if
750 name => p
750 .
750 name => got
750 (
750 name => _Rbrack
750 )
750 {
752 name => t
752 :=
752 name => new
752 (
752 name => IndexExpr
752 )
752 ;
753 name => t
753 .
753 name => init
753 (
753 name => p
753 )
753 ;
754 name => t
754 .
754 name => X
754 =
754 name => x
754 ;
755 name => t
755 .
755 name => Index
755 =
755 name => i
755 ;
756 name => x
756 =
756 name => t
756 ;
757 name => p
757 .
757 name => xnest
757 opop
757 ;
758 break
758 ;
759 }
759 ;
760 }
760 ;
763 name => t
763 :=
763 name => new
763 (
763 name => SliceExpr
763 )
763 ;
764 name => t
764 .
764 name => init
764 (
764 name => p
764 )
764 ;
765 name => t
765 .
765 name => X
765 =
765 name => x
765 ;
766 name => t
766 .
766 name => Index
766 [
766 literal
766 ]
766 =
766 name => i
766 ;
767 name => p
767 .
767 name => want
767 (
767 name => _Colon
767 )
767 ;
768 if
768 name => p
768 .
768 name => tok
768 op => != 3
768 name => _Colon
768 op => && 2
768 name => p
768 .
768 name => tok
768 op => != 3
768 name => _Rbrack
768 {
770 name => t
770 .
770 name => Index
770 [
770 literal
770 ]
770 =
770 name => p
770 .
770 name => expr
770 (
770 )
770 ;
771 }
771 ;
772 if
772 name => p
772 .
772 name => got
772 (
772 name => _Colon
772 )
772 {
773 name => t
773 .
773 name => Full
773 =
773 name => true
773 ;
775 if
775 name => t
775 .
775 name => Index
775 [
775 literal
775 ]
775 op => == 3
775 name => nil
775 {
776 name => p
776 .
776 name => error
776 (
776 literal
776 )
776 ;
777 }
777 ;
778 if
778 name => p
778 .
778 name => tok
778 op => != 3
778 name => _Rbrack
778 {
780 name => t
780 .
780 name => Index
780 [
780 literal
780 ]
780 =
780 name => p
780 .
780 name => expr
780 (
780 )
780 ;
781 }
781 else
781 {
782 name => p
782 .
782 name => error
782 (
782 literal
782 )
782 ;
783 }
783 ;
784 }
784 ;
785 name => p
785 .
785 name => want
785 (
785 name => _Rbrack
785 )
785 ;
787 name => x
787 =
787 name => t
787 ;
788 name => p
788 .
788 name => xnest
788 opop
788 ;
790 case
790 name => _Lparen
790 :
791 name => x
791 =
791 name => p
791 .
791 name => call
791 (
791 name => x
791 )
791 ;
793 case
793 name => _Lbrace
793 :
796 name => t
796 :=
796 name => unparen
796 (
796 name => x
796 )
796 ;
798 name => complit_ok
798 :=
798 name => false
798 ;
799 switch
799 name => t
799 .
799 (
799 type
799 )
799 {
800 case
800 *
800 name => Name
800 ,
800 *
800 name => SelectorExpr
800 :
801 if
801 name => p
801 .
801 name => xnest
801 op => >= 3
801 literal
801 {
803 name => complit_ok
803 =
803 name => true
803 ;
804 }
804 ;
805 case
805 *
805 name => ArrayType
805 ,
805 *
805 name => SliceType
805 ,
805 *
805 name => StructType
805 ,
805 *
805 name => MapType
805 :
807 name => complit_ok
807 =
807 name => true
807 ;
808 }
808 ;
809 if
809 op => ! 0
809 name => complit_ok
809 {
810 break
810 name => loop
810 ;
811 }
811 ;
812 if
812 name => t
812 op => != 3
812 name => x
812 {
813 name => p
813 .
813 name => syntax_error
813 (
813 literal
813 )
813 ;
815 }
815 ;
816 name => n
816 :=
816 name => p
816 .
816 name => complitexpr
816 (
816 )
816 ;
817 name => n
817 .
817 name => Type
817 =
817 name => x
817 ;
818 name => x
818 =
818 name => n
818 ;
820 default
820 :
821 break
821 name => loop
821 ;
822 }
822 ;
823 }
823 ;
825 return
825 name => x
825 ;
826 }
826 ;
829 func
829 (
829 name => p
829 *
829 name => parser
829 )
829 name => bare_complitexpr
829 (
829 )
829 name => Expr
829 {
830 if
830 name => trace
830 {
831 defer
831 name => p
831 .
831 name => trace
831 (
831 literal
831 )
831 (
831 )
831 ;
832 }
832 ;
834 if
834 name => p
834 .
834 name => tok
834 op => == 3
834 name => _Lbrace
834 {
836 return
836 name => p
836 .
836 name => complitexpr
836 (
836 )
836 ;
837 }
837 ;
839 return
839 name => p
839 .
839 name => expr
839 (
839 )
839 ;
840 }
840 ;
843 func
843 (
843 name => p
843 *
843 name => parser
843 )
843 name => complitexpr
843 (
843 )
843 *
843 name => CompositeLit
843 {
844 if
844 name => trace
844 {
845 defer
845 name => p
845 .
845 name => trace
845 (
845 literal
845 )
845 (
845 )
845 ;
846 }
846 ;
848 name => x
848 :=
848 name => new
848 (
848 name => CompositeLit
848 )
848 ;
849 name => x
849 .
849 name => init
849 (
849 name => p
849 )
849 ;
851 name => p
851 .
851 name => want
851 (
851 name => _Lbrace
851 )
851 ;
852 name => p
852 .
852 name => xnest
852 opop
852 ;
854 for
854 name => p
854 .
854 name => tok
854 op => != 3
854 name => _EOF
854 op => && 2
854 name => p
854 .
854 name => tok
854 op => != 3
854 name => _Rbrace
854 {
856 name => e
856 :=
856 name => p
856 .
856 name => bare_complitexpr
856 (
856 )
856 ;
857 if
857 name => p
857 .
857 name => got
857 (
857 name => _Colon
857 )
857 {
859 name => l
859 :=
859 name => new
859 (
859 name => KeyValueExpr
859 )
859 ;
860 name => l
860 .
860 name => init
860 (
860 name => p
860 )
860 ;
861 name => l
861 .
861 name => Key
861 =
861 name => e
861 ;
862 name => l
862 .
862 name => Value
862 =
862 name => p
862 .
862 name => bare_complitexpr
862 (
862 )
862 ;
863 if
863 name => gcCompat
863 {
864 name => l
864 .
864 name => init
864 (
864 name => p
864 )
864 ;
865 }
865 ;
866 name => e
866 =
866 name => l
866 ;
867 name => x
867 .
867 name => NKeys
867 opop
867 ;
868 }
868 ;
869 name => x
869 .
869 name => ElemList
869 =
869 name => append
869 (
869 name => x
869 .
869 name => ElemList
869 ,
869 name => e
869 )
869 ;
870 if
870 op => ! 0
870 name => p
870 .
870 name => ocomma
870 (
870 name => _Rbrace
870 )
870 {
871 break
871 ;
872 }
872 ;
873 }
873 ;
875 name => x
875 .
875 name => EndLine
875 =
875 name => uint32
875 (
875 name => p
875 .
875 name => line
875 )
875 ;
876 name => p
876 .
876 name => xnest
876 opop
876 ;
877 name => p
877 .
877 name => want
877 (
877 name => _Rbrace
877 )
877 ;
879 return
879 name => x
879 ;
880 }
880 ;
885 func
885 (
885 name => p
885 *
885 name => parser
885 )
885 name => type_
885 (
885 )
885 name => Expr
885 {
886 if
886 name => trace
886 {
887 defer
887 name => p
887 .
887 name => trace
887 (
887 literal
887 )
887 (
887 )
887 ;
888 }
888 ;
890 if
890 name => typ
890 :=
890 name => p
890 .
890 name => tryType
890 (
890 )
890 ;
890 name => typ
890 op => != 3
890 name => nil
890 {
891 return
891 name => typ
891 ;
892 }
892 ;
894 name => p
894 .
894 name => syntax_error
894 (
894 literal
894 )
894 ;
895 name => p
895 .
895 name => advance
895 (
895 )
895 ;
896 return
896 name => nil
896 ;
897 }
897 ;
899 func
899 name => indirect
899 (
899 name => typ
899 name => Expr
899 )
899 name => Expr
899 {
900 return
900 op => & 5
900 name => Operation
900 {
900 name => Op
900 :
900 name => Mul
900 ,
900 name => X
900 :
900 name => typ
900 }
900 ;
901 }
901 ;
910 func
910 (
910 name => p
910 *
910 name => parser
910 )
910 name => tryType
910 (
910 )
910 name => Expr
910 {
911 if
911 name => trace
911 {
912 defer
912 name => p
912 .
912 name => trace
912 (
912 literal
912 )
912 (
912 )
912 ;
913 }
913 ;
915 switch
915 name => p
915 .
915 name => tok
915 {
916 case
916 name => _Star
916 :
918 name => p
918 .
918 name => next
918 (
918 )
918 ;
919 return
919 name => indirect
919 (
919 name => p
919 .
919 name => type_
919 (
919 )
919 )
919 ;
921 case
921 name => _Arrow
921 :
923 name => p
923 .
923 name => next
923 (
923 )
923 ;
924 name => p
924 .
924 name => want
924 (
924 name => _Chan
924 )
924 ;
925 name => t
925 :=
925 name => new
925 (
925 name => ChanType
925 )
925 ;
926 name => t
926 .
926 name => init
926 (
926 name => p
926 )
926 ;
927 name => t
927 .
927 name => Dir
927 =
927 name => RecvOnly
927 ;
928 name => t
928 .
928 name => Elem
928 =
928 name => p
928 .
928 name => chanElem
928 (
928 )
928 ;
929 return
929 name => t
929 ;
931 case
931 name => _Func
931 :
933 name => p
933 .
933 name => next
933 (
933 )
933 ;
934 return
934 name => p
934 .
934 name => funcType
934 (
934 )
934 ;
936 case
936 name => _Lbrack
936 :
939 name => p
939 .
939 name => next
939 (
939 )
939 ;
940 name => p
940 .
940 name => xnest
940 opop
940 ;
941 if
941 name => p
941 .
941 name => got
941 (
941 name => _Rbrack
941 )
941 {
943 name => p
943 .
943 name => xnest
943 opop
943 ;
944 name => t
944 :=
944 name => new
944 (
944 name => SliceType
944 )
944 ;
945 name => t
945 .
945 name => init
945 (
945 name => p
945 )
945 ;
946 name => t
946 .
946 name => Elem
946 =
946 name => p
946 .
946 name => type_
946 (
946 )
946 ;
947 return
947 name => t
947 ;
948 }
948 ;
951 name => t
951 :=
951 name => new
951 (
951 name => ArrayType
951 )
951 ;
952 name => t
952 .
952 name => init
952 (
952 name => p
952 )
952 ;
953 if
953 op => ! 0
953 name => p
953 .
953 name => got
953 (
953 name => _DotDotDot
953 )
953 {
954 name => t
954 .
954 name => Len
954 =
954 name => p
954 .
954 name => expr
954 (
954 )
954 ;
955 }
955 ;
956 name => p
956 .
956 name => want
956 (
956 name => _Rbrack
956 )
956 ;
957 name => p
957 .
957 name => xnest
957 opop
957 ;
958 name => t
958 .
958 name => Elem
958 =
958 name => p
958 .
958 name => type_
958 (
958 )
958 ;
959 return
959 name => t
959 ;
961 case
961 name => _Chan
961 :
964 name => p
964 .
964 name => next
964 (
964 )
964 ;
965 name => t
965 :=
965 name => new
965 (
965 name => ChanType
965 )
965 ;
966 name => t
966 .
966 name => init
966 (
966 name => p
966 )
966 ;
967 if
967 name => p
967 .
967 name => got
967 (
967 name => _Arrow
967 )
967 {
968 name => t
968 .
968 name => Dir
968 =
968 name => SendOnly
968 ;
969 }
969 ;
970 name => t
970 .
970 name => Elem
970 =
970 name => p
970 .
970 name => chanElem
970 (
970 )
970 ;
971 return
971 name => t
971 ;
973 case
973 name => _Map
973 :
975 name => p
975 .
975 name => next
975 (
975 )
975 ;
976 name => p
976 .
976 name => want
976 (
976 name => _Lbrack
976 )
976 ;
977 name => t
977 :=
977 name => new
977 (
977 name => MapType
977 )
977 ;
978 name => t
978 .
978 name => init
978 (
978 name => p
978 )
978 ;
979 name => t
979 .
979 name => Key
979 =
979 name => p
979 .
979 name => type_
979 (
979 )
979 ;
980 name => p
980 .
980 name => want
980 (
980 name => _Rbrack
980 )
980 ;
981 name => t
981 .
981 name => Value
981 =
981 name => p
981 .
981 name => type_
981 (
981 )
981 ;
982 return
982 name => t
982 ;
984 case
984 name => _Struct
984 :
985 return
985 name => p
985 .
985 name => structType
985 (
985 )
985 ;
987 case
987 name => _Interface
987 :
988 return
988 name => p
988 .
988 name => interfaceType
988 (
988 )
988 ;
990 case
990 name => _Name
990 :
991 return
991 name => p
991 .
991 name => dotname
991 (
991 name => p
991 .
991 name => name
991 (
991 )
991 )
991 ;
993 case
993 name => _Lparen
993 :
994 name => p
994 .
994 name => next
994 (
994 )
994 ;
995 name => t
995 :=
995 name => p
995 .
995 name => type_
995 (
995 )
995 ;
996 name => p
996 .
996 name => want
996 (
996 name => _Rparen
996 )
996 ;
997 return
997 name => t
997 ;
998 }
998 ;
1000 return
1000 name => nil
1000 ;
1001 }
1001 ;
1003 func
1003 (
1003 name => p
1003 *
1003 name => parser
1003 )
1003 name => funcType
1003 (
1003 )
1003 *
1003 name => FuncType
1003 {
1004 if
1004 name => trace
1004 {
1005 defer
1005 name => p
1005 .
1005 name => trace
1005 (
1005 literal
1005 )
1005 (
1005 )
1005 ;
1006 }
1006 ;
1008 name => typ
1008 :=
1008 name => new
1008 (
1008 name => FuncType
1008 )
1008 ;
1009 name => typ
1009 .
1009 name => init
1009 (
1009 name => p
1009 )
1009 ;
1010 name => typ
1010 .
1010 name => ParamList
1010 =
1010 name => p
1010 .
1010 name => paramList
1010 (
1010 )
1010 ;
1011 name => typ
1011 .
1011 name => ResultList
1011 =
1011 name => p
1011 .
1011 name => funcResult
1011 (
1011 )
1011 ;
1012 if
1012 name => gcCompat
1012 {
1013 name => typ
1013 .
1013 name => init
1013 (
1013 name => p
1013 )
1013 ;
1014 }
1014 ;
1015 return
1015 name => typ
1015 ;
1016 }
1016 ;
1018 func
1018 (
1018 name => p
1018 *
1018 name => parser
1018 )
1018 name => chanElem
1018 (
1018 )
1018 name => Expr
1018 {
1019 if
1019 name => trace
1019 {
1020 defer
1020 name => p
1020 .
1020 name => trace
1020 (
1020 literal
1020 )
1020 (
1020 )
1020 ;
1021 }
1021 ;
1023 if
1023 name => typ
1023 :=
1023 name => p
1023 .
1023 name => tryType
1023 (
1023 )
1023 ;
1023 name => typ
1023 op => != 3
1023 name => nil
1023 {
1024 return
1024 name => typ
1024 ;
1025 }
1025 ;
1027 name => p
1027 .
1027 name => syntax_error
1027 (
1027 literal
1027 )
1027 ;
1029 return
1029 name => nil
1029 ;
1030 }
1030 ;
1032 func
1032 (
1032 name => p
1032 *
1032 name => parser
1032 )
1032 name => dotname
1032 (
1032 name => name
1032 *
1032 name => Name
1032 )
1032 name => Expr
1032 {
1033 if
1033 name => trace
1033 {
1034 defer
1034 name => p
1034 .
1034 name => trace
1034 (
1034 literal
1034 )
1034 (
1034 )
1034 ;
1035 }
1035 ;
1037 if
1037 name => p
1037 .
1037 name => got
1037 (
1037 name => _Dot
1037 )
1037 {
1038 name => s
1038 :=
1038 name => new
1038 (
1038 name => SelectorExpr
1038 )
1038 ;
1039 name => s
1039 .
1039 name => init
1039 (
1039 name => p
1039 )
1039 ;
1040 name => s
1040 .
1040 name => X
1040 =
1040 name => name
1040 ;
1041 name => s
1041 .
1041 name => Sel
1041 =
1041 name => p
1041 .
1041 name => name
1041 (
1041 )
1041 ;
1042 return
1042 name => s
1042 ;
1043 }
1043 ;
1044 return
1044 name => name
1044 ;
1045 }
1045 ;
1048 func
1048 (
1048 name => p
1048 *
1048 name => parser
1048 )
1048 name => structType
1048 (
1048 )
1048 *
1048 name => StructType
1048 {
1049 if
1049 name => trace
1049 {
1050 defer
1050 name => p
1050 .
1050 name => trace
1050 (
1050 literal
1050 )
1050 (
1050 )
1050 ;
1051 }
1051 ;
1053 name => typ
1053 :=
1053 name => new
1053 (
1053 name => StructType
1053 )
1053 ;
1054 name => typ
1054 .
1054 name => init
1054 (
1054 name => p
1054 )
1054 ;
1056 name => p
1056 .
1056 name => want
1056 (
1056 name => _Struct
1056 )
1056 ;
1057 name => p
1057 .
1057 name => want
1057 (
1057 name => _Lbrace
1057 )
1057 ;
1058 for
1058 name => p
1058 .
1058 name => tok
1058 op => != 3
1058 name => _EOF
1058 op => && 2
1058 name => p
1058 .
1058 name => tok
1058 op => != 3
1058 name => _Rbrace
1058 {
1059 name => p
1059 .
1059 name => fieldDecl
1059 (
1059 name => typ
1059 )
1059 ;
1060 if
1060 op => ! 0
1060 name => p
1060 .
1060 name => osemi
1060 (
1060 name => _Rbrace
1060 )
1060 {
1061 break
1061 ;
1062 }
1062 ;
1063 }
1063 ;
1064 if
1064 name => gcCompat
1064 {
1065 name => typ
1065 .
1065 name => init
1065 (
1065 name => p
1065 )
1065 ;
1066 }
1066 ;
1067 name => p
1067 .
1067 name => want
1067 (
1067 name => _Rbrace
1067 )
1067 ;
1069 return
1069 name => typ
1069 ;
1070 }
1070 ;
1073 func
1073 (
1073 name => p
1073 *
1073 name => parser
1073 )
1073 name => interfaceType
1073 (
1073 )
1073 *
1073 name => InterfaceType
1073 {
1074 if
1074 name => trace
1074 {
1075 defer
1075 name => p
1075 .
1075 name => trace
1075 (
1075 literal
1075 )
1075 (
1075 )
1075 ;
1076 }
1076 ;
1078 name => typ
1078 :=
1078 name => new
1078 (
1078 name => InterfaceType
1078 )
1078 ;
1079 name => typ
1079 .
1079 name => init
1079 (
1079 name => p
1079 )
1079 ;
1081 name => p
1081 .
1081 name => want
1081 (
1081 name => _Interface
1081 )
1081 ;
1082 name => p
1082 .
1082 name => want
1082 (
1082 name => _Lbrace
1082 )
1082 ;
1083 for
1083 name => p
1083 .
1083 name => tok
1083 op => != 3
1083 name => _EOF
1083 op => && 2
1083 name => p
1083 .
1083 name => tok
1083 op => != 3
1083 name => _Rbrace
1083 {
1084 if
1084 name => m
1084 :=
1084 name => p
1084 .
1084 name => methodDecl
1084 (
1084 )
1084 ;
1084 name => m
1084 op => != 3
1084 name => nil
1084 {
1085 name => typ
1085 .
1085 name => MethodList
1085 =
1085 name => append
1085 (
1085 name => typ
1085 .
1085 name => MethodList
1085 ,
1085 name => m
1085 )
1085 ;
1086 }
1086 ;
1087 if
1087 op => ! 0
1087 name => p
1087 .
1087 name => osemi
1087 (
1087 name => _Rbrace
1087 )
1087 {
1088 break
1088 ;
1089 }
1089 ;
1090 }
1090 ;
1091 if
1091 name => gcCompat
1091 {
1092 name => typ
1092 .
1092 name => init
1092 (
1092 name => p
1092 )
1092 ;
1093 }
1093 ;
1094 name => p
1094 .
1094 name => want
1094 (
1094 name => _Rbrace
1094 )
1094 ;
1096 return
1096 name => typ
1096 ;
1097 }
1097 ;
1100 func
1100 (
1100 name => p
1100 *
1100 name => parser
1100 )
1100 name => funcBody
1100 (
1100 )
1100 [
1100 ]
1100 name => Stmt
1100 {
1101 if
1101 name => trace
1101 {
1102 defer
1102 name => p
1102 .
1102 name => trace
1102 (
1102 literal
1102 )
1102 (
1102 )
1102 ;
1103 }
1103 ;
1105 if
1105 name => p
1105 .
1105 name => got
1105 (
1105 name => _Lbrace
1105 )
1105 {
1106 name => p
1106 .
1106 name => fnest
1106 opop
1106 ;
1107 name => body
1107 :=
1107 name => p
1107 .
1107 name => stmtList
1107 (
1107 )
1107 ;
1108 name => p
1108 .
1108 name => fnest
1108 opop
1108 ;
1109 name => p
1109 .
1109 name => want
1109 (
1109 name => _Rbrace
1109 )
1109 ;
1110 if
1110 name => body
1110 op => == 3
1110 name => nil
1110 {
1111 name => body
1111 =
1111 [
1111 ]
1111 name => Stmt
1111 {
1111 name => new
1111 (
1111 name => EmptyStmt
1111 )
1111 }
1111 ;
1112 }
1112 ;
1113 return
1113 name => body
1113 ;
1114 }
1114 ;
1116 return
1116 name => nil
1116 ;
1117 }
1117 ;
1120 func
1120 (
1120 name => p
1120 *
1120 name => parser
1120 )
1120 name => funcResult
1120 (
1120 )
1120 [
1120 ]
1120 *
1120 name => Field
1120 {
1121 if
1121 name => trace
1121 {
1122 defer
1122 name => p
1122 .
1122 name => trace
1122 (
1122 literal
1122 )
1122 (
1122 )
1122 ;
1123 }
1123 ;
1125 if
1125 name => p
1125 .
1125 name => tok
1125 op => == 3
1125 name => _Lparen
1125 {
1126 return
1126 name => p
1126 .
1126 name => paramList
1126 (
1126 )
1126 ;
1127 }
1127 ;
1129 if
1129 name => result
1129 :=
1129 name => p
1129 .
1129 name => tryType
1129 (
1129 )
1129 ;
1129 name => result
1129 op => != 3
1129 name => nil
1129 {
1130 name => f
1130 :=
1130 name => new
1130 (
1130 name => Field
1130 )
1130 ;
1131 name => f
1131 .
1131 name => init
1131 (
1131 name => p
1131 )
1131 ;
1132 name => f
1132 .
1132 name => Type
1132 =
1132 name => result
1132 ;
1133 return
1133 [
1133 ]
1133 *
1133 name => Field
1133 {
1133 name => f
1133 }
1133 ;
1134 }
1134 ;
1136 return
1136 name => nil
1136 ;
1137 }
1137 ;
1139 func
1139 (
1139 name => p
1139 *
1139 name => parser
1139 )
1139 name => addField
1139 (
1139 name => styp
1139 *
1139 name => StructType
1139 ,
1139 name => name
1139 *
1139 name => Name
1139 ,
1139 name => typ
1139 name => Expr
1139 ,
1139 name => tag
1139 *
1139 name => BasicLit
1139 )
1139 {
1140 if
1140 name => tag
1140 op => != 3
1140 name => nil
1140 {
1141 for
1141 name => i
1141 :=
1141 name => len
1141 (
1141 name => styp
1141 .
1141 name => FieldList
1141 )
1141 op => - 4
1141 name => len
1141 (
1141 name => styp
1141 .
1141 name => TagList
1141 )
1141 ;
1141 name => i
1141 op => > 3
1141 literal
1141 ;
1141 name => i
1141 opop
1141 {
1142 name => styp
1142 .
1142 name => TagList
1142 =
1142 name => append
1142 (
1142 name => styp
1142 .
1142 name => TagList
1142 ,
1142 name => nil
1142 )
1142 ;
1143 }
1143 ;
1144 name => styp
1144 .
1144 name => TagList
1144 =
1144 name => append
1144 (
1144 name => styp
1144 .
1144 name => TagList
1144 ,
1144 name => tag
1144 )
1144 ;
1145 }
1145 ;
1147 name => f
1147 :=
1147 name => new
1147 (
1147 name => Field
1147 )
1147 ;
1148 name => f
1148 .
1148 name => init
1148 (
1148 name => p
1148 )
1148 ;
1149 name => f
1149 .
1149 name => Name
1149 =
1149 name => name
1149 ;
1150 name => f
1150 .
1150 name => Type
1150 =
1150 name => typ
1150 ;
1151 name => styp
1151 .
1151 name => FieldList
1151 =
1151 name => append
1151 (
1151 name => styp
1151 .
1151 name => FieldList
1151 ,
1151 name => f
1151 )
1151 ;
1153 if
1153 name => gcCompat
1153 op => && 2
1153 name => name
1153 op => != 3
1153 name => nil
1153 {
1154 name => f
1154 .
1154 name => node
1154 =
1154 name => name
1154 .
1154 name => node
1154 ;
1155 }
1155 ;
1157 if
1157 name => debug
1157 op => && 2
1157 name => tag
1157 op => != 3
1157 name => nil
1157 op => && 2
1157 name => len
1157 (
1157 name => styp
1157 .
1157 name => FieldList
1157 )
1157 op => != 3
1157 name => len
1157 (
1157 name => styp
1157 .
1157 name => TagList
1157 )
1157 {
1158 name => panic
1158 (
1158 literal
1158 )
1158 ;
1159 }
1159 ;
1160 }
1160 ;
1165 func
1165 (
1165 name => p
1165 *
1165 name => parser
1165 )
1165 name => fieldDecl
1165 (
1165 name => styp
1165 *
1165 name => StructType
1165 )
1165 {
1166 if
1166 name => trace
1166 {
1167 defer
1167 name => p
1167 .
1167 name => trace
1167 (
1167 literal
1167 )
1167 (
1167 )
1167 ;
1168 }
1168 ;
1170 var
1170 name => name
1170 *
1170 name => Name
1170 ;
1171 switch
1171 name => p
1171 .
1171 name => tok
1171 {
1172 case
1172 name => _Name
1172 :
1173 name => name
1173 =
1173 name => p
1173 .
1173 name => name
1173 (
1173 )
1173 ;
1174 if
1174 name => p
1174 .
1174 name => tok
1174 op => == 3
1174 name => _Dot
1174 op => || 1
1174 name => p
1174 .
1174 name => tok
1174 op => == 3
1174 name => _Literal
1174 op => || 1
1174 name => p
1174 .
1174 name => tok
1174 op => == 3
1174 name => _Semi
1174 op => || 1
1174 name => p
1174 .
1174 name => tok
1174 op => == 3
1174 name => _Rbrace
1174 {
1176 name => typ
1176 :=
1176 name => p
1176 .
1176 name => qualifiedName
1176 (
1176 name => name
1176 )
1176 ;
1177 name => tag
1177 :=
1177 name => p
1177 .
1177 name => oliteral
1177 (
1177 )
1177 ;
1178 name => p
1178 .
1178 name => addField
1178 (
1178 name => styp
1178 ,
1178 name => nil
1178 ,
1178 name => typ
1178 ,
1178 name => tag
1178 )
1178 ;
1179 return
1179 ;
1180 }
1180 ;
1183 name => names
1183 :=
1183 name => p
1183 .
1183 name => nameList
1183 (
1183 name => name
1183 )
1183 ;
1184 name => typ
1184 :=
1184 name => p
1184 .
1184 name => type_
1184 (
1184 )
1184 ;
1185 name => tag
1185 :=
1185 name => p
1185 .
1185 name => oliteral
1185 (
1185 )
1185 ;
1187 for
1187 name => _
1187 ,
1187 name => name
1187 :=
1187 range
1187 name => names
1187 {
1188 name => p
1188 .
1188 name => addField
1188 (
1188 name => styp
1188 ,
1188 name => name
1188 ,
1188 name => typ
1188 ,
1188 name => tag
1188 )
1188 ;
1189 }
1189 ;
1191 case
1191 name => _Lparen
1191 :
1192 name => p
1192 .
1192 name => next
1192 (
1192 )
1192 ;
1193 if
1193 name => p
1193 .
1193 name => tok
1193 op => == 3
1193 name => _Star
1193 {
1195 name => p
1195 .
1195 name => next
1195 (
1195 )
1195 ;
1196 name => typ
1196 :=
1196 name => indirect
1196 (
1196 name => p
1196 .
1196 name => qualifiedName
1196 (
1196 name => nil
1196 )
1196 )
1196 ;
1197 name => p
1197 .
1197 name => want
1197 (
1197 name => _Rparen
1197 )
1197 ;
1198 name => tag
1198 :=
1198 name => p
1198 .
1198 name => oliteral
1198 (
1198 )
1198 ;
1199 name => p
1199 .
1199 name => addField
1199 (
1199 name => styp
1199 ,
1199 name => nil
1199 ,
1199 name => typ
1199 ,
1199 name => tag
1199 )
1199 ;
1200 name => p
1200 .
1200 name => error
1200 (
1200 literal
1200 )
1200 ;
1202 }
1202 else
1202 {
1204 name => typ
1204 :=
1204 name => p
1204 .
1204 name => qualifiedName
1204 (
1204 name => nil
1204 )
1204 ;
1205 name => p
1205 .
1205 name => want
1205 (
1205 name => _Rparen
1205 )
1205 ;
1206 name => tag
1206 :=
1206 name => p
1206 .
1206 name => oliteral
1206 (
1206 )
1206 ;
1207 name => p
1207 .
1207 name => addField
1207 (
1207 name => styp
1207 ,
1207 name => nil
1207 ,
1207 name => typ
1207 ,
1207 name => tag
1207 )
1207 ;
1208 name => p
1208 .
1208 name => error
1208 (
1208 literal
1208 )
1208 ;
1209 }
1209 ;
1211 case
1211 name => _Star
1211 :
1212 name => p
1212 .
1212 name => next
1212 (
1212 )
1212 ;
1213 if
1213 name => p
1213 .
1213 name => got
1213 (
1213 name => _Lparen
1213 )
1213 {
1215 name => typ
1215 :=
1215 name => indirect
1215 (
1215 name => p
1215 .
1215 name => qualifiedName
1215 (
1215 name => nil
1215 )
1215 )
1215 ;
1216 name => p
1216 .
1216 name => want
1216 (
1216 name => _Rparen
1216 )
1216 ;
1217 name => tag
1217 :=
1217 name => p
1217 .
1217 name => oliteral
1217 (
1217 )
1217 ;
1218 name => p
1218 .
1218 name => addField
1218 (
1218 name => styp
1218 ,
1218 name => nil
1218 ,
1218 name => typ
1218 ,
1218 name => tag
1218 )
1218 ;
1219 name => p
1219 .
1219 name => error
1219 (
1219 literal
1219 )
1219 ;
1221 }
1221 else
1221 {
1223 name => typ
1223 :=
1223 name => indirect
1223 (
1223 name => p
1223 .
1223 name => qualifiedName
1223 (
1223 name => nil
1223 )
1223 )
1223 ;
1224 name => tag
1224 :=
1224 name => p
1224 .
1224 name => oliteral
1224 (
1224 )
1224 ;
1225 name => p
1225 .
1225 name => addField
1225 (
1225 name => styp
1225 ,
1225 name => nil
1225 ,
1225 name => typ
1225 ,
1225 name => tag
1225 )
1225 ;
1226 }
1226 ;
1228 default
1228 :
1229 name => p
1229 .
1229 name => syntax_error
1229 (
1229 literal
1229 )
1229 ;
1230 name => p
1230 .
1230 name => advance
1230 (
1230 name => _Semi
1230 ,
1230 name => _Rbrace
1230 )
1230 ;
1231 }
1231 ;
1232 }
1232 ;
1234 func
1234 (
1234 name => p
1234 *
1234 name => parser
1234 )
1234 name => oliteral
1234 (
1234 )
1234 *
1234 name => BasicLit
1234 {
1235 if
1235 name => p
1235 .
1235 name => tok
1235 op => == 3
1235 name => _Literal
1235 {
1236 name => b
1236 :=
1236 name => new
1236 (
1236 name => BasicLit
1236 )
1236 ;
1237 name => b
1237 .
1237 name => init
1237 (
1237 name => p
1237 )
1237 ;
1238 name => b
1238 .
1238 name => Value
1238 =
1238 name => p
1238 .
1238 name => lit
1238 ;
1239 name => b
1239 .
1239 name => Kind
1239 =
1239 name => p
1239 .
1239 name => kind
1239 ;
1240 name => p
1240 .
1240 name => next
1240 (
1240 )
1240 ;
1241 return
1241 name => b
1241 ;
1242 }
1242 ;
1243 return
1243 name => nil
1243 ;
1244 }
1244 ;
1249 func
1249 (
1249 name => p
1249 *
1249 name => parser
1249 )
1249 name => methodDecl
1249 (
1249 )
1249 *
1249 name => Field
1249 {
1250 if
1250 name => trace
1250 {
1251 defer
1251 name => p
1251 .
1251 name => trace
1251 (
1251 literal
1251 )
1251 (
1251 )
1251 ;
1252 }
1252 ;
1254 switch
1254 name => p
1254 .
1254 name => tok
1254 {
1255 case
1255 name => _Name
1255 :
1256 name => name
1256 :=
1256 name => p
1256 .
1256 name => name
1256 (
1256 )
1256 ;
1259 name => hasNameList
1259 :=
1259 name => false
1259 ;
1260 for
1260 name => p
1260 .
1260 name => got
1260 (
1260 name => _Comma
1260 )
1260 {
1261 name => p
1261 .
1261 name => name
1261 (
1261 )
1261 ;
1262 name => hasNameList
1262 =
1262 name => true
1262 ;
1263 }
1263 ;
1264 if
1264 name => hasNameList
1264 {
1265 name => p
1265 .
1265 name => syntax_error
1265 (
1265 literal
1265 )
1265 ;
1267 }
1267 ;
1269 name => f
1269 :=
1269 name => new
1269 (
1269 name => Field
1269 )
1269 ;
1270 name => f
1270 .
1270 name => init
1270 (
1270 name => p
1270 )
1270 ;
1271 if
1271 name => p
1271 .
1271 name => tok
1271 op => != 3
1271 name => _Lparen
1271 {
1273 name => f
1273 .
1273 name => Type
1273 =
1273 name => p
1273 .
1273 name => qualifiedName
1273 (
1273 name => name
1273 )
1273 ;
1274 return
1274 name => f
1274 ;
1275 }
1275 ;
1277 name => f
1277 .
1277 name => Name
1277 =
1277 name => name
1277 ;
1278 name => f
1278 .
1278 name => Type
1278 =
1278 name => p
1278 .
1278 name => funcType
1278 (
1278 )
1278 ;
1279 return
1279 name => f
1279 ;
1281 case
1281 name => _Lparen
1281 :
1282 name => p
1282 .
1282 name => next
1282 (
1282 )
1282 ;
1283 name => f
1283 :=
1283 name => new
1283 (
1283 name => Field
1283 )
1283 ;
1284 name => f
1284 .
1284 name => init
1284 (
1284 name => p
1284 )
1284 ;
1285 name => f
1285 .
1285 name => Type
1285 =
1285 name => p
1285 .
1285 name => qualifiedName
1285 (
1285 name => nil
1285 )
1285 ;
1286 name => p
1286 .
1286 name => want
1286 (
1286 name => _Rparen
1286 )
1286 ;
1287 name => p
1287 .
1287 name => error
1287 (
1287 literal
1287 )
1287 ;
1288 return
1288 name => f
1288 ;
1290 default
1290 :
1291 name => p
1291 .
1291 name => syntax_error
1291 (
1291 literal
1291 )
1291 ;
1292 name => p
1292 .
1292 name => advance
1292 (
1292 name => _Semi
1292 ,
1292 name => _Rbrace
1292 )
1292 ;
1293 return
1293 name => nil
1293 ;
1294 }
1294 ;
1295 }
1295 ;
1298 func
1298 (
1298 name => p
1298 *
1298 name => parser
1298 )
1298 name => paramDecl
1298 (
1298 )
1298 *
1298 name => Field
1298 {
1299 if
1299 name => trace
1299 {
1300 defer
1300 name => p
1300 .
1300 name => trace
1300 (
1300 literal
1300 )
1300 (
1300 )
1300 ;
1301 }
1301 ;
1303 name => f
1303 :=
1303 name => new
1303 (
1303 name => Field
1303 )
1303 ;
1304 name => f
1304 .
1304 name => init
1304 (
1304 name => p
1304 )
1304 ;
1306 switch
1306 name => p
1306 .
1306 name => tok
1306 {
1307 case
1307 name => _Name
1307 :
1308 name => f
1308 .
1308 name => Name
1308 =
1308 name => p
1308 .
1308 name => name
1308 (
1308 )
1308 ;
1309 switch
1309 name => p
1309 .
1309 name => tok
1309 {
1310 case
1310 name => _Name
1310 ,
1310 name => _Star
1310 ,
1310 name => _Arrow
1310 ,
1310 name => _Func
1310 ,
1310 name => _Lbrack
1310 ,
1310 name => _Chan
1310 ,
1310 name => _Map
1310 ,
1310 name => _Struct
1310 ,
1310 name => _Interface
1310 ,
1310 name => _Lparen
1310 :
1312 name => f
1312 .
1312 name => Type
1312 =
1312 name => p
1312 .
1312 name => type_
1312 (
1312 )
1312 ;
1314 case
1314 name => _DotDotDot
1314 :
1316 name => f
1316 .
1316 name => Type
1316 =
1316 name => p
1316 .
1316 name => dotsType
1316 (
1316 )
1316 ;
1318 case
1318 name => _Dot
1318 :
1321 name => f
1321 .
1321 name => Type
1321 =
1321 name => p
1321 .
1321 name => dotname
1321 (
1321 name => f
1321 .
1321 name => Name
1321 )
1321 ;
1322 name => f
1322 .
1322 name => Name
1322 =
1322 name => nil
1322 ;
1323 }
1323 ;
1325 case
1325 name => _Arrow
1325 ,
1325 name => _Star
1325 ,
1325 name => _Func
1325 ,
1325 name => _Lbrack
1325 ,
1325 name => _Chan
1325 ,
1325 name => _Map
1325 ,
1325 name => _Struct
1325 ,
1325 name => _Interface
1325 ,
1325 name => _Lparen
1325 :
1327 name => f
1327 .
1327 name => Type
1327 =
1327 name => p
1327 .
1327 name => type_
1327 (
1327 )
1327 ;
1329 case
1329 name => _DotDotDot
1329 :
1331 name => f
1331 .
1331 name => Type
1331 =
1331 name => p
1331 .
1331 name => dotsType
1331 (
1331 )
1331 ;
1333 default
1333 :
1334 name => p
1334 .
1334 name => syntax_error
1334 (
1334 literal
1334 )
1334 ;
1335 name => p
1335 .
1335 name => advance
1335 (
1335 name => _Comma
1335 ,
1335 name => _Rparen
1335 )
1335 ;
1336 return
1336 name => nil
1336 ;
1337 }
1337 ;
1339 return
1339 name => f
1339 ;
1340 }
1340 ;
1343 func
1343 (
1343 name => p
1343 *
1343 name => parser
1343 )
1343 name => dotsType
1343 (
1343 )
1343 *
1343 name => DotsType
1343 {
1344 if
1344 name => trace
1344 {
1345 defer
1345 name => p
1345 .
1345 name => trace
1345 (
1345 literal
1345 )
1345 (
1345 )
1345 ;
1346 }
1346 ;
1348 name => t
1348 :=
1348 name => new
1348 (
1348 name => DotsType
1348 )
1348 ;
1349 name => t
1349 .
1349 name => init
1349 (
1349 name => p
1349 )
1349 ;
1351 name => p
1351 .
1351 name => want
1351 (
1351 name => _DotDotDot
1351 )
1351 ;
1352 name => t
1352 .
1352 name => Elem
1352 =
1352 name => p
1352 .
1352 name => tryType
1352 (
1352 )
1352 ;
1353 if
1353 name => t
1353 .
1353 name => Elem
1353 op => == 3
1353 name => nil
1353 {
1354 name => p
1354 .
1354 name => error
1354 (
1354 literal
1354 )
1354 ;
1355 }
1355 ;
1357 return
1357 name => t
1357 ;
1358 }
1358 ;
1362 func
1362 (
1362 name => p
1362 *
1362 name => parser
1362 )
1362 name => paramList
1362 (
1362 )
1362 (
1362 name => list
1362 [
1362 ]
1362 *
1362 name => Field
1362 )
1362 {
1363 if
1363 name => trace
1363 {
1364 defer
1364 name => p
1364 .
1364 name => trace
1364 (
1364 literal
1364 )
1364 (
1364 )
1364 ;
1365 }
1365 ;
1367 name => p
1367 .
1367 name => want
1367 (
1367 name => _Lparen
1367 )
1367 ;
1369 var
1369 name => named
1369 name => int
1369 ;
1370 for
1370 name => p
1370 .
1370 name => tok
1370 op => != 3
1370 name => _EOF
1370 op => && 2
1370 name => p
1370 .
1370 name => tok
1370 op => != 3
1370 name => _Rparen
1370 {
1371 if
1371 name => par
1371 :=
1371 name => p
1371 .
1371 name => paramDecl
1371 (
1371 )
1371 ;
1371 name => par
1371 op => != 3
1371 name => nil
1371 {
1372 if
1372 name => debug
1372 op => && 2
1372 name => par
1372 .
1372 name => Name
1372 op => == 3
1372 name => nil
1372 op => && 2
1372 name => par
1372 .
1372 name => Type
1372 op => == 3
1372 name => nil
1372 {
1373 name => panic
1373 (
1373 literal
1373 )
1373 ;
1374 }
1374 ;
1375 if
1375 name => par
1375 .
1375 name => Name
1375 op => != 3
1375 name => nil
1375 op => && 2
1375 name => par
1375 .
1375 name => Type
1375 op => != 3
1375 name => nil
1375 {
1376 name => named
1376 opop
1376 ;
1377 }
1377 ;
1378 name => list
1378 =
1378 name => append
1378 (
1378 name => list
1378 ,
1378 name => par
1378 )
1378 ;
1379 }
1379 ;
1380 if
1380 op => ! 0
1380 name => p
1380 .
1380 name => ocomma
1380 (
1380 name => _Rparen
1380 )
1380 {
1381 break
1381 ;
1382 }
1382 ;
1383 }
1383 ;
1386 if
1386 name => named
1386 op => == 3
1386 literal
1386 {
1388 for
1388 name => _
1388 ,
1388 name => par
1388 :=
1388 range
1388 name => list
1388 {
1389 if
1389 name => typ
1389 :=
1389 name => par
1389 .
1389 name => Name
1389 ;
1389 name => typ
1389 op => != 3
1389 name => nil
1389 {
1390 name => par
1390 .
1390 name => Type
1390 =
1390 name => typ
1390 ;
1391 name => par
1391 .
1391 name => Name
1391 =
1391 name => nil
1391 ;
1392 }
1392 ;
1393 }
1393 ;
1394 }
1394 else
1394 if
1394 name => named
1394 op => != 3
1394 name => len
1394 (
1394 name => list
1394 )
1394 {
1396 var
1396 name => typ
1396 name => Expr
1396 ;
1397 for
1397 name => i
1397 :=
1397 name => len
1397 (
1397 name => list
1397 )
1397 op => - 4
1397 literal
1397 ;
1397 name => i
1397 op => >= 3
1397 literal
1397 ;
1397 name => i
1397 opop
1397 {
1398 if
1398 name => par
1398 :=
1398 name => list
1398 [
1398 name => i
1398 ]
1398 ;
1398 name => par
1398 .
1398 name => Type
1398 op => != 3
1398 name => nil
1398 {
1399 name => typ
1399 =
1399 name => par
1399 .
1399 name => Type
1399 ;
1400 if
1400 name => par
1400 .
1400 name => Name
1400 op => == 3
1400 name => nil
1400 {
1401 name => typ
1401 =
1401 name => nil
1401 ;
1402 }
1402 ;
1403 }
1403 else
1403 {
1404 name => par
1404 .
1404 name => Type
1404 =
1404 name => typ
1404 ;
1405 }
1405 ;
1406 if
1406 name => typ
1406 op => == 3
1406 name => nil
1406 {
1407 name => p
1407 .
1407 name => syntax_error
1407 (
1407 literal
1407 )
1407 ;
1408 break
1408 ;
1409 }
1409 ;
1410 }
1410 ;
1411 }
1411 ;
1413 name => p
1413 .
1413 name => want
1413 (
1413 name => _Rparen
1413 )
1413 ;
1414 return
1414 ;
1415 }
1415 ;
1422 var
1422 name => ImplicitOne
1422 =
1422 op => & 5
1422 name => BasicLit
1422 {
1422 name => Value
1422 :
1422 literal
1422 }
1422 ;
1427 func
1427 (
1427 name => p
1427 *
1427 name => parser
1427 )
1427 name => simpleStmt
1427 (
1427 name => lhs
1427 name => Expr
1427 ,
1427 name => rangeOk
1427 name => bool
1427 )
1427 name => SimpleStmt
1427 {
1428 if
1428 name => trace
1428 {
1429 defer
1429 name => p
1429 .
1429 name => trace
1429 (
1429 literal
1429 )
1429 (
1429 )
1429 ;
1430 }
1430 ;
1432 if
1432 name => rangeOk
1432 op => && 2
1432 name => p
1432 .
1432 name => got
1432 (
1432 name => _Range
1432 )
1432 {
1434 if
1434 name => debug
1434 op => && 2
1434 name => lhs
1434 op => != 3
1434 name => nil
1434 {
1435 name => panic
1435 (
1435 literal
1435 )
1435 ;
1436 }
1436 ;
1437 return
1437 name => p
1437 .
1437 name => rangeClause
1437 (
1437 name => nil
1437 ,
1437 name => false
1437 )
1437 ;
1438 }
1438 ;
1440 if
1440 name => lhs
1440 op => == 3
1440 name => nil
1440 {
1441 name => lhs
1441 =
1441 name => p
1441 .
1441 name => exprList
1441 (
1441 )
1441 ;
1442 }
1442 ;
1444 if
1444 name => _
1444 ,
1444 name => ok
1444 :=
1444 name => lhs
1444 .
1444 (
1444 *
1444 name => ListExpr
1444 )
1444 ;
1444 op => ! 0
1444 name => ok
1444 op => && 2
1444 name => p
1444 .
1444 name => tok
1444 op => != 3
1444 name => _Assign
1444 op => && 2
1444 name => p
1444 .
1444 name => tok
1444 op => != 3
1444 name => _Define
1444 {
1446 switch
1446 name => p
1446 .
1446 name => tok
1446 {
1447 case
1447 name => _AssignOp
1447 :
1449 name => op
1449 :=
1449 name => p
1449 .
1449 name => op
1449 ;
1450 name => p
1450 .
1450 name => next
1450 (
1450 )
1450 ;
1451 return
1451 name => p
1451 .
1451 name => newAssignStmt
1451 (
1451 name => op
1451 ,
1451 name => lhs
1451 ,
1451 name => p
1451 .
1451 name => expr
1451 (
1451 )
1451 )
1451 ;
1453 case
1453 name => _IncOp
1453 :
1455 name => op
1455 :=
1455 name => p
1455 .
1455 name => op
1455 ;
1456 name => p
1456 .
1456 name => next
1456 (
1456 )
1456 ;
1457 return
1457 name => p
1457 .
1457 name => newAssignStmt
1457 (
1457 name => op
1457 ,
1457 name => lhs
1457 ,
1457 name => ImplicitOne
1457 )
1457 ;
1459 case
1459 name => _Arrow
1459 :
1461 name => p
1461 .
1461 name => next
1461 (
1461 )
1461 ;
1462 name => s
1462 :=
1462 name => new
1462 (
1462 name => SendStmt
1462 )
1462 ;
1463 name => s
1463 .
1463 name => init
1463 (
1463 name => p
1463 )
1463 ;
1464 name => s
1464 .
1464 name => Chan
1464 =
1464 name => lhs
1464 ;
1465 name => s
1465 .
1465 name => Value
1465 =
1465 name => p
1465 .
1465 name => expr
1465 (
1465 )
1465 ;
1466 if
1466 name => gcCompat
1466 {
1467 name => s
1467 .
1467 name => init
1467 (
1467 name => p
1467 )
1467 ;
1468 }
1468 ;
1469 return
1469 name => s
1469 ;
1471 default
1471 :
1473 return
1473 op => & 5
1473 name => ExprStmt
1473 {
1473 name => X
1473 :
1473 name => lhs
1473 }
1473 ;
1474 }
1474 ;
1475 }
1475 ;
1478 switch
1478 name => p
1478 .
1478 name => tok
1478 {
1479 case
1479 name => _Assign
1479 :
1480 name => p
1480 .
1480 name => next
1480 (
1480 )
1480 ;
1482 if
1482 name => rangeOk
1482 op => && 2
1482 name => p
1482 .
1482 name => got
1482 (
1482 name => _Range
1482 )
1482 {
1484 return
1484 name => p
1484 .
1484 name => rangeClause
1484 (
1484 name => lhs
1484 ,
1484 name => false
1484 )
1484 ;
1485 }
1485 ;
1488 return
1488 name => p
1488 .
1488 name => newAssignStmt
1488 (
1488 literal
1488 ,
1488 name => lhs
1488 ,
1488 name => p
1488 .
1488 name => exprList
1488 (
1488 )
1488 )
1488 ;
1490 case
1490 name => _Define
1490 :
1491 var
1491 name => n
1491 name => node
1491 ;
1492 name => n
1492 .
1492 name => init
1492 (
1492 name => p
1492 )
1492 ;
1493 name => p
1493 .
1493 name => next
1493 (
1493 )
1493 ;
1495 if
1495 name => rangeOk
1495 op => && 2
1495 name => p
1495 .
1495 name => got
1495 (
1495 name => _Range
1495 )
1495 {
1497 return
1497 name => p
1497 .
1497 name => rangeClause
1497 (
1497 name => lhs
1497 ,
1497 name => true
1497 )
1497 ;
1498 }
1498 ;
1501 name => rhs
1501 :=
1501 name => p
1501 .
1501 name => exprList
1501 (
1501 )
1501 ;
1503 if
1503 name => x
1503 ,
1503 name => ok
1503 :=
1503 name => rhs
1503 .
1503 (
1503 *
1503 name => TypeSwitchGuard
1503 )
1503 ;
1503 name => ok
1503 {
1504 switch
1504 name => lhs
1504 :=
1504 name => lhs
1504 .
1504 (
1504 type
1504 )
1504 {
1505 case
1505 *
1505 name => Name
1505 :
1506 name => x
1506 .
1506 name => Lhs
1506 =
1506 name => lhs
1506 ;
1507 case
1507 *
1507 name => ListExpr
1507 :
1508 name => p
1508 .
1508 name => error
1508 (
1508 name => fmt
1508 .
1508 name => Sprintf
1508 (
1508 literal
1508 ,
1508 name => len
1508 (
1508 name => lhs
1508 .
1508 name => ElemList
1508 )
1508 ,
1508 literal
1508 )
1508 )
1508 ;
1509 default
1509 :
1511 name => p
1511 .
1511 name => error
1511 (
1511 name => fmt
1511 .
1511 name => Sprintf
1511 (
1511 literal
1511 ,
1511 name => lhs
1511 )
1511 )
1511 ;
1512 }
1512 ;
1513 return
1513 op => & 5
1513 name => ExprStmt
1513 {
1513 name => X
1513 :
1513 name => x
1513 }
1513 ;
1514 }
1514 ;
1516 name => as
1516 :=
1516 name => p
1516 .
1516 name => newAssignStmt
1516 (
1516 name => Def
1516 ,
1516 name => lhs
1516 ,
1516 name => rhs
1516 )
1516 ;
1517 if
1517 name => gcCompat
1517 {
1518 name => as
1518 .
1518 name => node
1518 =
1518 name => n
1518 ;
1519 }
1519 ;
1520 return
1520 name => as
1520 ;
1522 default
1522 :
1523 name => p
1523 .
1523 name => syntax_error
1523 (
1523 literal
1523 )
1523 ;
1524 name => p
1524 .
1524 name => advance
1524 (
1524 name => _Semi
1524 ,
1524 name => _Rbrace
1524 )
1524 ;
1525 return
1525 name => nil
1525 ;
1526 }
1526 ;
1527 }
1527 ;
1529 func
1529 (
1529 name => p
1529 *
1529 name => parser
1529 )
1529 name => rangeClause
1529 (
1529 name => lhs
1529 name => Expr
1529 ,
1529 name => def
1529 name => bool
1529 )
1529 *
1529 name => RangeClause
1529 {
1530 name => r
1530 :=
1530 name => new
1530 (
1530 name => RangeClause
1530 )
1530 ;
1531 name => r
1531 .
1531 name => init
1531 (
1531 name => p
1531 )
1531 ;
1532 name => r
1532 .
1532 name => Lhs
1532 =
1532 name => lhs
1532 ;
1533 name => r
1533 .
1533 name => Def
1533 =
1533 name => def
1533 ;
1534 name => r
1534 .
1534 name => X
1534 =
1534 name => p
1534 .
1534 name => expr
1534 (
1534 )
1534 ;
1535 if
1535 name => gcCompat
1535 {
1536 name => r
1536 .
1536 name => init
1536 (
1536 name => p
1536 )
1536 ;
1537 }
1537 ;
1538 return
1538 name => r
1538 ;
1539 }
1539 ;
1541 func
1541 (
1541 name => p
1541 *
1541 name => parser
1541 )
1541 name => newAssignStmt
1541 (
1541 name => op
1541 name => Operator
1541 ,
1541 name => lhs
1541 ,
1541 name => rhs
1541 name => Expr
1541 )
1541 *
1541 name => AssignStmt
1541 {
1542 name => a
1542 :=
1542 name => new
1542 (
1542 name => AssignStmt
1542 )
1542 ;
1543 name => a
1543 .
1543 name => init
1543 (
1543 name => p
1543 )
1543 ;
1544 name => a
1544 .
1544 name => Op
1544 =
1544 name => op
1544 ;
1545 name => a
1545 .
1545 name => Lhs
1545 =
1545 name => lhs
1545 ;
1546 name => a
1546 .
1546 name => Rhs
1546 =
1546 name => rhs
1546 ;
1547 return
1547 name => a
1547 ;
1548 }
1548 ;
1550 func
1550 (
1550 name => p
1550 *
1550 name => parser
1550 )
1550 name => labeledStmt
1550 (
1550 name => label
1550 *
1550 name => Name
1550 )
1550 name => Stmt
1550 {
1551 if
1551 name => trace
1551 {
1552 defer
1552 name => p
1552 .
1552 name => trace
1552 (
1552 literal
1552 )
1552 (
1552 )
1552 ;
1553 }
1553 ;
1555 name => s
1555 :=
1555 name => new
1555 (
1555 name => LabeledStmt
1555 )
1555 ;
1556 name => s
1556 .
1556 name => init
1556 (
1556 name => p
1556 )
1556 ;
1557 name => s
1557 .
1557 name => Label
1557 =
1557 name => label
1557 ;
1559 name => p
1559 .
1559 name => want
1559 (
1559 name => _Colon
1559 )
1559 ;
1561 if
1561 name => p
1561 .
1561 name => tok
1561 op => != 3
1561 name => _Rbrace
1561 op => && 2
1561 name => p
1561 .
1561 name => tok
1561 op => != 3
1561 name => _EOF
1561 {
1562 name => s
1562 .
1562 name => Stmt
1562 =
1562 name => p
1562 .
1562 name => stmt
1562 (
1562 )
1562 ;
1563 if
1563 name => s
1563 .
1563 name => Stmt
1563 op => == 3
1563 name => missing_stmt
1563 {
1565 name => p
1565 .
1565 name => syntax_error_at
1565 (
1565 name => int
1565 (
1565 name => label
1565 .
1565 name => pos
1565 )
1565 ,
1565 name => int
1565 (
1565 name => label
1565 .
1565 name => line
1565 )
1565 ,
1565 literal
1565 )
1565 ;
1567 return
1567 name => missing_stmt
1567 ;
1568 }
1568 ;
1569 }
1569 ;
1571 return
1571 name => s
1571 ;
1572 }
1572 ;
1574 func
1574 (
1574 name => p
1574 *
1574 name => parser
1574 )
1574 name => blockStmt
1574 (
1574 )
1574 *
1574 name => BlockStmt
1574 {
1575 if
1575 name => trace
1575 {
1576 defer
1576 name => p
1576 .
1576 name => trace
1576 (
1576 literal
1576 )
1576 (
1576 )
1576 ;
1577 }
1577 ;
1579 name => s
1579 :=
1579 name => new
1579 (
1579 name => BlockStmt
1579 )
1579 ;
1580 name => s
1580 .
1580 name => init
1580 (
1580 name => p
1580 )
1580 ;
1581 name => p
1581 .
1581 name => want
1581 (
1581 name => _Lbrace
1581 )
1581 ;
1582 name => s
1582 .
1582 name => Body
1582 =
1582 name => p
1582 .
1582 name => stmtList
1582 (
1582 )
1582 ;
1583 name => p
1583 .
1583 name => want
1583 (
1583 name => _Rbrace
1583 )
1583 ;
1585 return
1585 name => s
1585 ;
1586 }
1586 ;
1588 func
1588 (
1588 name => p
1588 *
1588 name => parser
1588 )
1588 name => declStmt
1588 (
1588 name => f
1588 func
1588 (
1588 *
1588 name => Group
1588 )
1588 name => Decl
1588 )
1588 *
1588 name => DeclStmt
1588 {
1589 if
1589 name => trace
1589 {
1590 defer
1590 name => p
1590 .
1590 name => trace
1590 (
1590 literal
1590 )
1590 (
1590 )
1590 ;
1591 }
1591 ;
1593 name => s
1593 :=
1593 name => new
1593 (
1593 name => DeclStmt
1593 )
1593 ;
1594 name => s
1594 .
1594 name => init
1594 (
1594 name => p
1594 )
1594 ;
1596 name => p
1596 .
1596 name => next
1596 (
1596 )
1596 ;
1597 name => s
1597 .
1597 name => DeclList
1597 =
1597 name => p
1597 .
1597 name => appendGroup
1597 (
1597 name => nil
1597 ,
1597 name => f
1597 )
1597 ;
1599 return
1599 name => s
1599 ;
1600 }
1600 ;
1602 func
1602 (
1602 name => p
1602 *
1602 name => parser
1602 )
1602 name => forStmt
1602 (
1602 )
1602 name => Stmt
1602 {
1603 if
1603 name => trace
1603 {
1604 defer
1604 name => p
1604 .
1604 name => trace
1604 (
1604 literal
1604 )
1604 (
1604 )
1604 ;
1605 }
1605 ;
1607 name => s
1607 :=
1607 name => new
1607 (
1607 name => ForStmt
1607 )
1607 ;
1608 name => s
1608 .
1608 name => init
1608 (
1608 name => p
1608 )
1608 ;
1610 name => p
1610 .
1610 name => want
1610 (
1610 name => _For
1610 )
1610 ;
1611 name => s
1611 .
1611 name => Init
1611 ,
1611 name => s
1611 .
1611 name => Cond
1611 ,
1611 name => s
1611 .
1611 name => Post
1611 =
1611 name => p
1611 .
1611 name => header
1611 (
1611 name => true
1611 )
1611 ;
1612 if
1612 name => gcCompat
1612 {
1613 name => s
1613 .
1613 name => init
1613 (
1613 name => p
1613 )
1613 ;
1614 }
1614 ;
1615 name => s
1615 .
1615 name => Body
1615 =
1615 name => p
1615 .
1615 name => stmtBody
1615 (
1615 literal
1615 )
1615 ;
1617 return
1617 name => s
1617 ;
1618 }
1618 ;
1621 func
1621 (
1621 name => p
1621 *
1621 name => parser
1621 )
1621 name => stmtBody
1621 (
1621 name => context
1621 name => string
1621 )
1621 [
1621 ]
1621 name => Stmt
1621 {
1622 if
1622 name => trace
1622 {
1623 defer
1623 name => p
1623 .
1623 name => trace
1623 (
1623 literal
1623 )
1623 (
1623 )
1623 ;
1624 }
1624 ;
1626 if
1626 op => ! 0
1626 name => p
1626 .
1626 name => got
1626 (
1626 name => _Lbrace
1626 )
1626 {
1627 name => p
1627 .
1627 name => syntax_error
1627 (
1627 literal
1627 op => + 4
1627 name => context
1627 )
1627 ;
1628 name => p
1628 .
1628 name => advance
1628 (
1628 name => _Name
1628 ,
1628 name => _Rbrace
1628 )
1628 ;
1629 }
1629 ;
1631 name => body
1631 :=
1631 name => p
1631 .
1631 name => stmtList
1631 (
1631 )
1631 ;
1632 name => p
1632 .
1632 name => want
1632 (
1632 name => _Rbrace
1632 )
1632 ;
1634 return
1634 name => body
1634 ;
1635 }
1635 ;
1637 var
1637 name => dummyCond
1637 =
1637 op => & 5
1637 name => Name
1637 {
1637 name => Value
1637 :
1637 literal
1637 }
1637 ;
1639 func
1639 (
1639 name => p
1639 *
1639 name => parser
1639 )
1639 name => header
1639 (
1639 name => forStmt
1639 name => bool
1639 )
1639 (
1639 name => init
1639 name => SimpleStmt
1639 ,
1639 name => cond
1639 name => Expr
1639 ,
1639 name => post
1639 name => SimpleStmt
1639 )
1639 {
1640 if
1640 name => p
1640 .
1640 name => tok
1640 op => == 3
1640 name => _Lbrace
1640 {
1641 return
1641 ;
1642 }
1642 ;
1644 name => outer
1644 :=
1644 name => p
1644 .
1644 name => xnest
1644 ;
1645 name => p
1645 .
1645 name => xnest
1645 =
1645 op => - 4
1645 literal
1645 ;
1647 if
1647 name => p
1647 .
1647 name => tok
1647 op => != 3
1647 name => _Semi
1647 {
1649 if
1649 name => forStmt
1649 op => && 2
1649 name => p
1649 .
1649 name => got
1649 (
1649 name => _Var
1649 )
1649 {
1650 name => p
1650 .
1650 name => error
1650 (
1650 literal
1650 )
1650 ;
1651 }
1651 ;
1652 name => init
1652 =
1652 name => p
1652 .
1652 name => simpleStmt
1652 (
1652 name => nil
1652 ,
1652 name => forStmt
1652 )
1652 ;
1654 if
1654 name => _
1654 ,
1654 name => ok
1654 :=
1654 name => init
1654 .
1654 (
1654 *
1654 name => RangeClause
1654 )
1654 ;
1654 name => ok
1654 {
1655 name => p
1655 .
1655 name => xnest
1655 =
1655 name => outer
1655 ;
1656 return
1656 ;
1657 }
1657 ;
1658 }
1658 ;
1660 var
1660 name => condStmt
1660 name => SimpleStmt
1660 ;
1661 if
1661 name => p
1661 .
1661 name => got
1661 (
1661 name => _Semi
1661 )
1661 {
1662 if
1662 name => forStmt
1662 {
1663 if
1663 name => p
1663 .
1663 name => tok
1663 op => != 3
1663 name => _Semi
1663 {
1664 name => condStmt
1664 =
1664 name => p
1664 .
1664 name => simpleStmt
1664 (
1664 name => nil
1664 ,
1664 name => false
1664 )
1664 ;
1665 }
1665 ;
1666 name => p
1666 .
1666 name => want
1666 (
1666 name => _Semi
1666 )
1666 ;
1667 if
1667 name => p
1667 .
1667 name => tok
1667 op => != 3
1667 name => _Lbrace
1667 {
1668 name => post
1668 =
1668 name => p
1668 .
1668 name => simpleStmt
1668 (
1668 name => nil
1668 ,
1668 name => false
1668 )
1668 ;
1669 }
1669 ;
1670 }
1670 else
1670 if
1670 name => p
1670 .
1670 name => tok
1670 op => != 3
1670 name => _Lbrace
1670 {
1671 name => condStmt
1671 =
1671 name => p
1671 .
1671 name => simpleStmt
1671 (
1671 name => nil
1671 ,
1671 name => false
1671 )
1671 ;
1672 }
1672 ;
1673 }
1673 else
1673 {
1674 name => condStmt
1674 =
1674 name => init
1674 ;
1675 name => init
1675 =
1675 name => nil
1675 ;
1676 }
1676 ;
1679 switch
1679 name => s
1679 :=
1679 name => condStmt
1679 .
1679 (
1679 type
1679 )
1679 {
1680 case
1680 name => nil
1680 :
1682 case
1682 *
1682 name => ExprStmt
1682 :
1683 name => cond
1683 =
1683 name => s
1683 .
1683 name => X
1683 ;
1684 default
1684 :
1685 name => p
1685 .
1685 name => syntax_error
1685 (
1685 name => fmt
1685 .
1685 name => Sprintf
1685 (
1685 literal
1685 ,
1685 name => String
1685 (
1685 name => s
1685 )
1685 )
1685 )
1685 ;
1686 name => cond
1686 =
1686 name => dummyCond
1686 ;
1687 }
1687 ;
1689 name => p
1689 .
1689 name => xnest
1689 =
1689 name => outer
1689 ;
1690 return
1690 ;
1691 }
1691 ;
1693 func
1693 (
1693 name => p
1693 *
1693 name => parser
1693 )
1693 name => ifStmt
1693 (
1693 )
1693 *
1693 name => IfStmt
1693 {
1694 if
1694 name => trace
1694 {
1695 defer
1695 name => p
1695 .
1695 name => trace
1695 (
1695 literal
1695 )
1695 (
1695 )
1695 ;
1696 }
1696 ;
1698 name => s
1698 :=
1698 name => new
1698 (
1698 name => IfStmt
1698 )
1698 ;
1699 name => s
1699 .
1699 name => init
1699 (
1699 name => p
1699 )
1699 ;
1701 name => p
1701 .
1701 name => want
1701 (
1701 name => _If
1701 )
1701 ;
1702 name => s
1702 .
1702 name => Init
1702 ,
1702 name => s
1702 .
1702 name => Cond
1702 ,
1702 name => _
1702 =
1702 name => p
1702 .
1702 name => header
1702 (
1702 name => false
1702 )
1702 ;
1703 if
1703 name => s
1703 .
1703 name => Cond
1703 op => == 3
1703 name => nil
1703 {
1704 name => p
1704 .
1704 name => error
1704 (
1704 literal
1704 )
1704 ;
1705 }
1705 ;
1707 if
1707 name => gcCompat
1707 {
1708 name => s
1708 .
1708 name => init
1708 (
1708 name => p
1708 )
1708 ;
1709 }
1709 ;
1711 name => s
1711 .
1711 name => Then
1711 =
1711 name => p
1711 .
1711 name => stmtBody
1711 (
1711 literal
1711 )
1711 ;
1713 if
1713 name => p
1713 .
1713 name => got
1713 (
1713 name => _Else
1713 )
1713 {
1714 switch
1714 name => p
1714 .
1714 name => tok
1714 {
1715 case
1715 name => _If
1715 :
1716 name => s
1716 .
1716 name => Else
1716 =
1716 name => p
1716 .
1716 name => ifStmt
1716 (
1716 )
1716 ;
1717 case
1717 name => _Lbrace
1717 :
1718 name => s
1718 .
1718 name => Else
1718 =
1718 name => p
1718 .
1718 name => blockStmt
1718 (
1718 )
1718 ;
1719 default
1719 :
1720 name => p
1720 .
1720 name => error
1720 (
1720 literal
1720 )
1720 ;
1721 name => p
1721 .
1721 name => advance
1721 (
1721 name => _Name
1721 ,
1721 name => _Rbrace
1721 )
1721 ;
1722 }
1722 ;
1723 }
1723 ;
1725 return
1725 name => s
1725 ;
1726 }
1726 ;
1728 func
1728 (
1728 name => p
1728 *
1728 name => parser
1728 )
1728 name => switchStmt
1728 (
1728 )
1728 *
1728 name => SwitchStmt
1728 {
1729 if
1729 name => trace
1729 {
1730 defer
1730 name => p
1730 .
1730 name => trace
1730 (
1730 literal
1730 )
1730 (
1730 )
1730 ;
1731 }
1731 ;
1733 name => p
1733 .
1733 name => want
1733 (
1733 name => _Switch
1733 )
1733 ;
1734 name => s
1734 :=
1734 name => new
1734 (
1734 name => SwitchStmt
1734 )
1734 ;
1735 name => s
1735 .
1735 name => init
1735 (
1735 name => p
1735 )
1735 ;
1737 name => s
1737 .
1737 name => Init
1737 ,
1737 name => s
1737 .
1737 name => Tag
1737 ,
1737 name => _
1737 =
1737 name => p
1737 .
1737 name => header
1737 (
1737 name => false
1737 )
1737 ;
1739 if
1739 op => ! 0
1739 name => p
1739 .
1739 name => got
1739 (
1739 name => _Lbrace
1739 )
1739 {
1740 name => p
1740 .
1740 name => syntax_error
1740 (
1740 literal
1740 )
1740 ;
1741 name => p
1741 .
1741 name => advance
1741 (
1741 name => _Case
1741 ,
1741 name => _Default
1741 ,
1741 name => _Rbrace
1741 )
1741 ;
1742 }
1742 ;
1743 for
1743 name => p
1743 .
1743 name => tok
1743 op => != 3
1743 name => _EOF
1743 op => && 2
1743 name => p
1743 .
1743 name => tok
1743 op => != 3
1743 name => _Rbrace
1743 {
1744 name => s
1744 .
1744 name => Body
1744 =
1744 name => append
1744 (
1744 name => s
1744 .
1744 name => Body
1744 ,
1744 name => p
1744 .
1744 name => caseClause
1744 (
1744 )
1744 )
1744 ;
1745 }
1745 ;
1746 name => p
1746 .
1746 name => want
1746 (
1746 name => _Rbrace
1746 )
1746 ;
1748 return
1748 name => s
1748 ;
1749 }
1749 ;
1751 func
1751 (
1751 name => p
1751 *
1751 name => parser
1751 )
1751 name => selectStmt
1751 (
1751 )
1751 *
1751 name => SelectStmt
1751 {
1752 if
1752 name => trace
1752 {
1753 defer
1753 name => p
1753 .
1753 name => trace
1753 (
1753 literal
1753 )
1753 (
1753 )
1753 ;
1754 }
1754 ;
1756 name => p
1756 .
1756 name => want
1756 (
1756 name => _Select
1756 )
1756 ;
1757 name => s
1757 :=
1757 name => new
1757 (
1757 name => SelectStmt
1757 )
1757 ;
1758 name => s
1758 .
1758 name => init
1758 (
1758 name => p
1758 )
1758 ;
1760 if
1760 op => ! 0
1760 name => p
1760 .
1760 name => got
1760 (
1760 name => _Lbrace
1760 )
1760 {
1761 name => p
1761 .
1761 name => syntax_error
1761 (
1761 literal
1761 )
1761 ;
1762 name => p
1762 .
1762 name => advance
1762 (
1762 name => _Case
1762 ,
1762 name => _Default
1762 ,
1762 name => _Rbrace
1762 )
1762 ;
1763 }
1763 ;
1764 for
1764 name => p
1764 .
1764 name => tok
1764 op => != 3
1764 name => _EOF
1764 op => && 2
1764 name => p
1764 .
1764 name => tok
1764 op => != 3
1764 name => _Rbrace
1764 {
1765 name => s
1765 .
1765 name => Body
1765 =
1765 name => append
1765 (
1765 name => s
1765 .
1765 name => Body
1765 ,
1765 name => p
1765 .
1765 name => commClause
1765 (
1765 )
1765 )
1765 ;
1766 }
1766 ;
1767 name => p
1767 .
1767 name => want
1767 (
1767 name => _Rbrace
1767 )
1767 ;
1769 return
1769 name => s
1769 ;
1770 }
1770 ;
1772 func
1772 (
1772 name => p
1772 *
1772 name => parser
1772 )
1772 name => caseClause
1772 (
1772 )
1772 *
1772 name => CaseClause
1772 {
1773 if
1773 name => trace
1773 {
1774 defer
1774 name => p
1774 .
1774 name => trace
1774 (
1774 literal
1774 )
1774 (
1774 )
1774 ;
1775 }
1775 ;
1777 name => c
1777 :=
1777 name => new
1777 (
1777 name => CaseClause
1777 )
1777 ;
1778 name => c
1778 .
1778 name => init
1778 (
1778 name => p
1778 )
1778 ;
1780 switch
1780 name => p
1780 .
1780 name => tok
1780 {
1781 case
1781 name => _Case
1781 :
1782 name => p
1782 .
1782 name => next
1782 (
1782 )
1782 ;
1783 name => c
1783 .
1783 name => Cases
1783 =
1783 name => p
1783 .
1783 name => exprList
1783 (
1783 )
1783 ;
1785 case
1785 name => _Default
1785 :
1786 name => p
1786 .
1786 name => next
1786 (
1786 )
1786 ;
1788 default
1788 :
1789 name => p
1789 .
1789 name => syntax_error
1789 (
1789 literal
1789 )
1789 ;
1790 name => p
1790 .
1790 name => advance
1790 (
1790 name => _Case
1790 ,
1790 name => _Default
1790 ,
1790 name => _Rbrace
1790 )
1790 ;
1791 }
1791 ;
1793 if
1793 name => gcCompat
1793 {
1794 name => c
1794 .
1794 name => init
1794 (
1794 name => p
1794 )
1794 ;
1795 }
1795 ;
1796 name => p
1796 .
1796 name => want
1796 (
1796 name => _Colon
1796 )
1796 ;
1797 name => c
1797 .
1797 name => Body
1797 =
1797 name => p
1797 .
1797 name => stmtList
1797 (
1797 )
1797 ;
1799 return
1799 name => c
1799 ;
1800 }
1800 ;
1802 func
1802 (
1802 name => p
1802 *
1802 name => parser
1802 )
1802 name => commClause
1802 (
1802 )
1802 *
1802 name => CommClause
1802 {
1803 if
1803 name => trace
1803 {
1804 defer
1804 name => p
1804 .
1804 name => trace
1804 (
1804 literal
1804 )
1804 (
1804 )
1804 ;
1805 }
1805 ;
1807 name => c
1807 :=
1807 name => new
1807 (
1807 name => CommClause
1807 )
1807 ;
1808 name => c
1808 .
1808 name => init
1808 (
1808 name => p
1808 )
1808 ;
1810 switch
1810 name => p
1810 .
1810 name => tok
1810 {
1811 case
1811 name => _Case
1811 :
1812 name => p
1812 .
1812 name => next
1812 (
1812 )
1812 ;
1813 name => c
1813 .
1813 name => Comm
1813 =
1813 name => p
1813 .
1813 name => simpleStmt
1813 (
1813 name => nil
1813 ,
1813 name => false
1813 )
1813 ;
1827 case
1827 name => _Default
1827 :
1828 name => p
1828 .
1828 name => next
1828 (
1828 )
1828 ;
1830 default
1830 :
1831 name => p
1831 .
1831 name => syntax_error
1831 (
1831 literal
1831 )
1831 ;
1832 name => p
1832 .
1832 name => advance
1832 (
1832 name => _Case
1832 ,
1832 name => _Default
1832 ,
1832 name => _Rbrace
1832 )
1832 ;
1833 }
1833 ;
1835 if
1835 name => gcCompat
1835 {
1836 name => c
1836 .
1836 name => init
1836 (
1836 name => p
1836 )
1836 ;
1837 }
1837 ;
1838 name => p
1838 .
1838 name => want
1838 (
1838 name => _Colon
1838 )
1838 ;
1839 name => c
1839 .
1839 name => Body
1839 =
1839 name => p
1839 .
1839 name => stmtList
1839 (
1839 )
1839 ;
1841 return
1841 name => c
1841 ;
1842 }
1842 ;
1845 var
1845 name => missing_stmt
1845 name => Stmt
1845 =
1845 name => new
1845 (
1845 name => EmptyStmt
1845 )
1845 ;
1854 func
1854 (
1854 name => p
1854 *
1854 name => parser
1854 )
1854 name => stmt
1854 (
1854 )
1854 name => Stmt
1854 {
1855 if
1855 name => trace
1855 {
1856 defer
1856 name => p
1856 .
1856 name => trace
1856 (
1856 literal
1856 op => + 4
1856 name => p
1856 .
1856 name => tok
1856 .
1856 name => String
1856 (
1856 )
1856 )
1856 (
1856 )
1856 ;
1857 }
1857 ;
1861 if
1861 name => p
1861 .
1861 name => tok
1861 op => == 3
1861 name => _Name
1861 {
1862 name => lhs
1862 :=
1862 name => p
1862 .
1862 name => exprList
1862 (
1862 )
1862 ;
1863 if
1863 name => label
1863 ,
1863 name => ok
1863 :=
1863 name => lhs
1863 .
1863 (
1863 *
1863 name => Name
1863 )
1863 ;
1863 name => ok
1863 op => && 2
1863 name => p
1863 .
1863 name => tok
1863 op => == 3
1863 name => _Colon
1863 {
1864 return
1864 name => p
1864 .
1864 name => labeledStmt
1864 (
1864 name => label
1864 )
1864 ;
1865 }
1865 ;
1866 return
1866 name => p
1866 .
1866 name => simpleStmt
1866 (
1866 name => lhs
1866 ,
1866 name => false
1866 )
1866 ;
1867 }
1867 ;
1869 switch
1869 name => p
1869 .
1869 name => tok
1869 {
1870 case
1870 name => _Lbrace
1870 :
1871 return
1871 name => p
1871 .
1871 name => blockStmt
1871 (
1871 )
1871 ;
1873 case
1873 name => _Var
1873 :
1874 return
1874 name => p
1874 .
1874 name => declStmt
1874 (
1874 name => p
1874 .
1874 name => varDecl
1874 )
1874 ;
1876 case
1876 name => _Const
1876 :
1877 return
1877 name => p
1877 .
1877 name => declStmt
1877 (
1877 name => p
1877 .
1877 name => constDecl
1877 )
1877 ;
1879 case
1879 name => _Type
1879 :
1880 return
1880 name => p
1880 .
1880 name => declStmt
1880 (
1880 name => p
1880 .
1880 name => typeDecl
1880 )
1880 ;
1882 case
1882 name => _Operator
1882 ,
1882 name => _Star
1882 :
1883 switch
1883 name => p
1883 .
1883 name => op
1883 {
1884 case
1884 name => Add
1884 ,
1884 name => Sub
1884 ,
1884 name => Mul
1884 ,
1884 name => And
1884 ,
1884 name => Xor
1884 ,
1884 name => Not
1884 :
1885 return
1885 name => p
1885 .
1885 name => simpleStmt
1885 (
1885 name => nil
1885 ,
1885 name => false
1885 )
1885 ;
1886 }
1886 ;
1888 case
1888 name => _Literal
1888 ,
1888 name => _Func
1888 ,
1888 name => _Lparen
1888 ,
1889 name => _Lbrack
1889 ,
1889 name => _Struct
1889 ,
1889 name => _Map
1889 ,
1889 name => _Chan
1889 ,
1889 name => _Interface
1889 ,
1890 name => _Arrow
1890 :
1891 return
1891 name => p
1891 .
1891 name => simpleStmt
1891 (
1891 name => nil
1891 ,
1891 name => false
1891 )
1891 ;
1893 case
1893 name => _For
1893 :
1894 return
1894 name => p
1894 .
1894 name => forStmt
1894 (
1894 )
1894 ;
1896 case
1896 name => _Switch
1896 :
1897 return
1897 name => p
1897 .
1897 name => switchStmt
1897 (
1897 )
1897 ;
1899 case
1899 name => _Select
1899 :
1900 return
1900 name => p
1900 .
1900 name => selectStmt
1900 (
1900 )
1900 ;
1902 case
1902 name => _If
1902 :
1903 return
1903 name => p
1903 .
1903 name => ifStmt
1903 (
1903 )
1903 ;
1905 case
1905 name => _Fallthrough
1905 :
1906 name => p
1906 .
1906 name => next
1906 (
1906 )
1906 ;
1907 name => s
1907 :=
1907 name => new
1907 (
1907 name => BranchStmt
1907 )
1907 ;
1908 name => s
1908 .
1908 name => init
1908 (
1908 name => p
1908 )
1908 ;
1909 name => s
1909 .
1909 name => Tok
1909 =
1909 name => _Fallthrough
1909 ;
1910 return
1910 name => s
1910 ;
1916 case
1916 name => _Break
1916 ,
1916 name => _Continue
1916 :
1917 name => tok
1917 :=
1917 name => p
1917 .
1917 name => tok
1917 ;
1918 name => p
1918 .
1918 name => next
1918 (
1918 )
1918 ;
1919 name => s
1919 :=
1919 name => new
1919 (
1919 name => BranchStmt
1919 )
1919 ;
1920 name => s
1920 .
1920 name => init
1920 (
1920 name => p
1920 )
1920 ;
1921 name => s
1921 .
1921 name => Tok
1921 =
1921 name => tok
1921 ;
1922 if
1922 name => p
1922 .
1922 name => tok
1922 op => == 3
1922 name => _Name
1922 {
1923 name => s
1923 .
1923 name => Label
1923 =
1923 name => p
1923 .
1923 name => name
1923 (
1923 )
1923 ;
1924 }
1924 ;
1925 return
1925 name => s
1925 ;
1927 case
1927 name => _Go
1927 ,
1927 name => _Defer
1927 :
1928 return
1928 name => p
1928 .
1928 name => callStmt
1928 (
1928 )
1928 ;
1930 case
1930 name => _Goto
1930 :
1931 name => p
1931 .
1931 name => next
1931 (
1931 )
1931 ;
1932 name => s
1932 :=
1932 name => new
1932 (
1932 name => BranchStmt
1932 )
1932 ;
1933 name => s
1933 .
1933 name => init
1933 (
1933 name => p
1933 )
1933 ;
1934 name => s
1934 .
1934 name => Tok
1934 =
1934 name => _Goto
1934 ;
1935 name => s
1935 .
1935 name => Label
1935 =
1935 name => p
1935 .
1935 name => name
1935 (
1935 )
1935 ;
1936 return
1936 name => s
1936 ;
1941 case
1941 name => _Return
1941 :
1942 name => p
1942 .
1942 name => next
1942 (
1942 )
1942 ;
1943 name => s
1943 :=
1943 name => new
1943 (
1943 name => ReturnStmt
1943 )
1943 ;
1944 name => s
1944 .
1944 name => init
1944 (
1944 name => p
1944 )
1944 ;
1945 if
1945 name => p
1945 .
1945 name => tok
1945 op => != 3
1945 name => _Semi
1945 op => && 2
1945 name => p
1945 .
1945 name => tok
1945 op => != 3
1945 name => _Rbrace
1945 {
1946 name => s
1946 .
1946 name => Results
1946 =
1946 name => p
1946 .
1946 name => exprList
1946 (
1946 )
1946 ;
1947 }
1947 ;
1948 if
1948 name => gcCompat
1948 {
1949 name => s
1949 .
1949 name => init
1949 (
1949 name => p
1949 )
1949 ;
1950 }
1950 ;
1951 return
1951 name => s
1951 ;
1953 case
1953 name => _Semi
1953 :
1954 name => s
1954 :=
1954 name => new
1954 (
1954 name => EmptyStmt
1954 )
1954 ;
1955 name => s
1955 .
1955 name => init
1955 (
1955 name => p
1955 )
1955 ;
1956 return
1956 name => s
1956 ;
1957 }
1957 ;
1959 return
1959 name => missing_stmt
1959 ;
1960 }
1960 ;
1963 func
1963 (
1963 name => p
1963 *
1963 name => parser
1963 )
1963 name => stmtList
1963 (
1963 )
1963 (
1963 name => l
1963 [
1963 ]
1963 name => Stmt
1963 )
1963 {
1964 if
1964 name => trace
1964 {
1965 defer
1965 name => p
1965 .
1965 name => trace
1965 (
1965 literal
1965 )
1965 (
1965 )
1965 ;
1966 }
1966 ;
1968 for
1968 name => p
1968 .
1968 name => tok
1968 op => != 3
1968 name => _EOF
1968 op => && 2
1968 name => p
1968 .
1968 name => tok
1968 op => != 3
1968 name => _Rbrace
1968 op => && 2
1968 name => p
1968 .
1968 name => tok
1968 op => != 3
1968 name => _Case
1968 op => && 2
1968 name => p
1968 .
1968 name => tok
1968 op => != 3
1968 name => _Default
1968 {
1969 name => s
1969 :=
1969 name => p
1969 .
1969 name => stmt
1969 (
1969 )
1969 ;
1970 if
1970 name => s
1970 op => == 3
1970 name => missing_stmt
1970 {
1971 break
1971 ;
1972 }
1972 ;
1973 name => l
1973 =
1973 name => append
1973 (
1973 name => l
1973 ,
1973 name => s
1973 )
1973 ;
1976 if
1976 name => p
1976 .
1976 name => tok
1976 op => == 3
1976 name => _Rparen
1976 op => || 1
1976 name => p
1976 .
1976 name => tok
1976 op => == 3
1976 name => _Rbrace
1976 {
1977 continue
1977 ;
1978 }
1978 ;
1979 if
1979 op => ! 0
1979 name => p
1979 .
1979 name => got
1979 (
1979 name => _Semi
1979 )
1979 {
1980 name => p
1980 .
1980 name => syntax_error
1980 (
1980 literal
1980 )
1980 ;
1981 name => p
1981 .
1981 name => advance
1981 (
1981 name => _Semi
1981 ,
1981 name => _Rbrace
1981 )
1981 ;
1982 }
1982 ;
1983 }
1983 ;
1984 return
1984 ;
1985 }
1985 ;
1988 func
1988 (
1988 name => p
1988 *
1988 name => parser
1988 )
1988 name => call
1988 (
1988 name => fun
1988 name => Expr
1988 )
1988 *
1988 name => CallExpr
1988 {
1989 if
1989 name => trace
1989 {
1990 defer
1990 name => p
1990 .
1990 name => trace
1990 (
1990 literal
1990 )
1990 (
1990 )
1990 ;
1991 }
1991 ;
1995 name => c
1995 :=
1995 name => new
1995 (
1995 name => CallExpr
1995 )
1995 ;
1996 name => c
1996 .
1996 name => init
1996 (
1996 name => p
1996 )
1996 ;
1997 name => c
1997 .
1997 name => Fun
1997 =
1997 name => fun
1997 ;
1999 name => p
1999 .
1999 name => want
1999 (
1999 name => _Lparen
1999 )
1999 ;
2000 name => p
2000 .
2000 name => xnest
2000 opop
2000 ;
2002 for
2002 name => p
2002 .
2002 name => tok
2002 op => != 3
2002 name => _EOF
2002 op => && 2
2002 name => p
2002 .
2002 name => tok
2002 op => != 3
2002 name => _Rparen
2002 {
2003 name => c
2003 .
2003 name => ArgList
2003 =
2003 name => append
2003 (
2003 name => c
2003 .
2003 name => ArgList
2003 ,
2003 name => p
2003 .
2003 name => expr
2003 (
2003 )
2003 )
2003 ;
2004 name => c
2004 .
2004 name => HasDots
2004 =
2004 name => p
2004 .
2004 name => got
2004 (
2004 name => _DotDotDot
2004 )
2004 ;
2005 if
2005 op => ! 0
2005 name => p
2005 .
2005 name => ocomma
2005 (
2005 name => _Rparen
2005 )
2005 op => || 1
2005 name => c
2005 .
2005 name => HasDots
2005 {
2006 break
2006 ;
2007 }
2007 ;
2008 }
2008 ;
2010 name => p
2010 .
2010 name => xnest
2010 opop
2010 ;
2011 if
2011 name => gcCompat
2011 {
2012 name => c
2012 .
2012 name => init
2012 (
2012 name => p
2012 )
2012 ;
2013 }
2013 ;
2014 name => p
2014 .
2014 name => want
2014 (
2014 name => _Rparen
2014 )
2014 ;
2016 return
2016 name => c
2016 ;
2017 }
2017 ;
2022 func
2022 (
2022 name => p
2022 *
2022 name => parser
2022 )
2022 name => name
2022 (
2022 )
2022 *
2022 name => Name
2022 {
2025 name => n
2025 :=
2025 name => new
2025 (
2025 name => Name
2025 )
2025 ;
2026 name => n
2026 .
2026 name => init
2026 (
2026 name => p
2026 )
2026 ;
2028 if
2028 name => p
2028 .
2028 name => tok
2028 op => == 3
2028 name => _Name
2028 {
2029 name => n
2029 .
2029 name => Value
2029 =
2029 name => p
2029 .
2029 name => lit
2029 ;
2030 name => p
2030 .
2030 name => next
2030 (
2030 )
2030 ;
2031 }
2031 else
2031 {
2032 name => n
2032 .
2032 name => Value
2032 =
2032 literal
2032 ;
2033 name => p
2033 .
2033 name => syntax_error
2033 (
2033 literal
2033 )
2033 ;
2034 name => p
2034 .
2034 name => advance
2034 (
2034 )
2034 ;
2035 }
2035 ;
2037 return
2037 name => n
2037 ;
2038 }
2038 ;
2042 func
2042 (
2042 name => p
2042 *
2042 name => parser
2042 )
2042 name => nameList
2042 (
2042 name => first
2042 *
2042 name => Name
2042 )
2042 [
2042 ]
2042 *
2042 name => Name
2042 {
2043 if
2043 name => trace
2043 {
2044 defer
2044 name => p
2044 .
2044 name => trace
2044 (
2044 literal
2044 )
2044 (
2044 )
2044 ;
2045 }
2045 ;
2047 if
2047 name => debug
2047 op => && 2
2047 name => first
2047 op => == 3
2047 name => nil
2047 {
2048 name => panic
2048 (
2048 literal
2048 )
2048 ;
2049 }
2049 ;
2051 name => l
2051 :=
2051 [
2051 ]
2051 *
2051 name => Name
2051 {
2051 name => first
2051 }
2051 ;
2052 for
2052 name => p
2052 .
2052 name => got
2052 (
2052 name => _Comma
2052 )
2052 {
2053 name => l
2053 =
2053 name => append
2053 (
2053 name => l
2053 ,
2053 name => p
2053 .
2053 name => name
2053 (
2053 )
2053 )
2053 ;
2054 }
2054 ;
2056 return
2056 name => l
2056 ;
2057 }
2057 ;
2060 func
2060 (
2060 name => p
2060 *
2060 name => parser
2060 )
2060 name => qualifiedName
2060 (
2060 name => name
2060 *
2060 name => Name
2060 )
2060 name => Expr
2060 {
2061 if
2061 name => trace
2061 {
2062 defer
2062 name => p
2062 .
2062 name => trace
2062 (
2062 literal
2062 )
2062 (
2062 )
2062 ;
2063 }
2063 ;
2065 switch
2065 {
2066 case
2066 name => name
2066 op => != 3
2066 name => nil
2066 :
2068 case
2068 name => p
2068 .
2068 name => tok
2068 op => == 3
2068 name => _Name
2068 :
2069 name => name
2069 =
2069 name => p
2069 .
2069 name => name
2069 (
2069 )
2069 ;
2070 default
2070 :
2071 name => name
2071 =
2071 name => new
2071 (
2071 name => Name
2071 )
2071 ;
2072 name => name
2072 .
2072 name => init
2072 (
2072 name => p
2072 )
2072 ;
2073 name => p
2073 .
2073 name => syntax_error
2073 (
2073 literal
2073 )
2073 ;
2074 name => p
2074 .
2074 name => advance
2074 (
2074 name => _Dot
2074 ,
2074 name => _Semi
2074 ,
2074 name => _Rbrace
2074 )
2074 ;
2075 }
2075 ;
2077 return
2077 name => p
2077 .
2077 name => dotname
2077 (
2077 name => name
2077 )
2077 ;
2078 }
2078 ;
2081 func
2081 (
2081 name => p
2081 *
2081 name => parser
2081 )
2081 name => exprList
2081 (
2081 )
2081 name => Expr
2081 {
2082 if
2082 name => trace
2082 {
2083 defer
2083 name => p
2083 .
2083 name => trace
2083 (
2083 literal
2083 )
2083 (
2083 )
2083 ;
2084 }
2084 ;
2086 name => x
2086 :=
2086 name => p
2086 .
2086 name => expr
2086 (
2086 )
2086 ;
2087 if
2087 name => p
2087 .
2087 name => got
2087 (
2087 name => _Comma
2087 )
2087 {
2088 name => list
2088 :=
2088 [
2088 ]
2088 name => Expr
2088 {
2088 name => x
2088 ,
2088 name => p
2088 .
2088 name => expr
2088 (
2088 )
2088 }
2088 ;
2089 for
2089 name => p
2089 .
2089 name => got
2089 (
2089 name => _Comma
2089 )
2089 {
2090 name => list
2090 =
2090 name => append
2090 (
2090 name => list
2090 ,
2090 name => p
2090 .
2090 name => expr
2090 (
2090 )
2090 )
2090 ;
2091 }
2091 ;
2092 name => t
2092 :=
2092 name => new
2092 (
2092 name => ListExpr
2092 )
2092 ;
2093 name => t
2093 .
2093 name => init
2093 (
2093 name => p
2093 )
2093 ;
2094 name => t
2094 .
2094 name => ElemList
2094 =
2094 name => list
2094 ;
2095 name => x
2095 =
2095 name => t
2095 ;
2096 }
2096 ;
2097 return
2097 name => x
2097 ;
2098 }
2098 ;
2101 func
2101 (
2101 name => p
2101 *
2101 name => parser
2101 )
2101 name => osemi
2101 (
2101 name => follow
2101 name => token
2101 )
2101 name => bool
2101 {
2102 switch
2102 name => p
2102 .
2102 name => tok
2102 {
2103 case
2103 name => _Semi
2103 :
2104 name => p
2104 .
2104 name => next
2104 (
2104 )
2104 ;
2105 return
2105 name => true
2105 ;
2107 case
2107 name => _Rparen
2107 ,
2107 name => _Rbrace
2107 :
2109 return
2109 name => true
2109 ;
2110 }
2110 ;
2112 name => p
2112 .
2112 name => syntax_error
2112 (
2112 literal
2112 op => + 4
2112 name => tokstring
2112 (
2112 name => follow
2112 )
2112 )
2112 ;
2113 name => p
2113 .
2113 name => advance
2113 (
2113 name => follow
2113 )
2113 ;
2114 return
2114 name => false
2114 ;
2115 }
2115 ;
2118 func
2118 (
2118 name => p
2118 *
2118 name => parser
2118 )
2118 name => ocomma
2118 (
2118 name => follow
2118 name => token
2118 )
2118 name => bool
2118 {
2119 switch
2119 name => p
2119 .
2119 name => tok
2119 {
2120 case
2120 name => _Comma
2120 :
2121 name => p
2121 .
2121 name => next
2121 (
2121 )
2121 ;
2122 return
2122 name => true
2122 ;
2124 case
2124 name => _Rparen
2124 ,
2124 name => _Rbrace
2124 :
2126 return
2126 name => true
2126 ;
2127 }
2127 ;
2129 name => p
2129 .
2129 name => syntax_error
2129 (
2129 literal
2129 op => + 4
2129 name => tokstring
2129 (
2129 name => follow
2129 )
2129 )
2129 ;
2130 name => p
2130 .
2130 name => advance
2130 (
2130 name => follow
2130 )
2130 ;
2131 return
2131 name => false
2131 ;
2132 }
2132 ;
2135 func
2135 name => unparen
2135 (
2135 name => x
2135 name => Expr
2135 )
2135 name => Expr
2135 {
2136 for
2136 {
2137 name => p
2137 ,
2137 name => ok
2137 :=
2137 name => x
2137 .
2137 (
2137 *
2137 name => ParenExpr
2137 )
2137 ;
2138 if
2138 op => ! 0
2138 name => ok
2138 {
2139 break
2139 ;
2140 }
2140 ;
2141 name => x
2141 =
2141 name => p
2141 .
2141 name => X
2141 ;
2142 }
2142 ;
2143 return
2143 name => x
2143 ;
2144 }
2144 ;
FAIL
exit status 1
FAIL	cmd/compile/internal/syntax	1.301s
BenchmarkDivconstI64-12    	2000000000	         1.01 ns/op
BenchmarkDivconstU64-12    	2000000000	         1.81 ns/op
BenchmarkDivconstI32-12    	2000000000	         1.75 ns/op
BenchmarkDivconstU32-12    	1000000000	         1.82 ns/op
BenchmarkDivconstI16-12    	1000000000	         1.75 ns/op
BenchmarkDivconstU16-12    	1000000000	         1.88 ns/op
BenchmarkDivconstI8-12     	1000000000	         1.74 ns/op
BenchmarkDivconstU8-12     	1000000000	         1.83 ns/op
PASS
ok  	cmd/compile/internal/test	20.029s
?   	cmd/compile/internal/x86	[no test files]
PASS
ok  	cmd/cover	0.883s
?   	cmd/dist	[no test files]
PASS
ok  	cmd/doc	0.111s
PASS
ok  	cmd/fix	0.020s
