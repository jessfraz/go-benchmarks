hPASS
ok  	archive/tar	0.048s
goos: linux
goarch: amd64
pkg: archive/zip
BenchmarkCompressedZipGarbage-12    	     500	   2183727 ns/op	   25221 B/op	      44 allocs/op
BenchmarkZip64Test-12               	      20	  71658218 ns/op
BenchmarkZip64TestSizes/4096-12     	  200000	      6424 ns/op
BenchmarkZip64TestSizes/1048576-12  	   10000	    217241 ns/op
BenchmarkZip64TestSizes/67108864-12 	     100	  12808558 ns/op
PASS
ok  	archive/zip	14.248s
goos: linux
goarch: amd64
pkg: bufio
BenchmarkReaderCopyOptimal-12       	20000000	       163 ns/op
BenchmarkReaderCopyUnoptimal-12     	 5000000	       257 ns/op
BenchmarkReaderCopyNoWriteTo-12     	  300000	      3631 ns/op
BenchmarkReaderWriteToOptimal-12    	 5000000	       461 ns/op
BenchmarkWriterCopyOptimal-12       	10000000	       171 ns/op
BenchmarkWriterCopyUnoptimal-12     	 5000000	       259 ns/op
BenchmarkWriterCopyNoReadFrom-12    	  300000	      3560 ns/op
BenchmarkReaderEmpty-12             	 2000000	       728 ns/op	    4224 B/op	       3 allocs/op
BenchmarkWriterEmpty-12             	 2000000	       760 ns/op	    4096 B/op	       1 allocs/op
BenchmarkWriterFlush-12             	100000000	        14.8 ns/op	       0 B/op	       0 allocs/op
PASS
ok  	bufio	20.028s
?   	builtin	[no test files]
goos: linux
goarch: amd64
pkg: bytes
BenchmarkReadString-12                     	  200000	      6012 ns/op	5449.87 MB/s
BenchmarkWriteByte-12                      	  100000	     12911 ns/op	 317.23 MB/s
BenchmarkWriteRune-12                      	   50000	     32040 ns/op	 383.52 MB/s
BenchmarkBufferNotEmptyWriteRead-12        	    5000	    363848 ns/op
BenchmarkBufferFullSmallReads-12           	   20000	     93503 ns/op
BenchmarkIndexByte/10-12                   	300000000	         3.96 ns/op	2526.78 MB/s
BenchmarkIndexByte/32-12                   	300000000	         4.68 ns/op	6830.97 MB/s
BenchmarkIndexByte/4K-12                   	20000000	        82.9 ns/op	49416.83 MB/s
BenchmarkIndexByte/4M-12                   	   10000	    134008 ns/op	31298.87 MB/s
BenchmarkIndexByte/64M-12                  	     300	   4525111 ns/op	14830.32 MB/s
BenchmarkIndexBytePortable/10-12           	200000000	         6.89 ns/op	1452.16 MB/s
BenchmarkIndexBytePortable/32-12           	50000000	        26.4 ns/op	1210.12 MB/s
BenchmarkIndexBytePortable/4K-12           	 1000000	      1677 ns/op	2442.42 MB/s
BenchmarkIndexBytePortable/4M-12           	    1000	   1637259 ns/op	2561.78 MB/s
BenchmarkIndexBytePortable/64M-12          	      50	  26467145 ns/op	2535.55 MB/s
BenchmarkIndexRune/10-12                   	100000000	        19.5 ns/op	 512.87 MB/s
BenchmarkIndexRune/32-12                   	100000000	        18.4 ns/op	1739.91 MB/s
BenchmarkIndexRune/4K-12                   	20000000	        97.5 ns/op	42025.07 MB/s
BenchmarkIndexRune/4M-12                   	   10000	    111985 ns/op	37454.15 MB/s
BenchmarkIndexRune/64M-12                  	     300	   4745467 ns/op	14141.68 MB/s
BenchmarkIndexRuneASCII/10-12              	200000000	         6.08 ns/op	1645.02 MB/s
BenchmarkIndexRuneASCII/32-12              	200000000	         7.69 ns/op	4163.70 MB/s
BenchmarkIndexRuneASCII/4K-12              	20000000	        86.6 ns/op	47296.31 MB/s
BenchmarkIndexRuneASCII/4M-12              	   10000	    112186 ns/op	37386.89 MB/s
BenchmarkIndexRuneASCII/64M-12             	     300	   4587081 ns/op	14629.97 MB/s
BenchmarkEqual/0-12                        	500000000	         3.03 ns/op
BenchmarkEqual/1-12                        	500000000	         3.88 ns/op	 257.67 MB/s
BenchmarkEqual/6-12                        	300000000	         3.98 ns/op	1509.26 MB/s
BenchmarkEqual/9-12                        	300000000	         4.80 ns/op	1875.68 MB/s
BenchmarkEqual/15-12                       	300000000	         5.10 ns/op	2941.75 MB/s
BenchmarkEqual/16-12                       	300000000	         5.11 ns/op	3130.23 MB/s
BenchmarkEqual/20-12                       	200000000	         6.09 ns/op	3286.73 MB/s
BenchmarkEqual/32-12                       	200000000	         6.41 ns/op	4989.73 MB/s
BenchmarkEqual/4K-12                       	20000000	        78.9 ns/op	51884.21 MB/s
BenchmarkEqual/4M-12                       	   10000	    193071 ns/op	21724.09 MB/s
BenchmarkEqual/64M-12                      	     200	   9439665 ns/op	7109.24 MB/s
BenchmarkEqualPort/1-12                    	300000000	         4.50 ns/op	 222.21 MB/s
BenchmarkEqualPort/6-12                    	200000000	         7.94 ns/op	 755.65 MB/s
BenchmarkEqualPort/32-12                   	50000000	        23.5 ns/op	1359.14 MB/s
BenchmarkEqualPort/4K-12                   	 1000000	      1974 ns/op	2074.73 MB/s
BenchmarkEqualPort/4M-12                   	     500	   2020843 ns/op	2075.52 MB/s
BenchmarkEqualPort/64M-12                  	      50	  36173149 ns/op	1855.21 MB/s
BenchmarkIndex/10-12                       	100000000	        10.8 ns/op	 923.72 MB/s
BenchmarkIndex/32-12                       	100000000	        11.0 ns/op	2899.50 MB/s
BenchmarkIndex/4K-12                       	  500000	      2437 ns/op	1680.24 MB/s
BenchmarkIndex/4M-12                       	    1000	   2469782 ns/op	1698.25 MB/s
BenchmarkIndex/64M-12                      	      50	  40136926 ns/op	1672.00 MB/s
BenchmarkIndexEasy/10-12                   	200000000	        10.4 ns/op	 963.60 MB/s
BenchmarkIndexEasy/32-12                   	100000000	        11.4 ns/op	2805.63 MB/s
BenchmarkIndexEasy/4K-12                   	20000000	        94.0 ns/op	43582.44 MB/s
BenchmarkIndexEasy/4M-12                   	   10000	    115341 ns/op	36364.27 MB/s
BenchmarkIndexEasy/64M-12                  	     300	   4679219 ns/op	14341.89 MB/s
BenchmarkCount/10-12                       	100000000	        21.3 ns/op	 469.36 MB/s
BenchmarkCount/32-12                       	50000000	        24.3 ns/op	1318.83 MB/s
BenchmarkCount/4K-12                       	 1000000	      2210 ns/op	1852.81 MB/s
BenchmarkCount/4M-12                       	     500	   2631213 ns/op	1594.06 MB/s
BenchmarkCount/64M-12                      	      30	  37537373 ns/op	1787.79 MB/s
BenchmarkCountEasy/10-12                   	100000000	        19.5 ns/op	 512.24 MB/s
BenchmarkCountEasy/32-12                   	50000000	        25.0 ns/op	1282.28 MB/s
BenchmarkCountEasy/4K-12                   	20000000	       115 ns/op	35566.68 MB/s
BenchmarkCountEasy/4M-12                   	   10000	    112745 ns/op	37201.57 MB/s
BenchmarkCountEasy/64M-12                  	     300	   4502560 ns/op	14904.60 MB/s
BenchmarkCountSingle/10-12                 	200000000	         6.59 ns/op	1518.17 MB/s
BenchmarkCountSingle/32-12                 	200000000	         7.88 ns/op	4063.01 MB/s
BenchmarkCountSingle/4K-12                 	20000000	       105 ns/op	38747.36 MB/s
BenchmarkCountSingle/4M-12                 	   10000	    127141 ns/op	32989.25 MB/s
BenchmarkCountSingle/64M-12                	     300	   4924961 ns/op	13626.27 MB/s
BenchmarkFields-12                         	      50	  22171137 ns/op	  47.29 MB/s
BenchmarkFieldsFunc-12                     	     100	  22801830 ns/op	  45.99 MB/s
BenchmarkTrimSpace-12                      	30000000	        40.2 ns/op
BenchmarkSplitEmptySeparator-12            	     100	  22175174 ns/op
BenchmarkSplitSingleByteSeparator-12       	    1000	   2333723 ns/op
BenchmarkSplitMultiByteSeparator-12        	    1000	   1494336 ns/op
BenchmarkSplitNSingleByteSeparator-12      	 5000000	       362 ns/op
BenchmarkSplitNMultiByteSeparator-12       	 5000000	       318 ns/op
BenchmarkRepeat-12                         	20000000	       106 ns/op
BenchmarkBytesCompare/1-12                 	300000000	         4.98 ns/op
BenchmarkBytesCompare/2-12                 	300000000	         5.28 ns/op
BenchmarkBytesCompare/4-12                 	300000000	         5.28 ns/op
BenchmarkBytesCompare/8-12                 	300000000	         4.33 ns/op
BenchmarkBytesCompare/16-12                	300000000	         4.48 ns/op
BenchmarkBytesCompare/32-12                	300000000	         4.90 ns/op
BenchmarkBytesCompare/64-12                	200000000	         6.47 ns/op
BenchmarkBytesCompare/128-12               	200000000	         7.46 ns/op
BenchmarkBytesCompare/256-12               	200000000	         9.87 ns/op
BenchmarkBytesCompare/512-12               	100000000	        15.5 ns/op
BenchmarkBytesCompare/1024-12              	100000000	        24.6 ns/op
BenchmarkBytesCompare/2048-12              	30000000	        46.1 ns/op
BenchmarkIndexAnyASCII/1:1-12              	200000000	         6.54 ns/op
BenchmarkIndexAnyASCII/1:2-12              	200000000	         6.55 ns/op
BenchmarkIndexAnyASCII/1:4-12              	200000000	         8.95 ns/op
BenchmarkIndexAnyASCII/1:8-12              	100000000	        10.4 ns/op
BenchmarkIndexAnyASCII/1:16-12             	100000000	        16.4 ns/op
BenchmarkIndexAnyASCII/16:1-12             	50000000	        24.8 ns/op
BenchmarkIndexAnyASCII/16:2-12             	50000000	        25.1 ns/op
BenchmarkIndexAnyASCII/16:4-12             	50000000	        27.4 ns/op
BenchmarkIndexAnyASCII/16:8-12             	50000000	        36.2 ns/op
BenchmarkIndexAnyASCII/16:16-12            	30000000	        48.0 ns/op
BenchmarkIndexAnyASCII/256:1-12            	 5000000	       227 ns/op
BenchmarkIndexAnyASCII/256:2-12            	10000000	       213 ns/op
BenchmarkIndexAnyASCII/256:4-12            	 5000000	       233 ns/op
BenchmarkIndexAnyASCII/256:8-12            	 5000000	       214 ns/op
BenchmarkIndexAnyASCII/256:16-12           	10000000	       232 ns/op
BenchmarkIndexAnyASCII/4096:1-12           	  500000	      2931 ns/op
BenchmarkIndexAnyASCII/4096:2-12           	  500000	      2909 ns/op
BenchmarkIndexAnyASCII/4096:4-12           	  500000	      3168 ns/op
BenchmarkIndexAnyASCII/4096:8-12           	  500000	      2992 ns/op
BenchmarkIndexAnyASCII/4096:16-12          	  500000	      2920 ns/op
BenchmarkTrimASCII/1:1-12                  	20000000	        61.4 ns/op
BenchmarkTrimASCII/1:2-12                  	20000000	        97.0 ns/op
BenchmarkTrimASCII/1:4-12                  	20000000	       111 ns/op
BenchmarkTrimASCII/1:8-12                  	20000000	       118 ns/op
BenchmarkTrimASCII/1:16-12                 	10000000	       120 ns/op
BenchmarkTrimASCII/16:1-12                 	20000000	       112 ns/op
BenchmarkTrimASCII/16:2-12                 	10000000	       144 ns/op
BenchmarkTrimASCII/16:4-12                 	10000000	       154 ns/op
BenchmarkTrimASCII/16:8-12                 	10000000	       145 ns/op
BenchmarkTrimASCII/16:16-12                	10000000	       159 ns/op
BenchmarkTrimASCII/256:1-12                	 2000000	       808 ns/op
BenchmarkTrimASCII/256:2-12                	 2000000	       840 ns/op
BenchmarkTrimASCII/256:4-12                	 2000000	       792 ns/op
BenchmarkTrimASCII/256:8-12                	 2000000	       857 ns/op
BenchmarkTrimASCII/256:16-12               	 2000000	       864 ns/op
BenchmarkTrimASCII/4096:1-12               	  200000	     11819 ns/op
BenchmarkTrimASCII/4096:2-12               	  100000	     12503 ns/op
BenchmarkTrimASCII/4096:4-12               	  100000	     12717 ns/op
BenchmarkTrimASCII/4096:8-12               	  100000	     11603 ns/op
BenchmarkTrimASCII/4096:16-12              	  100000	     12924 ns/op
BenchmarkCompareBytesEqual-12              	300000000	         4.42 ns/op
BenchmarkCompareBytesToNil-12              	500000000	         3.69 ns/op
BenchmarkCompareBytesEmpty-12              	500000000	         2.83 ns/op
BenchmarkCompareBytesIdentical-12          	500000000	         2.74 ns/op
BenchmarkCompareBytesSameLength-12         	300000000	         4.54 ns/op
BenchmarkCompareBytesDifferentLength-12    	300000000	         4.58 ns/op
BenchmarkCompareBytesBigUnaligned-12       	   30000	     50438 ns/op	20789.59 MB/s
BenchmarkCompareBytesBig-12                	   30000	     49310 ns/op	21264.83 MB/s
BenchmarkCompareBytesBigIdentical-12       	500000000	         3.04 ns/op	345299892.15 MB/s
PASS
ok  	bytes	274.253s
PASS
ok  	cmd/addr2line	0.864s
goos: linux
goarch: amd64
pkg: cmd/api
BenchmarkAll-12    	       1	4218509360 ns/op
PASS
ok  	cmd/api	4.665s
?   	cmd/asm	[no test files]
?   	cmd/asm/internal/arch	[no test files]
PASS
ok  	cmd/asm/internal/asm	0.198s
?   	cmd/asm/internal/flags	[no test files]
PASS
ok  	cmd/asm/internal/lex	0.015s
?   	cmd/cgo	[no test files]

PASS
ok  	cmd/compile	2.724s
?   	cmd/compile/internal/amd64	[no test files]
?   	cmd/compile/internal/arm	[no test files]
?   	cmd/compile/internal/arm64	[no test files]
goos: linux
goarch: amd64
pkg: cmd/compile/internal/gc
BenchmarkMul2-12            	 3000000	       369 ns/op
BenchmarkMulNeg2-12         	 3000000	       383 ns/op
BenchmarkEfaceInteger-12    	1000000000	         2.46 ns/op
PASS
ok  	cmd/compile/internal/gc	9.505s
?   	cmd/compile/internal/mips	[no test files]
?   	cmd/compile/internal/mips64	[no test files]
?   	cmd/compile/internal/ppc64	[no test files]
?   	cmd/compile/internal/s390x	[no test files]
goos: linux
goarch: amd64
pkg: cmd/compile/internal/ssa
BenchmarkCopyElim1-12               	   30000	     46508 ns/op
BenchmarkCopyElim10-12              	   30000	     46564 ns/op
BenchmarkCopyElim100-12             	   10000	    100157 ns/op
BenchmarkCopyElim1000-12            	    3000	    614389 ns/op
BenchmarkCopyElim10000-12           	     100	  19055510 ns/op
BenchmarkCopyElim100000-12          	      10	 175398299 ns/op
BenchmarkDeadCode/1-12              	   30000	     43687 ns/op
BenchmarkDeadCode/10-12             	   30000	     53490 ns/op
BenchmarkDeadCode/100-12            	   10000	    102757 ns/op
BenchmarkDeadCode/1000-12           	    2000	    628081 ns/op
BenchmarkDeadCode/10000-12          	     200	   6679828 ns/op
BenchmarkDeadCode/100000-12         	      20	 121349857 ns/op
BenchmarkDeadCode/200000-12         	       5	 211185919 ns/op
BenchmarkDominatorsLinear-12        	    2000	   1283582 ns/op	   7.79 MB/s
BenchmarkDominatorsFwdBack-12       	    1000	   2137662 ns/op	   4.68 MB/s
BenchmarkDominatorsManyPred-12      	    1000	   1496435 ns/op	   6.68 MB/s
BenchmarkDominatorsMaxPred-12       	    1000	   1831512 ns/op	   5.46 MB/s
BenchmarkDominatorsMaxPredVal-12    	    2000	   1756603 ns/op	   5.69 MB/s
BenchmarkFuse/1-12                  	   10000	    133900 ns/op
BenchmarkFuse/10-12                 	   10000	    133156 ns/op
BenchmarkFuse/100-12                	   10000	    201813 ns/op
BenchmarkFuse/1000-12               	    1000	   1359335 ns/op
BenchmarkFuse/10000-12              	     100	  19044218 ns/op
BenchmarkNilCheckDeep1-12           	 1000000	      1116 ns/op	   0.90 MB/s	     101 B/op	       6 allocs/op
BenchmarkNilCheckDeep10-12          	 1000000	      1785 ns/op	   5.60 MB/s	     192 B/op	       6 allocs/op
BenchmarkNilCheckDeep100-12         	  200000	      9772 ns/op	  10.23 MB/s	    1168 B/op	       6 allocs/op
BenchmarkNilCheckDeep1000-12        	   20000	     63888 ns/op	  15.65 MB/s	   10304 B/op	       6 allocs/op
BenchmarkNilCheckDeep10000-12       	    2000	    851331 ns/op	  11.75 MB/s	  102504 B/op	       6 allocs/op
BenchmarkDSEPass-12                 	    5000	    293701 ns/op	   41208 B/op	       8 allocs/op
BenchmarkDSEPassBlock-12            	     300	   4805554 ns/op	  555673 B/op	     400 allocs/op
BenchmarkCSEPass-12                 	     500	   2862380 ns/op	  188640 B/op	       9 allocs/op
BenchmarkCSEPassBlock-12            	     100	  38347212 ns/op	 3104405 B/op	    1350 allocs/op
BenchmarkDeadcodePass-12            	   30000	     56076 ns/op	   10505 B/op	       3 allocs/op
BenchmarkDeadcodePassBlock-12       	    2000	   1076401 ns/op	  153696 B/op	      22 allocs/op
BenchmarkMultiPass-12               	   10000	    139877 ns/op	  240024 B/op	      11 allocs/op
BenchmarkMultiPassBlock-12          	    1000	   2155931 ns/op	 3600322 B/op	     165 allocs/op
PASS
ok  	cmd/compile/internal/ssa	156.792s
     1  *syntax.File {
     2  .  PkgName: syntax @ parser.go:5:9
     3  .  DeclList: []syntax.Decl (82 entries) {
     4  .  .  0: *syntax.ImportDecl {
     5  .  .  .  LocalPkgName: nil
     6  .  .  .  Path: *syntax.BasicLit {
     7  .  .  .  .  Value: "\"cmd/internal/src\""
     8  .  .  .  .  Kind: 4
     9  .  .  .  }
    10  .  .  .  Group: *syntax.Group {}
    11  .  .  }
    12  .  .  1: *syntax.ImportDecl {
    13  .  .  .  LocalPkgName: nil
    14  .  .  .  Path: *syntax.BasicLit {
    15  .  .  .  .  Value: "\"fmt\""
    16  .  .  .  .  Kind: 4
    17  .  .  .  }
    18  .  .  .  Group: *syntax.Group {}
    19  .  .  }
    20  .  .  2: *syntax.ImportDecl {
    21  .  .  .  LocalPkgName: nil
    22  .  .  .  Path: *syntax.BasicLit {
    23  .  .  .  .  Value: "\"io\""
    24  .  .  .  .  Kind: 4
    25  .  .  .  }
    26  .  .  .  Group: *syntax.Group {}
    27  .  .  }
    28  .  .  3: *syntax.ImportDecl {
    29  .  .  .  LocalPkgName: nil
    30  .  .  .  Path: *syntax.BasicLit {
    31  .  .  .  .  Value: "\"strconv\""
    32  .  .  .  .  Kind: 4
    33  .  .  .  }
    34  .  .  .  Group: *syntax.Group {}
    35  .  .  }
    36  .  .  4: *syntax.ImportDecl {
    37  .  .  .  LocalPkgName: nil
    38  .  .  .  Path: *syntax.BasicLit {
    39  .  .  .  .  Value: "\"strings\""
    40  .  .  .  .  Kind: 4
    41  .  .  .  }
    42  .  .  .  Group: *syntax.Group {}
    43  .  .  }
    44  .  .  5: *syntax.ConstDecl {
    45  .  .  .  NameList: []*syntax.Name (1 entries) {
    46  .  .  .  .  0: debug @ parser.go:15:7
    47  .  .  .  }
    48  .  .  .  Type: nil
    49  .  .  .  Values: false @ parser.go:15:15
    50  .  .  .  Group: nil
    51  .  .  }
    52  .  .  6: *syntax.ConstDecl {
    53  .  .  .  NameList: []*syntax.Name (1 entries) {
    54  .  .  .  .  0: trace @ parser.go:16:7
    55  .  .  .  }
    56  .  .  .  Type: nil
    57  .  .  .  Values: false @ parser.go:16:15
    58  .  .  .  Group: nil
    59  .  .  }
    60  .  .  7: *syntax.TypeDecl {
    61  .  .  .  Name: parser @ parser.go:18:6
    62  .  .  .  Alias: false
    63  .  .  .  Type: *syntax.StructType {
    64  .  .  .  .  FieldList: []*syntax.Field (9 entries) {
    65  .  .  .  .  .  0: *syntax.Field {
    66  .  .  .  .  .  .  Name: base @ parser.go:19:2
    67  .  .  .  .  .  .  Type: *syntax.Operation {
    68  .  .  .  .  .  .  .  Op: *
    69  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
    70  .  .  .  .  .  .  .  .  X: src @ parser.go:19:8
    71  .  .  .  .  .  .  .  .  Sel: PosBase @ parser.go:19:12
    72  .  .  .  .  .  .  .  }
    73  .  .  .  .  .  .  .  Y: nil
    74  .  .  .  .  .  .  }
    75  .  .  .  .  .  }
    76  .  .  .  .  .  1: *syntax.Field {
    77  .  .  .  .  .  .  Name: errh @ parser.go:20:2
    78  .  .  .  .  .  .  Type: ErrorHandler @ parser.go:20:7
    79  .  .  .  .  .  }
    80  .  .  .  .  .  2: *syntax.Field {
    81  .  .  .  .  .  .  Name: mode @ parser.go:21:2
    82  .  .  .  .  .  .  Type: Mode @ parser.go:21:7
    83  .  .  .  .  .  }
    84  .  .  .  .  .  3: *syntax.Field {
    85  .  .  .  .  .  .  Name: nil
    86  .  .  .  .  .  .  Type: scanner @ parser.go:22:2
    87  .  .  .  .  .  }
    88  .  .  .  .  .  4: *syntax.Field {
    89  .  .  .  .  .  .  Name: first @ parser.go:24:2
    90  .  .  .  .  .  .  Type: error @ parser.go:24:9
    91  .  .  .  .  .  }
    92  .  .  .  .  .  5: *syntax.Field {
    93  .  .  .  .  .  .  Name: pragma @ parser.go:25:2
    94  .  .  .  .  .  .  Type: Pragma @ parser.go:25:9
    95  .  .  .  .  .  }
    96  .  .  .  .  .  6: *syntax.Field {
    97  .  .  .  .  .  .  Name: fnest @ parser.go:27:2
    98  .  .  .  .  .  .  Type: int @ parser.go:27:9
    99  .  .  .  .  .  }
   100  .  .  .  .  .  7: *syntax.Field {
   101  .  .  .  .  .  .  Name: xnest @ parser.go:28:2
   102  .  .  .  .  .  .  Type: int @ parser.go:28:9
   103  .  .  .  .  .  }
   104  .  .  .  .  .  8: *syntax.Field {
   105  .  .  .  .  .  .  Name: indent @ parser.go:29:2
   106  .  .  .  .  .  .  Type: *syntax.SliceType {
   107  .  .  .  .  .  .  .  Elem: byte @ parser.go:29:11
   108  .  .  .  .  .  .  }
   109  .  .  .  .  .  }
   110  .  .  .  .  }
   111  .  .  .  .  TagList: nil
   112  .  .  .  }
   113  .  .  .  Group: nil
   114  .  .  .  Pragma: 0
   115  .  .  }
   116  .  .  8: *syntax.FuncDecl {
   117  .  .  .  Attr: map[]
   118  .  .  .  Recv: *syntax.Field {
   119  .  .  .  .  Name: p @ parser.go:32:7
   120  .  .  .  .  Type: *syntax.Operation {
   121  .  .  .  .  .  Op: *
   122  .  .  .  .  .  X: parser @ parser.go:32:10
   123  .  .  .  .  .  Y: nil
   124  .  .  .  .  }
   125  .  .  .  }
   126  .  .  .  Name: init @ parser.go:32:18
   127  .  .  .  Type: *syntax.FuncType {
   128  .  .  .  .  ParamList: []*syntax.Field (5 entries) {
   129  .  .  .  .  .  0: *syntax.Field {
   130  .  .  .  .  .  .  Name: base @ parser.go:32:23
   131  .  .  .  .  .  .  Type: *syntax.Operation {
   132  .  .  .  .  .  .  .  Op: *
   133  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   134  .  .  .  .  .  .  .  .  X: src @ parser.go:32:29
   135  .  .  .  .  .  .  .  .  Sel: PosBase @ parser.go:32:33
   136  .  .  .  .  .  .  .  }
   137  .  .  .  .  .  .  .  Y: nil
   138  .  .  .  .  .  .  }
   139  .  .  .  .  .  }
   140  .  .  .  .  .  1: *syntax.Field {
   141  .  .  .  .  .  .  Name: r @ parser.go:32:42
   142  .  .  .  .  .  .  Type: *syntax.SelectorExpr {
   143  .  .  .  .  .  .  .  X: io @ parser.go:32:44
   144  .  .  .  .  .  .  .  Sel: Reader @ parser.go:32:47
   145  .  .  .  .  .  .  }
   146  .  .  .  .  .  }
   147  .  .  .  .  .  2: *syntax.Field {
   148  .  .  .  .  .  .  Name: errh @ parser.go:32:55
   149  .  .  .  .  .  .  Type: ErrorHandler @ parser.go:32:60
   150  .  .  .  .  .  }
   151  .  .  .  .  .  3: *syntax.Field {
   152  .  .  .  .  .  .  Name: pragh @ parser.go:32:74
   153  .  .  .  .  .  .  Type: PragmaHandler @ parser.go:32:80
   154  .  .  .  .  .  }
   155  .  .  .  .  .  4: *syntax.Field {
   156  .  .  .  .  .  .  Name: mode @ parser.go:32:95
   157  .  .  .  .  .  .  Type: Mode @ parser.go:32:100
   158  .  .  .  .  .  }
   159  .  .  .  .  }
   160  .  .  .  .  ResultList: nil
   161  .  .  .  }
   162  .  .  .  Body: *syntax.BlockStmt {
   163  .  .  .  .  List: []syntax.Stmt (9 entries) {
   164  .  .  .  .  .  0: *syntax.AssignStmt {
   165  .  .  .  .  .  .  Op: <op-0>
   166  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   167  .  .  .  .  .  .  .  X: p @ parser.go:33:2
   168  .  .  .  .  .  .  .  Sel: base @ parser.go:33:4
   169  .  .  .  .  .  .  }
   170  .  .  .  .  .  .  Rhs: base @ parser.go:33:11
   171  .  .  .  .  .  }
   172  .  .  .  .  .  1: *syntax.AssignStmt {
   173  .  .  .  .  .  .  Op: <op-0>
   174  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   175  .  .  .  .  .  .  .  X: p @ parser.go:34:2
   176  .  .  .  .  .  .  .  Sel: errh @ parser.go:34:4
   177  .  .  .  .  .  .  }
   178  .  .  .  .  .  .  Rhs: errh @ parser.go:34:11
   179  .  .  .  .  .  }
   180  .  .  .  .  .  2: *syntax.AssignStmt {
   181  .  .  .  .  .  .  Op: <op-0>
   182  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   183  .  .  .  .  .  .  .  X: p @ parser.go:35:2
   184  .  .  .  .  .  .  .  Sel: mode @ parser.go:35:4
   185  .  .  .  .  .  .  }
   186  .  .  .  .  .  .  Rhs: mode @ parser.go:35:11
   187  .  .  .  .  .  }
   188  .  .  .  .  .  3: *syntax.ExprStmt {
   189  .  .  .  .  .  .  X: *syntax.CallExpr {
   190  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   191  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   192  .  .  .  .  .  .  .  .  .  X: p @ parser.go:36:2
   193  .  .  .  .  .  .  .  .  .  Sel: scanner @ parser.go:36:4
   194  .  .  .  .  .  .  .  .  }
   195  .  .  .  .  .  .  .  .  Sel: init @ parser.go:36:12
   196  .  .  .  .  .  .  .  }
   197  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
   198  .  .  .  .  .  .  .  .  0: r @ parser.go:37:3
   199  .  .  .  .  .  .  .  .  1: *syntax.FuncLit {
   200  .  .  .  .  .  .  .  .  .  Type: *syntax.FuncType {
   201  .  .  .  .  .  .  .  .  .  .  ParamList: []*syntax.Field (3 entries) {
   202  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.Field {
   203  .  .  .  .  .  .  .  .  .  .  .  .  Name: line @ parser.go:43:8
   204  .  .  .  .  .  .  .  .  .  .  .  .  Type: uint @ parser.go:43:18
   205  .  .  .  .  .  .  .  .  .  .  .  }
   206  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.Field {
   207  .  .  .  .  .  .  .  .  .  .  .  .  Name: col @ parser.go:43:14
   208  .  .  .  .  .  .  .  .  .  .  .  .  Type: uint @ parser.go:43:18
   209  .  .  .  .  .  .  .  .  .  .  .  }
   210  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.Field {
   211  .  .  .  .  .  .  .  .  .  .  .  .  Name: msg @ parser.go:43:24
   212  .  .  .  .  .  .  .  .  .  .  .  .  Type: string @ parser.go:43:28
   213  .  .  .  .  .  .  .  .  .  .  .  }
   214  .  .  .  .  .  .  .  .  .  .  }
   215  .  .  .  .  .  .  .  .  .  .  ResultList: nil
   216  .  .  .  .  .  .  .  .  .  }
   217  .  .  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
   218  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
   219  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
   220  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   221  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   222  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:44:4
   223  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error_at @ parser.go:44:6
   224  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   225  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
   226  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
   227  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   228  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:44:15
   229  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos_at @ parser.go:44:17
   230  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   231  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
   232  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: line @ parser.go:44:24
   233  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: col @ parser.go:44:30
   234  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   235  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   236  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   237  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: msg @ parser.go:44:36
   238  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   239  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   240  .  .  .  .  .  .  .  .  .  .  .  .  }
   241  .  .  .  .  .  .  .  .  .  .  .  }
   242  .  .  .  .  .  .  .  .  .  .  }
   243  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
   244  .  .  .  .  .  .  .  .  .  }
   245  .  .  .  .  .  .  .  .  }
   246  .  .  .  .  .  .  .  .  2: *syntax.FuncLit {
   247  .  .  .  .  .  .  .  .  .  Type: *syntax.FuncType {
   248  .  .  .  .  .  .  .  .  .  .  ParamList: []*syntax.Field (3 entries) {
   249  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.Field {
   250  .  .  .  .  .  .  .  .  .  .  .  .  Name: line @ parser.go:46:8
   251  .  .  .  .  .  .  .  .  .  .  .  .  Type: uint @ parser.go:46:18
   252  .  .  .  .  .  .  .  .  .  .  .  }
   253  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.Field {
   254  .  .  .  .  .  .  .  .  .  .  .  .  Name: col @ parser.go:46:14
   255  .  .  .  .  .  .  .  .  .  .  .  .  Type: uint @ parser.go:46:18
   256  .  .  .  .  .  .  .  .  .  .  .  }
   257  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.Field {
   258  .  .  .  .  .  .  .  .  .  .  .  .  Name: text @ parser.go:46:24
   259  .  .  .  .  .  .  .  .  .  .  .  .  Type: string @ parser.go:46:29
   260  .  .  .  .  .  .  .  .  .  .  .  }
   261  .  .  .  .  .  .  .  .  .  .  }
   262  .  .  .  .  .  .  .  .  .  .  ResultList: nil
   263  .  .  .  .  .  .  .  .  .  }
   264  .  .  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
   265  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
   266  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
   267  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
   268  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
   269  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   270  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: strings @ parser.go:47:7
   271  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: HasPrefix @ parser.go:47:15
   272  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   273  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
   274  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: text @ parser.go:47:25
   275  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
   276  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"line \""
   277  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   278  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   279  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   280  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   281  .  .  .  .  .  .  .  .  .  .  .  .  }
   282  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
   283  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
   284  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
   285  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   286  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   287  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:48:5
   288  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: updateBase @ parser.go:48:7
   289  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   290  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
   291  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: line @ parser.go:48:18
   292  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.Operation {
   293  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
   294  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: col @ parser.go:48:24
   295  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
   296  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "5"
   297  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
   298  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   299  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   300  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.SliceExpr {
   301  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: text @ parser.go:48:31
   302  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: [0xc420078b40 <nil> <nil>]
   303  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Full: false
   304  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   305  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   306  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   307  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   308  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   309  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
   310  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: nil
   311  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   312  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   313  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
   314  .  .  .  .  .  .  .  .  .  .  .  .  }
   315  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
   316  .  .  .  .  .  .  .  .  .  .  .  }
   317  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
   318  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
   319  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
   320  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
   321  .  .  .  .  .  .  .  .  .  .  .  .  .  X: pragh @ parser.go:51:7
   322  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:51:16
   323  .  .  .  .  .  .  .  .  .  .  .  .  }
   324  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
   325  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
   326  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
   327  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
   328  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   329  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:52:5
   330  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pragma @ parser.go:52:7
   331  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   332  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
   333  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: pragh @ parser.go:52:17
   334  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
   335  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
   336  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   337  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:52:23
   338  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos_at @ parser.go:52:25
   339  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   340  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
   341  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: line @ parser.go:52:32
   342  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: col @ parser.go:52:38
   343  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   344  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   345  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   346  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: text @ parser.go:52:44
   347  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   348  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   349  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   350  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   351  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   352  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
   353  .  .  .  .  .  .  .  .  .  .  .  .  }
   354  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
   355  .  .  .  .  .  .  .  .  .  .  .  }
   356  .  .  .  .  .  .  .  .  .  .  }
   357  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
   358  .  .  .  .  .  .  .  .  .  }
   359  .  .  .  .  .  .  .  .  }
   360  .  .  .  .  .  .  .  }
   361  .  .  .  .  .  .  .  HasDots: false
   362  .  .  .  .  .  .  }
   363  .  .  .  .  .  }
   364  .  .  .  .  .  4: *syntax.AssignStmt {
   365  .  .  .  .  .  .  Op: <op-0>
   366  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   367  .  .  .  .  .  .  .  X: p @ parser.go:57:2
   368  .  .  .  .  .  .  .  Sel: first @ parser.go:57:4
   369  .  .  .  .  .  .  }
   370  .  .  .  .  .  .  Rhs: nil @ parser.go:57:12
   371  .  .  .  .  .  }
   372  .  .  .  .  .  5: *syntax.AssignStmt {
   373  .  .  .  .  .  .  Op: <op-0>
   374  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   375  .  .  .  .  .  .  .  X: p @ parser.go:58:2
   376  .  .  .  .  .  .  .  Sel: pragma @ parser.go:58:4
   377  .  .  .  .  .  .  }
   378  .  .  .  .  .  .  Rhs: *syntax.BasicLit {
   379  .  .  .  .  .  .  .  Value: "0"
   380  .  .  .  .  .  .  .  Kind: 0
   381  .  .  .  .  .  .  }
   382  .  .  .  .  .  }
   383  .  .  .  .  .  6: *syntax.AssignStmt {
   384  .  .  .  .  .  .  Op: <op-0>
   385  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   386  .  .  .  .  .  .  .  X: p @ parser.go:60:2
   387  .  .  .  .  .  .  .  Sel: fnest @ parser.go:60:4
   388  .  .  .  .  .  .  }
   389  .  .  .  .  .  .  Rhs: *syntax.BasicLit {
   390  .  .  .  .  .  .  .  Value: "0"
   391  .  .  .  .  .  .  .  Kind: 0
   392  .  .  .  .  .  .  }
   393  .  .  .  .  .  }
   394  .  .  .  .  .  7: *syntax.AssignStmt {
   395  .  .  .  .  .  .  Op: <op-0>
   396  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   397  .  .  .  .  .  .  .  X: p @ parser.go:61:2
   398  .  .  .  .  .  .  .  Sel: xnest @ parser.go:61:4
   399  .  .  .  .  .  .  }
   400  .  .  .  .  .  .  Rhs: *syntax.BasicLit {
   401  .  .  .  .  .  .  .  Value: "0"
   402  .  .  .  .  .  .  .  Kind: 0
   403  .  .  .  .  .  .  }
   404  .  .  .  .  .  }
   405  .  .  .  .  .  8: *syntax.AssignStmt {
   406  .  .  .  .  .  .  Op: <op-0>
   407  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   408  .  .  .  .  .  .  .  X: p @ parser.go:62:2
   409  .  .  .  .  .  .  .  Sel: indent @ parser.go:62:4
   410  .  .  .  .  .  .  }
   411  .  .  .  .  .  .  Rhs: nil @ parser.go:62:13
   412  .  .  .  .  .  }
   413  .  .  .  .  }
   414  .  .  .  .  Rbrace: src.Pos {}
   415  .  .  .  }
   416  .  .  .  Pragma: 0
   417  .  .  }
   418  .  .  9: *syntax.ConstDecl {
   419  .  .  .  NameList: []*syntax.Name (1 entries) {
   420  .  .  .  .  0: lineMax @ parser.go:65:7
   421  .  .  .  }
   422  .  .  .  Type: nil
   423  .  .  .  Values: *syntax.Operation {
   424  .  .  .  .  Op: -
   425  .  .  .  .  X: *syntax.Operation {
   426  .  .  .  .  .  Op: <<
   427  .  .  .  .  .  X: *syntax.BasicLit {
   428  .  .  .  .  .  .  Value: "1"
   429  .  .  .  .  .  .  Kind: 0
   430  .  .  .  .  .  }
   431  .  .  .  .  .  Y: *syntax.BasicLit {
   432  .  .  .  .  .  .  Value: "24"
   433  .  .  .  .  .  .  Kind: 0
   434  .  .  .  .  .  }
   435  .  .  .  .  }
   436  .  .  .  .  Y: *syntax.BasicLit {
   437  .  .  .  .  .  Value: "1"
   438  .  .  .  .  .  Kind: 0
   439  .  .  .  .  }
   440  .  .  .  }
   441  .  .  .  Group: nil
   442  .  .  }
   443  .  .  10: *syntax.FuncDecl {
   444  .  .  .  Attr: map[]
   445  .  .  .  Recv: *syntax.Field {
   446  .  .  .  .  Name: p @ parser.go:67:7
   447  .  .  .  .  Type: *syntax.Operation {
   448  .  .  .  .  .  Op: *
   449  .  .  .  .  .  X: parser @ parser.go:67:10
   450  .  .  .  .  .  Y: nil
   451  .  .  .  .  }
   452  .  .  .  }
   453  .  .  .  Name: updateBase @ parser.go:67:18
   454  .  .  .  Type: *syntax.FuncType {
   455  .  .  .  .  ParamList: []*syntax.Field (3 entries) {
   456  .  .  .  .  .  0: *syntax.Field {
   457  .  .  .  .  .  .  Name: line @ parser.go:67:29
   458  .  .  .  .  .  .  Type: uint @ parser.go:67:39
   459  .  .  .  .  .  }
   460  .  .  .  .  .  1: *syntax.Field {
   461  .  .  .  .  .  .  Name: col @ parser.go:67:35
   462  .  .  .  .  .  .  Type: uint @ parser.go:67:39
   463  .  .  .  .  .  }
   464  .  .  .  .  .  2: *syntax.Field {
   465  .  .  .  .  .  .  Name: text @ parser.go:67:45
   466  .  .  .  .  .  .  Type: string @ parser.go:67:50
   467  .  .  .  .  .  }
   468  .  .  .  .  }
   469  .  .  .  .  ResultList: nil
   470  .  .  .  }
   471  .  .  .  Body: *syntax.BlockStmt {
   472  .  .  .  .  List: []syntax.Stmt (6 entries) {
   473  .  .  .  .  .  0: *syntax.AssignStmt {
   474  .  .  .  .  .  .  Op: :
   475  .  .  .  .  .  .  Lhs: i @ parser.go:69:2
   476  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
   477  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   478  .  .  .  .  .  .  .  .  X: strings @ parser.go:69:7
   479  .  .  .  .  .  .  .  .  Sel: LastIndex @ parser.go:69:15
   480  .  .  .  .  .  .  .  }
   481  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
   482  .  .  .  .  .  .  .  .  0: text @ parser.go:69:25
   483  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
   484  .  .  .  .  .  .  .  .  .  Value: "\":\""
   485  .  .  .  .  .  .  .  .  .  Kind: 4
   486  .  .  .  .  .  .  .  .  }
   487  .  .  .  .  .  .  .  }
   488  .  .  .  .  .  .  .  HasDots: false
   489  .  .  .  .  .  .  }
   490  .  .  .  .  .  }
   491  .  .  .  .  .  1: *syntax.IfStmt {
   492  .  .  .  .  .  .  Init: nil
   493  .  .  .  .  .  .  Cond: *syntax.Operation {
   494  .  .  .  .  .  .  .  Op: <
   495  .  .  .  .  .  .  .  X: i @ parser.go:70:5
   496  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
   497  .  .  .  .  .  .  .  .  Value: "0"
   498  .  .  .  .  .  .  .  .  Kind: 0
   499  .  .  .  .  .  .  .  }
   500  .  .  .  .  .  .  }
   501  .  .  .  .  .  .  Then: *syntax.BlockStmt {
   502  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
   503  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
   504  .  .  .  .  .  .  .  .  .  Results: nil
   505  .  .  .  .  .  .  .  .  }
   506  .  .  .  .  .  .  .  }
   507  .  .  .  .  .  .  .  Rbrace: src.Pos {}
   508  .  .  .  .  .  .  }
   509  .  .  .  .  .  .  Else: nil
   510  .  .  .  .  .  }
   511  .  .  .  .  .  2: *syntax.AssignStmt {
   512  .  .  .  .  .  .  Op: :
   513  .  .  .  .  .  .  Lhs: nstr @ parser.go:73:2
   514  .  .  .  .  .  .  Rhs: *syntax.SliceExpr {
   515  .  .  .  .  .  .  .  X: text @ parser.go:73:10
   516  .  .  .  .  .  .  .  Index: [0xc4200573c0 <nil> <nil>]
   517  .  .  .  .  .  .  .  Full: false
   518  .  .  .  .  .  .  }
   519  .  .  .  .  .  }
   520  .  .  .  .  .  3: *syntax.AssignStmt {
   521  .  .  .  .  .  .  Op: :
   522  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
   523  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
   524  .  .  .  .  .  .  .  .  0: n @ parser.go:74:2
   525  .  .  .  .  .  .  .  .  1: err @ parser.go:74:5
   526  .  .  .  .  .  .  .  }
   527  .  .  .  .  .  .  }
   528  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
   529  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   530  .  .  .  .  .  .  .  .  X: strconv @ parser.go:74:12
   531  .  .  .  .  .  .  .  .  Sel: Atoi @ parser.go:74:20
   532  .  .  .  .  .  .  .  }
   533  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
   534  .  .  .  .  .  .  .  .  0: nstr @ parser.go:74:25
   535  .  .  .  .  .  .  .  }
   536  .  .  .  .  .  .  .  HasDots: false
   537  .  .  .  .  .  .  }
   538  .  .  .  .  .  }
   539  .  .  .  .  .  4: *syntax.IfStmt {
   540  .  .  .  .  .  .  Init: nil
   541  .  .  .  .  .  .  Cond: *syntax.Operation {
   542  .  .  .  .  .  .  .  Op: ||
   543  .  .  .  .  .  .  .  X: *syntax.Operation {
   544  .  .  .  .  .  .  .  .  Op: ||
   545  .  .  .  .  .  .  .  .  X: *syntax.Operation {
   546  .  .  .  .  .  .  .  .  .  Op: !=
   547  .  .  .  .  .  .  .  .  .  X: err @ parser.go:75:5
   548  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:75:12
   549  .  .  .  .  .  .  .  .  }
   550  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
   551  .  .  .  .  .  .  .  .  .  Op: <=
   552  .  .  .  .  .  .  .  .  .  X: n @ parser.go:75:19
   553  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
   554  .  .  .  .  .  .  .  .  .  .  Value: "0"
   555  .  .  .  .  .  .  .  .  .  .  Kind: 0
   556  .  .  .  .  .  .  .  .  .  }
   557  .  .  .  .  .  .  .  .  }
   558  .  .  .  .  .  .  .  }
   559  .  .  .  .  .  .  .  Y: *syntax.Operation {
   560  .  .  .  .  .  .  .  .  Op: >
   561  .  .  .  .  .  .  .  .  X: n @ parser.go:75:29
   562  .  .  .  .  .  .  .  .  Y: lineMax @ parser.go:75:33
   563  .  .  .  .  .  .  .  }
   564  .  .  .  .  .  .  }
   565  .  .  .  .  .  .  Then: *syntax.BlockStmt {
   566  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
   567  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
   568  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   569  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   570  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:76:3
   571  .  .  .  .  .  .  .  .  .  .  .  Sel: error_at @ parser.go:76:5
   572  .  .  .  .  .  .  .  .  .  .  }
   573  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
   574  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
   575  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   576  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:76:14
   577  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos_at @ parser.go:76:16
   578  .  .  .  .  .  .  .  .  .  .  .  .  }
   579  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
   580  .  .  .  .  .  .  .  .  .  .  .  .  .  0: line @ parser.go:76:23
   581  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.Operation {
   582  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
   583  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: col @ parser.go:76:29
   584  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
   585  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: uint @ parser.go:76:33
   586  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
   587  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
   588  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
   589  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: i @ parser.go:76:38
   590  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
   591  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
   592  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
   593  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   594  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   595  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   596  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   597  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   598  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   599  .  .  .  .  .  .  .  .  .  .  .  .  }
   600  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   601  .  .  .  .  .  .  .  .  .  .  .  }
   602  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.Operation {
   603  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
   604  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   605  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"invalid line number: \""
   606  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   607  .  .  .  .  .  .  .  .  .  .  .  .  }
   608  .  .  .  .  .  .  .  .  .  .  .  .  Y: nstr @ parser.go:76:69
   609  .  .  .  .  .  .  .  .  .  .  .  }
   610  .  .  .  .  .  .  .  .  .  .  }
   611  .  .  .  .  .  .  .  .  .  .  HasDots: false
   612  .  .  .  .  .  .  .  .  .  }
   613  .  .  .  .  .  .  .  .  }
   614  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
   615  .  .  .  .  .  .  .  .  .  Results: nil
   616  .  .  .  .  .  .  .  .  }
   617  .  .  .  .  .  .  .  }
   618  .  .  .  .  .  .  .  Rbrace: src.Pos {}
   619  .  .  .  .  .  .  }
   620  .  .  .  .  .  .  Else: nil
   621  .  .  .  .  .  }
   622  .  .  .  .  .  5: *syntax.AssignStmt {
   623  .  .  .  .  .  .  Op: <op-0>
   624  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   625  .  .  .  .  .  .  .  X: p @ parser.go:79:2
   626  .  .  .  .  .  .  .  Sel: base @ parser.go:79:4
   627  .  .  .  .  .  .  }
   628  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
   629  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   630  .  .  .  .  .  .  .  .  X: src @ parser.go:79:11
   631  .  .  .  .  .  .  .  .  Sel: NewLinePragmaBase @ parser.go:79:15
   632  .  .  .  .  .  .  .  }
   633  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
   634  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
   635  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   636  .  .  .  .  .  .  .  .  .  .  X: src @ parser.go:79:33
   637  .  .  .  .  .  .  .  .  .  .  Sel: MakePos @ parser.go:79:37
   638  .  .  .  .  .  .  .  .  .  }
   639  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
   640  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
   641  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   642  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   643  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   644  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   645  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:79:45
   646  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: base @ parser.go:79:47
   647  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   648  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:79:52
   649  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   650  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
   651  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   652  .  .  .  .  .  .  .  .  .  .  .  .  }
   653  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Base @ parser.go:79:58
   654  .  .  .  .  .  .  .  .  .  .  .  }
   655  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
   656  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   657  .  .  .  .  .  .  .  .  .  .  }
   658  .  .  .  .  .  .  .  .  .  .  1: line @ parser.go:79:66
   659  .  .  .  .  .  .  .  .  .  .  2: col @ parser.go:79:72
   660  .  .  .  .  .  .  .  .  .  }
   661  .  .  .  .  .  .  .  .  .  HasDots: false
   662  .  .  .  .  .  .  .  .  }
   663  .  .  .  .  .  .  .  .  1: *syntax.SliceExpr {
   664  .  .  .  .  .  .  .  .  .  X: text @ parser.go:79:78
   665  .  .  .  .  .  .  .  .  .  Index: [<nil> 0xc42000b8a0 <nil>]
   666  .  .  .  .  .  .  .  .  .  Full: false
   667  .  .  .  .  .  .  .  .  }
   668  .  .  .  .  .  .  .  .  2: *syntax.CallExpr {
   669  .  .  .  .  .  .  .  .  .  Fun: uint @ parser.go:79:88
   670  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
   671  .  .  .  .  .  .  .  .  .  .  0: n @ parser.go:79:93
   672  .  .  .  .  .  .  .  .  .  }
   673  .  .  .  .  .  .  .  .  .  HasDots: false
   674  .  .  .  .  .  .  .  .  }
   675  .  .  .  .  .  .  .  }
   676  .  .  .  .  .  .  .  HasDots: false
   677  .  .  .  .  .  .  }
   678  .  .  .  .  .  }
   679  .  .  .  .  }
   680  .  .  .  .  Rbrace: src.Pos {}
   681  .  .  .  }
   682  .  .  .  Pragma: 0
   683  .  .  }
   684  .  .  11: *syntax.FuncDecl {
   685  .  .  .  Attr: map[]
   686  .  .  .  Recv: *syntax.Field {
   687  .  .  .  .  Name: p @ parser.go:82:7
   688  .  .  .  .  Type: *syntax.Operation {
   689  .  .  .  .  .  Op: *
   690  .  .  .  .  .  X: parser @ parser.go:82:10
   691  .  .  .  .  .  Y: nil
   692  .  .  .  .  }
   693  .  .  .  }
   694  .  .  .  Name: got @ parser.go:82:18
   695  .  .  .  Type: *syntax.FuncType {
   696  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
   697  .  .  .  .  .  0: *syntax.Field {
   698  .  .  .  .  .  .  Name: tok @ parser.go:82:22
   699  .  .  .  .  .  .  Type: token @ parser.go:82:26
   700  .  .  .  .  .  }
   701  .  .  .  .  }
   702  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
   703  .  .  .  .  .  0: *syntax.Field {
   704  .  .  .  .  .  .  Name: nil
   705  .  .  .  .  .  .  Type: bool @ parser.go:82:33
   706  .  .  .  .  .  }
   707  .  .  .  .  }
   708  .  .  .  }
   709  .  .  .  Body: *syntax.BlockStmt {
   710  .  .  .  .  List: []syntax.Stmt (2 entries) {
   711  .  .  .  .  .  0: *syntax.IfStmt {
   712  .  .  .  .  .  .  Init: nil
   713  .  .  .  .  .  .  Cond: *syntax.Operation {
   714  .  .  .  .  .  .  .  Op: ==
   715  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   716  .  .  .  .  .  .  .  .  X: p @ parser.go:83:5
   717  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:83:7
   718  .  .  .  .  .  .  .  }
   719  .  .  .  .  .  .  .  Y: tok @ parser.go:83:14
   720  .  .  .  .  .  .  }
   721  .  .  .  .  .  .  Then: *syntax.BlockStmt {
   722  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
   723  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
   724  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   725  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   726  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:84:3
   727  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:84:5
   728  .  .  .  .  .  .  .  .  .  .  }
   729  .  .  .  .  .  .  .  .  .  .  ArgList: nil
   730  .  .  .  .  .  .  .  .  .  .  HasDots: false
   731  .  .  .  .  .  .  .  .  .  }
   732  .  .  .  .  .  .  .  .  }
   733  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
   734  .  .  .  .  .  .  .  .  .  Results: true @ parser.go:85:10
   735  .  .  .  .  .  .  .  .  }
   736  .  .  .  .  .  .  .  }
   737  .  .  .  .  .  .  .  Rbrace: src.Pos {}
   738  .  .  .  .  .  .  }
   739  .  .  .  .  .  .  Else: nil
   740  .  .  .  .  .  }
   741  .  .  .  .  .  1: *syntax.ReturnStmt {
   742  .  .  .  .  .  .  Results: false @ parser.go:87:9
   743  .  .  .  .  .  }
   744  .  .  .  .  }
   745  .  .  .  .  Rbrace: src.Pos {}
   746  .  .  .  }
   747  .  .  .  Pragma: 0
   748  .  .  }
   749  .  .  12: *syntax.FuncDecl {
   750  .  .  .  Attr: map[]
   751  .  .  .  Recv: *syntax.Field {
   752  .  .  .  .  Name: p @ parser.go:90:7
   753  .  .  .  .  Type: *syntax.Operation {
   754  .  .  .  .  .  Op: *
   755  .  .  .  .  .  X: parser @ parser.go:90:10
   756  .  .  .  .  .  Y: nil
   757  .  .  .  .  }
   758  .  .  .  }
   759  .  .  .  Name: want @ parser.go:90:18
   760  .  .  .  Type: *syntax.FuncType {
   761  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
   762  .  .  .  .  .  0: *syntax.Field {
   763  .  .  .  .  .  .  Name: tok @ parser.go:90:23
   764  .  .  .  .  .  .  Type: token @ parser.go:90:27
   765  .  .  .  .  .  }
   766  .  .  .  .  }
   767  .  .  .  .  ResultList: nil
   768  .  .  .  }
   769  .  .  .  Body: *syntax.BlockStmt {
   770  .  .  .  .  List: []syntax.Stmt (1 entries) {
   771  .  .  .  .  .  0: *syntax.IfStmt {
   772  .  .  .  .  .  .  Init: nil
   773  .  .  .  .  .  .  Cond: *syntax.Operation {
   774  .  .  .  .  .  .  .  Op: !
   775  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   776  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   777  .  .  .  .  .  .  .  .  .  X: p @ parser.go:91:6
   778  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:91:8
   779  .  .  .  .  .  .  .  .  }
   780  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
   781  .  .  .  .  .  .  .  .  .  0: tok @ parser.go:91:12
   782  .  .  .  .  .  .  .  .  }
   783  .  .  .  .  .  .  .  .  HasDots: false
   784  .  .  .  .  .  .  .  }
   785  .  .  .  .  .  .  .  Y: nil
   786  .  .  .  .  .  .  }
   787  .  .  .  .  .  .  Then: *syntax.BlockStmt {
   788  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
   789  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
   790  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   791  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   792  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:92:3
   793  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:92:5
   794  .  .  .  .  .  .  .  .  .  .  }
   795  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
   796  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
   797  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
   798  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
   799  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting \""
   800  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
   801  .  .  .  .  .  .  .  .  .  .  .  .  }
   802  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
   803  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   804  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: tok @ parser.go:92:33
   805  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: String @ parser.go:92:37
   806  .  .  .  .  .  .  .  .  .  .  .  .  .  }
   807  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
   808  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
   809  .  .  .  .  .  .  .  .  .  .  .  .  }
   810  .  .  .  .  .  .  .  .  .  .  .  }
   811  .  .  .  .  .  .  .  .  .  .  }
   812  .  .  .  .  .  .  .  .  .  .  HasDots: false
   813  .  .  .  .  .  .  .  .  .  }
   814  .  .  .  .  .  .  .  .  }
   815  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
   816  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   817  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   818  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:93:3
   819  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:93:5
   820  .  .  .  .  .  .  .  .  .  .  }
   821  .  .  .  .  .  .  .  .  .  .  ArgList: nil
   822  .  .  .  .  .  .  .  .  .  .  HasDots: false
   823  .  .  .  .  .  .  .  .  .  }
   824  .  .  .  .  .  .  .  .  }
   825  .  .  .  .  .  .  .  }
   826  .  .  .  .  .  .  .  Rbrace: src.Pos {}
   827  .  .  .  .  .  .  }
   828  .  .  .  .  .  .  Else: nil
   829  .  .  .  .  .  }
   830  .  .  .  .  }
   831  .  .  .  .  Rbrace: src.Pos {}
   832  .  .  .  }
   833  .  .  .  Pragma: 0
   834  .  .  }
   835  .  .  13: *syntax.FuncDecl {
   836  .  .  .  Attr: map[]
   837  .  .  .  Recv: *syntax.Field {
   838  .  .  .  .  Name: p @ parser.go:101:7
   839  .  .  .  .  Type: *syntax.Operation {
   840  .  .  .  .  .  Op: *
   841  .  .  .  .  .  X: parser @ parser.go:101:10
   842  .  .  .  .  .  Y: nil
   843  .  .  .  .  }
   844  .  .  .  }
   845  .  .  .  Name: pos_at @ parser.go:101:18
   846  .  .  .  Type: *syntax.FuncType {
   847  .  .  .  .  ParamList: []*syntax.Field (2 entries) {
   848  .  .  .  .  .  0: *syntax.Field {
   849  .  .  .  .  .  .  Name: line @ parser.go:101:25
   850  .  .  .  .  .  .  Type: uint @ parser.go:101:35
   851  .  .  .  .  .  }
   852  .  .  .  .  .  1: *syntax.Field {
   853  .  .  .  .  .  .  Name: col @ parser.go:101:31
   854  .  .  .  .  .  .  Type: uint @ parser.go:101:35
   855  .  .  .  .  .  }
   856  .  .  .  .  }
   857  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
   858  .  .  .  .  .  0: *syntax.Field {
   859  .  .  .  .  .  .  Name: nil
   860  .  .  .  .  .  .  Type: *syntax.SelectorExpr {
   861  .  .  .  .  .  .  .  X: src @ parser.go:101:41
   862  .  .  .  .  .  .  .  Sel: Pos @ parser.go:101:45
   863  .  .  .  .  .  .  }
   864  .  .  .  .  .  }
   865  .  .  .  .  }
   866  .  .  .  }
   867  .  .  .  Body: *syntax.BlockStmt {
   868  .  .  .  .  List: []syntax.Stmt (1 entries) {
   869  .  .  .  .  .  0: *syntax.ReturnStmt {
   870  .  .  .  .  .  .  Results: *syntax.CallExpr {
   871  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   872  .  .  .  .  .  .  .  .  X: src @ parser.go:102:9
   873  .  .  .  .  .  .  .  .  Sel: MakePos @ parser.go:102:13
   874  .  .  .  .  .  .  .  }
   875  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
   876  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
   877  .  .  .  .  .  .  .  .  .  X: p @ parser.go:102:21
   878  .  .  .  .  .  .  .  .  .  Sel: base @ parser.go:102:23
   879  .  .  .  .  .  .  .  .  }
   880  .  .  .  .  .  .  .  .  1: line @ parser.go:102:29
   881  .  .  .  .  .  .  .  .  2: col @ parser.go:102:35
   882  .  .  .  .  .  .  .  }
   883  .  .  .  .  .  .  .  HasDots: false
   884  .  .  .  .  .  .  }
   885  .  .  .  .  .  }
   886  .  .  .  .  }
   887  .  .  .  .  Rbrace: src.Pos {}
   888  .  .  .  }
   889  .  .  .  Pragma: 0
   890  .  .  }
   891  .  .  14: *syntax.FuncDecl {
   892  .  .  .  Attr: map[]
   893  .  .  .  Recv: *syntax.Field {
   894  .  .  .  .  Name: p @ parser.go:106:7
   895  .  .  .  .  Type: *syntax.Operation {
   896  .  .  .  .  .  Op: *
   897  .  .  .  .  .  X: parser @ parser.go:106:10
   898  .  .  .  .  .  Y: nil
   899  .  .  .  .  }
   900  .  .  .  }
   901  .  .  .  Name: error_at @ parser.go:106:18
   902  .  .  .  Type: *syntax.FuncType {
   903  .  .  .  .  ParamList: []*syntax.Field (2 entries) {
   904  .  .  .  .  .  0: *syntax.Field {
   905  .  .  .  .  .  .  Name: pos @ parser.go:106:27
   906  .  .  .  .  .  .  Type: *syntax.SelectorExpr {
   907  .  .  .  .  .  .  .  X: src @ parser.go:106:31
   908  .  .  .  .  .  .  .  Sel: Pos @ parser.go:106:35
   909  .  .  .  .  .  .  }
   910  .  .  .  .  .  }
   911  .  .  .  .  .  1: *syntax.Field {
   912  .  .  .  .  .  .  Name: msg @ parser.go:106:40
   913  .  .  .  .  .  .  Type: string @ parser.go:106:44
   914  .  .  .  .  .  }
   915  .  .  .  .  }
   916  .  .  .  .  ResultList: nil
   917  .  .  .  }
   918  .  .  .  Body: *syntax.BlockStmt {
   919  .  .  .  .  List: []syntax.Stmt (4 entries) {
   920  .  .  .  .  .  0: *syntax.AssignStmt {
   921  .  .  .  .  .  .  Op: :
   922  .  .  .  .  .  .  Lhs: err @ parser.go:107:2
   923  .  .  .  .  .  .  Rhs: *syntax.CompositeLit {
   924  .  .  .  .  .  .  .  Type: Error @ parser.go:107:9
   925  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
   926  .  .  .  .  .  .  .  .  0: pos @ parser.go:107:15
   927  .  .  .  .  .  .  .  .  1: msg @ parser.go:107:20
   928  .  .  .  .  .  .  .  }
   929  .  .  .  .  .  .  .  NKeys: 0
   930  .  .  .  .  .  .  .  Rbrace: src.Pos {}
   931  .  .  .  .  .  .  }
   932  .  .  .  .  .  }
   933  .  .  .  .  .  1: *syntax.IfStmt {
   934  .  .  .  .  .  .  Init: nil
   935  .  .  .  .  .  .  Cond: *syntax.Operation {
   936  .  .  .  .  .  .  .  Op: ==
   937  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   938  .  .  .  .  .  .  .  .  X: p @ parser.go:108:5
   939  .  .  .  .  .  .  .  .  Sel: first @ parser.go:108:7
   940  .  .  .  .  .  .  .  }
   941  .  .  .  .  .  .  .  Y: nil @ parser.go:108:16
   942  .  .  .  .  .  .  }
   943  .  .  .  .  .  .  Then: *syntax.BlockStmt {
   944  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
   945  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
   946  .  .  .  .  .  .  .  .  .  Op: <op-0>
   947  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
   948  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:109:3
   949  .  .  .  .  .  .  .  .  .  .  Sel: first @ parser.go:109:5
   950  .  .  .  .  .  .  .  .  .  }
   951  .  .  .  .  .  .  .  .  .  Rhs: err @ parser.go:109:13
   952  .  .  .  .  .  .  .  .  }
   953  .  .  .  .  .  .  .  }
   954  .  .  .  .  .  .  .  Rbrace: src.Pos {}
   955  .  .  .  .  .  .  }
   956  .  .  .  .  .  .  Else: nil
   957  .  .  .  .  .  }
   958  .  .  .  .  .  2: *syntax.IfStmt {
   959  .  .  .  .  .  .  Init: nil
   960  .  .  .  .  .  .  Cond: *syntax.Operation {
   961  .  .  .  .  .  .  .  Op: ==
   962  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
   963  .  .  .  .  .  .  .  .  X: p @ parser.go:111:5
   964  .  .  .  .  .  .  .  .  Sel: errh @ parser.go:111:7
   965  .  .  .  .  .  .  .  }
   966  .  .  .  .  .  .  .  Y: nil @ parser.go:111:15
   967  .  .  .  .  .  .  }
   968  .  .  .  .  .  .  Then: *syntax.BlockStmt {
   969  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
   970  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
   971  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
   972  .  .  .  .  .  .  .  .  .  .  Fun: panic @ parser.go:112:3
   973  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
   974  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
   975  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:112:9
   976  .  .  .  .  .  .  .  .  .  .  .  .  Sel: first @ parser.go:112:11
   977  .  .  .  .  .  .  .  .  .  .  .  }
   978  .  .  .  .  .  .  .  .  .  .  }
   979  .  .  .  .  .  .  .  .  .  .  HasDots: false
   980  .  .  .  .  .  .  .  .  .  }
   981  .  .  .  .  .  .  .  .  }
   982  .  .  .  .  .  .  .  }
   983  .  .  .  .  .  .  .  Rbrace: src.Pos {}
   984  .  .  .  .  .  .  }
   985  .  .  .  .  .  .  Else: nil
   986  .  .  .  .  .  }
   987  .  .  .  .  .  3: *syntax.ExprStmt {
   988  .  .  .  .  .  .  X: *syntax.CallExpr {
   989  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
   990  .  .  .  .  .  .  .  .  X: p @ parser.go:114:2
   991  .  .  .  .  .  .  .  .  Sel: errh @ parser.go:114:4
   992  .  .  .  .  .  .  .  }
   993  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
   994  .  .  .  .  .  .  .  .  0: err @ parser.go:114:9
   995  .  .  .  .  .  .  .  }
   996  .  .  .  .  .  .  .  HasDots: false
   997  .  .  .  .  .  .  }
   998  .  .  .  .  .  }
   999  .  .  .  .  }
  1000  .  .  .  .  Rbrace: src.Pos {}
  1001  .  .  .  }
  1002  .  .  .  Pragma: 0
  1003  .  .  }
  1004  .  .  15: *syntax.FuncDecl {
  1005  .  .  .  Attr: map[]
  1006  .  .  .  Recv: *syntax.Field {
  1007  .  .  .  .  Name: p @ parser.go:118:7
  1008  .  .  .  .  Type: *syntax.Operation {
  1009  .  .  .  .  .  Op: *
  1010  .  .  .  .  .  X: parser @ parser.go:118:10
  1011  .  .  .  .  .  Y: nil
  1012  .  .  .  .  }
  1013  .  .  .  }
  1014  .  .  .  Name: syntax_error_at @ parser.go:118:18
  1015  .  .  .  Type: *syntax.FuncType {
  1016  .  .  .  .  ParamList: []*syntax.Field (2 entries) {
  1017  .  .  .  .  .  0: *syntax.Field {
  1018  .  .  .  .  .  .  Name: pos @ parser.go:118:34
  1019  .  .  .  .  .  .  Type: *syntax.SelectorExpr {
  1020  .  .  .  .  .  .  .  X: src @ parser.go:118:38
  1021  .  .  .  .  .  .  .  Sel: Pos @ parser.go:118:42
  1022  .  .  .  .  .  .  }
  1023  .  .  .  .  .  }
  1024  .  .  .  .  .  1: *syntax.Field {
  1025  .  .  .  .  .  .  Name: msg @ parser.go:118:47
  1026  .  .  .  .  .  .  Type: string @ parser.go:118:51
  1027  .  .  .  .  .  }
  1028  .  .  .  .  }
  1029  .  .  .  .  ResultList: nil
  1030  .  .  .  }
  1031  .  .  .  Body: *syntax.BlockStmt {
  1032  .  .  .  .  List: []syntax.Stmt (6 entries) {
  1033  .  .  .  .  .  0: *syntax.IfStmt {
  1034  .  .  .  .  .  .  Init: nil
  1035  .  .  .  .  .  .  Cond: trace @ parser.go:119:5
  1036  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  1037  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  1038  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  1039  .  .  .  .  .  .  .  .  .  Tok: defer
  1040  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  1041  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  1042  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1043  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:120:9
  1044  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:120:11
  1045  .  .  .  .  .  .  .  .  .  .  .  }
  1046  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1047  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
  1048  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
  1049  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1050  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
  1051  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1052  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"syntax_error (\""
  1053  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1054  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1055  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: msg @ parser.go:120:36
  1056  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1057  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  1058  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\")\""
  1059  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1060  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1061  .  .  .  .  .  .  .  .  .  .  .  .  }
  1062  .  .  .  .  .  .  .  .  .  .  .  }
  1063  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1064  .  .  .  .  .  .  .  .  .  .  }
  1065  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  1066  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1067  .  .  .  .  .  .  .  .  .  }
  1068  .  .  .  .  .  .  .  .  }
  1069  .  .  .  .  .  .  .  }
  1070  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  1071  .  .  .  .  .  .  }
  1072  .  .  .  .  .  .  Else: nil
  1073  .  .  .  .  .  }
  1074  .  .  .  .  .  1: *syntax.IfStmt {
  1075  .  .  .  .  .  .  Init: nil
  1076  .  .  .  .  .  .  Cond: *syntax.Operation {
  1077  .  .  .  .  .  .  .  Op: &&
  1078  .  .  .  .  .  .  .  X: *syntax.Operation {
  1079  .  .  .  .  .  .  .  .  Op: ==
  1080  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1081  .  .  .  .  .  .  .  .  .  X: p @ parser.go:123:5
  1082  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:123:7
  1083  .  .  .  .  .  .  .  .  }
  1084  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:123:14
  1085  .  .  .  .  .  .  .  }
  1086  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1087  .  .  .  .  .  .  .  .  Op: !=
  1088  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1089  .  .  .  .  .  .  .  .  .  X: p @ parser.go:123:22
  1090  .  .  .  .  .  .  .  .  .  Sel: first @ parser.go:123:24
  1091  .  .  .  .  .  .  .  .  }
  1092  .  .  .  .  .  .  .  .  Y: nil @ parser.go:123:33
  1093  .  .  .  .  .  .  .  }
  1094  .  .  .  .  .  .  }
  1095  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  1096  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  1097  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  1098  .  .  .  .  .  .  .  .  .  Results: nil
  1099  .  .  .  .  .  .  .  .  }
  1100  .  .  .  .  .  .  .  }
  1101  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  1102  .  .  .  .  .  .  }
  1103  .  .  .  .  .  .  Else: nil
  1104  .  .  .  .  .  }
  1105  .  .  .  .  .  2: *syntax.SwitchStmt {
  1106  .  .  .  .  .  .  Init: nil
  1107  .  .  .  .  .  .  Tag: nil
  1108  .  .  .  .  .  .  Body: []*syntax.CaseClause (4 entries) {
  1109  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  1110  .  .  .  .  .  .  .  .  Cases: *syntax.Operation {
  1111  .  .  .  .  .  .  .  .  .  Op: ==
  1112  .  .  .  .  .  .  .  .  .  X: msg @ parser.go:129:7
  1113  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  1114  .  .  .  .  .  .  .  .  .  .  Value: "\"\""
  1115  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1116  .  .  .  .  .  .  .  .  .  }
  1117  .  .  .  .  .  .  .  .  }
  1118  .  .  .  .  .  .  .  .  Body: nil
  1119  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1120  .  .  .  .  .  .  .  }
  1121  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  1122  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  1123  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (3 entries) {
  1124  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  1125  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1126  .  .  .  .  .  .  .  .  .  .  .  .  X: strings @ parser.go:131:7
  1127  .  .  .  .  .  .  .  .  .  .  .  .  Sel: HasPrefix @ parser.go:131:15
  1128  .  .  .  .  .  .  .  .  .  .  .  }
  1129  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1130  .  .  .  .  .  .  .  .  .  .  .  .  0: msg @ parser.go:131:25
  1131  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
  1132  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"in\""
  1133  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1134  .  .  .  .  .  .  .  .  .  .  .  .  }
  1135  .  .  .  .  .  .  .  .  .  .  .  }
  1136  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1137  .  .  .  .  .  .  .  .  .  .  }
  1138  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
  1139  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1140  .  .  .  .  .  .  .  .  .  .  .  .  X: strings @ parser.go:131:37
  1141  .  .  .  .  .  .  .  .  .  .  .  .  Sel: HasPrefix @ parser.go:131:45
  1142  .  .  .  .  .  .  .  .  .  .  .  }
  1143  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1144  .  .  .  .  .  .  .  .  .  .  .  .  0: msg @ parser.go:131:55
  1145  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
  1146  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"at\""
  1147  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1148  .  .  .  .  .  .  .  .  .  .  .  .  }
  1149  .  .  .  .  .  .  .  .  .  .  .  }
  1150  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1151  .  .  .  .  .  .  .  .  .  .  }
  1152  .  .  .  .  .  .  .  .  .  .  2: *syntax.CallExpr {
  1153  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1154  .  .  .  .  .  .  .  .  .  .  .  .  X: strings @ parser.go:131:67
  1155  .  .  .  .  .  .  .  .  .  .  .  .  Sel: HasPrefix @ parser.go:131:75
  1156  .  .  .  .  .  .  .  .  .  .  .  }
  1157  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1158  .  .  .  .  .  .  .  .  .  .  .  .  0: msg @ parser.go:131:85
  1159  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
  1160  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"after\""
  1161  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1162  .  .  .  .  .  .  .  .  .  .  .  .  }
  1163  .  .  .  .  .  .  .  .  .  .  .  }
  1164  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1165  .  .  .  .  .  .  .  .  .  .  }
  1166  .  .  .  .  .  .  .  .  .  }
  1167  .  .  .  .  .  .  .  .  }
  1168  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1169  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  1170  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  1171  .  .  .  .  .  .  .  .  .  .  Lhs: msg @ parser.go:132:3
  1172  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
  1173  .  .  .  .  .  .  .  .  .  .  .  Op: +
  1174  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1175  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\" \""
  1176  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1177  .  .  .  .  .  .  .  .  .  .  .  }
  1178  .  .  .  .  .  .  .  .  .  .  .  Y: msg @ parser.go:132:15
  1179  .  .  .  .  .  .  .  .  .  .  }
  1180  .  .  .  .  .  .  .  .  .  }
  1181  .  .  .  .  .  .  .  .  }
  1182  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1183  .  .  .  .  .  .  .  }
  1184  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  1185  .  .  .  .  .  .  .  .  Cases: *syntax.CallExpr {
  1186  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1187  .  .  .  .  .  .  .  .  .  .  X: strings @ parser.go:133:7
  1188  .  .  .  .  .  .  .  .  .  .  Sel: HasPrefix @ parser.go:133:15
  1189  .  .  .  .  .  .  .  .  .  }
  1190  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1191  .  .  .  .  .  .  .  .  .  .  0: msg @ parser.go:133:25
  1192  .  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
  1193  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting\""
  1194  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1195  .  .  .  .  .  .  .  .  .  .  }
  1196  .  .  .  .  .  .  .  .  .  }
  1197  .  .  .  .  .  .  .  .  .  HasDots: false
  1198  .  .  .  .  .  .  .  .  }
  1199  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1200  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  1201  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  1202  .  .  .  .  .  .  .  .  .  .  Lhs: msg @ parser.go:134:3
  1203  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
  1204  .  .  .  .  .  .  .  .  .  .  .  Op: +
  1205  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1206  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\", \""
  1207  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1208  .  .  .  .  .  .  .  .  .  .  .  }
  1209  .  .  .  .  .  .  .  .  .  .  .  Y: msg @ parser.go:134:16
  1210  .  .  .  .  .  .  .  .  .  .  }
  1211  .  .  .  .  .  .  .  .  .  }
  1212  .  .  .  .  .  .  .  .  }
  1213  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1214  .  .  .  .  .  .  .  }
  1215  .  .  .  .  .  .  .  3: *syntax.CaseClause {
  1216  .  .  .  .  .  .  .  .  Cases: nil
  1217  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  1218  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1219  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1220  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1221  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:137:3
  1222  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error_at @ parser.go:137:5
  1223  .  .  .  .  .  .  .  .  .  .  .  }
  1224  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1225  .  .  .  .  .  .  .  .  .  .  .  .  0: pos @ parser.go:137:14
  1226  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.Operation {
  1227  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
  1228  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1229  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"syntax error: \""
  1230  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1231  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1232  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: msg @ parser.go:137:36
  1233  .  .  .  .  .  .  .  .  .  .  .  .  }
  1234  .  .  .  .  .  .  .  .  .  .  .  }
  1235  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1236  .  .  .  .  .  .  .  .  .  .  }
  1237  .  .  .  .  .  .  .  .  .  }
  1238  .  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
  1239  .  .  .  .  .  .  .  .  .  .  Results: nil
  1240  .  .  .  .  .  .  .  .  .  }
  1241  .  .  .  .  .  .  .  .  }
  1242  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1243  .  .  .  .  .  .  .  }
  1244  .  .  .  .  .  .  }
  1245  .  .  .  .  .  .  Rbrace: src.Pos {}
  1246  .  .  .  .  .  }
  1247  .  .  .  .  .  3: *syntax.DeclStmt {
  1248  .  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
  1249  .  .  .  .  .  .  .  0: *syntax.VarDecl {
  1250  .  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
  1251  .  .  .  .  .  .  .  .  .  0: tok @ parser.go:142:6
  1252  .  .  .  .  .  .  .  .  }
  1253  .  .  .  .  .  .  .  .  Type: string @ parser.go:142:10
  1254  .  .  .  .  .  .  .  .  Values: nil
  1255  .  .  .  .  .  .  .  .  Group: nil
  1256  .  .  .  .  .  .  .  }
  1257  .  .  .  .  .  .  }
  1258  .  .  .  .  .  }
  1259  .  .  .  .  .  4: *syntax.SwitchStmt {
  1260  .  .  .  .  .  .  Init: nil
  1261  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  1262  .  .  .  .  .  .  .  X: p @ parser.go:143:9
  1263  .  .  .  .  .  .  .  Sel: tok @ parser.go:143:11
  1264  .  .  .  .  .  .  }
  1265  .  .  .  .  .  .  Body: []*syntax.CaseClause (6 entries) {
  1266  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  1267  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  1268  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  1269  .  .  .  .  .  .  .  .  .  .  0: _Name @ parser.go:144:7
  1270  .  .  .  .  .  .  .  .  .  .  1: _Semi @ parser.go:144:14
  1271  .  .  .  .  .  .  .  .  .  }
  1272  .  .  .  .  .  .  .  .  }
  1273  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1274  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  1275  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  1276  .  .  .  .  .  .  .  .  .  .  Lhs: tok @ parser.go:145:3
  1277  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  1278  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:145:9
  1279  .  .  .  .  .  .  .  .  .  .  .  Sel: lit @ parser.go:145:11
  1280  .  .  .  .  .  .  .  .  .  .  }
  1281  .  .  .  .  .  .  .  .  .  }
  1282  .  .  .  .  .  .  .  .  }
  1283  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1284  .  .  .  .  .  .  .  }
  1285  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  1286  .  .  .  .  .  .  .  .  Cases: _Literal @ parser.go:146:7
  1287  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1288  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  1289  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  1290  .  .  .  .  .  .  .  .  .  .  Lhs: tok @ parser.go:147:3
  1291  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
  1292  .  .  .  .  .  .  .  .  .  .  .  Op: +
  1293  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1294  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"literal \""
  1295  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1296  .  .  .  .  .  .  .  .  .  .  .  }
  1297  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.SelectorExpr {
  1298  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:147:22
  1299  .  .  .  .  .  .  .  .  .  .  .  .  Sel: lit @ parser.go:147:24
  1300  .  .  .  .  .  .  .  .  .  .  .  }
  1301  .  .  .  .  .  .  .  .  .  .  }
  1302  .  .  .  .  .  .  .  .  .  }
  1303  .  .  .  .  .  .  .  .  }
  1304  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1305  .  .  .  .  .  .  .  }
  1306  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  1307  .  .  .  .  .  .  .  .  Cases: _Operator @ parser.go:148:7
  1308  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1309  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  1310  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  1311  .  .  .  .  .  .  .  .  .  .  Lhs: tok @ parser.go:149:3
  1312  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  1313  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1314  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1315  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:149:9
  1316  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: op @ parser.go:149:11
  1317  .  .  .  .  .  .  .  .  .  .  .  .  }
  1318  .  .  .  .  .  .  .  .  .  .  .  .  Sel: String @ parser.go:149:14
  1319  .  .  .  .  .  .  .  .  .  .  .  }
  1320  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  1321  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1322  .  .  .  .  .  .  .  .  .  .  }
  1323  .  .  .  .  .  .  .  .  .  }
  1324  .  .  .  .  .  .  .  .  }
  1325  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1326  .  .  .  .  .  .  .  }
  1327  .  .  .  .  .  .  .  3: *syntax.CaseClause {
  1328  .  .  .  .  .  .  .  .  Cases: _AssignOp @ parser.go:150:7
  1329  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1330  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  1331  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  1332  .  .  .  .  .  .  .  .  .  .  Lhs: tok @ parser.go:151:3
  1333  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
  1334  .  .  .  .  .  .  .  .  .  .  .  Op: +
  1335  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1336  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1337  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1338  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:151:9
  1339  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: op @ parser.go:151:11
  1340  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1341  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: String @ parser.go:151:14
  1342  .  .  .  .  .  .  .  .  .  .  .  .  }
  1343  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  1344  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1345  .  .  .  .  .  .  .  .  .  .  .  }
  1346  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  1347  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"=\""
  1348  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1349  .  .  .  .  .  .  .  .  .  .  .  }
  1350  .  .  .  .  .  .  .  .  .  .  }
  1351  .  .  .  .  .  .  .  .  .  }
  1352  .  .  .  .  .  .  .  .  }
  1353  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1354  .  .  .  .  .  .  .  }
  1355  .  .  .  .  .  .  .  4: *syntax.CaseClause {
  1356  .  .  .  .  .  .  .  .  Cases: _IncOp @ parser.go:152:7
  1357  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  1358  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  1359  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  1360  .  .  .  .  .  .  .  .  .  .  Lhs: tok @ parser.go:153:3
  1361  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  1362  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1363  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1364  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:153:9
  1365  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: op @ parser.go:153:11
  1366  .  .  .  .  .  .  .  .  .  .  .  .  }
  1367  .  .  .  .  .  .  .  .  .  .  .  .  Sel: String @ parser.go:153:14
  1368  .  .  .  .  .  .  .  .  .  .  .  }
  1369  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  1370  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1371  .  .  .  .  .  .  .  .  .  .  }
  1372  .  .  .  .  .  .  .  .  .  }
  1373  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  1374  .  .  .  .  .  .  .  .  .  .  Op: +
  1375  .  .  .  .  .  .  .  .  .  .  Lhs: tok @ parser.go:154:3
  1376  .  .  .  .  .  .  .  .  .  .  Rhs: tok @ parser.go:154:10
  1377  .  .  .  .  .  .  .  .  .  }
  1378  .  .  .  .  .  .  .  .  }
  1379  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1380  .  .  .  .  .  .  .  }
  1381  .  .  .  .  .  .  .  5: *syntax.CaseClause {
  1382  .  .  .  .  .  .  .  .  Cases: nil
  1383  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1384  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  1385  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  1386  .  .  .  .  .  .  .  .  .  .  Lhs: tok @ parser.go:156:3
  1387  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  1388  .  .  .  .  .  .  .  .  .  .  .  Fun: tokstring @ parser.go:156:9
  1389  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1390  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  1391  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:156:19
  1392  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:156:21
  1393  .  .  .  .  .  .  .  .  .  .  .  .  }
  1394  .  .  .  .  .  .  .  .  .  .  .  }
  1395  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1396  .  .  .  .  .  .  .  .  .  .  }
  1397  .  .  .  .  .  .  .  .  .  }
  1398  .  .  .  .  .  .  .  .  }
  1399  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1400  .  .  .  .  .  .  .  }
  1401  .  .  .  .  .  .  }
  1402  .  .  .  .  .  .  Rbrace: src.Pos {}
  1403  .  .  .  .  .  }
  1404  .  .  .  .  .  5: *syntax.ExprStmt {
  1405  .  .  .  .  .  .  X: *syntax.CallExpr {
  1406  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1407  .  .  .  .  .  .  .  .  X: p @ parser.go:159:2
  1408  .  .  .  .  .  .  .  .  Sel: error_at @ parser.go:159:4
  1409  .  .  .  .  .  .  .  }
  1410  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1411  .  .  .  .  .  .  .  .  0: pos @ parser.go:159:13
  1412  .  .  .  .  .  .  .  .  1: *syntax.Operation {
  1413  .  .  .  .  .  .  .  .  .  Op: +
  1414  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1415  .  .  .  .  .  .  .  .  .  .  Op: +
  1416  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1417  .  .  .  .  .  .  .  .  .  .  .  Value: "\"syntax error: unexpected \""
  1418  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1419  .  .  .  .  .  .  .  .  .  .  }
  1420  .  .  .  .  .  .  .  .  .  .  Y: tok @ parser.go:159:46
  1421  .  .  .  .  .  .  .  .  .  }
  1422  .  .  .  .  .  .  .  .  .  Y: msg @ parser.go:159:50
  1423  .  .  .  .  .  .  .  .  }
  1424  .  .  .  .  .  .  .  }
  1425  .  .  .  .  .  .  .  HasDots: false
  1426  .  .  .  .  .  .  }
  1427  .  .  .  .  .  }
  1428  .  .  .  .  }
  1429  .  .  .  .  Rbrace: src.Pos {}
  1430  .  .  .  }
  1431  .  .  .  Pragma: 0
  1432  .  .  }
  1433  .  .  16: *syntax.FuncDecl {
  1434  .  .  .  Attr: map[]
  1435  .  .  .  Recv: *syntax.Field {
  1436  .  .  .  .  Name: p @ parser.go:163:7
  1437  .  .  .  .  Type: *syntax.Operation {
  1438  .  .  .  .  .  Op: *
  1439  .  .  .  .  .  X: parser @ parser.go:163:10
  1440  .  .  .  .  .  Y: nil
  1441  .  .  .  .  }
  1442  .  .  .  }
  1443  .  .  .  Name: pos @ parser.go:163:18
  1444  .  .  .  Type: *syntax.FuncType {
  1445  .  .  .  .  ParamList: nil
  1446  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  1447  .  .  .  .  .  0: *syntax.Field {
  1448  .  .  .  .  .  .  Name: nil
  1449  .  .  .  .  .  .  Type: *syntax.SelectorExpr {
  1450  .  .  .  .  .  .  .  X: src @ parser.go:163:24
  1451  .  .  .  .  .  .  .  Sel: Pos @ parser.go:163:28
  1452  .  .  .  .  .  .  }
  1453  .  .  .  .  .  }
  1454  .  .  .  .  }
  1455  .  .  .  }
  1456  .  .  .  Body: *syntax.BlockStmt {
  1457  .  .  .  .  List: []syntax.Stmt (1 entries) {
  1458  .  .  .  .  .  0: *syntax.ReturnStmt {
  1459  .  .  .  .  .  .  Results: *syntax.CallExpr {
  1460  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1461  .  .  .  .  .  .  .  .  X: p @ parser.go:163:52
  1462  .  .  .  .  .  .  .  .  Sel: pos_at @ parser.go:163:54
  1463  .  .  .  .  .  .  .  }
  1464  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1465  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  1466  .  .  .  .  .  .  .  .  .  X: p @ parser.go:163:61
  1467  .  .  .  .  .  .  .  .  .  Sel: line @ parser.go:163:63
  1468  .  .  .  .  .  .  .  .  }
  1469  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  1470  .  .  .  .  .  .  .  .  .  X: p @ parser.go:163:69
  1471  .  .  .  .  .  .  .  .  .  Sel: col @ parser.go:163:71
  1472  .  .  .  .  .  .  .  .  }
  1473  .  .  .  .  .  .  .  }
  1474  .  .  .  .  .  .  .  HasDots: false
  1475  .  .  .  .  .  .  }
  1476  .  .  .  .  .  }
  1477  .  .  .  .  }
  1478  .  .  .  .  Rbrace: src.Pos {}
  1479  .  .  .  }
  1480  .  .  .  Pragma: 0
  1481  .  .  }
  1482  .  .  17: *syntax.FuncDecl {
  1483  .  .  .  Attr: map[]
  1484  .  .  .  Recv: *syntax.Field {
  1485  .  .  .  .  Name: p @ parser.go:164:7
  1486  .  .  .  .  Type: *syntax.Operation {
  1487  .  .  .  .  .  Op: *
  1488  .  .  .  .  .  X: parser @ parser.go:164:10
  1489  .  .  .  .  .  Y: nil
  1490  .  .  .  .  }
  1491  .  .  .  }
  1492  .  .  .  Name: error @ parser.go:164:18
  1493  .  .  .  Type: *syntax.FuncType {
  1494  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  1495  .  .  .  .  .  0: *syntax.Field {
  1496  .  .  .  .  .  .  Name: msg @ parser.go:164:24
  1497  .  .  .  .  .  .  Type: string @ parser.go:164:28
  1498  .  .  .  .  .  }
  1499  .  .  .  .  }
  1500  .  .  .  .  ResultList: nil
  1501  .  .  .  }
  1502  .  .  .  Body: *syntax.BlockStmt {
  1503  .  .  .  .  List: []syntax.Stmt (1 entries) {
  1504  .  .  .  .  .  0: *syntax.ExprStmt {
  1505  .  .  .  .  .  .  X: *syntax.CallExpr {
  1506  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1507  .  .  .  .  .  .  .  .  X: p @ parser.go:164:45
  1508  .  .  .  .  .  .  .  .  Sel: error_at @ parser.go:164:47
  1509  .  .  .  .  .  .  .  }
  1510  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1511  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  1512  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1513  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:164:56
  1514  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:164:58
  1515  .  .  .  .  .  .  .  .  .  }
  1516  .  .  .  .  .  .  .  .  .  ArgList: nil
  1517  .  .  .  .  .  .  .  .  .  HasDots: false
  1518  .  .  .  .  .  .  .  .  }
  1519  .  .  .  .  .  .  .  .  1: msg @ parser.go:164:65
  1520  .  .  .  .  .  .  .  }
  1521  .  .  .  .  .  .  .  HasDots: false
  1522  .  .  .  .  .  .  }
  1523  .  .  .  .  .  }
  1524  .  .  .  .  }
  1525  .  .  .  .  Rbrace: src.Pos {}
  1526  .  .  .  }
  1527  .  .  .  Pragma: 0
  1528  .  .  }
  1529  .  .  18: *syntax.FuncDecl {
  1530  .  .  .  Attr: map[]
  1531  .  .  .  Recv: *syntax.Field {
  1532  .  .  .  .  Name: p @ parser.go:165:7
  1533  .  .  .  .  Type: *syntax.Operation {
  1534  .  .  .  .  .  Op: *
  1535  .  .  .  .  .  X: parser @ parser.go:165:10
  1536  .  .  .  .  .  Y: nil
  1537  .  .  .  .  }
  1538  .  .  .  }
  1539  .  .  .  Name: syntax_error @ parser.go:165:18
  1540  .  .  .  Type: *syntax.FuncType {
  1541  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  1542  .  .  .  .  .  0: *syntax.Field {
  1543  .  .  .  .  .  .  Name: msg @ parser.go:165:31
  1544  .  .  .  .  .  .  Type: string @ parser.go:165:35
  1545  .  .  .  .  .  }
  1546  .  .  .  .  }
  1547  .  .  .  .  ResultList: nil
  1548  .  .  .  }
  1549  .  .  .  Body: *syntax.BlockStmt {
  1550  .  .  .  .  List: []syntax.Stmt (1 entries) {
  1551  .  .  .  .  .  0: *syntax.ExprStmt {
  1552  .  .  .  .  .  .  X: *syntax.CallExpr {
  1553  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1554  .  .  .  .  .  .  .  .  X: p @ parser.go:165:45
  1555  .  .  .  .  .  .  .  .  Sel: syntax_error_at @ parser.go:165:47
  1556  .  .  .  .  .  .  .  }
  1557  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1558  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  1559  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1560  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:165:63
  1561  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:165:65
  1562  .  .  .  .  .  .  .  .  .  }
  1563  .  .  .  .  .  .  .  .  .  ArgList: nil
  1564  .  .  .  .  .  .  .  .  .  HasDots: false
  1565  .  .  .  .  .  .  .  .  }
  1566  .  .  .  .  .  .  .  .  1: msg @ parser.go:165:72
  1567  .  .  .  .  .  .  .  }
  1568  .  .  .  .  .  .  .  HasDots: false
  1569  .  .  .  .  .  .  }
  1570  .  .  .  .  .  }
  1571  .  .  .  .  }
  1572  .  .  .  .  Rbrace: src.Pos {}
  1573  .  .  .  }
  1574  .  .  .  Pragma: 0
  1575  .  .  }
  1576  .  .  19: *syntax.ConstDecl {
  1577  .  .  .  NameList: []*syntax.Name (1 entries) {
  1578  .  .  .  .  0: stopset @ parser.go:170:7
  1579  .  .  .  }
  1580  .  .  .  Type: uint64 @ parser.go:170:15
  1581  .  .  .  Values: *syntax.Operation {
  1582  .  .  .  .  Op: |
  1583  .  .  .  .  X: *syntax.Operation {
  1584  .  .  .  .  .  Op: |
  1585  .  .  .  .  .  X: *syntax.Operation {
  1586  .  .  .  .  .  .  Op: |
  1587  .  .  .  .  .  .  X: *syntax.Operation {
  1588  .  .  .  .  .  .  .  Op: |
  1589  .  .  .  .  .  .  .  X: *syntax.Operation {
  1590  .  .  .  .  .  .  .  .  Op: |
  1591  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1592  .  .  .  .  .  .  .  .  .  Op: |
  1593  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1594  .  .  .  .  .  .  .  .  .  .  Op: |
  1595  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1596  .  .  .  .  .  .  .  .  .  .  .  Op: |
  1597  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1598  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
  1599  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1600  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
  1601  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1602  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
  1603  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1604  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
  1605  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1606  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
  1607  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1608  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: |
  1609  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1610  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
  1611  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1612  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1613  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1614  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1615  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Break @ parser.go:170:27
  1616  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1617  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1618  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
  1619  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1620  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1621  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1622  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1623  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Const @ parser.go:171:5
  1624  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1625  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1626  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1627  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
  1628  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1629  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1630  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1631  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1632  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Continue @ parser.go:172:5
  1633  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1634  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1635  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1636  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
  1637  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1638  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1639  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1640  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1641  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Defer @ parser.go:173:5
  1642  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1643  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1644  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1645  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
  1646  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1647  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1648  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1649  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1650  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Fallthrough @ parser.go:174:5
  1651  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1652  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1653  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1654  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
  1655  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1656  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1657  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1658  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1659  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _For @ parser.go:175:5
  1660  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1661  .  .  .  .  .  .  .  .  .  .  .  .  }
  1662  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1663  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
  1664  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1665  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1666  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1667  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  1668  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Func @ parser.go:176:5
  1669  .  .  .  .  .  .  .  .  .  .  .  .  }
  1670  .  .  .  .  .  .  .  .  .  .  .  }
  1671  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1672  .  .  .  .  .  .  .  .  .  .  .  .  Op: <<
  1673  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1674  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1675  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1676  .  .  .  .  .  .  .  .  .  .  .  .  }
  1677  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Go @ parser.go:177:5
  1678  .  .  .  .  .  .  .  .  .  .  .  }
  1679  .  .  .  .  .  .  .  .  .  .  }
  1680  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1681  .  .  .  .  .  .  .  .  .  .  .  Op: <<
  1682  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1683  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1684  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1685  .  .  .  .  .  .  .  .  .  .  .  }
  1686  .  .  .  .  .  .  .  .  .  .  .  Y: _Goto @ parser.go:178:5
  1687  .  .  .  .  .  .  .  .  .  .  }
  1688  .  .  .  .  .  .  .  .  .  }
  1689  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1690  .  .  .  .  .  .  .  .  .  .  Op: <<
  1691  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1692  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1693  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1694  .  .  .  .  .  .  .  .  .  .  }
  1695  .  .  .  .  .  .  .  .  .  .  Y: _If @ parser.go:179:5
  1696  .  .  .  .  .  .  .  .  .  }
  1697  .  .  .  .  .  .  .  .  }
  1698  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1699  .  .  .  .  .  .  .  .  .  Op: <<
  1700  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1701  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1702  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1703  .  .  .  .  .  .  .  .  .  }
  1704  .  .  .  .  .  .  .  .  .  Y: _Return @ parser.go:180:5
  1705  .  .  .  .  .  .  .  .  }
  1706  .  .  .  .  .  .  .  }
  1707  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1708  .  .  .  .  .  .  .  .  Op: <<
  1709  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1710  .  .  .  .  .  .  .  .  .  Value: "1"
  1711  .  .  .  .  .  .  .  .  .  Kind: 0
  1712  .  .  .  .  .  .  .  .  }
  1713  .  .  .  .  .  .  .  .  Y: _Select @ parser.go:181:5
  1714  .  .  .  .  .  .  .  }
  1715  .  .  .  .  .  .  }
  1716  .  .  .  .  .  .  Y: *syntax.Operation {
  1717  .  .  .  .  .  .  .  Op: <<
  1718  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1719  .  .  .  .  .  .  .  .  Value: "1"
  1720  .  .  .  .  .  .  .  .  Kind: 0
  1721  .  .  .  .  .  .  .  }
  1722  .  .  .  .  .  .  .  Y: _Switch @ parser.go:182:5
  1723  .  .  .  .  .  .  }
  1724  .  .  .  .  .  }
  1725  .  .  .  .  .  Y: *syntax.Operation {
  1726  .  .  .  .  .  .  Op: <<
  1727  .  .  .  .  .  .  X: *syntax.BasicLit {
  1728  .  .  .  .  .  .  .  Value: "1"
  1729  .  .  .  .  .  .  .  Kind: 0
  1730  .  .  .  .  .  .  }
  1731  .  .  .  .  .  .  Y: _Type @ parser.go:183:5
  1732  .  .  .  .  .  }
  1733  .  .  .  .  }
  1734  .  .  .  .  Y: *syntax.Operation {
  1735  .  .  .  .  .  Op: <<
  1736  .  .  .  .  .  X: *syntax.BasicLit {
  1737  .  .  .  .  .  .  Value: "1"
  1738  .  .  .  .  .  .  Kind: 0
  1739  .  .  .  .  .  }
  1740  .  .  .  .  .  Y: _Var @ parser.go:184:5
  1741  .  .  .  .  }
  1742  .  .  .  }
  1743  .  .  .  Group: nil
  1744  .  .  }
  1745  .  .  20: *syntax.FuncDecl {
  1746  .  .  .  Attr: map[]
  1747  .  .  .  Recv: *syntax.Field {
  1748  .  .  .  .  Name: p @ parser.go:190:7
  1749  .  .  .  .  Type: *syntax.Operation {
  1750  .  .  .  .  .  Op: *
  1751  .  .  .  .  .  X: parser @ parser.go:190:10
  1752  .  .  .  .  .  Y: nil
  1753  .  .  .  .  }
  1754  .  .  .  }
  1755  .  .  .  Name: advance @ parser.go:190:18
  1756  .  .  .  Type: *syntax.FuncType {
  1757  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  1758  .  .  .  .  .  0: *syntax.Field {
  1759  .  .  .  .  .  .  Name: followlist @ parser.go:190:26
  1760  .  .  .  .  .  .  Type: *syntax.DotsType {
  1761  .  .  .  .  .  .  .  Elem: token @ parser.go:190:40
  1762  .  .  .  .  .  .  }
  1763  .  .  .  .  .  }
  1764  .  .  .  .  }
  1765  .  .  .  .  ResultList: nil
  1766  .  .  .  }
  1767  .  .  .  Body: *syntax.BlockStmt {
  1768  .  .  .  .  List: []syntax.Stmt (4 entries) {
  1769  .  .  .  .  .  0: *syntax.IfStmt {
  1770  .  .  .  .  .  .  Init: nil
  1771  .  .  .  .  .  .  Cond: *syntax.Operation {
  1772  .  .  .  .  .  .  .  Op: ==
  1773  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1774  .  .  .  .  .  .  .  .  Fun: len @ parser.go:191:5
  1775  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  1776  .  .  .  .  .  .  .  .  .  0: followlist @ parser.go:191:9
  1777  .  .  .  .  .  .  .  .  }
  1778  .  .  .  .  .  .  .  .  HasDots: false
  1779  .  .  .  .  .  .  .  }
  1780  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  1781  .  .  .  .  .  .  .  .  Value: "0"
  1782  .  .  .  .  .  .  .  .  Kind: 0
  1783  .  .  .  .  .  .  .  }
  1784  .  .  .  .  .  .  }
  1785  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  1786  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  1787  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1788  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1789  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1790  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:192:3
  1791  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:192:5
  1792  .  .  .  .  .  .  .  .  .  .  }
  1793  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  1794  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1795  .  .  .  .  .  .  .  .  .  }
  1796  .  .  .  .  .  .  .  .  }
  1797  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
  1798  .  .  .  .  .  .  .  .  .  Results: nil
  1799  .  .  .  .  .  .  .  .  }
  1800  .  .  .  .  .  .  .  }
  1801  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  1802  .  .  .  .  .  .  }
  1803  .  .  .  .  .  .  Else: nil
  1804  .  .  .  .  .  }
  1805  .  .  .  .  .  1: *syntax.DeclStmt {
  1806  .  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
  1807  .  .  .  .  .  .  .  0: *syntax.VarDecl {
  1808  .  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
  1809  .  .  .  .  .  .  .  .  .  0: followset @ parser.go:198:6
  1810  .  .  .  .  .  .  .  .  }
  1811  .  .  .  .  .  .  .  .  Type: uint64 @ parser.go:198:16
  1812  .  .  .  .  .  .  .  .  Values: *syntax.Operation {
  1813  .  .  .  .  .  .  .  .  .  Op: <<
  1814  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1815  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1816  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1817  .  .  .  .  .  .  .  .  .  }
  1818  .  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:198:30
  1819  .  .  .  .  .  .  .  .  }
  1820  .  .  .  .  .  .  .  .  Group: nil
  1821  .  .  .  .  .  .  .  }
  1822  .  .  .  .  .  .  }
  1823  .  .  .  .  .  }
  1824  .  .  .  .  .  2: *syntax.ForStmt {
  1825  .  .  .  .  .  .  Init: *syntax.RangeClause {
  1826  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
  1827  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  1828  .  .  .  .  .  .  .  .  .  0: _ @ parser.go:199:6
  1829  .  .  .  .  .  .  .  .  .  1: tok @ parser.go:199:9
  1830  .  .  .  .  .  .  .  .  }
  1831  .  .  .  .  .  .  .  }
  1832  .  .  .  .  .  .  .  Def: true
  1833  .  .  .  .  .  .  .  X: followlist @ parser.go:199:22
  1834  .  .  .  .  .  .  }
  1835  .  .  .  .  .  .  Cond: nil
  1836  .  .  .  .  .  .  Post: nil
  1837  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  1838  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  1839  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  1840  .  .  .  .  .  .  .  .  .  Op: |
  1841  .  .  .  .  .  .  .  .  .  Lhs: followset @ parser.go:200:3
  1842  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
  1843  .  .  .  .  .  .  .  .  .  .  Op: <<
  1844  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  1845  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  1846  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1847  .  .  .  .  .  .  .  .  .  .  }
  1848  .  .  .  .  .  .  .  .  .  .  Y: tok @ parser.go:200:21
  1849  .  .  .  .  .  .  .  .  .  }
  1850  .  .  .  .  .  .  .  .  }
  1851  .  .  .  .  .  .  .  }
  1852  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  1853  .  .  .  .  .  .  }
  1854  .  .  .  .  .  }
  1855  .  .  .  .  .  3: *syntax.ForStmt {
  1856  .  .  .  .  .  .  Init: nil
  1857  .  .  .  .  .  .  Cond: *syntax.Operation {
  1858  .  .  .  .  .  .  .  Op: !
  1859  .  .  .  .  .  .  .  X: *syntax.ParenExpr {
  1860  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1861  .  .  .  .  .  .  .  .  .  Op: ||
  1862  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1863  .  .  .  .  .  .  .  .  .  .  Fun: contains @ parser.go:203:8
  1864  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1865  .  .  .  .  .  .  .  .  .  .  .  0: followset @ parser.go:203:17
  1866  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  1867  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:203:28
  1868  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:203:30
  1869  .  .  .  .  .  .  .  .  .  .  .  }
  1870  .  .  .  .  .  .  .  .  .  .  }
  1871  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1872  .  .  .  .  .  .  .  .  .  }
  1873  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  1874  .  .  .  .  .  .  .  .  .  .  Op: &&
  1875  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  1876  .  .  .  .  .  .  .  .  .  .  .  Op: >
  1877  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  1878  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:203:38
  1879  .  .  .  .  .  .  .  .  .  .  .  .  Sel: fnest @ parser.go:203:40
  1880  .  .  .  .  .  .  .  .  .  .  .  }
  1881  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  1882  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  1883  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  1884  .  .  .  .  .  .  .  .  .  .  .  }
  1885  .  .  .  .  .  .  .  .  .  .  }
  1886  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
  1887  .  .  .  .  .  .  .  .  .  .  .  Fun: contains @ parser.go:203:53
  1888  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  1889  .  .  .  .  .  .  .  .  .  .  .  .  0: stopset @ parser.go:203:62
  1890  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  1891  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:203:71
  1892  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:203:73
  1893  .  .  .  .  .  .  .  .  .  .  .  .  }
  1894  .  .  .  .  .  .  .  .  .  .  .  }
  1895  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1896  .  .  .  .  .  .  .  .  .  .  }
  1897  .  .  .  .  .  .  .  .  .  }
  1898  .  .  .  .  .  .  .  .  }
  1899  .  .  .  .  .  .  .  }
  1900  .  .  .  .  .  .  .  Y: nil
  1901  .  .  .  .  .  .  }
  1902  .  .  .  .  .  .  Post: nil
  1903  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  1904  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  1905  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  1906  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  1907  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1908  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:204:3
  1909  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:204:5
  1910  .  .  .  .  .  .  .  .  .  .  }
  1911  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  1912  .  .  .  .  .  .  .  .  .  .  HasDots: false
  1913  .  .  .  .  .  .  .  .  .  }
  1914  .  .  .  .  .  .  .  .  }
  1915  .  .  .  .  .  .  .  }
  1916  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  1917  .  .  .  .  .  .  }
  1918  .  .  .  .  .  }
  1919  .  .  .  .  }
  1920  .  .  .  .  Rbrace: src.Pos {}
  1921  .  .  .  }
  1922  .  .  .  Pragma: 0
  1923  .  .  }
  1924  .  .  21: *syntax.FuncDecl {
  1925  .  .  .  Attr: map[]
  1926  .  .  .  Recv: nil
  1927  .  .  .  Name: tokstring @ parser.go:208:6
  1928  .  .  .  Type: *syntax.FuncType {
  1929  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  1930  .  .  .  .  .  0: *syntax.Field {
  1931  .  .  .  .  .  .  Name: tok @ parser.go:208:16
  1932  .  .  .  .  .  .  Type: token @ parser.go:208:20
  1933  .  .  .  .  .  }
  1934  .  .  .  .  }
  1935  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  1936  .  .  .  .  .  0: *syntax.Field {
  1937  .  .  .  .  .  .  Name: nil
  1938  .  .  .  .  .  .  Type: string @ parser.go:208:27
  1939  .  .  .  .  .  }
  1940  .  .  .  .  }
  1941  .  .  .  }
  1942  .  .  .  Body: *syntax.BlockStmt {
  1943  .  .  .  .  List: []syntax.Stmt (2 entries) {
  1944  .  .  .  .  .  0: *syntax.SwitchStmt {
  1945  .  .  .  .  .  .  Init: nil
  1946  .  .  .  .  .  .  Tag: tok @ parser.go:209:9
  1947  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
  1948  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  1949  .  .  .  .  .  .  .  .  Cases: _EOF @ parser.go:210:7
  1950  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1951  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  1952  .  .  .  .  .  .  .  .  .  .  Results: *syntax.BasicLit {
  1953  .  .  .  .  .  .  .  .  .  .  .  Value: "\"EOF\""
  1954  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1955  .  .  .  .  .  .  .  .  .  .  }
  1956  .  .  .  .  .  .  .  .  .  }
  1957  .  .  .  .  .  .  .  .  }
  1958  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1959  .  .  .  .  .  .  .  }
  1960  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  1961  .  .  .  .  .  .  .  .  Cases: _Comma @ parser.go:212:7
  1962  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1963  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  1964  .  .  .  .  .  .  .  .  .  .  Results: *syntax.BasicLit {
  1965  .  .  .  .  .  .  .  .  .  .  .  Value: "\"comma\""
  1966  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1967  .  .  .  .  .  .  .  .  .  .  }
  1968  .  .  .  .  .  .  .  .  .  }
  1969  .  .  .  .  .  .  .  .  }
  1970  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1971  .  .  .  .  .  .  .  }
  1972  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  1973  .  .  .  .  .  .  .  .  Cases: _Semi @ parser.go:214:7
  1974  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  1975  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  1976  .  .  .  .  .  .  .  .  .  .  Results: *syntax.BasicLit {
  1977  .  .  .  .  .  .  .  .  .  .  .  Value: "\"semicolon\""
  1978  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  1979  .  .  .  .  .  .  .  .  .  .  }
  1980  .  .  .  .  .  .  .  .  .  }
  1981  .  .  .  .  .  .  .  .  }
  1982  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  1983  .  .  .  .  .  .  .  }
  1984  .  .  .  .  .  .  }
  1985  .  .  .  .  .  .  Rbrace: src.Pos {}
  1986  .  .  .  .  .  }
  1987  .  .  .  .  .  1: *syntax.ReturnStmt {
  1988  .  .  .  .  .  .  Results: *syntax.CallExpr {
  1989  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  1990  .  .  .  .  .  .  .  .  X: tok @ parser.go:217:9
  1991  .  .  .  .  .  .  .  .  Sel: String @ parser.go:217:13
  1992  .  .  .  .  .  .  .  }
  1993  .  .  .  .  .  .  .  ArgList: nil
  1994  .  .  .  .  .  .  .  HasDots: false
  1995  .  .  .  .  .  .  }
  1996  .  .  .  .  .  }
  1997  .  .  .  .  }
  1998  .  .  .  .  Rbrace: src.Pos {}
  1999  .  .  .  }
  2000  .  .  .  Pragma: 0
  2001  .  .  }
  2002  .  .  22: *syntax.FuncDecl {
  2003  .  .  .  Attr: map[]
  2004  .  .  .  Recv: *syntax.Field {
  2005  .  .  .  .  Name: p @ parser.go:221:7
  2006  .  .  .  .  Type: *syntax.Operation {
  2007  .  .  .  .  .  Op: *
  2008  .  .  .  .  .  X: parser @ parser.go:221:10
  2009  .  .  .  .  .  Y: nil
  2010  .  .  .  .  }
  2011  .  .  .  }
  2012  .  .  .  Name: trace @ parser.go:221:18
  2013  .  .  .  Type: *syntax.FuncType {
  2014  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  2015  .  .  .  .  .  0: *syntax.Field {
  2016  .  .  .  .  .  .  Name: msg @ parser.go:221:24
  2017  .  .  .  .  .  .  Type: string @ parser.go:221:28
  2018  .  .  .  .  .  }
  2019  .  .  .  .  }
  2020  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  2021  .  .  .  .  .  0: *syntax.Field {
  2022  .  .  .  .  .  .  Name: nil
  2023  .  .  .  .  .  .  Type: *syntax.FuncType {
  2024  .  .  .  .  .  .  .  ParamList: nil
  2025  .  .  .  .  .  .  .  ResultList: nil
  2026  .  .  .  .  .  .  }
  2027  .  .  .  .  .  }
  2028  .  .  .  .  }
  2029  .  .  .  }
  2030  .  .  .  Body: *syntax.BlockStmt {
  2031  .  .  .  .  List: []syntax.Stmt (4 entries) {
  2032  .  .  .  .  .  0: *syntax.ExprStmt {
  2033  .  .  .  .  .  .  X: *syntax.CallExpr {
  2034  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2035  .  .  .  .  .  .  .  .  X: fmt @ parser.go:222:2
  2036  .  .  .  .  .  .  .  .  Sel: Printf @ parser.go:222:6
  2037  .  .  .  .  .  .  .  }
  2038  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
  2039  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2040  .  .  .  .  .  .  .  .  .  Value: "\"%5d: %s%s (\\n\""
  2041  .  .  .  .  .  .  .  .  .  Kind: 4
  2042  .  .  .  .  .  .  .  .  }
  2043  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  2044  .  .  .  .  .  .  .  .  .  X: p @ parser.go:222:30
  2045  .  .  .  .  .  .  .  .  .  Sel: line @ parser.go:222:32
  2046  .  .  .  .  .  .  .  .  }
  2047  .  .  .  .  .  .  .  .  2: *syntax.SelectorExpr {
  2048  .  .  .  .  .  .  .  .  .  X: p @ parser.go:222:38
  2049  .  .  .  .  .  .  .  .  .  Sel: indent @ parser.go:222:40
  2050  .  .  .  .  .  .  .  .  }
  2051  .  .  .  .  .  .  .  .  3: msg @ parser.go:222:48
  2052  .  .  .  .  .  .  .  }
  2053  .  .  .  .  .  .  .  HasDots: false
  2054  .  .  .  .  .  .  }
  2055  .  .  .  .  .  }
  2056  .  .  .  .  .  1: *syntax.DeclStmt {
  2057  .  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
  2058  .  .  .  .  .  .  .  0: *syntax.ConstDecl {
  2059  .  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
  2060  .  .  .  .  .  .  .  .  .  0: tab @ parser.go:223:8
  2061  .  .  .  .  .  .  .  .  }
  2062  .  .  .  .  .  .  .  .  Type: nil
  2063  .  .  .  .  .  .  .  .  Values: *syntax.BasicLit {
  2064  .  .  .  .  .  .  .  .  .  Value: "\". \""
  2065  .  .  .  .  .  .  .  .  .  Kind: 4
  2066  .  .  .  .  .  .  .  .  }
  2067  .  .  .  .  .  .  .  .  Group: nil
  2068  .  .  .  .  .  .  .  }
  2069  .  .  .  .  .  .  }
  2070  .  .  .  .  .  }
  2071  .  .  .  .  .  2: *syntax.AssignStmt {
  2072  .  .  .  .  .  .  Op: <op-0>
  2073  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2074  .  .  .  .  .  .  .  X: p @ parser.go:224:2
  2075  .  .  .  .  .  .  .  Sel: indent @ parser.go:224:4
  2076  .  .  .  .  .  .  }
  2077  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2078  .  .  .  .  .  .  .  Fun: append @ parser.go:224:13
  2079  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  2080  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  2081  .  .  .  .  .  .  .  .  .  X: p @ parser.go:224:20
  2082  .  .  .  .  .  .  .  .  .  Sel: indent @ parser.go:224:22
  2083  .  .  .  .  .  .  .  .  }
  2084  .  .  .  .  .  .  .  .  1: tab @ parser.go:224:30
  2085  .  .  .  .  .  .  .  }
  2086  .  .  .  .  .  .  .  HasDots: true
  2087  .  .  .  .  .  .  }
  2088  .  .  .  .  .  }
  2089  .  .  .  .  .  3: *syntax.ReturnStmt {
  2090  .  .  .  .  .  .  Results: *syntax.FuncLit {
  2091  .  .  .  .  .  .  .  Type: *syntax.FuncType {
  2092  .  .  .  .  .  .  .  .  ParamList: nil
  2093  .  .  .  .  .  .  .  .  ResultList: nil
  2094  .  .  .  .  .  .  .  }
  2095  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  2096  .  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
  2097  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2098  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2099  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2100  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:226:3
  2101  .  .  .  .  .  .  .  .  .  .  .  Sel: indent @ parser.go:226:5
  2102  .  .  .  .  .  .  .  .  .  .  }
  2103  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SliceExpr {
  2104  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2105  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:226:14
  2106  .  .  .  .  .  .  .  .  .  .  .  .  Sel: indent @ parser.go:226:16
  2107  .  .  .  .  .  .  .  .  .  .  .  }
  2108  .  .  .  .  .  .  .  .  .  .  .  Index: [<nil> 0xc4200aa340 <nil>]
  2109  .  .  .  .  .  .  .  .  .  .  .  Full: false
  2110  .  .  .  .  .  .  .  .  .  .  }
  2111  .  .  .  .  .  .  .  .  .  }
  2112  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  2113  .  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
  2114  .  .  .  .  .  .  .  .  .  .  .  Op: :
  2115  .  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:227:6
  2116  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2117  .  .  .  .  .  .  .  .  .  .  .  .  Fun: recover @ parser.go:227:11
  2118  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  2119  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2120  .  .  .  .  .  .  .  .  .  .  .  }
  2121  .  .  .  .  .  .  .  .  .  .  }
  2122  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  2123  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  2124  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:227:22
  2125  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:227:27
  2126  .  .  .  .  .  .  .  .  .  .  }
  2127  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  2128  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  2129  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  2130  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2131  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: panic @ parser.go:228:4
  2132  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2133  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: x @ parser.go:228:10
  2134  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2135  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2136  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2137  .  .  .  .  .  .  .  .  .  .  .  .  }
  2138  .  .  .  .  .  .  .  .  .  .  .  }
  2139  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  2140  .  .  .  .  .  .  .  .  .  .  }
  2141  .  .  .  .  .  .  .  .  .  .  Else: nil
  2142  .  .  .  .  .  .  .  .  .  }
  2143  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  2144  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2145  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2146  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt @ parser.go:230:3
  2147  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Printf @ parser.go:230:7
  2148  .  .  .  .  .  .  .  .  .  .  .  }
  2149  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
  2150  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2151  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"%5d: %s)\\n\""
  2152  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2153  .  .  .  .  .  .  .  .  .  .  .  .  }
  2154  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  2155  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:230:28
  2156  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: line @ parser.go:230:30
  2157  .  .  .  .  .  .  .  .  .  .  .  .  }
  2158  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.SelectorExpr {
  2159  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:230:36
  2160  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: indent @ parser.go:230:38
  2161  .  .  .  .  .  .  .  .  .  .  .  .  }
  2162  .  .  .  .  .  .  .  .  .  .  .  }
  2163  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2164  .  .  .  .  .  .  .  .  .  .  }
  2165  .  .  .  .  .  .  .  .  .  }
  2166  .  .  .  .  .  .  .  .  }
  2167  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  2168  .  .  .  .  .  .  .  }
  2169  .  .  .  .  .  .  }
  2170  .  .  .  .  .  }
  2171  .  .  .  .  }
  2172  .  .  .  .  Rbrace: src.Pos {}
  2173  .  .  .  }
  2174  .  .  .  Pragma: 0
  2175  .  .  }
  2176  .  .  23: *syntax.FuncDecl {
  2177  .  .  .  Attr: map[]
  2178  .  .  .  Recv: *syntax.Field {
  2179  .  .  .  .  Name: p @ parser.go:245:7
  2180  .  .  .  .  Type: *syntax.Operation {
  2181  .  .  .  .  .  Op: *
  2182  .  .  .  .  .  X: parser @ parser.go:245:10
  2183  .  .  .  .  .  Y: nil
  2184  .  .  .  .  }
  2185  .  .  .  }
  2186  .  .  .  Name: fileOrNil @ parser.go:245:18
  2187  .  .  .  Type: *syntax.FuncType {
  2188  .  .  .  .  ParamList: nil
  2189  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  2190  .  .  .  .  .  0: *syntax.Field {
  2191  .  .  .  .  .  .  Name: nil
  2192  .  .  .  .  .  .  Type: *syntax.Operation {
  2193  .  .  .  .  .  .  .  Op: *
  2194  .  .  .  .  .  .  .  X: File @ parser.go:245:31
  2195  .  .  .  .  .  .  .  Y: nil
  2196  .  .  .  .  .  .  }
  2197  .  .  .  .  .  }
  2198  .  .  .  .  }
  2199  .  .  .  }
  2200  .  .  .  Body: *syntax.BlockStmt {
  2201  .  .  .  .  List: []syntax.Stmt (11 entries) {
  2202  .  .  .  .  .  0: *syntax.IfStmt {
  2203  .  .  .  .  .  .  Init: nil
  2204  .  .  .  .  .  .  Cond: trace @ parser.go:246:5
  2205  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  2206  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  2207  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  2208  .  .  .  .  .  .  .  .  .  Tok: defer
  2209  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  2210  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  2211  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2212  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:247:9
  2213  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:247:11
  2214  .  .  .  .  .  .  .  .  .  .  .  }
  2215  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2216  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2217  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"file\""
  2218  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2219  .  .  .  .  .  .  .  .  .  .  .  .  }
  2220  .  .  .  .  .  .  .  .  .  .  .  }
  2221  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2222  .  .  .  .  .  .  .  .  .  .  }
  2223  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  2224  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2225  .  .  .  .  .  .  .  .  .  }
  2226  .  .  .  .  .  .  .  .  }
  2227  .  .  .  .  .  .  .  }
  2228  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  2229  .  .  .  .  .  .  }
  2230  .  .  .  .  .  .  Else: nil
  2231  .  .  .  .  .  }
  2232  .  .  .  .  .  1: *syntax.AssignStmt {
  2233  .  .  .  .  .  .  Op: :
  2234  .  .  .  .  .  .  Lhs: f @ parser.go:250:2
  2235  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2236  .  .  .  .  .  .  .  Fun: new @ parser.go:250:7
  2237  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2238  .  .  .  .  .  .  .  .  0: File @ parser.go:250:11
  2239  .  .  .  .  .  .  .  }
  2240  .  .  .  .  .  .  .  HasDots: false
  2241  .  .  .  .  .  .  }
  2242  .  .  .  .  .  }
  2243  .  .  .  .  .  2: *syntax.AssignStmt {
  2244  .  .  .  .  .  .  Op: <op-0>
  2245  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2246  .  .  .  .  .  .  .  X: f @ parser.go:251:2
  2247  .  .  .  .  .  .  .  Sel: pos @ parser.go:251:4
  2248  .  .  .  .  .  .  }
  2249  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2250  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2251  .  .  .  .  .  .  .  .  X: p @ parser.go:251:10
  2252  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:251:12
  2253  .  .  .  .  .  .  .  }
  2254  .  .  .  .  .  .  .  ArgList: nil
  2255  .  .  .  .  .  .  .  HasDots: false
  2256  .  .  .  .  .  .  }
  2257  .  .  .  .  .  }
  2258  .  .  .  .  .  3: *syntax.IfStmt {
  2259  .  .  .  .  .  .  Init: nil
  2260  .  .  .  .  .  .  Cond: *syntax.Operation {
  2261  .  .  .  .  .  .  .  Op: !
  2262  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2263  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2264  .  .  .  .  .  .  .  .  .  X: p @ parser.go:254:6
  2265  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:254:8
  2266  .  .  .  .  .  .  .  .  }
  2267  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2268  .  .  .  .  .  .  .  .  .  0: _Package @ parser.go:254:12
  2269  .  .  .  .  .  .  .  .  }
  2270  .  .  .  .  .  .  .  .  HasDots: false
  2271  .  .  .  .  .  .  .  }
  2272  .  .  .  .  .  .  .  Y: nil
  2273  .  .  .  .  .  .  }
  2274  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  2275  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  2276  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  2277  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2278  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2279  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:255:3
  2280  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:255:5
  2281  .  .  .  .  .  .  .  .  .  .  }
  2282  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2283  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2284  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"package statement must be first\""
  2285  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2286  .  .  .  .  .  .  .  .  .  .  .  }
  2287  .  .  .  .  .  .  .  .  .  .  }
  2288  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2289  .  .  .  .  .  .  .  .  .  }
  2290  .  .  .  .  .  .  .  .  }
  2291  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
  2292  .  .  .  .  .  .  .  .  .  Results: nil @ parser.go:256:10
  2293  .  .  .  .  .  .  .  .  }
  2294  .  .  .  .  .  .  .  }
  2295  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  2296  .  .  .  .  .  .  }
  2297  .  .  .  .  .  .  Else: nil
  2298  .  .  .  .  .  }
  2299  .  .  .  .  .  4: *syntax.AssignStmt {
  2300  .  .  .  .  .  .  Op: <op-0>
  2301  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2302  .  .  .  .  .  .  .  X: f @ parser.go:258:2
  2303  .  .  .  .  .  .  .  Sel: PkgName @ parser.go:258:4
  2304  .  .  .  .  .  .  }
  2305  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2306  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2307  .  .  .  .  .  .  .  .  X: p @ parser.go:258:14
  2308  .  .  .  .  .  .  .  .  Sel: name @ parser.go:258:16
  2309  .  .  .  .  .  .  .  }
  2310  .  .  .  .  .  .  .  ArgList: nil
  2311  .  .  .  .  .  .  .  HasDots: false
  2312  .  .  .  .  .  .  }
  2313  .  .  .  .  .  }
  2314  .  .  .  .  .  5: *syntax.ExprStmt {
  2315  .  .  .  .  .  .  X: *syntax.CallExpr {
  2316  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2317  .  .  .  .  .  .  .  .  X: p @ parser.go:259:2
  2318  .  .  .  .  .  .  .  .  Sel: want @ parser.go:259:4
  2319  .  .  .  .  .  .  .  }
  2320  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2321  .  .  .  .  .  .  .  .  0: _Semi @ parser.go:259:9
  2322  .  .  .  .  .  .  .  }
  2323  .  .  .  .  .  .  .  HasDots: false
  2324  .  .  .  .  .  .  }
  2325  .  .  .  .  .  }
  2326  .  .  .  .  .  6: *syntax.IfStmt {
  2327  .  .  .  .  .  .  Init: nil
  2328  .  .  .  .  .  .  Cond: *syntax.Operation {
  2329  .  .  .  .  .  .  .  Op: !=
  2330  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2331  .  .  .  .  .  .  .  .  X: p @ parser.go:262:5
  2332  .  .  .  .  .  .  .  .  Sel: first @ parser.go:262:7
  2333  .  .  .  .  .  .  .  }
  2334  .  .  .  .  .  .  .  Y: nil @ parser.go:262:16
  2335  .  .  .  .  .  .  }
  2336  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  2337  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  2338  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  2339  .  .  .  .  .  .  .  .  .  Results: nil @ parser.go:263:10
  2340  .  .  .  .  .  .  .  .  }
  2341  .  .  .  .  .  .  .  }
  2342  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  2343  .  .  .  .  .  .  }
  2344  .  .  .  .  .  .  Else: nil
  2345  .  .  .  .  .  }
  2346  .  .  .  .  .  7: *syntax.ForStmt {
  2347  .  .  .  .  .  .  Init: nil
  2348  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  2349  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2350  .  .  .  .  .  .  .  .  X: p @ parser.go:267:6
  2351  .  .  .  .  .  .  .  .  Sel: got @ parser.go:267:8
  2352  .  .  .  .  .  .  .  }
  2353  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2354  .  .  .  .  .  .  .  .  0: _Import @ parser.go:267:12
  2355  .  .  .  .  .  .  .  }
  2356  .  .  .  .  .  .  .  HasDots: false
  2357  .  .  .  .  .  .  }
  2358  .  .  .  .  .  .  Post: nil
  2359  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  2360  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  2361  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2362  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2363  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2364  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:268:3
  2365  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:268:5
  2366  .  .  .  .  .  .  .  .  .  }
  2367  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2368  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2369  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:268:16
  2370  .  .  .  .  .  .  .  .  .  .  .  Sel: appendGroup @ parser.go:268:18
  2371  .  .  .  .  .  .  .  .  .  .  }
  2372  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  2373  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  2374  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:268:30
  2375  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:268:32
  2376  .  .  .  .  .  .  .  .  .  .  .  }
  2377  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  2378  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:268:42
  2379  .  .  .  .  .  .  .  .  .  .  .  .  Sel: importDecl @ parser.go:268:44
  2380  .  .  .  .  .  .  .  .  .  .  .  }
  2381  .  .  .  .  .  .  .  .  .  .  }
  2382  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2383  .  .  .  .  .  .  .  .  .  }
  2384  .  .  .  .  .  .  .  .  }
  2385  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  2386  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2387  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2388  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:269:3
  2389  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:269:5
  2390  .  .  .  .  .  .  .  .  .  .  }
  2391  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2392  .  .  .  .  .  .  .  .  .  .  .  0: _Semi @ parser.go:269:10
  2393  .  .  .  .  .  .  .  .  .  .  }
  2394  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2395  .  .  .  .  .  .  .  .  .  }
  2396  .  .  .  .  .  .  .  .  }
  2397  .  .  .  .  .  .  .  }
  2398  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  2399  .  .  .  .  .  .  }
  2400  .  .  .  .  .  }
  2401  .  .  .  .  .  8: *syntax.ForStmt {
  2402  .  .  .  .  .  .  Init: nil
  2403  .  .  .  .  .  .  Cond: *syntax.Operation {
  2404  .  .  .  .  .  .  .  Op: !=
  2405  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2406  .  .  .  .  .  .  .  .  X: p @ parser.go:273:6
  2407  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:273:8
  2408  .  .  .  .  .  .  .  }
  2409  .  .  .  .  .  .  .  Y: _EOF @ parser.go:273:15
  2410  .  .  .  .  .  .  }
  2411  .  .  .  .  .  .  Post: nil
  2412  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  2413  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
  2414  .  .  .  .  .  .  .  .  0: *syntax.SwitchStmt {
  2415  .  .  .  .  .  .  .  .  .  Init: nil
  2416  .  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  2417  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:274:10
  2418  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:274:12
  2419  .  .  .  .  .  .  .  .  .  }
  2420  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (5 entries) {
  2421  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  2422  .  .  .  .  .  .  .  .  .  .  .  Cases: _Const @ parser.go:275:8
  2423  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  2424  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  2425  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2426  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2427  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:276:4
  2428  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:276:6
  2429  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2430  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  2431  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2432  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2433  .  .  .  .  .  .  .  .  .  .  .  .  }
  2434  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  2435  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2436  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2437  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:277:4
  2438  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:277:6
  2439  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2440  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2441  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2442  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:277:17
  2443  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: appendGroup @ parser.go:277:19
  2444  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2445  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  2446  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  2447  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:277:31
  2448  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:277:33
  2449  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2450  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  2451  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:277:43
  2452  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: constDecl @ parser.go:277:45
  2453  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2454  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2455  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2456  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2457  .  .  .  .  .  .  .  .  .  .  .  .  }
  2458  .  .  .  .  .  .  .  .  .  .  .  }
  2459  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  2460  .  .  .  .  .  .  .  .  .  .  }
  2461  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  2462  .  .  .  .  .  .  .  .  .  .  .  Cases: _Type @ parser.go:279:8
  2463  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  2464  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  2465  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2466  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2467  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:280:4
  2468  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:280:6
  2469  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2470  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  2471  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2472  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2473  .  .  .  .  .  .  .  .  .  .  .  .  }
  2474  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  2475  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2476  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2477  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:281:4
  2478  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:281:6
  2479  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2480  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2481  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2482  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:281:17
  2483  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: appendGroup @ parser.go:281:19
  2484  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2485  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  2486  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  2487  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:281:31
  2488  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:281:33
  2489  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2490  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  2491  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:281:43
  2492  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: typeDecl @ parser.go:281:45
  2493  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2494  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2495  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2496  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2497  .  .  .  .  .  .  .  .  .  .  .  .  }
  2498  .  .  .  .  .  .  .  .  .  .  .  }
  2499  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  2500  .  .  .  .  .  .  .  .  .  .  }
  2501  .  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  2502  .  .  .  .  .  .  .  .  .  .  .  Cases: _Var @ parser.go:283:8
  2503  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  2504  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  2505  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2506  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2507  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:284:4
  2508  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:284:6
  2509  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2510  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  2511  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2512  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2513  .  .  .  .  .  .  .  .  .  .  .  .  }
  2514  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  2515  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2516  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2517  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:285:4
  2518  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:285:6
  2519  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2520  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2521  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2522  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:285:17
  2523  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: appendGroup @ parser.go:285:19
  2524  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2525  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  2526  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  2527  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:285:31
  2528  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:285:33
  2529  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2530  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  2531  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:285:43
  2532  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: varDecl @ parser.go:285:45
  2533  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2534  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2535  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2536  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2537  .  .  .  .  .  .  .  .  .  .  .  .  }
  2538  .  .  .  .  .  .  .  .  .  .  .  }
  2539  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  2540  .  .  .  .  .  .  .  .  .  .  }
  2541  .  .  .  .  .  .  .  .  .  .  3: *syntax.CaseClause {
  2542  .  .  .  .  .  .  .  .  .  .  .  Cases: _Func @ parser.go:287:8
  2543  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  2544  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  2545  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2546  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2547  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:288:4
  2548  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:288:6
  2549  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2550  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  2551  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2552  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2553  .  .  .  .  .  .  .  .  .  .  .  .  }
  2554  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  2555  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
  2556  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  2557  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: d @ parser.go:289:7
  2558  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2559  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2560  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:289:12
  2561  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: funcDeclOrNil @ parser.go:289:14
  2562  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2563  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  2564  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2565  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2566  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2567  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  2568  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  2569  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: d @ parser.go:289:31
  2570  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:289:36
  2571  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2572  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  2573  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  2574  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2575  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2576  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2577  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:290:5
  2578  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:290:7
  2579  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2580  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2581  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:290:18
  2582  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  2583  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  2584  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:290:25
  2585  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:290:27
  2586  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2587  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: d @ parser.go:290:37
  2588  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2589  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2590  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2591  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2592  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2593  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  2594  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2595  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  2596  .  .  .  .  .  .  .  .  .  .  .  .  }
  2597  .  .  .  .  .  .  .  .  .  .  .  }
  2598  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  2599  .  .  .  .  .  .  .  .  .  .  }
  2600  .  .  .  .  .  .  .  .  .  .  4: *syntax.CaseClause {
  2601  .  .  .  .  .  .  .  .  .  .  .  Cases: nil
  2602  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
  2603  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
  2604  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  2605  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  2606  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: &&
  2607  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  2608  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: &&
  2609  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  2610  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  2611  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2612  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:294:7
  2613  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:294:9
  2614  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2615  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Lbrace @ parser.go:294:16
  2616  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2617  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  2618  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: >
  2619  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2620  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: len @ parser.go:294:27
  2621  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2622  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  2623  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:294:31
  2624  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:294:33
  2625  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2626  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2627  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2628  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2629  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  2630  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  2631  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  2632  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2633  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2634  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2635  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
  2636  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: isEmptyFuncDecl @ parser.go:294:50
  2637  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2638  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IndexExpr {
  2639  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2640  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:294:66
  2641  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:294:68
  2642  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2643  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.Operation {
  2644  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: -
  2645  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2646  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: len @ parser.go:294:77
  2647  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2648  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  2649  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:294:81
  2650  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:294:83
  2651  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2652  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2653  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2654  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2655  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  2656  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  2657  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  2658  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2659  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2660  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2661  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2662  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2663  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2664  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2665  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  2666  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  2667  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  2668  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2669  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2670  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:296:5
  2671  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:296:7
  2672  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2673  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2674  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2675  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"unexpected semicolon or newline before {\""
  2676  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2677  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2678  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2679  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2680  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2681  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2682  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2683  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  2684  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2685  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
  2686  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  2687  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  2688  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2689  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2690  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:298:5
  2691  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:298:7
  2692  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2693  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2694  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2695  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"non-declaration statement outside function body\""
  2696  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2697  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2698  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2699  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2700  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2701  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2702  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2703  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  2704  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2705  .  .  .  .  .  .  .  .  .  .  .  .  }
  2706  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  2707  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2708  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2709  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:300:4
  2710  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:300:6
  2711  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2712  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
  2713  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Const @ parser.go:300:14
  2714  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: _Type @ parser.go:300:22
  2715  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: _Var @ parser.go:300:29
  2716  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: _Func @ parser.go:300:35
  2717  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2718  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2719  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2720  .  .  .  .  .  .  .  .  .  .  .  .  }
  2721  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.BranchStmt {
  2722  .  .  .  .  .  .  .  .  .  .  .  .  .  Tok: continue
  2723  .  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
  2724  .  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 2401)
  2725  .  .  .  .  .  .  .  .  .  .  .  .  }
  2726  .  .  .  .  .  .  .  .  .  .  .  }
  2727  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  2728  .  .  .  .  .  .  .  .  .  .  }
  2729  .  .  .  .  .  .  .  .  .  }
  2730  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  2731  .  .  .  .  .  .  .  .  }
  2732  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  2733  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2734  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2735  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:306:3
  2736  .  .  .  .  .  .  .  .  .  .  Sel: pragma @ parser.go:306:5
  2737  .  .  .  .  .  .  .  .  .  }
  2738  .  .  .  .  .  .  .  .  .  Rhs: *syntax.BasicLit {
  2739  .  .  .  .  .  .  .  .  .  .  Value: "0"
  2740  .  .  .  .  .  .  .  .  .  .  Kind: 0
  2741  .  .  .  .  .  .  .  .  .  }
  2742  .  .  .  .  .  .  .  .  }
  2743  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
  2744  .  .  .  .  .  .  .  .  .  Init: nil
  2745  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  2746  .  .  .  .  .  .  .  .  .  .  Op: &&
  2747  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  2748  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  2749  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2750  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:308:6
  2751  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:308:8
  2752  .  .  .  .  .  .  .  .  .  .  .  }
  2753  .  .  .  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:308:15
  2754  .  .  .  .  .  .  .  .  .  .  }
  2755  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  2756  .  .  .  .  .  .  .  .  .  .  .  Op: !
  2757  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2758  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2759  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:308:24
  2760  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:308:26
  2761  .  .  .  .  .  .  .  .  .  .  .  .  }
  2762  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2763  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Semi @ parser.go:308:30
  2764  .  .  .  .  .  .  .  .  .  .  .  .  }
  2765  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2766  .  .  .  .  .  .  .  .  .  .  .  }
  2767  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  2768  .  .  .  .  .  .  .  .  .  .  }
  2769  .  .  .  .  .  .  .  .  .  }
  2770  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  2771  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  2772  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  2773  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2774  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2775  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:309:4
  2776  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:309:6
  2777  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2778  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2779  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  2780  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"after top level declaration\""
  2781  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  2782  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2783  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2784  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2785  .  .  .  .  .  .  .  .  .  .  .  .  }
  2786  .  .  .  .  .  .  .  .  .  .  .  }
  2787  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  2788  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  2789  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2790  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:310:4
  2791  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:310:6
  2792  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2793  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
  2794  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Const @ parser.go:310:14
  2795  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: _Type @ parser.go:310:22
  2796  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: _Var @ parser.go:310:29
  2797  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: _Func @ parser.go:310:35
  2798  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  2799  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2800  .  .  .  .  .  .  .  .  .  .  .  .  }
  2801  .  .  .  .  .  .  .  .  .  .  .  }
  2802  .  .  .  .  .  .  .  .  .  .  }
  2803  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  2804  .  .  .  .  .  .  .  .  .  }
  2805  .  .  .  .  .  .  .  .  .  Else: nil
  2806  .  .  .  .  .  .  .  .  }
  2807  .  .  .  .  .  .  .  }
  2808  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  2809  .  .  .  .  .  .  }
  2810  .  .  .  .  .  }
  2811  .  .  .  .  .  9: *syntax.AssignStmt {
  2812  .  .  .  .  .  .  Op: <op-0>
  2813  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  2814  .  .  .  .  .  .  .  X: f @ parser.go:315:2
  2815  .  .  .  .  .  .  .  Sel: Lines @ parser.go:315:4
  2816  .  .  .  .  .  .  }
  2817  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  2818  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2819  .  .  .  .  .  .  .  .  X: p @ parser.go:315:12
  2820  .  .  .  .  .  .  .  .  Sel: source @ parser.go:315:14
  2821  .  .  .  .  .  .  .  }
  2822  .  .  .  .  .  .  .  Sel: line @ parser.go:315:21
  2823  .  .  .  .  .  .  }
  2824  .  .  .  .  .  }
  2825  .  .  .  .  .  10: *syntax.ReturnStmt {
  2826  .  .  .  .  .  .  Results: f @ parser.go:317:9
  2827  .  .  .  .  .  }
  2828  .  .  .  .  }
  2829  .  .  .  .  Rbrace: src.Pos {}
  2830  .  .  .  }
  2831  .  .  .  Pragma: 0
  2832  .  .  }
  2833  .  .  24: *syntax.FuncDecl {
  2834  .  .  .  Attr: map[]
  2835  .  .  .  Recv: nil
  2836  .  .  .  Name: isEmptyFuncDecl @ parser.go:320:6
  2837  .  .  .  Type: *syntax.FuncType {
  2838  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  2839  .  .  .  .  .  0: *syntax.Field {
  2840  .  .  .  .  .  .  Name: dcl @ parser.go:320:22
  2841  .  .  .  .  .  .  Type: Decl @ parser.go:320:26
  2842  .  .  .  .  .  }
  2843  .  .  .  .  }
  2844  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  2845  .  .  .  .  .  0: *syntax.Field {
  2846  .  .  .  .  .  .  Name: nil
  2847  .  .  .  .  .  .  Type: bool @ parser.go:320:32
  2848  .  .  .  .  .  }
  2849  .  .  .  .  }
  2850  .  .  .  }
  2851  .  .  .  Body: *syntax.BlockStmt {
  2852  .  .  .  .  List: []syntax.Stmt (2 entries) {
  2853  .  .  .  .  .  0: *syntax.AssignStmt {
  2854  .  .  .  .  .  .  Op: :
  2855  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
  2856  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  2857  .  .  .  .  .  .  .  .  0: f @ parser.go:321:2
  2858  .  .  .  .  .  .  .  .  1: ok @ parser.go:321:5
  2859  .  .  .  .  .  .  .  }
  2860  .  .  .  .  .  .  }
  2861  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
  2862  .  .  .  .  .  .  .  X: dcl @ parser.go:321:11
  2863  .  .  .  .  .  .  .  Type: *syntax.Operation {
  2864  .  .  .  .  .  .  .  .  Op: *
  2865  .  .  .  .  .  .  .  .  X: FuncDecl @ parser.go:321:17
  2866  .  .  .  .  .  .  .  .  Y: nil
  2867  .  .  .  .  .  .  .  }
  2868  .  .  .  .  .  .  }
  2869  .  .  .  .  .  }
  2870  .  .  .  .  .  1: *syntax.ReturnStmt {
  2871  .  .  .  .  .  .  Results: *syntax.Operation {
  2872  .  .  .  .  .  .  .  Op: &&
  2873  .  .  .  .  .  .  .  X: ok @ parser.go:322:9
  2874  .  .  .  .  .  .  .  Y: *syntax.Operation {
  2875  .  .  .  .  .  .  .  .  Op: ==
  2876  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2877  .  .  .  .  .  .  .  .  .  X: f @ parser.go:322:15
  2878  .  .  .  .  .  .  .  .  .  Sel: Body @ parser.go:322:17
  2879  .  .  .  .  .  .  .  .  }
  2880  .  .  .  .  .  .  .  .  Y: nil @ parser.go:322:25
  2881  .  .  .  .  .  .  .  }
  2882  .  .  .  .  .  .  }
  2883  .  .  .  .  .  }
  2884  .  .  .  .  }
  2885  .  .  .  .  Rbrace: src.Pos {}
  2886  .  .  .  }
  2887  .  .  .  Pragma: 0
  2888  .  .  }
  2889  .  .  25: *syntax.FuncDecl {
  2890  .  .  .  Attr: map[]
  2891  .  .  .  Recv: *syntax.Field {
  2892  .  .  .  .  Name: p @ parser.go:329:7
  2893  .  .  .  .  Type: *syntax.Operation {
  2894  .  .  .  .  .  Op: *
  2895  .  .  .  .  .  X: parser @ parser.go:329:10
  2896  .  .  .  .  .  Y: nil
  2897  .  .  .  .  }
  2898  .  .  .  }
  2899  .  .  .  Name: appendGroup @ parser.go:329:18
  2900  .  .  .  Type: *syntax.FuncType {
  2901  .  .  .  .  ParamList: []*syntax.Field (2 entries) {
  2902  .  .  .  .  .  0: *syntax.Field {
  2903  .  .  .  .  .  .  Name: list @ parser.go:329:30
  2904  .  .  .  .  .  .  Type: *syntax.SliceType {
  2905  .  .  .  .  .  .  .  Elem: Decl @ parser.go:329:37
  2906  .  .  .  .  .  .  }
  2907  .  .  .  .  .  }
  2908  .  .  .  .  .  1: *syntax.Field {
  2909  .  .  .  .  .  .  Name: f @ parser.go:329:43
  2910  .  .  .  .  .  .  Type: *syntax.FuncType {
  2911  .  .  .  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  2912  .  .  .  .  .  .  .  .  0: *syntax.Field {
  2913  .  .  .  .  .  .  .  .  .  Name: nil
  2914  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
  2915  .  .  .  .  .  .  .  .  .  .  Op: *
  2916  .  .  .  .  .  .  .  .  .  .  X: Group @ parser.go:329:51
  2917  .  .  .  .  .  .  .  .  .  .  Y: nil
  2918  .  .  .  .  .  .  .  .  .  }
  2919  .  .  .  .  .  .  .  .  }
  2920  .  .  .  .  .  .  .  }
  2921  .  .  .  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  2922  .  .  .  .  .  .  .  .  0: *syntax.Field {
  2923  .  .  .  .  .  .  .  .  .  Name: nil
  2924  .  .  .  .  .  .  .  .  .  Type: Decl @ parser.go:329:58
  2925  .  .  .  .  .  .  .  .  }
  2926  .  .  .  .  .  .  .  }
  2927  .  .  .  .  .  .  }
  2928  .  .  .  .  .  }
  2929  .  .  .  .  }
  2930  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  2931  .  .  .  .  .  0: *syntax.Field {
  2932  .  .  .  .  .  .  Name: nil
  2933  .  .  .  .  .  .  Type: *syntax.SliceType {
  2934  .  .  .  .  .  .  .  Elem: Decl @ parser.go:329:66
  2935  .  .  .  .  .  .  }
  2936  .  .  .  .  .  }
  2937  .  .  .  .  }
  2938  .  .  .  }
  2939  .  .  .  Body: *syntax.BlockStmt {
  2940  .  .  .  .  List: []syntax.Stmt (3 entries) {
  2941  .  .  .  .  .  0: *syntax.IfStmt {
  2942  .  .  .  .  .  .  Init: nil
  2943  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  2944  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  2945  .  .  .  .  .  .  .  .  X: p @ parser.go:330:5
  2946  .  .  .  .  .  .  .  .  Sel: got @ parser.go:330:7
  2947  .  .  .  .  .  .  .  }
  2948  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2949  .  .  .  .  .  .  .  .  0: _Lparen @ parser.go:330:11
  2950  .  .  .  .  .  .  .  }
  2951  .  .  .  .  .  .  .  HasDots: false
  2952  .  .  .  .  .  .  }
  2953  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  2954  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
  2955  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2956  .  .  .  .  .  .  .  .  .  Op: :
  2957  .  .  .  .  .  .  .  .  .  Lhs: g @ parser.go:331:3
  2958  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2959  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:331:8
  2960  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  2961  .  .  .  .  .  .  .  .  .  .  .  0: Group @ parser.go:331:12
  2962  .  .  .  .  .  .  .  .  .  .  }
  2963  .  .  .  .  .  .  .  .  .  .  HasDots: false
  2964  .  .  .  .  .  .  .  .  .  }
  2965  .  .  .  .  .  .  .  .  }
  2966  .  .  .  .  .  .  .  .  1: *syntax.ForStmt {
  2967  .  .  .  .  .  .  .  .  .  Init: nil
  2968  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  2969  .  .  .  .  .  .  .  .  .  .  Op: &&
  2970  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  2971  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  2972  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2973  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:332:7
  2974  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:332:9
  2975  .  .  .  .  .  .  .  .  .  .  .  }
  2976  .  .  .  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:332:16
  2977  .  .  .  .  .  .  .  .  .  .  }
  2978  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  2979  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  2980  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  2981  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:332:24
  2982  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:332:26
  2983  .  .  .  .  .  .  .  .  .  .  .  }
  2984  .  .  .  .  .  .  .  .  .  .  .  Y: _Rparen @ parser.go:332:33
  2985  .  .  .  .  .  .  .  .  .  .  }
  2986  .  .  .  .  .  .  .  .  .  }
  2987  .  .  .  .  .  .  .  .  .  Post: nil
  2988  .  .  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  2989  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  2990  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  2991  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  2992  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: list @ parser.go:333:4
  2993  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  2994  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:333:11
  2995  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  2996  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: list @ parser.go:333:18
  2997  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
  2998  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: f @ parser.go:333:24
  2999  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3000  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: g @ parser.go:333:26
  3001  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3002  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3003  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3004  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3005  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3006  .  .  .  .  .  .  .  .  .  .  .  .  }
  3007  .  .  .  .  .  .  .  .  .  .  .  }
  3008  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  3009  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  3010  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  3011  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !
  3012  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3013  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3014  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:334:8
  3015  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: osemi @ parser.go:334:10
  3016  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3017  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3018  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:334:16
  3019  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3020  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3021  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3022  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  3023  .  .  .  .  .  .  .  .  .  .  .  .  }
  3024  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3025  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  3026  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  3027  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  3028  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
  3029  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 2966)
  3030  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3031  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3032  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3033  .  .  .  .  .  .  .  .  .  .  .  .  }
  3034  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  3035  .  .  .  .  .  .  .  .  .  .  .  }
  3036  .  .  .  .  .  .  .  .  .  .  }
  3037  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3038  .  .  .  .  .  .  .  .  .  }
  3039  .  .  .  .  .  .  .  .  }
  3040  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  3041  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3042  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3043  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:338:3
  3044  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:338:5
  3045  .  .  .  .  .  .  .  .  .  .  }
  3046  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3047  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:338:10
  3048  .  .  .  .  .  .  .  .  .  .  }
  3049  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3050  .  .  .  .  .  .  .  .  .  }
  3051  .  .  .  .  .  .  .  .  }
  3052  .  .  .  .  .  .  .  }
  3053  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3054  .  .  .  .  .  .  }
  3055  .  .  .  .  .  .  Else: *syntax.BlockStmt {
  3056  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  3057  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3058  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3059  .  .  .  .  .  .  .  .  .  Lhs: list @ parser.go:340:3
  3060  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3061  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:340:10
  3062  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  3063  .  .  .  .  .  .  .  .  .  .  .  0: list @ parser.go:340:17
  3064  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
  3065  .  .  .  .  .  .  .  .  .  .  .  .  Fun: f @ parser.go:340:23
  3066  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3067  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:340:25
  3068  .  .  .  .  .  .  .  .  .  .  .  .  }
  3069  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3070  .  .  .  .  .  .  .  .  .  .  .  }
  3071  .  .  .  .  .  .  .  .  .  .  }
  3072  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3073  .  .  .  .  .  .  .  .  .  }
  3074  .  .  .  .  .  .  .  .  }
  3075  .  .  .  .  .  .  .  }
  3076  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3077  .  .  .  .  .  .  }
  3078  .  .  .  .  .  }
  3079  .  .  .  .  .  1: *syntax.IfStmt {
  3080  .  .  .  .  .  .  Init: nil
  3081  .  .  .  .  .  .  Cond: debug @ parser.go:343:5
  3082  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3083  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  3084  .  .  .  .  .  .  .  .  0: *syntax.ForStmt {
  3085  .  .  .  .  .  .  .  .  .  Init: *syntax.RangeClause {
  3086  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
  3087  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  3088  .  .  .  .  .  .  .  .  .  .  .  .  0: _ @ parser.go:344:7
  3089  .  .  .  .  .  .  .  .  .  .  .  .  1: d @ parser.go:344:10
  3090  .  .  .  .  .  .  .  .  .  .  .  }
  3091  .  .  .  .  .  .  .  .  .  .  }
  3092  .  .  .  .  .  .  .  .  .  .  Def: true
  3093  .  .  .  .  .  .  .  .  .  .  X: list @ parser.go:344:21
  3094  .  .  .  .  .  .  .  .  .  }
  3095  .  .  .  .  .  .  .  .  .  Cond: nil
  3096  .  .  .  .  .  .  .  .  .  Post: nil
  3097  .  .  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  3098  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  3099  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
  3100  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  3101  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  3102  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  3103  .  .  .  .  .  .  .  .  .  .  .  .  .  X: d @ parser.go:345:7
  3104  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:345:12
  3105  .  .  .  .  .  .  .  .  .  .  .  .  }
  3106  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3107  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  3108  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  3109  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3110  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: panic @ parser.go:346:5
  3111  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3112  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3113  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"nil list entry\""
  3114  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3115  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3116  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3117  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3118  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3119  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3120  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3121  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3122  .  .  .  .  .  .  .  .  .  .  .  .  }
  3123  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  3124  .  .  .  .  .  .  .  .  .  .  .  }
  3125  .  .  .  .  .  .  .  .  .  .  }
  3126  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3127  .  .  .  .  .  .  .  .  .  }
  3128  .  .  .  .  .  .  .  .  }
  3129  .  .  .  .  .  .  .  }
  3130  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3131  .  .  .  .  .  .  }
  3132  .  .  .  .  .  .  Else: nil
  3133  .  .  .  .  .  }
  3134  .  .  .  .  .  2: *syntax.ReturnStmt {
  3135  .  .  .  .  .  .  Results: list @ parser.go:351:9
  3136  .  .  .  .  .  }
  3137  .  .  .  .  }
  3138  .  .  .  .  Rbrace: src.Pos {}
  3139  .  .  .  }
  3140  .  .  .  Pragma: 0
  3141  .  .  }
  3142  .  .  26: *syntax.FuncDecl {
  3143  .  .  .  Attr: map[]
  3144  .  .  .  Recv: *syntax.Field {
  3145  .  .  .  .  Name: p @ parser.go:356:7
  3146  .  .  .  .  Type: *syntax.Operation {
  3147  .  .  .  .  .  Op: *
  3148  .  .  .  .  .  X: parser @ parser.go:356:10
  3149  .  .  .  .  .  Y: nil
  3150  .  .  .  .  }
  3151  .  .  .  }
  3152  .  .  .  Name: importDecl @ parser.go:356:18
  3153  .  .  .  Type: *syntax.FuncType {
  3154  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  3155  .  .  .  .  .  0: *syntax.Field {
  3156  .  .  .  .  .  .  Name: group @ parser.go:356:29
  3157  .  .  .  .  .  .  Type: *syntax.Operation {
  3158  .  .  .  .  .  .  .  Op: *
  3159  .  .  .  .  .  .  .  X: Group @ parser.go:356:36
  3160  .  .  .  .  .  .  .  Y: nil
  3161  .  .  .  .  .  .  }
  3162  .  .  .  .  .  }
  3163  .  .  .  .  }
  3164  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  3165  .  .  .  .  .  0: *syntax.Field {
  3166  .  .  .  .  .  .  Name: nil
  3167  .  .  .  .  .  .  Type: Decl @ parser.go:356:43
  3168  .  .  .  .  .  }
  3169  .  .  .  .  }
  3170  .  .  .  }
  3171  .  .  .  Body: *syntax.BlockStmt {
  3172  .  .  .  .  List: []syntax.Stmt (8 entries) {
  3173  .  .  .  .  .  0: *syntax.IfStmt {
  3174  .  .  .  .  .  .  Init: nil
  3175  .  .  .  .  .  .  Cond: trace @ parser.go:357:5
  3176  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3177  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  3178  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  3179  .  .  .  .  .  .  .  .  .  Tok: defer
  3180  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  3181  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  3182  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3183  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:358:9
  3184  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:358:11
  3185  .  .  .  .  .  .  .  .  .  .  .  }
  3186  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3187  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3188  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"importDecl\""
  3189  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3190  .  .  .  .  .  .  .  .  .  .  .  .  }
  3191  .  .  .  .  .  .  .  .  .  .  .  }
  3192  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3193  .  .  .  .  .  .  .  .  .  .  }
  3194  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3195  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3196  .  .  .  .  .  .  .  .  .  }
  3197  .  .  .  .  .  .  .  .  }
  3198  .  .  .  .  .  .  .  }
  3199  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3200  .  .  .  .  .  .  }
  3201  .  .  .  .  .  .  Else: nil
  3202  .  .  .  .  .  }
  3203  .  .  .  .  .  1: *syntax.AssignStmt {
  3204  .  .  .  .  .  .  Op: :
  3205  .  .  .  .  .  .  Lhs: d @ parser.go:361:2
  3206  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3207  .  .  .  .  .  .  .  Fun: new @ parser.go:361:7
  3208  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3209  .  .  .  .  .  .  .  .  0: ImportDecl @ parser.go:361:11
  3210  .  .  .  .  .  .  .  }
  3211  .  .  .  .  .  .  .  HasDots: false
  3212  .  .  .  .  .  .  }
  3213  .  .  .  .  .  }
  3214  .  .  .  .  .  2: *syntax.AssignStmt {
  3215  .  .  .  .  .  .  Op: <op-0>
  3216  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3217  .  .  .  .  .  .  .  X: d @ parser.go:362:2
  3218  .  .  .  .  .  .  .  Sel: pos @ parser.go:362:4
  3219  .  .  .  .  .  .  }
  3220  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3221  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3222  .  .  .  .  .  .  .  .  X: p @ parser.go:362:10
  3223  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:362:12
  3224  .  .  .  .  .  .  .  }
  3225  .  .  .  .  .  .  .  ArgList: nil
  3226  .  .  .  .  .  .  .  HasDots: false
  3227  .  .  .  .  .  .  }
  3228  .  .  .  .  .  }
  3229  .  .  .  .  .  3: *syntax.SwitchStmt {
  3230  .  .  .  .  .  .  Init: nil
  3231  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  3232  .  .  .  .  .  .  .  X: p @ parser.go:364:9
  3233  .  .  .  .  .  .  .  Sel: tok @ parser.go:364:11
  3234  .  .  .  .  .  .  }
  3235  .  .  .  .  .  .  Body: []*syntax.CaseClause (2 entries) {
  3236  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  3237  .  .  .  .  .  .  .  .  Cases: _Name @ parser.go:365:7
  3238  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  3239  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3240  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3241  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3242  .  .  .  .  .  .  .  .  .  .  .  X: d @ parser.go:366:3
  3243  .  .  .  .  .  .  .  .  .  .  .  Sel: LocalPkgName @ parser.go:366:5
  3244  .  .  .  .  .  .  .  .  .  .  }
  3245  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3246  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3247  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:366:20
  3248  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:366:22
  3249  .  .  .  .  .  .  .  .  .  .  .  }
  3250  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3251  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3252  .  .  .  .  .  .  .  .  .  .  }
  3253  .  .  .  .  .  .  .  .  .  }
  3254  .  .  .  .  .  .  .  .  }
  3255  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  3256  .  .  .  .  .  .  .  }
  3257  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  3258  .  .  .  .  .  .  .  .  Cases: _Dot @ parser.go:367:7
  3259  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  3260  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3261  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3262  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3263  .  .  .  .  .  .  .  .  .  .  .  X: d @ parser.go:368:3
  3264  .  .  .  .  .  .  .  .  .  .  .  Sel: LocalPkgName @ parser.go:368:5
  3265  .  .  .  .  .  .  .  .  .  .  }
  3266  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3267  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3268  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:368:20
  3269  .  .  .  .  .  .  .  .  .  .  .  .  Sel: newName @ parser.go:368:22
  3270  .  .  .  .  .  .  .  .  .  .  .  }
  3271  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3272  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3273  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\".\""
  3274  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3275  .  .  .  .  .  .  .  .  .  .  .  .  }
  3276  .  .  .  .  .  .  .  .  .  .  .  }
  3277  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3278  .  .  .  .  .  .  .  .  .  .  }
  3279  .  .  .  .  .  .  .  .  .  }
  3280  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  3281  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3282  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3283  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:369:3
  3284  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:369:5
  3285  .  .  .  .  .  .  .  .  .  .  .  }
  3286  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3287  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3288  .  .  .  .  .  .  .  .  .  .  }
  3289  .  .  .  .  .  .  .  .  .  }
  3290  .  .  .  .  .  .  .  .  }
  3291  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  3292  .  .  .  .  .  .  .  }
  3293  .  .  .  .  .  .  }
  3294  .  .  .  .  .  .  Rbrace: src.Pos {}
  3295  .  .  .  .  .  }
  3296  .  .  .  .  .  4: *syntax.AssignStmt {
  3297  .  .  .  .  .  .  Op: <op-0>
  3298  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3299  .  .  .  .  .  .  .  X: d @ parser.go:371:2
  3300  .  .  .  .  .  .  .  Sel: Path @ parser.go:371:4
  3301  .  .  .  .  .  .  }
  3302  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3303  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3304  .  .  .  .  .  .  .  .  X: p @ parser.go:371:11
  3305  .  .  .  .  .  .  .  .  Sel: oliteral @ parser.go:371:13
  3306  .  .  .  .  .  .  .  }
  3307  .  .  .  .  .  .  .  ArgList: nil
  3308  .  .  .  .  .  .  .  HasDots: false
  3309  .  .  .  .  .  .  }
  3310  .  .  .  .  .  }
  3311  .  .  .  .  .  5: *syntax.IfStmt {
  3312  .  .  .  .  .  .  Init: nil
  3313  .  .  .  .  .  .  Cond: *syntax.Operation {
  3314  .  .  .  .  .  .  .  Op: ==
  3315  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  3316  .  .  .  .  .  .  .  .  X: d @ parser.go:372:5
  3317  .  .  .  .  .  .  .  .  Sel: Path @ parser.go:372:7
  3318  .  .  .  .  .  .  .  }
  3319  .  .  .  .  .  .  .  Y: nil @ parser.go:372:15
  3320  .  .  .  .  .  .  }
  3321  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3322  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
  3323  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  3324  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3325  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3326  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:373:3
  3327  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:373:5
  3328  .  .  .  .  .  .  .  .  .  .  }
  3329  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3330  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3331  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"missing import path\""
  3332  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3333  .  .  .  .  .  .  .  .  .  .  .  }
  3334  .  .  .  .  .  .  .  .  .  .  }
  3335  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3336  .  .  .  .  .  .  .  .  .  }
  3337  .  .  .  .  .  .  .  .  }
  3338  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  3339  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3340  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3341  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:374:3
  3342  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:374:5
  3343  .  .  .  .  .  .  .  .  .  .  }
  3344  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  3345  .  .  .  .  .  .  .  .  .  .  .  0: _Semi @ parser.go:374:13
  3346  .  .  .  .  .  .  .  .  .  .  .  1: _Rparen @ parser.go:374:20
  3347  .  .  .  .  .  .  .  .  .  .  }
  3348  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3349  .  .  .  .  .  .  .  .  .  }
  3350  .  .  .  .  .  .  .  .  }
  3351  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
  3352  .  .  .  .  .  .  .  .  .  Results: nil @ parser.go:375:10
  3353  .  .  .  .  .  .  .  .  }
  3354  .  .  .  .  .  .  .  }
  3355  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3356  .  .  .  .  .  .  }
  3357  .  .  .  .  .  .  Else: nil
  3358  .  .  .  .  .  }
  3359  .  .  .  .  .  6: *syntax.AssignStmt {
  3360  .  .  .  .  .  .  Op: <op-0>
  3361  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3362  .  .  .  .  .  .  .  X: d @ parser.go:377:2
  3363  .  .  .  .  .  .  .  Sel: Group @ parser.go:377:4
  3364  .  .  .  .  .  .  }
  3365  .  .  .  .  .  .  Rhs: group @ parser.go:377:12
  3366  .  .  .  .  .  }
  3367  .  .  .  .  .  7: *syntax.ReturnStmt {
  3368  .  .  .  .  .  .  Results: d @ parser.go:379:9
  3369  .  .  .  .  .  }
  3370  .  .  .  .  }
  3371  .  .  .  .  Rbrace: src.Pos {}
  3372  .  .  .  }
  3373  .  .  .  Pragma: 0
  3374  .  .  }
  3375  .  .  27: *syntax.FuncDecl {
  3376  .  .  .  Attr: map[]
  3377  .  .  .  Recv: *syntax.Field {
  3378  .  .  .  .  Name: p @ parser.go:383:7
  3379  .  .  .  .  Type: *syntax.Operation {
  3380  .  .  .  .  .  Op: *
  3381  .  .  .  .  .  X: parser @ parser.go:383:10
  3382  .  .  .  .  .  Y: nil
  3383  .  .  .  .  }
  3384  .  .  .  }
  3385  .  .  .  Name: constDecl @ parser.go:383:18
  3386  .  .  .  Type: *syntax.FuncType {
  3387  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  3388  .  .  .  .  .  0: *syntax.Field {
  3389  .  .  .  .  .  .  Name: group @ parser.go:383:28
  3390  .  .  .  .  .  .  Type: *syntax.Operation {
  3391  .  .  .  .  .  .  .  Op: *
  3392  .  .  .  .  .  .  .  X: Group @ parser.go:383:35
  3393  .  .  .  .  .  .  .  Y: nil
  3394  .  .  .  .  .  .  }
  3395  .  .  .  .  .  }
  3396  .  .  .  .  }
  3397  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  3398  .  .  .  .  .  0: *syntax.Field {
  3399  .  .  .  .  .  .  Name: nil
  3400  .  .  .  .  .  .  Type: Decl @ parser.go:383:42
  3401  .  .  .  .  .  }
  3402  .  .  .  .  }
  3403  .  .  .  }
  3404  .  .  .  Body: *syntax.BlockStmt {
  3405  .  .  .  .  List: []syntax.Stmt (7 entries) {
  3406  .  .  .  .  .  0: *syntax.IfStmt {
  3407  .  .  .  .  .  .  Init: nil
  3408  .  .  .  .  .  .  Cond: trace @ parser.go:384:5
  3409  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3410  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  3411  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  3412  .  .  .  .  .  .  .  .  .  Tok: defer
  3413  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  3414  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  3415  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3416  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:385:9
  3417  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:385:11
  3418  .  .  .  .  .  .  .  .  .  .  .  }
  3419  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3420  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3421  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"constDecl\""
  3422  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3423  .  .  .  .  .  .  .  .  .  .  .  .  }
  3424  .  .  .  .  .  .  .  .  .  .  .  }
  3425  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3426  .  .  .  .  .  .  .  .  .  .  }
  3427  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3428  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3429  .  .  .  .  .  .  .  .  .  }
  3430  .  .  .  .  .  .  .  .  }
  3431  .  .  .  .  .  .  .  }
  3432  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3433  .  .  .  .  .  .  }
  3434  .  .  .  .  .  .  Else: nil
  3435  .  .  .  .  .  }
  3436  .  .  .  .  .  1: *syntax.AssignStmt {
  3437  .  .  .  .  .  .  Op: :
  3438  .  .  .  .  .  .  Lhs: d @ parser.go:388:2
  3439  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3440  .  .  .  .  .  .  .  Fun: new @ parser.go:388:7
  3441  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3442  .  .  .  .  .  .  .  .  0: ConstDecl @ parser.go:388:11
  3443  .  .  .  .  .  .  .  }
  3444  .  .  .  .  .  .  .  HasDots: false
  3445  .  .  .  .  .  .  }
  3446  .  .  .  .  .  }
  3447  .  .  .  .  .  2: *syntax.AssignStmt {
  3448  .  .  .  .  .  .  Op: <op-0>
  3449  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3450  .  .  .  .  .  .  .  X: d @ parser.go:389:2
  3451  .  .  .  .  .  .  .  Sel: pos @ parser.go:389:4
  3452  .  .  .  .  .  .  }
  3453  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3454  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3455  .  .  .  .  .  .  .  .  X: p @ parser.go:389:10
  3456  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:389:12
  3457  .  .  .  .  .  .  .  }
  3458  .  .  .  .  .  .  .  ArgList: nil
  3459  .  .  .  .  .  .  .  HasDots: false
  3460  .  .  .  .  .  .  }
  3461  .  .  .  .  .  }
  3462  .  .  .  .  .  3: *syntax.AssignStmt {
  3463  .  .  .  .  .  .  Op: <op-0>
  3464  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3465  .  .  .  .  .  .  .  X: d @ parser.go:391:2
  3466  .  .  .  .  .  .  .  Sel: NameList @ parser.go:391:4
  3467  .  .  .  .  .  .  }
  3468  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3469  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3470  .  .  .  .  .  .  .  .  X: p @ parser.go:391:15
  3471  .  .  .  .  .  .  .  .  Sel: nameList @ parser.go:391:17
  3472  .  .  .  .  .  .  .  }
  3473  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3474  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  3475  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3476  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:391:26
  3477  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:391:28
  3478  .  .  .  .  .  .  .  .  .  }
  3479  .  .  .  .  .  .  .  .  .  ArgList: nil
  3480  .  .  .  .  .  .  .  .  .  HasDots: false
  3481  .  .  .  .  .  .  .  .  }
  3482  .  .  .  .  .  .  .  }
  3483  .  .  .  .  .  .  .  HasDots: false
  3484  .  .  .  .  .  .  }
  3485  .  .  .  .  .  }
  3486  .  .  .  .  .  4: *syntax.IfStmt {
  3487  .  .  .  .  .  .  Init: nil
  3488  .  .  .  .  .  .  Cond: *syntax.Operation {
  3489  .  .  .  .  .  .  .  Op: &&
  3490  .  .  .  .  .  .  .  X: *syntax.Operation {
  3491  .  .  .  .  .  .  .  .  Op: &&
  3492  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  3493  .  .  .  .  .  .  .  .  .  Op: !=
  3494  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  3495  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:392:5
  3496  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:392:7
  3497  .  .  .  .  .  .  .  .  .  }
  3498  .  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:392:14
  3499  .  .  .  .  .  .  .  .  }
  3500  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  3501  .  .  .  .  .  .  .  .  .  Op: !=
  3502  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  3503  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:392:22
  3504  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:392:24
  3505  .  .  .  .  .  .  .  .  .  }
  3506  .  .  .  .  .  .  .  .  .  Y: _Semi @ parser.go:392:31
  3507  .  .  .  .  .  .  .  .  }
  3508  .  .  .  .  .  .  .  }
  3509  .  .  .  .  .  .  .  Y: *syntax.Operation {
  3510  .  .  .  .  .  .  .  .  Op: !=
  3511  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  3512  .  .  .  .  .  .  .  .  .  X: p @ parser.go:392:40
  3513  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:392:42
  3514  .  .  .  .  .  .  .  .  }
  3515  .  .  .  .  .  .  .  .  Y: _Rparen @ parser.go:392:49
  3516  .  .  .  .  .  .  .  }
  3517  .  .  .  .  .  .  }
  3518  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3519  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  3520  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3521  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3522  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3523  .  .  .  .  .  .  .  .  .  .  X: d @ parser.go:393:3
  3524  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:393:5
  3525  .  .  .  .  .  .  .  .  .  }
  3526  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3527  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3528  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:393:12
  3529  .  .  .  .  .  .  .  .  .  .  .  Sel: typeOrNil @ parser.go:393:14
  3530  .  .  .  .  .  .  .  .  .  .  }
  3531  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3532  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3533  .  .  .  .  .  .  .  .  .  }
  3534  .  .  .  .  .  .  .  .  }
  3535  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  3536  .  .  .  .  .  .  .  .  .  Init: nil
  3537  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  3538  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3539  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:394:6
  3540  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:394:8
  3541  .  .  .  .  .  .  .  .  .  .  }
  3542  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3543  .  .  .  .  .  .  .  .  .  .  .  0: _Assign @ parser.go:394:12
  3544  .  .  .  .  .  .  .  .  .  .  }
  3545  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3546  .  .  .  .  .  .  .  .  .  }
  3547  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3548  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  3549  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3550  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3551  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3552  .  .  .  .  .  .  .  .  .  .  .  .  .  X: d @ parser.go:395:4
  3553  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Values @ parser.go:395:6
  3554  .  .  .  .  .  .  .  .  .  .  .  .  }
  3555  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3556  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3557  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:395:15
  3558  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList @ parser.go:395:17
  3559  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3560  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3561  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3562  .  .  .  .  .  .  .  .  .  .  .  .  }
  3563  .  .  .  .  .  .  .  .  .  .  .  }
  3564  .  .  .  .  .  .  .  .  .  .  }
  3565  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3566  .  .  .  .  .  .  .  .  .  }
  3567  .  .  .  .  .  .  .  .  .  Else: nil
  3568  .  .  .  .  .  .  .  .  }
  3569  .  .  .  .  .  .  .  }
  3570  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3571  .  .  .  .  .  .  }
  3572  .  .  .  .  .  .  Else: nil
  3573  .  .  .  .  .  }
  3574  .  .  .  .  .  5: *syntax.AssignStmt {
  3575  .  .  .  .  .  .  Op: <op-0>
  3576  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3577  .  .  .  .  .  .  .  X: d @ parser.go:398:2
  3578  .  .  .  .  .  .  .  Sel: Group @ parser.go:398:4
  3579  .  .  .  .  .  .  }
  3580  .  .  .  .  .  .  Rhs: group @ parser.go:398:12
  3581  .  .  .  .  .  }
  3582  .  .  .  .  .  6: *syntax.ReturnStmt {
  3583  .  .  .  .  .  .  Results: d @ parser.go:400:9
  3584  .  .  .  .  .  }
  3585  .  .  .  .  }
  3586  .  .  .  .  Rbrace: src.Pos {}
  3587  .  .  .  }
  3588  .  .  .  Pragma: 0
  3589  .  .  }
  3590  .  .  28: *syntax.FuncDecl {
  3591  .  .  .  Attr: map[]
  3592  .  .  .  Recv: *syntax.Field {
  3593  .  .  .  .  Name: p @ parser.go:404:7
  3594  .  .  .  .  Type: *syntax.Operation {
  3595  .  .  .  .  .  Op: *
  3596  .  .  .  .  .  X: parser @ parser.go:404:10
  3597  .  .  .  .  .  Y: nil
  3598  .  .  .  .  }
  3599  .  .  .  }
  3600  .  .  .  Name: typeDecl @ parser.go:404:18
  3601  .  .  .  Type: *syntax.FuncType {
  3602  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  3603  .  .  .  .  .  0: *syntax.Field {
  3604  .  .  .  .  .  .  Name: group @ parser.go:404:27
  3605  .  .  .  .  .  .  Type: *syntax.Operation {
  3606  .  .  .  .  .  .  .  Op: *
  3607  .  .  .  .  .  .  .  X: Group @ parser.go:404:34
  3608  .  .  .  .  .  .  .  Y: nil
  3609  .  .  .  .  .  .  }
  3610  .  .  .  .  .  }
  3611  .  .  .  .  }
  3612  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  3613  .  .  .  .  .  0: *syntax.Field {
  3614  .  .  .  .  .  .  Name: nil
  3615  .  .  .  .  .  .  Type: Decl @ parser.go:404:41
  3616  .  .  .  .  .  }
  3617  .  .  .  .  }
  3618  .  .  .  }
  3619  .  .  .  Body: *syntax.BlockStmt {
  3620  .  .  .  .  List: []syntax.Stmt (10 entries) {
  3621  .  .  .  .  .  0: *syntax.IfStmt {
  3622  .  .  .  .  .  .  Init: nil
  3623  .  .  .  .  .  .  Cond: trace @ parser.go:405:5
  3624  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3625  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  3626  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  3627  .  .  .  .  .  .  .  .  .  Tok: defer
  3628  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  3629  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  3630  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3631  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:406:9
  3632  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:406:11
  3633  .  .  .  .  .  .  .  .  .  .  .  }
  3634  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3635  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3636  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"typeDecl\""
  3637  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3638  .  .  .  .  .  .  .  .  .  .  .  .  }
  3639  .  .  .  .  .  .  .  .  .  .  .  }
  3640  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3641  .  .  .  .  .  .  .  .  .  .  }
  3642  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3643  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3644  .  .  .  .  .  .  .  .  .  }
  3645  .  .  .  .  .  .  .  .  }
  3646  .  .  .  .  .  .  .  }
  3647  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3648  .  .  .  .  .  .  }
  3649  .  .  .  .  .  .  Else: nil
  3650  .  .  .  .  .  }
  3651  .  .  .  .  .  1: *syntax.AssignStmt {
  3652  .  .  .  .  .  .  Op: :
  3653  .  .  .  .  .  .  Lhs: d @ parser.go:409:2
  3654  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3655  .  .  .  .  .  .  .  Fun: new @ parser.go:409:7
  3656  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3657  .  .  .  .  .  .  .  .  0: TypeDecl @ parser.go:409:11
  3658  .  .  .  .  .  .  .  }
  3659  .  .  .  .  .  .  .  HasDots: false
  3660  .  .  .  .  .  .  }
  3661  .  .  .  .  .  }
  3662  .  .  .  .  .  2: *syntax.AssignStmt {
  3663  .  .  .  .  .  .  Op: <op-0>
  3664  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3665  .  .  .  .  .  .  .  X: d @ parser.go:410:2
  3666  .  .  .  .  .  .  .  Sel: pos @ parser.go:410:4
  3667  .  .  .  .  .  .  }
  3668  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3669  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3670  .  .  .  .  .  .  .  .  X: p @ parser.go:410:10
  3671  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:410:12
  3672  .  .  .  .  .  .  .  }
  3673  .  .  .  .  .  .  .  ArgList: nil
  3674  .  .  .  .  .  .  .  HasDots: false
  3675  .  .  .  .  .  .  }
  3676  .  .  .  .  .  }
  3677  .  .  .  .  .  3: *syntax.AssignStmt {
  3678  .  .  .  .  .  .  Op: <op-0>
  3679  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3680  .  .  .  .  .  .  .  X: d @ parser.go:412:2
  3681  .  .  .  .  .  .  .  Sel: Name @ parser.go:412:4
  3682  .  .  .  .  .  .  }
  3683  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3684  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3685  .  .  .  .  .  .  .  .  X: p @ parser.go:412:11
  3686  .  .  .  .  .  .  .  .  Sel: name @ parser.go:412:13
  3687  .  .  .  .  .  .  .  }
  3688  .  .  .  .  .  .  .  ArgList: nil
  3689  .  .  .  .  .  .  .  HasDots: false
  3690  .  .  .  .  .  .  }
  3691  .  .  .  .  .  }
  3692  .  .  .  .  .  4: *syntax.AssignStmt {
  3693  .  .  .  .  .  .  Op: <op-0>
  3694  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3695  .  .  .  .  .  .  .  X: d @ parser.go:413:2
  3696  .  .  .  .  .  .  .  Sel: Alias @ parser.go:413:4
  3697  .  .  .  .  .  .  }
  3698  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3699  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3700  .  .  .  .  .  .  .  .  X: p @ parser.go:413:12
  3701  .  .  .  .  .  .  .  .  Sel: got @ parser.go:413:14
  3702  .  .  .  .  .  .  .  }
  3703  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3704  .  .  .  .  .  .  .  .  0: _Assign @ parser.go:413:18
  3705  .  .  .  .  .  .  .  }
  3706  .  .  .  .  .  .  .  HasDots: false
  3707  .  .  .  .  .  .  }
  3708  .  .  .  .  .  }
  3709  .  .  .  .  .  5: *syntax.AssignStmt {
  3710  .  .  .  .  .  .  Op: <op-0>
  3711  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3712  .  .  .  .  .  .  .  X: d @ parser.go:414:2
  3713  .  .  .  .  .  .  .  Sel: Type @ parser.go:414:4
  3714  .  .  .  .  .  .  }
  3715  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3716  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3717  .  .  .  .  .  .  .  .  X: p @ parser.go:414:11
  3718  .  .  .  .  .  .  .  .  Sel: typeOrNil @ parser.go:414:13
  3719  .  .  .  .  .  .  .  }
  3720  .  .  .  .  .  .  .  ArgList: nil
  3721  .  .  .  .  .  .  .  HasDots: false
  3722  .  .  .  .  .  .  }
  3723  .  .  .  .  .  }
  3724  .  .  .  .  .  6: *syntax.IfStmt {
  3725  .  .  .  .  .  .  Init: nil
  3726  .  .  .  .  .  .  Cond: *syntax.Operation {
  3727  .  .  .  .  .  .  .  Op: ==
  3728  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  3729  .  .  .  .  .  .  .  .  X: d @ parser.go:415:5
  3730  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:415:7
  3731  .  .  .  .  .  .  .  }
  3732  .  .  .  .  .  .  .  Y: nil @ parser.go:415:15
  3733  .  .  .  .  .  .  }
  3734  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3735  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
  3736  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3737  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3738  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3739  .  .  .  .  .  .  .  .  .  .  X: d @ parser.go:416:3
  3740  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:416:5
  3741  .  .  .  .  .  .  .  .  .  }
  3742  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3743  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3744  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:416:12
  3745  .  .  .  .  .  .  .  .  .  .  .  Sel: bad @ parser.go:416:14
  3746  .  .  .  .  .  .  .  .  .  .  }
  3747  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3748  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3749  .  .  .  .  .  .  .  .  .  }
  3750  .  .  .  .  .  .  .  .  }
  3751  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  3752  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3753  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3754  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:417:3
  3755  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:417:5
  3756  .  .  .  .  .  .  .  .  .  .  }
  3757  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3758  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3759  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"in type declaration\""
  3760  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3761  .  .  .  .  .  .  .  .  .  .  .  }
  3762  .  .  .  .  .  .  .  .  .  .  }
  3763  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3764  .  .  .  .  .  .  .  .  .  }
  3765  .  .  .  .  .  .  .  .  }
  3766  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  3767  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  3768  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3769  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:418:3
  3770  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:418:5
  3771  .  .  .  .  .  .  .  .  .  .  }
  3772  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  3773  .  .  .  .  .  .  .  .  .  .  .  0: _Semi @ parser.go:418:13
  3774  .  .  .  .  .  .  .  .  .  .  .  1: _Rparen @ parser.go:418:20
  3775  .  .  .  .  .  .  .  .  .  .  }
  3776  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3777  .  .  .  .  .  .  .  .  .  }
  3778  .  .  .  .  .  .  .  .  }
  3779  .  .  .  .  .  .  .  }
  3780  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3781  .  .  .  .  .  .  }
  3782  .  .  .  .  .  .  Else: nil
  3783  .  .  .  .  .  }
  3784  .  .  .  .  .  7: *syntax.AssignStmt {
  3785  .  .  .  .  .  .  Op: <op-0>
  3786  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3787  .  .  .  .  .  .  .  X: d @ parser.go:420:2
  3788  .  .  .  .  .  .  .  Sel: Group @ parser.go:420:4
  3789  .  .  .  .  .  .  }
  3790  .  .  .  .  .  .  Rhs: group @ parser.go:420:12
  3791  .  .  .  .  .  }
  3792  .  .  .  .  .  8: *syntax.AssignStmt {
  3793  .  .  .  .  .  .  Op: <op-0>
  3794  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3795  .  .  .  .  .  .  .  X: d @ parser.go:421:2
  3796  .  .  .  .  .  .  .  Sel: Pragma @ parser.go:421:4
  3797  .  .  .  .  .  .  }
  3798  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  3799  .  .  .  .  .  .  .  X: p @ parser.go:421:13
  3800  .  .  .  .  .  .  .  Sel: pragma @ parser.go:421:15
  3801  .  .  .  .  .  .  }
  3802  .  .  .  .  .  }
  3803  .  .  .  .  .  9: *syntax.ReturnStmt {
  3804  .  .  .  .  .  .  Results: d @ parser.go:423:9
  3805  .  .  .  .  .  }
  3806  .  .  .  .  }
  3807  .  .  .  .  Rbrace: src.Pos {}
  3808  .  .  .  }
  3809  .  .  .  Pragma: 0
  3810  .  .  }
  3811  .  .  29: *syntax.FuncDecl {
  3812  .  .  .  Attr: map[]
  3813  .  .  .  Recv: *syntax.Field {
  3814  .  .  .  .  Name: p @ parser.go:427:7
  3815  .  .  .  .  Type: *syntax.Operation {
  3816  .  .  .  .  .  Op: *
  3817  .  .  .  .  .  X: parser @ parser.go:427:10
  3818  .  .  .  .  .  Y: nil
  3819  .  .  .  .  }
  3820  .  .  .  }
  3821  .  .  .  Name: varDecl @ parser.go:427:18
  3822  .  .  .  Type: *syntax.FuncType {
  3823  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  3824  .  .  .  .  .  0: *syntax.Field {
  3825  .  .  .  .  .  .  Name: group @ parser.go:427:26
  3826  .  .  .  .  .  .  Type: *syntax.Operation {
  3827  .  .  .  .  .  .  .  Op: *
  3828  .  .  .  .  .  .  .  X: Group @ parser.go:427:33
  3829  .  .  .  .  .  .  .  Y: nil
  3830  .  .  .  .  .  .  }
  3831  .  .  .  .  .  }
  3832  .  .  .  .  }
  3833  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  3834  .  .  .  .  .  0: *syntax.Field {
  3835  .  .  .  .  .  .  Name: nil
  3836  .  .  .  .  .  .  Type: Decl @ parser.go:427:40
  3837  .  .  .  .  .  }
  3838  .  .  .  .  }
  3839  .  .  .  }
  3840  .  .  .  Body: *syntax.BlockStmt {
  3841  .  .  .  .  List: []syntax.Stmt (7 entries) {
  3842  .  .  .  .  .  0: *syntax.IfStmt {
  3843  .  .  .  .  .  .  Init: nil
  3844  .  .  .  .  .  .  Cond: trace @ parser.go:428:5
  3845  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3846  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  3847  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  3848  .  .  .  .  .  .  .  .  .  Tok: defer
  3849  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  3850  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  3851  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3852  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:429:9
  3853  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:429:11
  3854  .  .  .  .  .  .  .  .  .  .  .  }
  3855  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3856  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  3857  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"varDecl\""
  3858  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  3859  .  .  .  .  .  .  .  .  .  .  .  .  }
  3860  .  .  .  .  .  .  .  .  .  .  .  }
  3861  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3862  .  .  .  .  .  .  .  .  .  .  }
  3863  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3864  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3865  .  .  .  .  .  .  .  .  .  }
  3866  .  .  .  .  .  .  .  .  }
  3867  .  .  .  .  .  .  .  }
  3868  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3869  .  .  .  .  .  .  }
  3870  .  .  .  .  .  .  Else: nil
  3871  .  .  .  .  .  }
  3872  .  .  .  .  .  1: *syntax.AssignStmt {
  3873  .  .  .  .  .  .  Op: :
  3874  .  .  .  .  .  .  Lhs: d @ parser.go:432:2
  3875  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3876  .  .  .  .  .  .  .  Fun: new @ parser.go:432:7
  3877  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3878  .  .  .  .  .  .  .  .  0: VarDecl @ parser.go:432:11
  3879  .  .  .  .  .  .  .  }
  3880  .  .  .  .  .  .  .  HasDots: false
  3881  .  .  .  .  .  .  }
  3882  .  .  .  .  .  }
  3883  .  .  .  .  .  2: *syntax.AssignStmt {
  3884  .  .  .  .  .  .  Op: <op-0>
  3885  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3886  .  .  .  .  .  .  .  X: d @ parser.go:433:2
  3887  .  .  .  .  .  .  .  Sel: pos @ parser.go:433:4
  3888  .  .  .  .  .  .  }
  3889  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3890  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3891  .  .  .  .  .  .  .  .  X: p @ parser.go:433:10
  3892  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:433:12
  3893  .  .  .  .  .  .  .  }
  3894  .  .  .  .  .  .  .  ArgList: nil
  3895  .  .  .  .  .  .  .  HasDots: false
  3896  .  .  .  .  .  .  }
  3897  .  .  .  .  .  }
  3898  .  .  .  .  .  3: *syntax.AssignStmt {
  3899  .  .  .  .  .  .  Op: <op-0>
  3900  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3901  .  .  .  .  .  .  .  X: d @ parser.go:435:2
  3902  .  .  .  .  .  .  .  Sel: NameList @ parser.go:435:4
  3903  .  .  .  .  .  .  }
  3904  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3905  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3906  .  .  .  .  .  .  .  .  X: p @ parser.go:435:15
  3907  .  .  .  .  .  .  .  .  Sel: nameList @ parser.go:435:17
  3908  .  .  .  .  .  .  .  }
  3909  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3910  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  3911  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3912  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:435:26
  3913  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:435:28
  3914  .  .  .  .  .  .  .  .  .  }
  3915  .  .  .  .  .  .  .  .  .  ArgList: nil
  3916  .  .  .  .  .  .  .  .  .  HasDots: false
  3917  .  .  .  .  .  .  .  .  }
  3918  .  .  .  .  .  .  .  }
  3919  .  .  .  .  .  .  .  HasDots: false
  3920  .  .  .  .  .  .  }
  3921  .  .  .  .  .  }
  3922  .  .  .  .  .  4: *syntax.IfStmt {
  3923  .  .  .  .  .  .  Init: nil
  3924  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  3925  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3926  .  .  .  .  .  .  .  .  X: p @ parser.go:436:5
  3927  .  .  .  .  .  .  .  .  Sel: got @ parser.go:436:7
  3928  .  .  .  .  .  .  .  }
  3929  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3930  .  .  .  .  .  .  .  .  0: _Assign @ parser.go:436:11
  3931  .  .  .  .  .  .  .  }
  3932  .  .  .  .  .  .  .  HasDots: false
  3933  .  .  .  .  .  .  }
  3934  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3935  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  3936  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3937  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3938  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3939  .  .  .  .  .  .  .  .  .  .  X: d @ parser.go:437:3
  3940  .  .  .  .  .  .  .  .  .  .  Sel: Values @ parser.go:437:5
  3941  .  .  .  .  .  .  .  .  .  }
  3942  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3943  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3944  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:437:14
  3945  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList @ parser.go:437:16
  3946  .  .  .  .  .  .  .  .  .  .  }
  3947  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3948  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3949  .  .  .  .  .  .  .  .  .  }
  3950  .  .  .  .  .  .  .  .  }
  3951  .  .  .  .  .  .  .  }
  3952  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  3953  .  .  .  .  .  .  }
  3954  .  .  .  .  .  .  Else: *syntax.BlockStmt {
  3955  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  3956  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3957  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3958  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3959  .  .  .  .  .  .  .  .  .  .  X: d @ parser.go:439:3
  3960  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:439:5
  3961  .  .  .  .  .  .  .  .  .  }
  3962  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3963  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3964  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:439:12
  3965  .  .  .  .  .  .  .  .  .  .  .  Sel: type_ @ parser.go:439:14
  3966  .  .  .  .  .  .  .  .  .  .  }
  3967  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3968  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3969  .  .  .  .  .  .  .  .  .  }
  3970  .  .  .  .  .  .  .  .  }
  3971  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  3972  .  .  .  .  .  .  .  .  .  Init: nil
  3973  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  3974  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3975  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:440:6
  3976  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:440:8
  3977  .  .  .  .  .  .  .  .  .  .  }
  3978  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  3979  .  .  .  .  .  .  .  .  .  .  .  0: _Assign @ parser.go:440:12
  3980  .  .  .  .  .  .  .  .  .  .  }
  3981  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3982  .  .  .  .  .  .  .  .  .  }
  3983  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  3984  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  3985  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  3986  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  3987  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  3988  .  .  .  .  .  .  .  .  .  .  .  .  .  X: d @ parser.go:441:4
  3989  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Values @ parser.go:441:6
  3990  .  .  .  .  .  .  .  .  .  .  .  .  }
  3991  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  3992  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  3993  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:441:15
  3994  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList @ parser.go:441:17
  3995  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  3996  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  3997  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  3998  .  .  .  .  .  .  .  .  .  .  .  .  }
  3999  .  .  .  .  .  .  .  .  .  .  .  }
  4000  .  .  .  .  .  .  .  .  .  .  }
  4001  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4002  .  .  .  .  .  .  .  .  .  }
  4003  .  .  .  .  .  .  .  .  .  Else: nil
  4004  .  .  .  .  .  .  .  .  }
  4005  .  .  .  .  .  .  .  }
  4006  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4007  .  .  .  .  .  .  }
  4008  .  .  .  .  .  }
  4009  .  .  .  .  .  5: *syntax.AssignStmt {
  4010  .  .  .  .  .  .  Op: <op-0>
  4011  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4012  .  .  .  .  .  .  .  X: d @ parser.go:444:2
  4013  .  .  .  .  .  .  .  Sel: Group @ parser.go:444:4
  4014  .  .  .  .  .  .  }
  4015  .  .  .  .  .  .  Rhs: group @ parser.go:444:12
  4016  .  .  .  .  .  }
  4017  .  .  .  .  .  6: *syntax.ReturnStmt {
  4018  .  .  .  .  .  .  Results: d @ parser.go:446:9
  4019  .  .  .  .  .  }
  4020  .  .  .  .  }
  4021  .  .  .  .  Rbrace: src.Pos {}
  4022  .  .  .  }
  4023  .  .  .  Pragma: 0
  4024  .  .  }
  4025  .  .  30: *syntax.FuncDecl {
  4026  .  .  .  Attr: map[]
  4027  .  .  .  Recv: *syntax.Field {
  4028  .  .  .  .  Name: p @ parser.go:454:7
  4029  .  .  .  .  Type: *syntax.Operation {
  4030  .  .  .  .  .  Op: *
  4031  .  .  .  .  .  X: parser @ parser.go:454:10
  4032  .  .  .  .  .  Y: nil
  4033  .  .  .  .  }
  4034  .  .  .  }
  4035  .  .  .  Name: funcDeclOrNil @ parser.go:454:18
  4036  .  .  .  Type: *syntax.FuncType {
  4037  .  .  .  .  ParamList: nil
  4038  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  4039  .  .  .  .  .  0: *syntax.Field {
  4040  .  .  .  .  .  .  Name: nil
  4041  .  .  .  .  .  .  Type: *syntax.Operation {
  4042  .  .  .  .  .  .  .  Op: *
  4043  .  .  .  .  .  .  .  X: FuncDecl @ parser.go:454:35
  4044  .  .  .  .  .  .  .  Y: nil
  4045  .  .  .  .  .  .  }
  4046  .  .  .  .  .  }
  4047  .  .  .  .  }
  4048  .  .  .  }
  4049  .  .  .  Body: *syntax.BlockStmt {
  4050  .  .  .  .  List: []syntax.Stmt (10 entries) {
  4051  .  .  .  .  .  0: *syntax.IfStmt {
  4052  .  .  .  .  .  .  Init: nil
  4053  .  .  .  .  .  .  Cond: trace @ parser.go:455:5
  4054  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  4055  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  4056  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  4057  .  .  .  .  .  .  .  .  .  Tok: defer
  4058  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  4059  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  4060  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4061  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:456:9
  4062  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:456:11
  4063  .  .  .  .  .  .  .  .  .  .  .  }
  4064  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4065  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4066  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"funcDecl\""
  4067  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4068  .  .  .  .  .  .  .  .  .  .  .  .  }
  4069  .  .  .  .  .  .  .  .  .  .  .  }
  4070  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4071  .  .  .  .  .  .  .  .  .  .  }
  4072  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4073  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4074  .  .  .  .  .  .  .  .  .  }
  4075  .  .  .  .  .  .  .  .  }
  4076  .  .  .  .  .  .  .  }
  4077  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4078  .  .  .  .  .  .  }
  4079  .  .  .  .  .  .  Else: nil
  4080  .  .  .  .  .  }
  4081  .  .  .  .  .  1: *syntax.AssignStmt {
  4082  .  .  .  .  .  .  Op: :
  4083  .  .  .  .  .  .  Lhs: f @ parser.go:459:2
  4084  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4085  .  .  .  .  .  .  .  Fun: new @ parser.go:459:7
  4086  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4087  .  .  .  .  .  .  .  .  0: FuncDecl @ parser.go:459:11
  4088  .  .  .  .  .  .  .  }
  4089  .  .  .  .  .  .  .  HasDots: false
  4090  .  .  .  .  .  .  }
  4091  .  .  .  .  .  }
  4092  .  .  .  .  .  2: *syntax.AssignStmt {
  4093  .  .  .  .  .  .  Op: <op-0>
  4094  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4095  .  .  .  .  .  .  .  X: f @ parser.go:460:2
  4096  .  .  .  .  .  .  .  Sel: pos @ parser.go:460:4
  4097  .  .  .  .  .  .  }
  4098  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4099  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4100  .  .  .  .  .  .  .  .  X: p @ parser.go:460:10
  4101  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:460:12
  4102  .  .  .  .  .  .  .  }
  4103  .  .  .  .  .  .  .  ArgList: nil
  4104  .  .  .  .  .  .  .  HasDots: false
  4105  .  .  .  .  .  .  }
  4106  .  .  .  .  .  }
  4107  .  .  .  .  .  3: *syntax.IfStmt {
  4108  .  .  .  .  .  .  Init: nil
  4109  .  .  .  .  .  .  Cond: *syntax.Operation {
  4110  .  .  .  .  .  .  .  Op: ==
  4111  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  4112  .  .  .  .  .  .  .  .  X: p @ parser.go:462:5
  4113  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:462:7
  4114  .  .  .  .  .  .  .  }
  4115  .  .  .  .  .  .  .  Y: _Lparen @ parser.go:462:14
  4116  .  .  .  .  .  .  }
  4117  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  4118  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  4119  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4120  .  .  .  .  .  .  .  .  .  Op: :
  4121  .  .  .  .  .  .  .  .  .  Lhs: rcvr @ parser.go:463:3
  4122  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4123  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4124  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:463:11
  4125  .  .  .  .  .  .  .  .  .  .  .  Sel: paramList @ parser.go:463:13
  4126  .  .  .  .  .  .  .  .  .  .  }
  4127  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4128  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4129  .  .  .  .  .  .  .  .  .  }
  4130  .  .  .  .  .  .  .  .  }
  4131  .  .  .  .  .  .  .  .  1: *syntax.SwitchStmt {
  4132  .  .  .  .  .  .  .  .  .  Init: nil
  4133  .  .  .  .  .  .  .  .  .  Tag: *syntax.CallExpr {
  4134  .  .  .  .  .  .  .  .  .  .  Fun: len @ parser.go:464:10
  4135  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4136  .  .  .  .  .  .  .  .  .  .  .  0: rcvr @ parser.go:464:14
  4137  .  .  .  .  .  .  .  .  .  .  }
  4138  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4139  .  .  .  .  .  .  .  .  .  }
  4140  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
  4141  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  4142  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.BasicLit {
  4143  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  4144  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  4145  .  .  .  .  .  .  .  .  .  .  .  }
  4146  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  4147  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4148  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4149  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4150  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:466:4
  4151  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error @ parser.go:466:6
  4152  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4153  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4154  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4155  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"method has no receiver\""
  4156  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4157  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4158  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4159  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4160  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4161  .  .  .  .  .  .  .  .  .  .  .  .  }
  4162  .  .  .  .  .  .  .  .  .  .  .  }
  4163  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  4164  .  .  .  .  .  .  .  .  .  .  }
  4165  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  4166  .  .  .  .  .  .  .  .  .  .  .  Cases: nil
  4167  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  4168  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4169  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4170  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4171  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:468:4
  4172  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error @ parser.go:468:6
  4173  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4174  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4175  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4176  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"method has multiple receivers\""
  4177  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4178  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4179  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4180  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4181  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4182  .  .  .  .  .  .  .  .  .  .  .  .  }
  4183  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BranchStmt {
  4184  .  .  .  .  .  .  .  .  .  .  .  .  .  Tok: fallthrough
  4185  .  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
  4186  .  .  .  .  .  .  .  .  .  .  .  .  .  Target: nil
  4187  .  .  .  .  .  .  .  .  .  .  .  .  }
  4188  .  .  .  .  .  .  .  .  .  .  .  }
  4189  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  4190  .  .  .  .  .  .  .  .  .  .  }
  4191  .  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  4192  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.BasicLit {
  4193  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  4194  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  4195  .  .  .  .  .  .  .  .  .  .  .  }
  4196  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  4197  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4198  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4199  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4200  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:471:4
  4201  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Recv @ parser.go:471:6
  4202  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4203  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.IndexExpr {
  4204  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: rcvr @ parser.go:471:13
  4205  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.BasicLit {
  4206  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  4207  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  4208  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4209  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4210  .  .  .  .  .  .  .  .  .  .  .  .  }
  4211  .  .  .  .  .  .  .  .  .  .  .  }
  4212  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  4213  .  .  .  .  .  .  .  .  .  .  }
  4214  .  .  .  .  .  .  .  .  .  }
  4215  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4216  .  .  .  .  .  .  .  .  }
  4217  .  .  .  .  .  .  .  }
  4218  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4219  .  .  .  .  .  .  }
  4220  .  .  .  .  .  .  Else: nil
  4221  .  .  .  .  .  }
  4222  .  .  .  .  .  4: *syntax.IfStmt {
  4223  .  .  .  .  .  .  Init: nil
  4224  .  .  .  .  .  .  Cond: *syntax.Operation {
  4225  .  .  .  .  .  .  .  Op: !=
  4226  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  4227  .  .  .  .  .  .  .  .  X: p @ parser.go:475:5
  4228  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:475:7
  4229  .  .  .  .  .  .  .  }
  4230  .  .  .  .  .  .  .  Y: _Name @ parser.go:475:14
  4231  .  .  .  .  .  .  }
  4232  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  4233  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
  4234  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4235  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4236  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4237  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:476:3
  4238  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:476:5
  4239  .  .  .  .  .  .  .  .  .  .  }
  4240  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4241  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4242  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting name or (\""
  4243  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4244  .  .  .  .  .  .  .  .  .  .  .  }
  4245  .  .  .  .  .  .  .  .  .  .  }
  4246  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4247  .  .  .  .  .  .  .  .  .  }
  4248  .  .  .  .  .  .  .  .  }
  4249  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  4250  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4251  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4252  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:477:3
  4253  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:477:5
  4254  .  .  .  .  .  .  .  .  .  .  }
  4255  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  4256  .  .  .  .  .  .  .  .  .  .  .  0: _Lbrace @ parser.go:477:13
  4257  .  .  .  .  .  .  .  .  .  .  .  1: _Semi @ parser.go:477:22
  4258  .  .  .  .  .  .  .  .  .  .  }
  4259  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4260  .  .  .  .  .  .  .  .  .  }
  4261  .  .  .  .  .  .  .  .  }
  4262  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
  4263  .  .  .  .  .  .  .  .  .  Results: nil @ parser.go:478:10
  4264  .  .  .  .  .  .  .  .  }
  4265  .  .  .  .  .  .  .  }
  4266  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4267  .  .  .  .  .  .  }
  4268  .  .  .  .  .  .  Else: nil
  4269  .  .  .  .  .  }
  4270  .  .  .  .  .  5: *syntax.AssignStmt {
  4271  .  .  .  .  .  .  Op: <op-0>
  4272  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4273  .  .  .  .  .  .  .  X: f @ parser.go:495:2
  4274  .  .  .  .  .  .  .  Sel: Name @ parser.go:495:4
  4275  .  .  .  .  .  .  }
  4276  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4277  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4278  .  .  .  .  .  .  .  .  X: p @ parser.go:495:11
  4279  .  .  .  .  .  .  .  .  Sel: name @ parser.go:495:13
  4280  .  .  .  .  .  .  .  }
  4281  .  .  .  .  .  .  .  ArgList: nil
  4282  .  .  .  .  .  .  .  HasDots: false
  4283  .  .  .  .  .  .  }
  4284  .  .  .  .  .  }
  4285  .  .  .  .  .  6: *syntax.AssignStmt {
  4286  .  .  .  .  .  .  Op: <op-0>
  4287  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4288  .  .  .  .  .  .  .  X: f @ parser.go:496:2
  4289  .  .  .  .  .  .  .  Sel: Type @ parser.go:496:4
  4290  .  .  .  .  .  .  }
  4291  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4292  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4293  .  .  .  .  .  .  .  .  X: p @ parser.go:496:11
  4294  .  .  .  .  .  .  .  .  Sel: funcType @ parser.go:496:13
  4295  .  .  .  .  .  .  .  }
  4296  .  .  .  .  .  .  .  ArgList: nil
  4297  .  .  .  .  .  .  .  HasDots: false
  4298  .  .  .  .  .  .  }
  4299  .  .  .  .  .  }
  4300  .  .  .  .  .  7: *syntax.IfStmt {
  4301  .  .  .  .  .  .  Init: nil
  4302  .  .  .  .  .  .  Cond: *syntax.Operation {
  4303  .  .  .  .  .  .  .  Op: ==
  4304  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  4305  .  .  .  .  .  .  .  .  X: p @ parser.go:497:5
  4306  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:497:7
  4307  .  .  .  .  .  .  .  }
  4308  .  .  .  .  .  .  .  Y: _Lbrace @ parser.go:497:14
  4309  .  .  .  .  .  .  }
  4310  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  4311  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  4312  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4313  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4314  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4315  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:498:3
  4316  .  .  .  .  .  .  .  .  .  .  Sel: Body @ parser.go:498:5
  4317  .  .  .  .  .  .  .  .  .  }
  4318  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4319  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4320  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:498:12
  4321  .  .  .  .  .  .  .  .  .  .  .  Sel: blockStmt @ parser.go:498:14
  4322  .  .  .  .  .  .  .  .  .  .  }
  4323  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4324  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4325  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"\""
  4326  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4327  .  .  .  .  .  .  .  .  .  .  .  }
  4328  .  .  .  .  .  .  .  .  .  .  }
  4329  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4330  .  .  .  .  .  .  .  .  .  }
  4331  .  .  .  .  .  .  .  .  }
  4332  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  4333  .  .  .  .  .  .  .  .  .  Init: nil
  4334  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  4335  .  .  .  .  .  .  .  .  .  .  Op: !=
  4336  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  4337  .  .  .  .  .  .  .  .  .  .  .  Op: &
  4338  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  4339  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:499:6
  4340  .  .  .  .  .  .  .  .  .  .  .  .  Sel: mode @ parser.go:499:8
  4341  .  .  .  .  .  .  .  .  .  .  .  }
  4342  .  .  .  .  .  .  .  .  .  .  .  Y: CheckBranches @ parser.go:499:13
  4343  .  .  .  .  .  .  .  .  .  .  }
  4344  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  4345  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  4346  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  4347  .  .  .  .  .  .  .  .  .  .  }
  4348  .  .  .  .  .  .  .  .  .  }
  4349  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  4350  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  4351  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  4352  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4353  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: checkBranches @ parser.go:500:4
  4354  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  4355  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  4356  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:500:18
  4357  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Body @ parser.go:500:20
  4358  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4359  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  4360  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:500:26
  4361  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: errh @ parser.go:500:28
  4362  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4363  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4364  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4365  .  .  .  .  .  .  .  .  .  .  .  .  }
  4366  .  .  .  .  .  .  .  .  .  .  .  }
  4367  .  .  .  .  .  .  .  .  .  .  }
  4368  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4369  .  .  .  .  .  .  .  .  .  }
  4370  .  .  .  .  .  .  .  .  .  Else: nil
  4371  .  .  .  .  .  .  .  .  }
  4372  .  .  .  .  .  .  .  }
  4373  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4374  .  .  .  .  .  .  }
  4375  .  .  .  .  .  .  Else: nil
  4376  .  .  .  .  .  }
  4377  .  .  .  .  .  8: *syntax.AssignStmt {
  4378  .  .  .  .  .  .  Op: <op-0>
  4379  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4380  .  .  .  .  .  .  .  X: f @ parser.go:504:2
  4381  .  .  .  .  .  .  .  Sel: Pragma @ parser.go:504:4
  4382  .  .  .  .  .  .  }
  4383  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  4384  .  .  .  .  .  .  .  X: p @ parser.go:504:13
  4385  .  .  .  .  .  .  .  Sel: pragma @ parser.go:504:15
  4386  .  .  .  .  .  .  }
  4387  .  .  .  .  .  }
  4388  .  .  .  .  .  9: *syntax.ReturnStmt {
  4389  .  .  .  .  .  .  Results: f @ parser.go:511:9
  4390  .  .  .  .  .  }
  4391  .  .  .  .  }
  4392  .  .  .  .  Rbrace: src.Pos {}
  4393  .  .  .  }
  4394  .  .  .  Pragma: 0
  4395  .  .  }
  4396  .  .  31: *syntax.FuncDecl {
  4397  .  .  .  Attr: map[]
  4398  .  .  .  Recv: *syntax.Field {
  4399  .  .  .  .  Name: p @ parser.go:517:7
  4400  .  .  .  .  Type: *syntax.Operation {
  4401  .  .  .  .  .  Op: *
  4402  .  .  .  .  .  X: parser @ parser.go:517:10
  4403  .  .  .  .  .  Y: nil
  4404  .  .  .  .  }
  4405  .  .  .  }
  4406  .  .  .  Name: expr @ parser.go:517:18
  4407  .  .  .  Type: *syntax.FuncType {
  4408  .  .  .  .  ParamList: nil
  4409  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  4410  .  .  .  .  .  0: *syntax.Field {
  4411  .  .  .  .  .  .  Name: nil
  4412  .  .  .  .  .  .  Type: Expr @ parser.go:517:25
  4413  .  .  .  .  .  }
  4414  .  .  .  .  }
  4415  .  .  .  }
  4416  .  .  .  Body: *syntax.BlockStmt {
  4417  .  .  .  .  List: []syntax.Stmt (2 entries) {
  4418  .  .  .  .  .  0: *syntax.IfStmt {
  4419  .  .  .  .  .  .  Init: nil
  4420  .  .  .  .  .  .  Cond: trace @ parser.go:518:5
  4421  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  4422  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  4423  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  4424  .  .  .  .  .  .  .  .  .  Tok: defer
  4425  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  4426  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  4427  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4428  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:519:9
  4429  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:519:11
  4430  .  .  .  .  .  .  .  .  .  .  .  }
  4431  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4432  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4433  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expr\""
  4434  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4435  .  .  .  .  .  .  .  .  .  .  .  .  }
  4436  .  .  .  .  .  .  .  .  .  .  .  }
  4437  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4438  .  .  .  .  .  .  .  .  .  .  }
  4439  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4440  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4441  .  .  .  .  .  .  .  .  .  }
  4442  .  .  .  .  .  .  .  .  }
  4443  .  .  .  .  .  .  .  }
  4444  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4445  .  .  .  .  .  .  }
  4446  .  .  .  .  .  .  Else: nil
  4447  .  .  .  .  .  }
  4448  .  .  .  .  .  1: *syntax.ReturnStmt {
  4449  .  .  .  .  .  .  Results: *syntax.CallExpr {
  4450  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4451  .  .  .  .  .  .  .  .  X: p @ parser.go:522:9
  4452  .  .  .  .  .  .  .  .  Sel: binaryExpr @ parser.go:522:11
  4453  .  .  .  .  .  .  .  }
  4454  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4455  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4456  .  .  .  .  .  .  .  .  .  Value: "0"
  4457  .  .  .  .  .  .  .  .  .  Kind: 0
  4458  .  .  .  .  .  .  .  .  }
  4459  .  .  .  .  .  .  .  }
  4460  .  .  .  .  .  .  .  HasDots: false
  4461  .  .  .  .  .  .  }
  4462  .  .  .  .  .  }
  4463  .  .  .  .  }
  4464  .  .  .  .  Rbrace: src.Pos {}
  4465  .  .  .  }
  4466  .  .  .  Pragma: 0
  4467  .  .  }
  4468  .  .  32: *syntax.FuncDecl {
  4469  .  .  .  Attr: map[]
  4470  .  .  .  Recv: *syntax.Field {
  4471  .  .  .  .  Name: p @ parser.go:526:7
  4472  .  .  .  .  Type: *syntax.Operation {
  4473  .  .  .  .  .  Op: *
  4474  .  .  .  .  .  X: parser @ parser.go:526:10
  4475  .  .  .  .  .  Y: nil
  4476  .  .  .  .  }
  4477  .  .  .  }
  4478  .  .  .  Name: binaryExpr @ parser.go:526:18
  4479  .  .  .  Type: *syntax.FuncType {
  4480  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  4481  .  .  .  .  .  0: *syntax.Field {
  4482  .  .  .  .  .  .  Name: prec @ parser.go:526:29
  4483  .  .  .  .  .  .  Type: int @ parser.go:526:34
  4484  .  .  .  .  .  }
  4485  .  .  .  .  }
  4486  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  4487  .  .  .  .  .  0: *syntax.Field {
  4488  .  .  .  .  .  .  Name: nil
  4489  .  .  .  .  .  .  Type: Expr @ parser.go:526:39
  4490  .  .  .  .  .  }
  4491  .  .  .  .  }
  4492  .  .  .  }
  4493  .  .  .  Body: *syntax.BlockStmt {
  4494  .  .  .  .  List: []syntax.Stmt (3 entries) {
  4495  .  .  .  .  .  0: *syntax.AssignStmt {
  4496  .  .  .  .  .  .  Op: :
  4497  .  .  .  .  .  .  Lhs: x @ parser.go:529:2
  4498  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4499  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4500  .  .  .  .  .  .  .  .  X: p @ parser.go:529:7
  4501  .  .  .  .  .  .  .  .  Sel: unaryExpr @ parser.go:529:9
  4502  .  .  .  .  .  .  .  }
  4503  .  .  .  .  .  .  .  ArgList: nil
  4504  .  .  .  .  .  .  .  HasDots: false
  4505  .  .  .  .  .  .  }
  4506  .  .  .  .  .  }
  4507  .  .  .  .  .  1: *syntax.ForStmt {
  4508  .  .  .  .  .  .  Init: nil
  4509  .  .  .  .  .  .  Cond: *syntax.Operation {
  4510  .  .  .  .  .  .  .  Op: &&
  4511  .  .  .  .  .  .  .  X: *syntax.ParenExpr {
  4512  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  4513  .  .  .  .  .  .  .  .  .  Op: ||
  4514  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  4515  .  .  .  .  .  .  .  .  .  .  Op: ==
  4516  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  4517  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:530:7
  4518  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:530:9
  4519  .  .  .  .  .  .  .  .  .  .  }
  4520  .  .  .  .  .  .  .  .  .  .  Y: _Operator @ parser.go:530:16
  4521  .  .  .  .  .  .  .  .  .  }
  4522  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  4523  .  .  .  .  .  .  .  .  .  .  Op: ==
  4524  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  4525  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:530:29
  4526  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:530:31
  4527  .  .  .  .  .  .  .  .  .  .  }
  4528  .  .  .  .  .  .  .  .  .  .  Y: _Star @ parser.go:530:38
  4529  .  .  .  .  .  .  .  .  .  }
  4530  .  .  .  .  .  .  .  .  }
  4531  .  .  .  .  .  .  .  }
  4532  .  .  .  .  .  .  .  Y: *syntax.Operation {
  4533  .  .  .  .  .  .  .  .  Op: >
  4534  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  4535  .  .  .  .  .  .  .  .  .  X: p @ parser.go:530:48
  4536  .  .  .  .  .  .  .  .  .  Sel: prec @ parser.go:530:50
  4537  .  .  .  .  .  .  .  .  }
  4538  .  .  .  .  .  .  .  .  Y: prec @ parser.go:530:57
  4539  .  .  .  .  .  .  .  }
  4540  .  .  .  .  .  .  }
  4541  .  .  .  .  .  .  Post: nil
  4542  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  4543  .  .  .  .  .  .  .  List: []syntax.Stmt (8 entries) {
  4544  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4545  .  .  .  .  .  .  .  .  .  Op: :
  4546  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:531:3
  4547  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4548  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:531:8
  4549  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4550  .  .  .  .  .  .  .  .  .  .  .  0: Operation @ parser.go:531:12
  4551  .  .  .  .  .  .  .  .  .  .  }
  4552  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4553  .  .  .  .  .  .  .  .  .  }
  4554  .  .  .  .  .  .  .  .  }
  4555  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  4556  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4557  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4558  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:532:3
  4559  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:532:5
  4560  .  .  .  .  .  .  .  .  .  }
  4561  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4562  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4563  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:532:11
  4564  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:532:13
  4565  .  .  .  .  .  .  .  .  .  .  }
  4566  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4567  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4568  .  .  .  .  .  .  .  .  .  }
  4569  .  .  .  .  .  .  .  .  }
  4570  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  4571  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4572  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4573  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:533:3
  4574  .  .  .  .  .  .  .  .  .  .  Sel: Op @ parser.go:533:5
  4575  .  .  .  .  .  .  .  .  .  }
  4576  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  4577  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:533:10
  4578  .  .  .  .  .  .  .  .  .  .  Sel: op @ parser.go:533:12
  4579  .  .  .  .  .  .  .  .  .  }
  4580  .  .  .  .  .  .  .  .  }
  4581  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  4582  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4583  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4584  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:534:3
  4585  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:534:5
  4586  .  .  .  .  .  .  .  .  .  }
  4587  .  .  .  .  .  .  .  .  .  Rhs: x @ parser.go:534:9
  4588  .  .  .  .  .  .  .  .  }
  4589  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  4590  .  .  .  .  .  .  .  .  .  Op: :
  4591  .  .  .  .  .  .  .  .  .  Lhs: tprec @ parser.go:535:3
  4592  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  4593  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:535:12
  4594  .  .  .  .  .  .  .  .  .  .  Sel: prec @ parser.go:535:14
  4595  .  .  .  .  .  .  .  .  .  }
  4596  .  .  .  .  .  .  .  .  }
  4597  .  .  .  .  .  .  .  .  5: *syntax.ExprStmt {
  4598  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4599  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4600  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:536:3
  4601  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:536:5
  4602  .  .  .  .  .  .  .  .  .  .  }
  4603  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4604  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4605  .  .  .  .  .  .  .  .  .  }
  4606  .  .  .  .  .  .  .  .  }
  4607  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
  4608  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4609  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4610  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:537:3
  4611  .  .  .  .  .  .  .  .  .  .  Sel: Y @ parser.go:537:5
  4612  .  .  .  .  .  .  .  .  .  }
  4613  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4614  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4615  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:537:9
  4616  .  .  .  .  .  .  .  .  .  .  .  Sel: binaryExpr @ parser.go:537:11
  4617  .  .  .  .  .  .  .  .  .  .  }
  4618  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4619  .  .  .  .  .  .  .  .  .  .  .  0: tprec @ parser.go:537:22
  4620  .  .  .  .  .  .  .  .  .  .  }
  4621  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4622  .  .  .  .  .  .  .  .  .  }
  4623  .  .  .  .  .  .  .  .  }
  4624  .  .  .  .  .  .  .  .  7: *syntax.AssignStmt {
  4625  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4626  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:538:3
  4627  .  .  .  .  .  .  .  .  .  Rhs: t @ parser.go:538:7
  4628  .  .  .  .  .  .  .  .  }
  4629  .  .  .  .  .  .  .  }
  4630  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4631  .  .  .  .  .  .  }
  4632  .  .  .  .  .  }
  4633  .  .  .  .  .  2: *syntax.ReturnStmt {
  4634  .  .  .  .  .  .  Results: x @ parser.go:540:9
  4635  .  .  .  .  .  }
  4636  .  .  .  .  }
  4637  .  .  .  .  Rbrace: src.Pos {}
  4638  .  .  .  }
  4639  .  .  .  Pragma: 0
  4640  .  .  }
  4641  .  .  33: *syntax.FuncDecl {
  4642  .  .  .  Attr: map[]
  4643  .  .  .  Recv: *syntax.Field {
  4644  .  .  .  .  Name: p @ parser.go:544:7
  4645  .  .  .  .  Type: *syntax.Operation {
  4646  .  .  .  .  .  Op: *
  4647  .  .  .  .  .  X: parser @ parser.go:544:10
  4648  .  .  .  .  .  Y: nil
  4649  .  .  .  .  }
  4650  .  .  .  }
  4651  .  .  .  Name: unaryExpr @ parser.go:544:18
  4652  .  .  .  Type: *syntax.FuncType {
  4653  .  .  .  .  ParamList: nil
  4654  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  4655  .  .  .  .  .  0: *syntax.Field {
  4656  .  .  .  .  .  .  Name: nil
  4657  .  .  .  .  .  .  Type: Expr @ parser.go:544:30
  4658  .  .  .  .  .  }
  4659  .  .  .  .  }
  4660  .  .  .  }
  4661  .  .  .  Body: *syntax.BlockStmt {
  4662  .  .  .  .  List: []syntax.Stmt (3 entries) {
  4663  .  .  .  .  .  0: *syntax.IfStmt {
  4664  .  .  .  .  .  .  Init: nil
  4665  .  .  .  .  .  .  Cond: trace @ parser.go:545:5
  4666  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  4667  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  4668  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  4669  .  .  .  .  .  .  .  .  .  Tok: defer
  4670  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  4671  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  4672  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4673  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:546:9
  4674  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:546:11
  4675  .  .  .  .  .  .  .  .  .  .  .  }
  4676  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4677  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  4678  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"unaryExpr\""
  4679  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  4680  .  .  .  .  .  .  .  .  .  .  .  .  }
  4681  .  .  .  .  .  .  .  .  .  .  .  }
  4682  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4683  .  .  .  .  .  .  .  .  .  .  }
  4684  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4685  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4686  .  .  .  .  .  .  .  .  .  }
  4687  .  .  .  .  .  .  .  .  }
  4688  .  .  .  .  .  .  .  }
  4689  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4690  .  .  .  .  .  .  }
  4691  .  .  .  .  .  .  Else: nil
  4692  .  .  .  .  .  }
  4693  .  .  .  .  .  1: *syntax.SwitchStmt {
  4694  .  .  .  .  .  .  Init: nil
  4695  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  4696  .  .  .  .  .  .  .  X: p @ parser.go:549:9
  4697  .  .  .  .  .  .  .  Sel: tok @ parser.go:549:11
  4698  .  .  .  .  .  .  }
  4699  .  .  .  .  .  .  Body: []*syntax.CaseClause (2 entries) {
  4700  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  4701  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  4702  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  4703  .  .  .  .  .  .  .  .  .  .  0: _Operator @ parser.go:550:7
  4704  .  .  .  .  .  .  .  .  .  .  1: _Star @ parser.go:550:18
  4705  .  .  .  .  .  .  .  .  .  }
  4706  .  .  .  .  .  .  .  .  }
  4707  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  4708  .  .  .  .  .  .  .  .  .  0: *syntax.SwitchStmt {
  4709  .  .  .  .  .  .  .  .  .  .  Init: nil
  4710  .  .  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  4711  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:551:10
  4712  .  .  .  .  .  .  .  .  .  .  .  Sel: op @ parser.go:551:12
  4713  .  .  .  .  .  .  .  .  .  .  }
  4714  .  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (2 entries) {
  4715  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  4716  .  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  4717  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (5 entries) {
  4718  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: Mul @ parser.go:552:8
  4719  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: Add @ parser.go:552:13
  4720  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: Sub @ parser.go:552:18
  4721  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: Not @ parser.go:552:23
  4722  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: Xor @ parser.go:552:28
  4723  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4724  .  .  .  .  .  .  .  .  .  .  .  .  }
  4725  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
  4726  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4727  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  4728  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:553:4
  4729  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4730  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:553:9
  4731  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4732  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: Operation @ parser.go:553:13
  4733  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4734  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4735  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4736  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4737  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  4738  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4739  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4740  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:554:4
  4741  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:554:6
  4742  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4743  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4744  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4745  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:554:12
  4746  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:554:14
  4747  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4748  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4749  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4750  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4751  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4752  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  4753  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4754  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4755  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:555:4
  4756  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Op @ parser.go:555:6
  4757  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4758  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  4759  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:555:11
  4760  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: op @ parser.go:555:13
  4761  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4762  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4763  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
  4764  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4765  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4766  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:556:4
  4767  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:556:6
  4768  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4769  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4770  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4771  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4772  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4773  .  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  4774  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4775  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4776  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:557:4
  4777  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:557:6
  4778  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4779  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4780  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4781  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:557:10
  4782  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: unaryExpr @ parser.go:557:12
  4783  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4784  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4785  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4786  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4787  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4788  .  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
  4789  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: x @ parser.go:558:11
  4790  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4791  .  .  .  .  .  .  .  .  .  .  .  .  }
  4792  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  4793  .  .  .  .  .  .  .  .  .  .  .  }
  4794  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  4795  .  .  .  .  .  .  .  .  .  .  .  .  Cases: And @ parser.go:560:8
  4796  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
  4797  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4798  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  4799  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:561:4
  4800  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4801  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:561:9
  4802  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4803  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: Operation @ parser.go:561:13
  4804  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4805  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4806  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4807  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4808  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  4809  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4810  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4811  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:562:4
  4812  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:562:6
  4813  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4814  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4815  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4816  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:562:12
  4817  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:562:14
  4818  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4819  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4820  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4821  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4822  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4823  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  4824  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4825  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4826  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:563:4
  4827  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Op @ parser.go:563:6
  4828  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4829  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: And @ parser.go:563:11
  4830  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4831  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
  4832  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4833  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4834  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:564:4
  4835  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:564:6
  4836  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4837  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4838  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4839  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4840  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4841  .  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  4842  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4843  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  4844  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:567:4
  4845  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:567:6
  4846  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4847  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4848  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: unparen @ parser.go:567:10
  4849  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  4850  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  4851  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4852  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:567:18
  4853  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: unaryExpr @ parser.go:567:20
  4854  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4855  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4856  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4857  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4858  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4859  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4860  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4861  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4862  .  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
  4863  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: x @ parser.go:568:11
  4864  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4865  .  .  .  .  .  .  .  .  .  .  .  .  }
  4866  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  4867  .  .  .  .  .  .  .  .  .  .  .  }
  4868  .  .  .  .  .  .  .  .  .  .  }
  4869  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4870  .  .  .  .  .  .  .  .  .  }
  4871  .  .  .  .  .  .  .  .  }
  4872  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  4873  .  .  .  .  .  .  .  }
  4874  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  4875  .  .  .  .  .  .  .  .  Cases: _Arrow @ parser.go:571:7
  4876  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (9 entries) {
  4877  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4878  .  .  .  .  .  .  .  .  .  .  Op: :
  4879  .  .  .  .  .  .  .  .  .  .  Lhs: pos @ parser.go:573:3
  4880  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4881  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4882  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:573:10
  4883  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:573:12
  4884  .  .  .  .  .  .  .  .  .  .  .  }
  4885  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4886  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4887  .  .  .  .  .  .  .  .  .  .  }
  4888  .  .  .  .  .  .  .  .  .  }
  4889  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  4890  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  4891  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4892  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:574:3
  4893  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:574:5
  4894  .  .  .  .  .  .  .  .  .  .  .  }
  4895  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4896  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4897  .  .  .  .  .  .  .  .  .  .  }
  4898  .  .  .  .  .  .  .  .  .  }
  4899  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  4900  .  .  .  .  .  .  .  .  .  .  Op: :
  4901  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:580:3
  4902  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  4903  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  4904  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:580:8
  4905  .  .  .  .  .  .  .  .  .  .  .  .  Sel: unaryExpr @ parser.go:580:10
  4906  .  .  .  .  .  .  .  .  .  .  .  }
  4907  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  4908  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  4909  .  .  .  .  .  .  .  .  .  .  }
  4910  .  .  .  .  .  .  .  .  .  }
  4911  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  4912  .  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
  4913  .  .  .  .  .  .  .  .  .  .  .  Op: :
  4914  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
  4915  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  4916  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _ @ parser.go:593:6
  4917  .  .  .  .  .  .  .  .  .  .  .  .  .  1: ok @ parser.go:593:9
  4918  .  .  .  .  .  .  .  .  .  .  .  .  }
  4919  .  .  .  .  .  .  .  .  .  .  .  }
  4920  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
  4921  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:593:15
  4922  .  .  .  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
  4923  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  4924  .  .  .  .  .  .  .  .  .  .  .  .  .  X: ChanType @ parser.go:593:19
  4925  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  4926  .  .  .  .  .  .  .  .  .  .  .  .  }
  4927  .  .  .  .  .  .  .  .  .  .  .  }
  4928  .  .  .  .  .  .  .  .  .  .  }
  4929  .  .  .  .  .  .  .  .  .  .  Cond: ok @ parser.go:593:30
  4930  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  4931  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (5 entries) {
  4932  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4933  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  4934  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: dir @ parser.go:595:4
  4935  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: SendOnly @ parser.go:595:11
  4936  .  .  .  .  .  .  .  .  .  .  .  .  }
  4937  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  4938  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  4939  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:596:4
  4940  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x @ parser.go:596:9
  4941  .  .  .  .  .  .  .  .  .  .  .  .  }
  4942  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.ForStmt {
  4943  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  4944  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  4945  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  4946  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: dir @ parser.go:597:8
  4947  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: SendOnly @ parser.go:597:15
  4948  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4949  .  .  .  .  .  .  .  .  .  .  .  .  .  Post: nil
  4950  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  4951  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (6 entries) {
  4952  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  4953  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  4954  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
  4955  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  4956  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: c @ parser.go:598:5
  4957  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: ok @ parser.go:598:8
  4958  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4959  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4960  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
  4961  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:598:14
  4962  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
  4963  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  4964  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: ChanType @ parser.go:598:18
  4965  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  4966  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4967  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4968  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4969  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  4970  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  4971  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  4972  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !
  4973  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: ok @ parser.go:599:9
  4974  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  4975  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4976  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  4977  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  4978  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  4979  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  4980  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
  4981  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 4942)
  4982  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4983  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4984  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  4985  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4986  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  4987  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4988  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  4989  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  4990  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: dir @ parser.go:602:5
  4991  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  4992  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: c @ parser.go:602:11
  4993  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Dir @ parser.go:602:13
  4994  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4995  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  4996  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  4997  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  4998  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  4999  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  5000  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: dir @ parser.go:603:8
  5001  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: RecvOnly @ parser.go:603:15
  5002  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5003  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  5004  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  5005  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  5006  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5007  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5008  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:606:6
  5009  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:606:8
  5010  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5011  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5012  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5013  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"unexpected <-, expecting chan\""
  5014  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5015  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5016  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5017  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5018  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5019  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5020  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5021  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  5022  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5023  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  5024  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5025  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  5026  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5027  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5028  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: c @ parser.go:609:5
  5029  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Dir @ parser.go:609:7
  5030  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5031  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: RecvOnly @ parser.go:609:13
  5032  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5033  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  5034  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5035  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:610:5
  5036  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  5037  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: c @ parser.go:610:9
  5038  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Elem @ parser.go:610:11
  5039  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5040  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5041  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5042  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  5043  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5044  .  .  .  .  .  .  .  .  .  .  .  .  }
  5045  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  5046  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5047  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  5048  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  5049  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: dir @ parser.go:612:7
  5050  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: SendOnly @ parser.go:612:14
  5051  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5052  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  5053  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  5054  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  5055  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5056  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5057  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:615:5
  5058  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:615:7
  5059  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5060  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5061  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  5062  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5063  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt @ parser.go:615:20
  5064  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf @ parser.go:615:24
  5065  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5066  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  5067  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5068  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"unexpected %s, expecting chan\""
  5069  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5070  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5071  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
  5072  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: String @ parser.go:615:65
  5073  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5074  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: t @ parser.go:615:72
  5075  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5076  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5077  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5078  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5079  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5080  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5081  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5082  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5083  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5084  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5085  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5086  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  5087  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5088  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  5089  .  .  .  .  .  .  .  .  .  .  .  .  }
  5090  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.ReturnStmt {
  5091  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: x @ parser.go:618:11
  5092  .  .  .  .  .  .  .  .  .  .  .  .  }
  5093  .  .  .  .  .  .  .  .  .  .  .  }
  5094  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  5095  .  .  .  .  .  .  .  .  .  .  }
  5096  .  .  .  .  .  .  .  .  .  .  Else: nil
  5097  .  .  .  .  .  .  .  .  .  }
  5098  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  5099  .  .  .  .  .  .  .  .  .  .  Op: :
  5100  .  .  .  .  .  .  .  .  .  .  Lhs: o @ parser.go:622:3
  5101  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5102  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:622:8
  5103  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5104  .  .  .  .  .  .  .  .  .  .  .  .  0: Operation @ parser.go:622:12
  5105  .  .  .  .  .  .  .  .  .  .  .  }
  5106  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5107  .  .  .  .  .  .  .  .  .  .  }
  5108  .  .  .  .  .  .  .  .  .  }
  5109  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  5110  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5111  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5112  .  .  .  .  .  .  .  .  .  .  .  X: o @ parser.go:623:3
  5113  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:623:5
  5114  .  .  .  .  .  .  .  .  .  .  }
  5115  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:623:11
  5116  .  .  .  .  .  .  .  .  .  }
  5117  .  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
  5118  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5119  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5120  .  .  .  .  .  .  .  .  .  .  .  X: o @ parser.go:624:3
  5121  .  .  .  .  .  .  .  .  .  .  .  Sel: Op @ parser.go:624:5
  5122  .  .  .  .  .  .  .  .  .  .  }
  5123  .  .  .  .  .  .  .  .  .  .  Rhs: Recv @ parser.go:624:10
  5124  .  .  .  .  .  .  .  .  .  }
  5125  .  .  .  .  .  .  .  .  .  7: *syntax.AssignStmt {
  5126  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5127  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5128  .  .  .  .  .  .  .  .  .  .  .  X: o @ parser.go:625:3
  5129  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:625:5
  5130  .  .  .  .  .  .  .  .  .  .  }
  5131  .  .  .  .  .  .  .  .  .  .  Rhs: x @ parser.go:625:9
  5132  .  .  .  .  .  .  .  .  .  }
  5133  .  .  .  .  .  .  .  .  .  8: *syntax.ReturnStmt {
  5134  .  .  .  .  .  .  .  .  .  .  Results: o @ parser.go:626:10
  5135  .  .  .  .  .  .  .  .  .  }
  5136  .  .  .  .  .  .  .  .  }
  5137  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  5138  .  .  .  .  .  .  .  }
  5139  .  .  .  .  .  .  }
  5140  .  .  .  .  .  .  Rbrace: src.Pos {}
  5141  .  .  .  .  .  }
  5142  .  .  .  .  .  2: *syntax.ReturnStmt {
  5143  .  .  .  .  .  .  Results: *syntax.CallExpr {
  5144  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5145  .  .  .  .  .  .  .  .  X: p @ parser.go:632:9
  5146  .  .  .  .  .  .  .  .  Sel: pexpr @ parser.go:632:11
  5147  .  .  .  .  .  .  .  }
  5148  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5149  .  .  .  .  .  .  .  .  0: true @ parser.go:632:17
  5150  .  .  .  .  .  .  .  }
  5151  .  .  .  .  .  .  .  HasDots: false
  5152  .  .  .  .  .  .  }
  5153  .  .  .  .  .  }
  5154  .  .  .  .  }
  5155  .  .  .  .  Rbrace: src.Pos {}
  5156  .  .  .  }
  5157  .  .  .  Pragma: 0
  5158  .  .  }
  5159  .  .  34: *syntax.FuncDecl {
  5160  .  .  .  Attr: map[]
  5161  .  .  .  Recv: *syntax.Field {
  5162  .  .  .  .  Name: p @ parser.go:636:7
  5163  .  .  .  .  Type: *syntax.Operation {
  5164  .  .  .  .  .  Op: *
  5165  .  .  .  .  .  X: parser @ parser.go:636:10
  5166  .  .  .  .  .  Y: nil
  5167  .  .  .  .  }
  5168  .  .  .  }
  5169  .  .  .  Name: callStmt @ parser.go:636:18
  5170  .  .  .  Type: *syntax.FuncType {
  5171  .  .  .  .  ParamList: nil
  5172  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  5173  .  .  .  .  .  0: *syntax.Field {
  5174  .  .  .  .  .  .  Name: nil
  5175  .  .  .  .  .  .  Type: *syntax.Operation {
  5176  .  .  .  .  .  .  .  Op: *
  5177  .  .  .  .  .  .  .  X: CallStmt @ parser.go:636:30
  5178  .  .  .  .  .  .  .  Y: nil
  5179  .  .  .  .  .  .  }
  5180  .  .  .  .  .  }
  5181  .  .  .  .  }
  5182  .  .  .  }
  5183  .  .  .  Body: *syntax.BlockStmt {
  5184  .  .  .  .  List: []syntax.Stmt (11 entries) {
  5185  .  .  .  .  .  0: *syntax.IfStmt {
  5186  .  .  .  .  .  .  Init: nil
  5187  .  .  .  .  .  .  Cond: trace @ parser.go:637:5
  5188  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  5189  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  5190  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  5191  .  .  .  .  .  .  .  .  .  Tok: defer
  5192  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  5193  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  5194  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5195  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:638:9
  5196  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:638:11
  5197  .  .  .  .  .  .  .  .  .  .  .  }
  5198  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5199  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5200  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"callStmt\""
  5201  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5202  .  .  .  .  .  .  .  .  .  .  .  .  }
  5203  .  .  .  .  .  .  .  .  .  .  .  }
  5204  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5205  .  .  .  .  .  .  .  .  .  .  }
  5206  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5207  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5208  .  .  .  .  .  .  .  .  .  }
  5209  .  .  .  .  .  .  .  .  }
  5210  .  .  .  .  .  .  .  }
  5211  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  5212  .  .  .  .  .  .  }
  5213  .  .  .  .  .  .  Else: nil
  5214  .  .  .  .  .  }
  5215  .  .  .  .  .  1: *syntax.AssignStmt {
  5216  .  .  .  .  .  .  Op: :
  5217  .  .  .  .  .  .  Lhs: s @ parser.go:641:2
  5218  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5219  .  .  .  .  .  .  .  Fun: new @ parser.go:641:7
  5220  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5221  .  .  .  .  .  .  .  .  0: CallStmt @ parser.go:641:11
  5222  .  .  .  .  .  .  .  }
  5223  .  .  .  .  .  .  .  HasDots: false
  5224  .  .  .  .  .  .  }
  5225  .  .  .  .  .  }
  5226  .  .  .  .  .  2: *syntax.AssignStmt {
  5227  .  .  .  .  .  .  Op: <op-0>
  5228  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5229  .  .  .  .  .  .  .  X: s @ parser.go:642:2
  5230  .  .  .  .  .  .  .  Sel: pos @ parser.go:642:4
  5231  .  .  .  .  .  .  }
  5232  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5233  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5234  .  .  .  .  .  .  .  .  X: p @ parser.go:642:10
  5235  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:642:12
  5236  .  .  .  .  .  .  .  }
  5237  .  .  .  .  .  .  .  ArgList: nil
  5238  .  .  .  .  .  .  .  HasDots: false
  5239  .  .  .  .  .  .  }
  5240  .  .  .  .  .  }
  5241  .  .  .  .  .  3: *syntax.AssignStmt {
  5242  .  .  .  .  .  .  Op: <op-0>
  5243  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5244  .  .  .  .  .  .  .  X: s @ parser.go:643:2
  5245  .  .  .  .  .  .  .  Sel: Tok @ parser.go:643:4
  5246  .  .  .  .  .  .  }
  5247  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
  5248  .  .  .  .  .  .  .  X: p @ parser.go:643:10
  5249  .  .  .  .  .  .  .  Sel: tok @ parser.go:643:12
  5250  .  .  .  .  .  .  }
  5251  .  .  .  .  .  }
  5252  .  .  .  .  .  4: *syntax.ExprStmt {
  5253  .  .  .  .  .  .  X: *syntax.CallExpr {
  5254  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5255  .  .  .  .  .  .  .  .  X: p @ parser.go:644:2
  5256  .  .  .  .  .  .  .  .  Sel: next @ parser.go:644:4
  5257  .  .  .  .  .  .  .  }
  5258  .  .  .  .  .  .  .  ArgList: nil
  5259  .  .  .  .  .  .  .  HasDots: false
  5260  .  .  .  .  .  .  }
  5261  .  .  .  .  .  }
  5262  .  .  .  .  .  5: *syntax.AssignStmt {
  5263  .  .  .  .  .  .  Op: :
  5264  .  .  .  .  .  .  Lhs: x @ parser.go:646:2
  5265  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5266  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5267  .  .  .  .  .  .  .  .  X: p @ parser.go:646:7
  5268  .  .  .  .  .  .  .  .  Sel: pexpr @ parser.go:646:9
  5269  .  .  .  .  .  .  .  }
  5270  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5271  .  .  .  .  .  .  .  .  0: *syntax.Operation {
  5272  .  .  .  .  .  .  .  .  .  Op: ==
  5273  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5274  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:646:15
  5275  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:646:17
  5276  .  .  .  .  .  .  .  .  .  }
  5277  .  .  .  .  .  .  .  .  .  Y: _Lparen @ parser.go:646:24
  5278  .  .  .  .  .  .  .  .  }
  5279  .  .  .  .  .  .  .  }
  5280  .  .  .  .  .  .  .  HasDots: false
  5281  .  .  .  .  .  .  }
  5282  .  .  .  .  .  }
  5283  .  .  .  .  .  6: *syntax.IfStmt {
  5284  .  .  .  .  .  .  Init: *syntax.AssignStmt {
  5285  .  .  .  .  .  .  .  Op: :
  5286  .  .  .  .  .  .  .  Lhs: t @ parser.go:647:5
  5287  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5288  .  .  .  .  .  .  .  .  Fun: unparen @ parser.go:647:10
  5289  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5290  .  .  .  .  .  .  .  .  .  0: x @ parser.go:647:18
  5291  .  .  .  .  .  .  .  .  }
  5292  .  .  .  .  .  .  .  .  HasDots: false
  5293  .  .  .  .  .  .  .  }
  5294  .  .  .  .  .  .  }
  5295  .  .  .  .  .  .  Cond: *syntax.Operation {
  5296  .  .  .  .  .  .  .  Op: !=
  5297  .  .  .  .  .  .  .  X: t @ parser.go:647:22
  5298  .  .  .  .  .  .  .  Y: x @ parser.go:647:27
  5299  .  .  .  .  .  .  }
  5300  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  5301  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  5302  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  5303  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5304  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5305  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:648:3
  5306  .  .  .  .  .  .  .  .  .  .  .  Sel: error @ parser.go:648:5
  5307  .  .  .  .  .  .  .  .  .  .  }
  5308  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5309  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  5310  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5311  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt @ parser.go:648:11
  5312  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf @ parser.go:648:15
  5313  .  .  .  .  .  .  .  .  .  .  .  .  }
  5314  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  5315  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5316  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expression in %s must not be parenthesized\""
  5317  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5318  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5319  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  5320  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:648:69
  5321  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Tok @ parser.go:648:71
  5322  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5323  .  .  .  .  .  .  .  .  .  .  .  .  }
  5324  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5325  .  .  .  .  .  .  .  .  .  .  .  }
  5326  .  .  .  .  .  .  .  .  .  .  }
  5327  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5328  .  .  .  .  .  .  .  .  .  }
  5329  .  .  .  .  .  .  .  .  }
  5330  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  5331  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5332  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:650:3
  5333  .  .  .  .  .  .  .  .  .  Rhs: t @ parser.go:650:7
  5334  .  .  .  .  .  .  .  .  }
  5335  .  .  .  .  .  .  .  }
  5336  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  5337  .  .  .  .  .  .  }
  5338  .  .  .  .  .  .  Else: nil
  5339  .  .  .  .  .  }
  5340  .  .  .  .  .  7: *syntax.AssignStmt {
  5341  .  .  .  .  .  .  Op: :
  5342  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
  5343  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  5344  .  .  .  .  .  .  .  .  0: cx @ parser.go:653:2
  5345  .  .  .  .  .  .  .  .  1: ok @ parser.go:653:6
  5346  .  .  .  .  .  .  .  }
  5347  .  .  .  .  .  .  }
  5348  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
  5349  .  .  .  .  .  .  .  X: x @ parser.go:653:12
  5350  .  .  .  .  .  .  .  Type: *syntax.Operation {
  5351  .  .  .  .  .  .  .  .  Op: *
  5352  .  .  .  .  .  .  .  .  X: CallExpr @ parser.go:653:16
  5353  .  .  .  .  .  .  .  .  Y: nil
  5354  .  .  .  .  .  .  .  }
  5355  .  .  .  .  .  .  }
  5356  .  .  .  .  .  }
  5357  .  .  .  .  .  8: *syntax.IfStmt {
  5358  .  .  .  .  .  .  Init: nil
  5359  .  .  .  .  .  .  Cond: *syntax.Operation {
  5360  .  .  .  .  .  .  .  Op: !
  5361  .  .  .  .  .  .  .  X: ok @ parser.go:654:6
  5362  .  .  .  .  .  .  .  Y: nil
  5363  .  .  .  .  .  .  }
  5364  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  5365  .  .  .  .  .  .  .  List: []syntax.Stmt (4 entries) {
  5366  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  5367  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5368  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5369  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:655:3
  5370  .  .  .  .  .  .  .  .  .  .  .  Sel: error @ parser.go:655:5
  5371  .  .  .  .  .  .  .  .  .  .  }
  5372  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5373  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  5374  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5375  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt @ parser.go:655:11
  5376  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf @ parser.go:655:15
  5377  .  .  .  .  .  .  .  .  .  .  .  .  }
  5378  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  5379  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5380  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expression in %s must be function call\""
  5381  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5382  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5383  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  5384  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:655:65
  5385  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Tok @ parser.go:655:67
  5386  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5387  .  .  .  .  .  .  .  .  .  .  .  .  }
  5388  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5389  .  .  .  .  .  .  .  .  .  .  .  }
  5390  .  .  .  .  .  .  .  .  .  .  }
  5391  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5392  .  .  .  .  .  .  .  .  .  }
  5393  .  .  .  .  .  .  .  .  }
  5394  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  5395  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5396  .  .  .  .  .  .  .  .  .  Lhs: cx @ parser.go:657:3
  5397  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5398  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:657:8
  5399  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5400  .  .  .  .  .  .  .  .  .  .  .  0: CallExpr @ parser.go:657:12
  5401  .  .  .  .  .  .  .  .  .  .  }
  5402  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5403  .  .  .  .  .  .  .  .  .  }
  5404  .  .  .  .  .  .  .  .  }
  5405  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  5406  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5407  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5408  .  .  .  .  .  .  .  .  .  .  X: cx @ parser.go:658:3
  5409  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:658:6
  5410  .  .  .  .  .  .  .  .  .  }
  5411  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5412  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5413  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:658:12
  5414  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:658:14
  5415  .  .  .  .  .  .  .  .  .  .  }
  5416  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5417  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5418  .  .  .  .  .  .  .  .  .  }
  5419  .  .  .  .  .  .  .  .  }
  5420  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  5421  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5422  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5423  .  .  .  .  .  .  .  .  .  .  X: cx @ parser.go:659:3
  5424  .  .  .  .  .  .  .  .  .  .  Sel: Fun @ parser.go:659:6
  5425  .  .  .  .  .  .  .  .  .  }
  5426  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5427  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5428  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:659:12
  5429  .  .  .  .  .  .  .  .  .  .  .  Sel: bad @ parser.go:659:14
  5430  .  .  .  .  .  .  .  .  .  .  }
  5431  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5432  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5433  .  .  .  .  .  .  .  .  .  }
  5434  .  .  .  .  .  .  .  .  }
  5435  .  .  .  .  .  .  .  }
  5436  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  5437  .  .  .  .  .  .  }
  5438  .  .  .  .  .  .  Else: nil
  5439  .  .  .  .  .  }
  5440  .  .  .  .  .  9: *syntax.AssignStmt {
  5441  .  .  .  .  .  .  Op: <op-0>
  5442  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5443  .  .  .  .  .  .  .  X: s @ parser.go:662:2
  5444  .  .  .  .  .  .  .  Sel: Call @ parser.go:662:4
  5445  .  .  .  .  .  .  }
  5446  .  .  .  .  .  .  Rhs: cx @ parser.go:662:11
  5447  .  .  .  .  .  }
  5448  .  .  .  .  .  10: *syntax.ReturnStmt {
  5449  .  .  .  .  .  .  Results: s @ parser.go:663:9
  5450  .  .  .  .  .  }
  5451  .  .  .  .  }
  5452  .  .  .  .  Rbrace: src.Pos {}
  5453  .  .  .  }
  5454  .  .  .  Pragma: 0
  5455  .  .  }
  5456  .  .  35: *syntax.FuncDecl {
  5457  .  .  .  Attr: map[]
  5458  .  .  .  Recv: *syntax.Field {
  5459  .  .  .  .  Name: p @ parser.go:670:7
  5460  .  .  .  .  Type: *syntax.Operation {
  5461  .  .  .  .  .  Op: *
  5462  .  .  .  .  .  X: parser @ parser.go:670:10
  5463  .  .  .  .  .  Y: nil
  5464  .  .  .  .  }
  5465  .  .  .  }
  5466  .  .  .  Name: operand @ parser.go:670:18
  5467  .  .  .  Type: *syntax.FuncType {
  5468  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  5469  .  .  .  .  .  0: *syntax.Field {
  5470  .  .  .  .  .  .  Name: keep_parens @ parser.go:670:26
  5471  .  .  .  .  .  .  Type: bool @ parser.go:670:38
  5472  .  .  .  .  .  }
  5473  .  .  .  .  }
  5474  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  5475  .  .  .  .  .  0: *syntax.Field {
  5476  .  .  .  .  .  .  Name: nil
  5477  .  .  .  .  .  .  Type: Expr @ parser.go:670:44
  5478  .  .  .  .  .  }
  5479  .  .  .  .  }
  5480  .  .  .  }
  5481  .  .  .  Body: *syntax.BlockStmt {
  5482  .  .  .  .  List: []syntax.Stmt (2 entries) {
  5483  .  .  .  .  .  0: *syntax.IfStmt {
  5484  .  .  .  .  .  .  Init: nil
  5485  .  .  .  .  .  .  Cond: trace @ parser.go:671:5
  5486  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  5487  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  5488  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  5489  .  .  .  .  .  .  .  .  .  Tok: defer
  5490  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  5491  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  5492  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5493  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:672:9
  5494  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:672:11
  5495  .  .  .  .  .  .  .  .  .  .  .  }
  5496  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5497  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
  5498  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
  5499  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
  5500  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"operand \""
  5501  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5502  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5503  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
  5504  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5505  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5506  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:672:30
  5507  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:672:32
  5508  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5509  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: String @ parser.go:672:36
  5510  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5511  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5512  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5513  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5514  .  .  .  .  .  .  .  .  .  .  .  .  }
  5515  .  .  .  .  .  .  .  .  .  .  .  }
  5516  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5517  .  .  .  .  .  .  .  .  .  .  }
  5518  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5519  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5520  .  .  .  .  .  .  .  .  .  }
  5521  .  .  .  .  .  .  .  .  }
  5522  .  .  .  .  .  .  .  }
  5523  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  5524  .  .  .  .  .  .  }
  5525  .  .  .  .  .  .  Else: nil
  5526  .  .  .  .  .  }
  5527  .  .  .  .  .  1: *syntax.SwitchStmt {
  5528  .  .  .  .  .  .  Init: nil
  5529  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  5530  .  .  .  .  .  .  .  X: p @ parser.go:675:9
  5531  .  .  .  .  .  .  .  Sel: tok @ parser.go:675:11
  5532  .  .  .  .  .  .  }
  5533  .  .  .  .  .  .  Body: []*syntax.CaseClause (6 entries) {
  5534  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  5535  .  .  .  .  .  .  .  .  Cases: _Name @ parser.go:676:7
  5536  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  5537  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  5538  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  5539  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5540  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:677:10
  5541  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:677:12
  5542  .  .  .  .  .  .  .  .  .  .  .  }
  5543  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5544  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5545  .  .  .  .  .  .  .  .  .  .  }
  5546  .  .  .  .  .  .  .  .  .  }
  5547  .  .  .  .  .  .  .  .  }
  5548  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  5549  .  .  .  .  .  .  .  }
  5550  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  5551  .  .  .  .  .  .  .  .  Cases: _Literal @ parser.go:679:7
  5552  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  5553  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  5554  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  5555  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5556  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:680:10
  5557  .  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral @ parser.go:680:12
  5558  .  .  .  .  .  .  .  .  .  .  .  }
  5559  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5560  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5561  .  .  .  .  .  .  .  .  .  .  }
  5562  .  .  .  .  .  .  .  .  .  }
  5563  .  .  .  .  .  .  .  .  }
  5564  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  5565  .  .  .  .  .  .  .  }
  5566  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  5567  .  .  .  .  .  .  .  .  Cases: _Lparen @ parser.go:682:7
  5568  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (9 entries) {
  5569  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5570  .  .  .  .  .  .  .  .  .  .  Op: :
  5571  .  .  .  .  .  .  .  .  .  .  Lhs: pos @ parser.go:683:3
  5572  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5573  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5574  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:683:10
  5575  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:683:12
  5576  .  .  .  .  .  .  .  .  .  .  .  }
  5577  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5578  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5579  .  .  .  .  .  .  .  .  .  .  }
  5580  .  .  .  .  .  .  .  .  .  }
  5581  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  5582  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5583  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5584  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:684:3
  5585  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:684:5
  5586  .  .  .  .  .  .  .  .  .  .  .  }
  5587  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5588  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5589  .  .  .  .  .  .  .  .  .  .  }
  5590  .  .  .  .  .  .  .  .  .  }
  5591  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  5592  .  .  .  .  .  .  .  .  .  .  Op: +
  5593  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5594  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:685:3
  5595  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest @ parser.go:685:5
  5596  .  .  .  .  .  .  .  .  .  .  }
  5597  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.BasicLit {
  5598  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  5599  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  5600  .  .  .  .  .  .  .  .  .  .  }
  5601  .  .  .  .  .  .  .  .  .  }
  5602  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  5603  .  .  .  .  .  .  .  .  .  .  Op: :
  5604  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:686:3
  5605  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5606  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5607  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:686:8
  5608  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:686:10
  5609  .  .  .  .  .  .  .  .  .  .  .  }
  5610  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5611  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5612  .  .  .  .  .  .  .  .  .  .  }
  5613  .  .  .  .  .  .  .  .  .  }
  5614  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  5615  .  .  .  .  .  .  .  .  .  .  Op: -
  5616  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5617  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:687:3
  5618  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest @ parser.go:687:5
  5619  .  .  .  .  .  .  .  .  .  .  }
  5620  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  5621  .  .  .  .  .  .  .  .  .  }
  5622  .  .  .  .  .  .  .  .  .  5: *syntax.ExprStmt {
  5623  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5624  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5625  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:688:3
  5626  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:688:5
  5627  .  .  .  .  .  .  .  .  .  .  .  }
  5628  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5629  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:688:10
  5630  .  .  .  .  .  .  .  .  .  .  .  }
  5631  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5632  .  .  .  .  .  .  .  .  .  .  }
  5633  .  .  .  .  .  .  .  .  .  }
  5634  .  .  .  .  .  .  .  .  .  6: *syntax.IfStmt {
  5635  .  .  .  .  .  .  .  .  .  .  Init: nil
  5636  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  5637  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  5638  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5639  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:704:6
  5640  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:704:8
  5641  .  .  .  .  .  .  .  .  .  .  .  }
  5642  .  .  .  .  .  .  .  .  .  .  .  Y: _Lbrace @ parser.go:704:15
  5643  .  .  .  .  .  .  .  .  .  .  }
  5644  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  5645  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  5646  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5647  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5648  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: keep_parens @ parser.go:705:4
  5649  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: true @ parser.go:705:18
  5650  .  .  .  .  .  .  .  .  .  .  .  .  }
  5651  .  .  .  .  .  .  .  .  .  .  .  }
  5652  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  5653  .  .  .  .  .  .  .  .  .  .  }
  5654  .  .  .  .  .  .  .  .  .  .  Else: nil
  5655  .  .  .  .  .  .  .  .  .  }
  5656  .  .  .  .  .  .  .  .  .  7: *syntax.IfStmt {
  5657  .  .  .  .  .  .  .  .  .  .  Init: nil
  5658  .  .  .  .  .  .  .  .  .  .  Cond: keep_parens @ parser.go:711:6
  5659  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  5660  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (4 entries) {
  5661  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5662  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  5663  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: px @ parser.go:712:4
  5664  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5665  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:712:10
  5666  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5667  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: ParenExpr @ parser.go:712:14
  5668  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5669  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5670  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5671  .  .  .  .  .  .  .  .  .  .  .  .  }
  5672  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  5673  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5674  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5675  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: px @ parser.go:713:4
  5676  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:713:7
  5677  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5678  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:713:13
  5679  .  .  .  .  .  .  .  .  .  .  .  .  }
  5680  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  5681  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5682  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5683  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: px @ parser.go:714:4
  5684  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:714:7
  5685  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5686  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x @ parser.go:714:11
  5687  .  .  .  .  .  .  .  .  .  .  .  .  }
  5688  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  5689  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5690  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:715:4
  5691  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: px @ parser.go:715:8
  5692  .  .  .  .  .  .  .  .  .  .  .  .  }
  5693  .  .  .  .  .  .  .  .  .  .  .  }
  5694  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  5695  .  .  .  .  .  .  .  .  .  .  }
  5696  .  .  .  .  .  .  .  .  .  .  Else: nil
  5697  .  .  .  .  .  .  .  .  .  }
  5698  .  .  .  .  .  .  .  .  .  8: *syntax.ReturnStmt {
  5699  .  .  .  .  .  .  .  .  .  .  Results: x @ parser.go:717:10
  5700  .  .  .  .  .  .  .  .  .  }
  5701  .  .  .  .  .  .  .  .  }
  5702  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  5703  .  .  .  .  .  .  .  }
  5704  .  .  .  .  .  .  .  3: *syntax.CaseClause {
  5705  .  .  .  .  .  .  .  .  Cases: _Func @ parser.go:719:7
  5706  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (5 entries) {
  5707  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5708  .  .  .  .  .  .  .  .  .  .  Op: :
  5709  .  .  .  .  .  .  .  .  .  .  Lhs: pos @ parser.go:720:3
  5710  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5711  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5712  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:720:10
  5713  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:720:12
  5714  .  .  .  .  .  .  .  .  .  .  .  }
  5715  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5716  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5717  .  .  .  .  .  .  .  .  .  .  }
  5718  .  .  .  .  .  .  .  .  .  }
  5719  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  5720  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5721  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5722  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:721:3
  5723  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:721:5
  5724  .  .  .  .  .  .  .  .  .  .  .  }
  5725  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5726  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5727  .  .  .  .  .  .  .  .  .  .  }
  5728  .  .  .  .  .  .  .  .  .  }
  5729  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  5730  .  .  .  .  .  .  .  .  .  .  Op: :
  5731  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:722:3
  5732  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5733  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5734  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:722:8
  5735  .  .  .  .  .  .  .  .  .  .  .  .  Sel: funcType @ parser.go:722:10
  5736  .  .  .  .  .  .  .  .  .  .  .  }
  5737  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5738  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5739  .  .  .  .  .  .  .  .  .  .  }
  5740  .  .  .  .  .  .  .  .  .  }
  5741  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  5742  .  .  .  .  .  .  .  .  .  .  Init: nil
  5743  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  5744  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  5745  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5746  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:723:6
  5747  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:723:8
  5748  .  .  .  .  .  .  .  .  .  .  .  }
  5749  .  .  .  .  .  .  .  .  .  .  .  Y: _Lbrace @ parser.go:723:15
  5750  .  .  .  .  .  .  .  .  .  .  }
  5751  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  5752  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (8 entries) {
  5753  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5754  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
  5755  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5756  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:724:4
  5757  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest @ parser.go:724:6
  5758  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5759  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  5760  .  .  .  .  .  .  .  .  .  .  .  .  }
  5761  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  5762  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  5763  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: f @ parser.go:726:4
  5764  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5765  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:726:9
  5766  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5767  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: FuncLit @ parser.go:726:13
  5768  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5769  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5770  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5771  .  .  .  .  .  .  .  .  .  .  .  .  }
  5772  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  5773  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5774  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5775  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:727:4
  5776  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:727:6
  5777  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5778  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:727:12
  5779  .  .  .  .  .  .  .  .  .  .  .  .  }
  5780  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  5781  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5782  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5783  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:728:4
  5784  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:728:6
  5785  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5786  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: t @ parser.go:728:13
  5787  .  .  .  .  .  .  .  .  .  .  .  .  }
  5788  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  5789  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  5790  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5791  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:729:4
  5792  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Body @ parser.go:729:6
  5793  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5794  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5795  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5796  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:729:13
  5797  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: blockStmt @ parser.go:729:15
  5798  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5799  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5800  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5801  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"\""
  5802  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5803  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5804  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5805  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5806  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5807  .  .  .  .  .  .  .  .  .  .  .  .  }
  5808  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.IfStmt {
  5809  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  5810  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  5811  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  5812  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  5813  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: &
  5814  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  5815  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:730:7
  5816  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: mode @ parser.go:730:9
  5817  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5818  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: CheckBranches @ parser.go:730:14
  5819  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5820  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  5821  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  5822  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  5823  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5824  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5825  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  5826  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  5827  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  5828  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5829  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: checkBranches @ parser.go:731:5
  5830  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  5831  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  5832  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:731:19
  5833  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Body @ parser.go:731:21
  5834  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5835  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
  5836  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:731:27
  5837  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: errh @ parser.go:731:29
  5838  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5839  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5840  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5841  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5842  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5843  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5844  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  5845  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5846  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  5847  .  .  .  .  .  .  .  .  .  .  .  .  }
  5848  .  .  .  .  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
  5849  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: -
  5850  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  5851  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:734:4
  5852  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest @ parser.go:734:6
  5853  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  5854  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  5855  .  .  .  .  .  .  .  .  .  .  .  .  }
  5856  .  .  .  .  .  .  .  .  .  .  .  .  7: *syntax.ReturnStmt {
  5857  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: f @ parser.go:735:11
  5858  .  .  .  .  .  .  .  .  .  .  .  .  }
  5859  .  .  .  .  .  .  .  .  .  .  .  }
  5860  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  5861  .  .  .  .  .  .  .  .  .  .  }
  5862  .  .  .  .  .  .  .  .  .  .  Else: nil
  5863  .  .  .  .  .  .  .  .  .  }
  5864  .  .  .  .  .  .  .  .  .  4: *syntax.ReturnStmt {
  5865  .  .  .  .  .  .  .  .  .  .  Results: t @ parser.go:737:10
  5866  .  .  .  .  .  .  .  .  .  }
  5867  .  .  .  .  .  .  .  .  }
  5868  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  5869  .  .  .  .  .  .  .  }
  5870  .  .  .  .  .  .  .  4: *syntax.CaseClause {
  5871  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  5872  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (5 entries) {
  5873  .  .  .  .  .  .  .  .  .  .  0: _Lbrack @ parser.go:739:7
  5874  .  .  .  .  .  .  .  .  .  .  1: _Chan @ parser.go:739:16
  5875  .  .  .  .  .  .  .  .  .  .  2: _Map @ parser.go:739:23
  5876  .  .  .  .  .  .  .  .  .  .  3: _Struct @ parser.go:739:29
  5877  .  .  .  .  .  .  .  .  .  .  4: _Interface @ parser.go:739:38
  5878  .  .  .  .  .  .  .  .  .  }
  5879  .  .  .  .  .  .  .  .  }
  5880  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  5881  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  5882  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  5883  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5884  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:740:10
  5885  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_ @ parser.go:740:12
  5886  .  .  .  .  .  .  .  .  .  .  .  }
  5887  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5888  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5889  .  .  .  .  .  .  .  .  .  .  }
  5890  .  .  .  .  .  .  .  .  .  }
  5891  .  .  .  .  .  .  .  .  }
  5892  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  5893  .  .  .  .  .  .  .  }
  5894  .  .  .  .  .  .  .  5: *syntax.CaseClause {
  5895  .  .  .  .  .  .  .  .  Cases: nil
  5896  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (4 entries) {
  5897  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  5898  .  .  .  .  .  .  .  .  .  .  Op: :
  5899  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:743:3
  5900  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  5901  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5902  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:743:8
  5903  .  .  .  .  .  .  .  .  .  .  .  .  Sel: bad @ parser.go:743:10
  5904  .  .  .  .  .  .  .  .  .  .  .  }
  5905  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5906  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5907  .  .  .  .  .  .  .  .  .  .  }
  5908  .  .  .  .  .  .  .  .  .  }
  5909  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  5910  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5911  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5912  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:744:3
  5913  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:744:5
  5914  .  .  .  .  .  .  .  .  .  .  .  }
  5915  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5916  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5917  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting expression\""
  5918  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5919  .  .  .  .  .  .  .  .  .  .  .  .  }
  5920  .  .  .  .  .  .  .  .  .  .  .  }
  5921  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5922  .  .  .  .  .  .  .  .  .  .  }
  5923  .  .  .  .  .  .  .  .  .  }
  5924  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  5925  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  5926  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5927  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:745:3
  5928  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:745:5
  5929  .  .  .  .  .  .  .  .  .  .  .  }
  5930  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5931  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5932  .  .  .  .  .  .  .  .  .  .  }
  5933  .  .  .  .  .  .  .  .  .  }
  5934  .  .  .  .  .  .  .  .  .  3: *syntax.ReturnStmt {
  5935  .  .  .  .  .  .  .  .  .  .  Results: x @ parser.go:746:10
  5936  .  .  .  .  .  .  .  .  .  }
  5937  .  .  .  .  .  .  .  .  }
  5938  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  5939  .  .  .  .  .  .  .  }
  5940  .  .  .  .  .  .  }
  5941  .  .  .  .  .  .  Rbrace: src.Pos {}
  5942  .  .  .  .  .  }
  5943  .  .  .  .  }
  5944  .  .  .  .  Rbrace: src.Pos {}
  5945  .  .  .  }
  5946  .  .  .  Pragma: 0
  5947  .  .  }
  5948  .  .  36: *syntax.FuncDecl {
  5949  .  .  .  Attr: map[]
  5950  .  .  .  Recv: *syntax.Field {
  5951  .  .  .  .  Name: p @ parser.go:771:7
  5952  .  .  .  .  Type: *syntax.Operation {
  5953  .  .  .  .  .  Op: *
  5954  .  .  .  .  .  X: parser @ parser.go:771:10
  5955  .  .  .  .  .  Y: nil
  5956  .  .  .  .  }
  5957  .  .  .  }
  5958  .  .  .  Name: pexpr @ parser.go:771:18
  5959  .  .  .  Type: *syntax.FuncType {
  5960  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  5961  .  .  .  .  .  0: *syntax.Field {
  5962  .  .  .  .  .  .  Name: keep_parens @ parser.go:771:24
  5963  .  .  .  .  .  .  Type: bool @ parser.go:771:36
  5964  .  .  .  .  .  }
  5965  .  .  .  .  }
  5966  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  5967  .  .  .  .  .  0: *syntax.Field {
  5968  .  .  .  .  .  .  Name: nil
  5969  .  .  .  .  .  .  Type: Expr @ parser.go:771:42
  5970  .  .  .  .  .  }
  5971  .  .  .  .  }
  5972  .  .  .  }
  5973  .  .  .  Body: *syntax.BlockStmt {
  5974  .  .  .  .  List: []syntax.Stmt (4 entries) {
  5975  .  .  .  .  .  0: *syntax.IfStmt {
  5976  .  .  .  .  .  .  Init: nil
  5977  .  .  .  .  .  .  Cond: trace @ parser.go:772:5
  5978  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  5979  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  5980  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  5981  .  .  .  .  .  .  .  .  .  Tok: defer
  5982  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  5983  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  5984  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  5985  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:773:9
  5986  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:773:11
  5987  .  .  .  .  .  .  .  .  .  .  .  }
  5988  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  5989  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  5990  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"pexpr\""
  5991  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  5992  .  .  .  .  .  .  .  .  .  .  .  .  }
  5993  .  .  .  .  .  .  .  .  .  .  .  }
  5994  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5995  .  .  .  .  .  .  .  .  .  .  }
  5996  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  5997  .  .  .  .  .  .  .  .  .  .  HasDots: false
  5998  .  .  .  .  .  .  .  .  .  }
  5999  .  .  .  .  .  .  .  .  }
  6000  .  .  .  .  .  .  .  }
  6001  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6002  .  .  .  .  .  .  }
  6003  .  .  .  .  .  .  Else: nil
  6004  .  .  .  .  .  }
  6005  .  .  .  .  .  1: *syntax.AssignStmt {
  6006  .  .  .  .  .  .  Op: :
  6007  .  .  .  .  .  .  Lhs: x @ parser.go:776:2
  6008  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6009  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6010  .  .  .  .  .  .  .  .  X: p @ parser.go:776:7
  6011  .  .  .  .  .  .  .  .  Sel: operand @ parser.go:776:9
  6012  .  .  .  .  .  .  .  }
  6013  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6014  .  .  .  .  .  .  .  .  0: keep_parens @ parser.go:776:17
  6015  .  .  .  .  .  .  .  }
  6016  .  .  .  .  .  .  .  HasDots: false
  6017  .  .  .  .  .  .  }
  6018  .  .  .  .  .  }
  6019  .  .  .  .  .  2: *syntax.LabeledStmt {
  6020  .  .  .  .  .  .  Label: loop @ parser.go:778:1
  6021  .  .  .  .  .  .  Stmt: *syntax.ForStmt {
  6022  .  .  .  .  .  .  .  Init: nil
  6023  .  .  .  .  .  .  .  Cond: nil
  6024  .  .  .  .  .  .  .  Post: nil
  6025  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  6026  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  6027  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6028  .  .  .  .  .  .  .  .  .  .  Op: :
  6029  .  .  .  .  .  .  .  .  .  .  Lhs: pos @ parser.go:780:3
  6030  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6031  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6032  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:780:10
  6033  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:780:12
  6034  .  .  .  .  .  .  .  .  .  .  .  }
  6035  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6036  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6037  .  .  .  .  .  .  .  .  .  .  }
  6038  .  .  .  .  .  .  .  .  .  }
  6039  .  .  .  .  .  .  .  .  .  1: *syntax.SwitchStmt {
  6040  .  .  .  .  .  .  .  .  .  .  Init: nil
  6041  .  .  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  6042  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:781:10
  6043  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:781:12
  6044  .  .  .  .  .  .  .  .  .  .  }
  6045  .  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (5 entries) {
  6046  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  6047  .  .  .  .  .  .  .  .  .  .  .  .  Cases: _Dot @ parser.go:782:8
  6048  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  6049  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6050  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6051  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6052  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:783:4
  6053  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:783:6
  6054  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6055  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6056  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6057  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6058  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6059  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SwitchStmt {
  6060  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  6061  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  6062  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:784:11
  6063  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:784:13
  6064  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6065  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
  6066  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  6067  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: _Name @ parser.go:785:9
  6068  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (5 entries) {
  6069  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6070  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  6071  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:787:5
  6072  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6073  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:787:10
  6074  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6075  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: SelectorExpr @ parser.go:787:14
  6076  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6077  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6078  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6079  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6080  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  6081  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6082  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6083  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:788:5
  6084  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:788:7
  6085  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6086  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:788:13
  6087  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6088  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  6089  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6090  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6091  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:789:5
  6092  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:789:7
  6093  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6094  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x @ parser.go:789:11
  6095  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6096  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  6097  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6098  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6099  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:790:5
  6100  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sel @ parser.go:790:7
  6101  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6102  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6103  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6104  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:790:13
  6105  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:790:15
  6106  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6107  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6108  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6109  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6110  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6111  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  6112  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6113  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:791:5
  6114  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: t @ parser.go:791:9
  6115  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6116  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6117  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  6118  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6119  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  6120  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: _Lparen @ parser.go:793:9
  6121  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
  6122  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6123  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6124  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6125  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:794:5
  6126  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:794:7
  6127  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6128  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6129  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6130  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6131  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6132  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  6133  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  6134  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  6135  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6136  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:795:8
  6137  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:795:10
  6138  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6139  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6140  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Type @ parser.go:795:14
  6141  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6142  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6143  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6144  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  6145  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (4 entries) {
  6146  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6147  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  6148  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:796:6
  6149  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6150  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:796:11
  6151  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6152  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: TypeSwitchGuard @ parser.go:796:15
  6153  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6154  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6155  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6156  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6157  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  6158  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6159  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6160  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:797:6
  6161  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:797:8
  6162  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6163  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:797:14
  6164  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6165  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  6166  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6167  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6168  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:798:6
  6169  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:798:8
  6170  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6171  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x @ parser.go:798:12
  6172  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6173  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  6174  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6175  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:799:6
  6176  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: t @ parser.go:799:10
  6177  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6178  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6179  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6180  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6181  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
  6182  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (5 entries) {
  6183  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6184  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  6185  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:801:6
  6186  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6187  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:801:11
  6188  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6189  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: AssertExpr @ parser.go:801:15
  6190  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6191  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6192  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6193  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6194  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  6195  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6196  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6197  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:802:6
  6198  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:802:8
  6199  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6200  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:802:14
  6201  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6202  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  6203  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6204  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6205  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:803:6
  6206  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:803:8
  6207  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6208  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x @ parser.go:803:12
  6209  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6210  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  6211  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6212  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6213  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:804:6
  6214  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:804:8
  6215  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6216  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6217  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6218  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:804:15
  6219  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:804:17
  6220  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6221  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6222  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6223  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6224  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6225  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  6226  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6227  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:805:6
  6228  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: t @ parser.go:805:10
  6229  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6230  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6231  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6232  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6233  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6234  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  6235  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6236  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6237  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:807:5
  6238  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:807:7
  6239  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6240  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6241  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:807:12
  6242  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6243  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6244  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6245  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6246  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6247  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  6248  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6249  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  6250  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: nil
  6251  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  6252  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6253  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6254  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6255  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:810:5
  6256  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:810:7
  6257  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6258  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6259  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  6260  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting name or (\""
  6261  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  6262  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6263  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6264  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6265  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6266  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6267  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  6268  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6269  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6270  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:811:5
  6271  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:811:7
  6272  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6273  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  6274  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Semi @ parser.go:811:15
  6275  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: _Rparen @ parser.go:811:22
  6276  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6277  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6278  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6279  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6280  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6281  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  6282  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6283  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6284  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6285  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6286  .  .  .  .  .  .  .  .  .  .  .  .  }
  6287  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  6288  .  .  .  .  .  .  .  .  .  .  .  }
  6289  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  6290  .  .  .  .  .  .  .  .  .  .  .  .  Cases: _Lbrack @ parser.go:814:8
  6291  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (14 entries) {
  6292  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6293  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6294  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6295  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:815:4
  6296  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:815:6
  6297  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6298  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6299  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6300  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6301  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6302  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  6303  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
  6304  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6305  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:816:4
  6306  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest @ parser.go:816:6
  6307  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6308  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  6309  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6310  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.DeclStmt {
  6311  .  .  .  .  .  .  .  .  .  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
  6312  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.VarDecl {
  6313  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
  6314  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: i @ parser.go:818:8
  6315  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6316  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Type: Expr @ parser.go:818:10
  6317  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Values: nil
  6318  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Group: nil
  6319  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6320  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6321  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6322  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  6323  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  6324  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  6325  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  6326  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  6327  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:819:7
  6328  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:819:9
  6329  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6330  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Colon @ parser.go:819:16
  6331  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6332  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  6333  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  6334  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6335  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6336  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: i @ parser.go:820:5
  6337  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6338  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6339  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:820:9
  6340  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:820:11
  6341  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6342  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6343  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6344  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6345  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6346  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  6347  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  6348  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  6349  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6350  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:821:8
  6351  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:821:10
  6352  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6353  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6354  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrack @ parser.go:821:14
  6355  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6356  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6357  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6358  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  6359  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (7 entries) {
  6360  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6361  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  6362  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:823:6
  6363  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6364  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:823:11
  6365  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6366  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: IndexExpr @ parser.go:823:15
  6367  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6368  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6369  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6370  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6371  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  6372  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6373  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6374  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:824:6
  6375  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:824:8
  6376  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6377  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:824:14
  6378  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6379  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  6380  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6381  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6382  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:825:6
  6383  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:825:8
  6384  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6385  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x @ parser.go:825:12
  6386  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6387  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  6388  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6389  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6390  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:826:6
  6391  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Index @ parser.go:826:8
  6392  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6393  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: i @ parser.go:826:16
  6394  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6395  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  6396  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6397  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:827:6
  6398  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: t @ parser.go:827:10
  6399  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6400  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  6401  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: -
  6402  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6403  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:828:6
  6404  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest @ parser.go:828:8
  6405  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6406  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  6407  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6408  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  6: *syntax.BranchStmt {
  6409  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  6410  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
  6411  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 6039)
  6412  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6413  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6414  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6415  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6416  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  6417  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6418  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6419  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6420  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6421  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  6422  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6423  .  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  6424  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  6425  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:834:4
  6426  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6427  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:834:9
  6428  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6429  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: SliceExpr @ parser.go:834:13
  6430  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6431  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6432  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6433  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6434  .  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  6435  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6436  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6437  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:835:4
  6438  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:835:6
  6439  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6440  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:835:12
  6441  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6442  .  .  .  .  .  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
  6443  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6444  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6445  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:836:4
  6446  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:836:6
  6447  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6448  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x @ parser.go:836:10
  6449  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6450  .  .  .  .  .  .  .  .  .  .  .  .  .  7: *syntax.AssignStmt {
  6451  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6452  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.IndexExpr {
  6453  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  6454  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:837:4
  6455  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Index @ parser.go:837:6
  6456  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6457  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.BasicLit {
  6458  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  6459  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  6460  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6461  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6462  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: i @ parser.go:837:17
  6463  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6464  .  .  .  .  .  .  .  .  .  .  .  .  .  8: *syntax.ExprStmt {
  6465  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6466  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6467  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:838:4
  6468  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:838:6
  6469  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6470  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6471  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Colon @ parser.go:838:11
  6472  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6473  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6474  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6475  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6476  .  .  .  .  .  .  .  .  .  .  .  .  .  9: *syntax.IfStmt {
  6477  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  6478  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  6479  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: &&
  6480  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  6481  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  6482  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  6483  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:839:7
  6484  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:839:9
  6485  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6486  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Colon @ parser.go:839:16
  6487  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6488  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  6489  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  6490  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  6491  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:839:26
  6492  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:839:28
  6493  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6494  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Rbrack @ parser.go:839:35
  6495  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6496  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6497  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  6498  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  6499  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6500  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6501  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.IndexExpr {
  6502  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  6503  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:841:5
  6504  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Index @ parser.go:841:7
  6505  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6506  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.BasicLit {
  6507  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  6508  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  6509  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6510  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6511  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6512  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6513  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:841:18
  6514  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:841:20
  6515  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6516  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6517  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6518  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6519  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6520  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6521  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6522  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6523  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  6524  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6525  .  .  .  .  .  .  .  .  .  .  .  .  .  10: *syntax.IfStmt {
  6526  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  6527  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  6528  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6529  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:843:7
  6530  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:843:9
  6531  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6532  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6533  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Colon @ parser.go:843:13
  6534  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6535  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6536  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6537  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  6538  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
  6539  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6540  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6541  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6542  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:844:5
  6543  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Full @ parser.go:844:7
  6544  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6545  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: true @ parser.go:844:14
  6546  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6547  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  6548  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  6549  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  6550  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  6551  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.IndexExpr {
  6552  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  6553  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:846:8
  6554  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Index @ parser.go:846:10
  6555  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6556  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.BasicLit {
  6557  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
  6558  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  6559  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6560  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6561  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:846:22
  6562  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6563  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  6564  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  6565  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6566  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6567  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6568  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:847:6
  6569  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error @ parser.go:847:8
  6570  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6571  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6572  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  6573  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"middle index required in 3-index slice\""
  6574  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  6575  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6576  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6577  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6578  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6579  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6580  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6581  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6582  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6583  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  6584  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6585  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
  6586  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  6587  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  6588  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  6589  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  6590  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:849:8
  6591  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:849:10
  6592  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6593  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Rbrack @ parser.go:849:17
  6594  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6595  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  6596  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  6597  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6598  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6599  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.IndexExpr {
  6600  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  6601  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:851:6
  6602  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Index @ parser.go:851:8
  6603  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6604  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.BasicLit {
  6605  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "2"
  6606  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  6607  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6608  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6609  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6610  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6611  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:851:19
  6612  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:851:21
  6613  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6614  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6615  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6616  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6617  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6618  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6619  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6620  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6621  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
  6622  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  6623  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6624  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6625  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6626  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:853:6
  6627  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error @ parser.go:853:8
  6628  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6629  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6630  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  6631  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"final index required in 3-index slice\""
  6632  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  6633  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6634  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6635  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6636  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6637  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6638  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6639  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6640  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6641  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6642  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6643  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6644  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6645  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  6646  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6647  .  .  .  .  .  .  .  .  .  .  .  .  .  11: *syntax.ExprStmt {
  6648  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6649  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6650  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:856:4
  6651  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:856:6
  6652  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6653  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6654  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrack @ parser.go:856:11
  6655  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6656  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6657  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6658  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6659  .  .  .  .  .  .  .  .  .  .  .  .  .  12: *syntax.AssignStmt {
  6660  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6661  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:858:4
  6662  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: t @ parser.go:858:8
  6663  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6664  .  .  .  .  .  .  .  .  .  .  .  .  .  13: *syntax.AssignStmt {
  6665  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: -
  6666  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6667  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:859:4
  6668  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest @ parser.go:859:6
  6669  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6670  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  6671  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6672  .  .  .  .  .  .  .  .  .  .  .  .  }
  6673  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  6674  .  .  .  .  .  .  .  .  .  .  .  }
  6675  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  6676  .  .  .  .  .  .  .  .  .  .  .  .  Cases: _Lparen @ parser.go:861:8
  6677  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  6678  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6679  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6680  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:862:4
  6681  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6682  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6683  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:862:8
  6684  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: call @ parser.go:862:10
  6685  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6686  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6687  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: x @ parser.go:862:15
  6688  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6689  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6690  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6691  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6692  .  .  .  .  .  .  .  .  .  .  .  .  }
  6693  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  6694  .  .  .  .  .  .  .  .  .  .  .  }
  6695  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.CaseClause {
  6696  .  .  .  .  .  .  .  .  .  .  .  .  Cases: _Lbrace @ parser.go:864:8
  6697  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (8 entries) {
  6698  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6699  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  6700  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:867:4
  6701  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6702  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: unparen @ parser.go:867:9
  6703  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6704  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: x @ parser.go:867:17
  6705  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6706  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6707  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6708  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6709  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  6710  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  6711  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: complit_ok @ parser.go:869:4
  6712  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: false @ parser.go:869:18
  6713  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6714  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.SwitchStmt {
  6715  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  6716  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Tag: *syntax.TypeSwitchGuard {
  6717  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: nil
  6718  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:870:11
  6719  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6720  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (2 entries) {
  6721  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  6722  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  6723  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  6724  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
  6725  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  6726  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: Name @ parser.go:871:10
  6727  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  6728  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6729  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.Operation {
  6730  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  6731  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: SelectorExpr @ parser.go:871:17
  6732  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  6733  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6734  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6735  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6736  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  6737  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
  6738  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  6739  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  6740  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: >=
  6741  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  6742  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:872:8
  6743  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest @ parser.go:872:10
  6744  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6745  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  6746  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  6747  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  6748  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6749  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6750  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  6751  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  6752  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6753  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6754  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: complit_ok @ parser.go:874:6
  6755  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: true @ parser.go:874:19
  6756  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6757  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6758  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6759  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6760  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  6761  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6762  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6763  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  6764  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6765  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  6766  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
  6767  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (4 entries) {
  6768  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
  6769  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  6770  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: ArrayType @ parser.go:876:10
  6771  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  6772  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6773  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.Operation {
  6774  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  6775  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: SliceType @ parser.go:876:22
  6776  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  6777  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6778  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.Operation {
  6779  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  6780  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: StructType @ parser.go:876:34
  6781  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  6782  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6783  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.Operation {
  6784  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  6785  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: MapType @ parser.go:876:47
  6786  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  6787  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6788  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6789  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6790  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  6791  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  6792  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6793  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: complit_ok @ parser.go:878:5
  6794  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: true @ parser.go:878:18
  6795  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6796  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6797  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  6798  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6799  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6800  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6801  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6802  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  6803  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  6804  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  6805  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !
  6806  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: complit_ok @ parser.go:880:8
  6807  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  6808  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6809  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  6810  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  6811  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  6812  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  6813  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Label: loop @ parser.go:881:11
  6814  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 6021)
  6815  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6816  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6817  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6818  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6819  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  6820  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6821  .  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.IfStmt {
  6822  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
  6823  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  6824  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
  6825  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:883:7
  6826  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: x @ parser.go:883:12
  6827  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6828  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  6829  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  6830  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  6831  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  6832  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6833  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:884:5
  6834  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:884:7
  6835  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6836  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6837  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  6838  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"cannot parenthesize type in composite literal\""
  6839  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  6840  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6841  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6842  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6843  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6844  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6845  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6846  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6847  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6848  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
  6849  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6850  .  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  6851  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  6852  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: n @ parser.go:887:4
  6853  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  6854  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6855  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:887:9
  6856  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: complitexpr @ parser.go:887:11
  6857  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6858  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6859  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6860  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6861  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6862  .  .  .  .  .  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
  6863  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6864  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  6865  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: n @ parser.go:888:4
  6866  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:888:6
  6867  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6868  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x @ parser.go:888:13
  6869  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6870  .  .  .  .  .  .  .  .  .  .  .  .  .  7: *syntax.AssignStmt {
  6871  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  6872  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:889:4
  6873  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: n @ parser.go:889:8
  6874  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6875  .  .  .  .  .  .  .  .  .  .  .  .  }
  6876  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  6877  .  .  .  .  .  .  .  .  .  .  .  }
  6878  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.CaseClause {
  6879  .  .  .  .  .  .  .  .  .  .  .  .  Cases: nil
  6880  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  6881  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  6882  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  6883  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Label: loop @ parser.go:892:10
  6884  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 6021)
  6885  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  6886  .  .  .  .  .  .  .  .  .  .  .  .  }
  6887  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  6888  .  .  .  .  .  .  .  .  .  .  .  }
  6889  .  .  .  .  .  .  .  .  .  .  }
  6890  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6891  .  .  .  .  .  .  .  .  .  }
  6892  .  .  .  .  .  .  .  .  }
  6893  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6894  .  .  .  .  .  .  .  }
  6895  .  .  .  .  .  .  }
  6896  .  .  .  .  .  }
  6897  .  .  .  .  .  3: *syntax.ReturnStmt {
  6898  .  .  .  .  .  .  Results: x @ parser.go:896:9
  6899  .  .  .  .  .  }
  6900  .  .  .  .  }
  6901  .  .  .  .  Rbrace: src.Pos {}
  6902  .  .  .  }
  6903  .  .  .  Pragma: 0
  6904  .  .  }
  6905  .  .  37: *syntax.FuncDecl {
  6906  .  .  .  Attr: map[]
  6907  .  .  .  Recv: *syntax.Field {
  6908  .  .  .  .  Name: p @ parser.go:900:7
  6909  .  .  .  .  Type: *syntax.Operation {
  6910  .  .  .  .  .  Op: *
  6911  .  .  .  .  .  X: parser @ parser.go:900:10
  6912  .  .  .  .  .  Y: nil
  6913  .  .  .  .  }
  6914  .  .  .  }
  6915  .  .  .  Name: bare_complitexpr @ parser.go:900:18
  6916  .  .  .  Type: *syntax.FuncType {
  6917  .  .  .  .  ParamList: nil
  6918  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  6919  .  .  .  .  .  0: *syntax.Field {
  6920  .  .  .  .  .  .  Name: nil
  6921  .  .  .  .  .  .  Type: Expr @ parser.go:900:37
  6922  .  .  .  .  .  }
  6923  .  .  .  .  }
  6924  .  .  .  }
  6925  .  .  .  Body: *syntax.BlockStmt {
  6926  .  .  .  .  List: []syntax.Stmt (3 entries) {
  6927  .  .  .  .  .  0: *syntax.IfStmt {
  6928  .  .  .  .  .  .  Init: nil
  6929  .  .  .  .  .  .  Cond: trace @ parser.go:901:5
  6930  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  6931  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  6932  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  6933  .  .  .  .  .  .  .  .  .  Tok: defer
  6934  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  6935  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  6936  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6937  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:902:9
  6938  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:902:11
  6939  .  .  .  .  .  .  .  .  .  .  .  }
  6940  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  6941  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  6942  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"bare_complitexpr\""
  6943  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  6944  .  .  .  .  .  .  .  .  .  .  .  .  }
  6945  .  .  .  .  .  .  .  .  .  .  .  }
  6946  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6947  .  .  .  .  .  .  .  .  .  .  }
  6948  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6949  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6950  .  .  .  .  .  .  .  .  .  }
  6951  .  .  .  .  .  .  .  .  }
  6952  .  .  .  .  .  .  .  }
  6953  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6954  .  .  .  .  .  .  }
  6955  .  .  .  .  .  .  Else: nil
  6956  .  .  .  .  .  }
  6957  .  .  .  .  .  1: *syntax.IfStmt {
  6958  .  .  .  .  .  .  Init: nil
  6959  .  .  .  .  .  .  Cond: *syntax.Operation {
  6960  .  .  .  .  .  .  .  Op: ==
  6961  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  6962  .  .  .  .  .  .  .  .  X: p @ parser.go:905:5
  6963  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:905:7
  6964  .  .  .  .  .  .  .  }
  6965  .  .  .  .  .  .  .  Y: _Lbrace @ parser.go:905:14
  6966  .  .  .  .  .  .  }
  6967  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  6968  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  6969  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  6970  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  6971  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6972  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:907:10
  6973  .  .  .  .  .  .  .  .  .  .  .  Sel: complitexpr @ parser.go:907:12
  6974  .  .  .  .  .  .  .  .  .  .  }
  6975  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  6976  .  .  .  .  .  .  .  .  .  .  HasDots: false
  6977  .  .  .  .  .  .  .  .  .  }
  6978  .  .  .  .  .  .  .  .  }
  6979  .  .  .  .  .  .  .  }
  6980  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  6981  .  .  .  .  .  .  }
  6982  .  .  .  .  .  .  Else: nil
  6983  .  .  .  .  .  }
  6984  .  .  .  .  .  2: *syntax.ReturnStmt {
  6985  .  .  .  .  .  .  Results: *syntax.CallExpr {
  6986  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  6987  .  .  .  .  .  .  .  .  X: p @ parser.go:910:9
  6988  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:910:11
  6989  .  .  .  .  .  .  .  }
  6990  .  .  .  .  .  .  .  ArgList: nil
  6991  .  .  .  .  .  .  .  HasDots: false
  6992  .  .  .  .  .  .  }
  6993  .  .  .  .  .  }
  6994  .  .  .  .  }
  6995  .  .  .  .  Rbrace: src.Pos {}
  6996  .  .  .  }
  6997  .  .  .  Pragma: 0
  6998  .  .  }
  6999  .  .  38: *syntax.FuncDecl {
  7000  .  .  .  Attr: map[]
  7001  .  .  .  Recv: *syntax.Field {
  7002  .  .  .  .  Name: p @ parser.go:914:7
  7003  .  .  .  .  Type: *syntax.Operation {
  7004  .  .  .  .  .  Op: *
  7005  .  .  .  .  .  X: parser @ parser.go:914:10
  7006  .  .  .  .  .  Y: nil
  7007  .  .  .  .  }
  7008  .  .  .  }
  7009  .  .  .  Name: complitexpr @ parser.go:914:18
  7010  .  .  .  Type: *syntax.FuncType {
  7011  .  .  .  .  ParamList: nil
  7012  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  7013  .  .  .  .  .  0: *syntax.Field {
  7014  .  .  .  .  .  .  Name: nil
  7015  .  .  .  .  .  .  Type: *syntax.Operation {
  7016  .  .  .  .  .  .  .  Op: *
  7017  .  .  .  .  .  .  .  X: CompositeLit @ parser.go:914:33
  7018  .  .  .  .  .  .  .  Y: nil
  7019  .  .  .  .  .  .  }
  7020  .  .  .  .  .  }
  7021  .  .  .  .  }
  7022  .  .  .  }
  7023  .  .  .  Body: *syntax.BlockStmt {
  7024  .  .  .  .  List: []syntax.Stmt (10 entries) {
  7025  .  .  .  .  .  0: *syntax.IfStmt {
  7026  .  .  .  .  .  .  Init: nil
  7027  .  .  .  .  .  .  Cond: trace @ parser.go:915:5
  7028  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  7029  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  7030  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  7031  .  .  .  .  .  .  .  .  .  Tok: defer
  7032  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  7033  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  7034  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7035  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:916:9
  7036  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:916:11
  7037  .  .  .  .  .  .  .  .  .  .  .  }
  7038  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7039  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  7040  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"complitexpr\""
  7041  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  7042  .  .  .  .  .  .  .  .  .  .  .  .  }
  7043  .  .  .  .  .  .  .  .  .  .  .  }
  7044  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7045  .  .  .  .  .  .  .  .  .  .  }
  7046  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7047  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7048  .  .  .  .  .  .  .  .  .  }
  7049  .  .  .  .  .  .  .  .  }
  7050  .  .  .  .  .  .  .  }
  7051  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  7052  .  .  .  .  .  .  }
  7053  .  .  .  .  .  .  Else: nil
  7054  .  .  .  .  .  }
  7055  .  .  .  .  .  1: *syntax.AssignStmt {
  7056  .  .  .  .  .  .  Op: :
  7057  .  .  .  .  .  .  Lhs: x @ parser.go:919:2
  7058  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7059  .  .  .  .  .  .  .  Fun: new @ parser.go:919:7
  7060  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7061  .  .  .  .  .  .  .  .  0: CompositeLit @ parser.go:919:11
  7062  .  .  .  .  .  .  .  }
  7063  .  .  .  .  .  .  .  HasDots: false
  7064  .  .  .  .  .  .  }
  7065  .  .  .  .  .  }
  7066  .  .  .  .  .  2: *syntax.AssignStmt {
  7067  .  .  .  .  .  .  Op: <op-0>
  7068  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7069  .  .  .  .  .  .  .  X: x @ parser.go:920:2
  7070  .  .  .  .  .  .  .  Sel: pos @ parser.go:920:4
  7071  .  .  .  .  .  .  }
  7072  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7073  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7074  .  .  .  .  .  .  .  .  X: p @ parser.go:920:10
  7075  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:920:12
  7076  .  .  .  .  .  .  .  }
  7077  .  .  .  .  .  .  .  ArgList: nil
  7078  .  .  .  .  .  .  .  HasDots: false
  7079  .  .  .  .  .  .  }
  7080  .  .  .  .  .  }
  7081  .  .  .  .  .  3: *syntax.ExprStmt {
  7082  .  .  .  .  .  .  X: *syntax.CallExpr {
  7083  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7084  .  .  .  .  .  .  .  .  X: p @ parser.go:922:2
  7085  .  .  .  .  .  .  .  .  Sel: want @ parser.go:922:4
  7086  .  .  .  .  .  .  .  }
  7087  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7088  .  .  .  .  .  .  .  .  0: _Lbrace @ parser.go:922:9
  7089  .  .  .  .  .  .  .  }
  7090  .  .  .  .  .  .  .  HasDots: false
  7091  .  .  .  .  .  .  }
  7092  .  .  .  .  .  }
  7093  .  .  .  .  .  4: *syntax.AssignStmt {
  7094  .  .  .  .  .  .  Op: +
  7095  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7096  .  .  .  .  .  .  .  X: p @ parser.go:923:2
  7097  .  .  .  .  .  .  .  Sel: xnest @ parser.go:923:4
  7098  .  .  .  .  .  .  }
  7099  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  7100  .  .  .  .  .  }
  7101  .  .  .  .  .  5: *syntax.ForStmt {
  7102  .  .  .  .  .  .  Init: nil
  7103  .  .  .  .  .  .  Cond: *syntax.Operation {
  7104  .  .  .  .  .  .  .  Op: &&
  7105  .  .  .  .  .  .  .  X: *syntax.Operation {
  7106  .  .  .  .  .  .  .  .  Op: !=
  7107  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  7108  .  .  .  .  .  .  .  .  .  X: p @ parser.go:925:6
  7109  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:925:8
  7110  .  .  .  .  .  .  .  .  }
  7111  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:925:15
  7112  .  .  .  .  .  .  .  }
  7113  .  .  .  .  .  .  .  Y: *syntax.Operation {
  7114  .  .  .  .  .  .  .  .  Op: !=
  7115  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  7116  .  .  .  .  .  .  .  .  .  X: p @ parser.go:925:23
  7117  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:925:25
  7118  .  .  .  .  .  .  .  .  }
  7119  .  .  .  .  .  .  .  .  Y: _Rbrace @ parser.go:925:32
  7120  .  .  .  .  .  .  .  }
  7121  .  .  .  .  .  .  }
  7122  .  .  .  .  .  .  Post: nil
  7123  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  7124  .  .  .  .  .  .  .  List: []syntax.Stmt (4 entries) {
  7125  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  7126  .  .  .  .  .  .  .  .  .  Op: :
  7127  .  .  .  .  .  .  .  .  .  Lhs: e @ parser.go:927:3
  7128  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7129  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7130  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:927:8
  7131  .  .  .  .  .  .  .  .  .  .  .  Sel: bare_complitexpr @ parser.go:927:10
  7132  .  .  .  .  .  .  .  .  .  .  }
  7133  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7134  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7135  .  .  .  .  .  .  .  .  .  }
  7136  .  .  .  .  .  .  .  .  }
  7137  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  7138  .  .  .  .  .  .  .  .  .  Init: nil
  7139  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  7140  .  .  .  .  .  .  .  .  .  .  Op: ==
  7141  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  7142  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:928:6
  7143  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:928:8
  7144  .  .  .  .  .  .  .  .  .  .  }
  7145  .  .  .  .  .  .  .  .  .  .  Y: _Colon @ parser.go:928:15
  7146  .  .  .  .  .  .  .  .  .  }
  7147  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  7148  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (7 entries) {
  7149  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  7150  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  7151  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: l @ parser.go:930:4
  7152  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7153  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:930:9
  7154  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7155  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: KeyValueExpr @ parser.go:930:13
  7156  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7157  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7158  .  .  .  .  .  .  .  .  .  .  .  .  }
  7159  .  .  .  .  .  .  .  .  .  .  .  }
  7160  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  7161  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7162  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7163  .  .  .  .  .  .  .  .  .  .  .  .  .  X: l @ parser.go:931:4
  7164  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:931:6
  7165  .  .  .  .  .  .  .  .  .  .  .  .  }
  7166  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7167  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7168  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:931:12
  7169  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:931:14
  7170  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7171  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7172  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7173  .  .  .  .  .  .  .  .  .  .  .  .  }
  7174  .  .  .  .  .  .  .  .  .  .  .  }
  7175  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  7176  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7177  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7178  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:932:4
  7179  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:932:6
  7180  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7181  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7182  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7183  .  .  .  .  .  .  .  .  .  .  .  .  }
  7184  .  .  .  .  .  .  .  .  .  .  .  }
  7185  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  7186  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7187  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7188  .  .  .  .  .  .  .  .  .  .  .  .  .  X: l @ parser.go:933:4
  7189  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Key @ parser.go:933:6
  7190  .  .  .  .  .  .  .  .  .  .  .  .  }
  7191  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: e @ parser.go:933:12
  7192  .  .  .  .  .  .  .  .  .  .  .  }
  7193  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  7194  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7195  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7196  .  .  .  .  .  .  .  .  .  .  .  .  .  X: l @ parser.go:934:4
  7197  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Value @ parser.go:934:6
  7198  .  .  .  .  .  .  .  .  .  .  .  .  }
  7199  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7200  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7201  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:934:14
  7202  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: bare_complitexpr @ parser.go:934:16
  7203  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7204  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7205  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7206  .  .  .  .  .  .  .  .  .  .  .  .  }
  7207  .  .  .  .  .  .  .  .  .  .  .  }
  7208  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  7209  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7210  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: e @ parser.go:935:4
  7211  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: l @ parser.go:935:8
  7212  .  .  .  .  .  .  .  .  .  .  .  }
  7213  .  .  .  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
  7214  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
  7215  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7216  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:936:4
  7217  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: NKeys @ parser.go:936:6
  7218  .  .  .  .  .  .  .  .  .  .  .  .  }
  7219  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  7220  .  .  .  .  .  .  .  .  .  .  .  }
  7221  .  .  .  .  .  .  .  .  .  .  }
  7222  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  7223  .  .  .  .  .  .  .  .  .  }
  7224  .  .  .  .  .  .  .  .  .  Else: nil
  7225  .  .  .  .  .  .  .  .  }
  7226  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  7227  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7228  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7229  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:938:3
  7230  .  .  .  .  .  .  .  .  .  .  Sel: ElemList @ parser.go:938:5
  7231  .  .  .  .  .  .  .  .  .  }
  7232  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7233  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:938:16
  7234  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  7235  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  7236  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:938:23
  7237  .  .  .  .  .  .  .  .  .  .  .  .  Sel: ElemList @ parser.go:938:25
  7238  .  .  .  .  .  .  .  .  .  .  .  }
  7239  .  .  .  .  .  .  .  .  .  .  .  1: e @ parser.go:938:35
  7240  .  .  .  .  .  .  .  .  .  .  }
  7241  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7242  .  .  .  .  .  .  .  .  .  }
  7243  .  .  .  .  .  .  .  .  }
  7244  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  7245  .  .  .  .  .  .  .  .  .  Init: nil
  7246  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  7247  .  .  .  .  .  .  .  .  .  .  Op: !
  7248  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7249  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7250  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:939:7
  7251  .  .  .  .  .  .  .  .  .  .  .  .  Sel: ocomma @ parser.go:939:9
  7252  .  .  .  .  .  .  .  .  .  .  .  }
  7253  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7254  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrace @ parser.go:939:16
  7255  .  .  .  .  .  .  .  .  .  .  .  }
  7256  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7257  .  .  .  .  .  .  .  .  .  .  }
  7258  .  .  .  .  .  .  .  .  .  .  Y: nil
  7259  .  .  .  .  .  .  .  .  .  }
  7260  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  7261  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  7262  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  7263  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  7264  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
  7265  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 7101)
  7266  .  .  .  .  .  .  .  .  .  .  .  }
  7267  .  .  .  .  .  .  .  .  .  .  }
  7268  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  7269  .  .  .  .  .  .  .  .  .  }
  7270  .  .  .  .  .  .  .  .  .  Else: nil
  7271  .  .  .  .  .  .  .  .  }
  7272  .  .  .  .  .  .  .  }
  7273  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  7274  .  .  .  .  .  .  }
  7275  .  .  .  .  .  }
  7276  .  .  .  .  .  6: *syntax.AssignStmt {
  7277  .  .  .  .  .  .  Op: <op-0>
  7278  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7279  .  .  .  .  .  .  .  X: x @ parser.go:944:2
  7280  .  .  .  .  .  .  .  Sel: Rbrace @ parser.go:944:4
  7281  .  .  .  .  .  .  }
  7282  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7283  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7284  .  .  .  .  .  .  .  .  X: p @ parser.go:944:13
  7285  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:944:15
  7286  .  .  .  .  .  .  .  }
  7287  .  .  .  .  .  .  .  ArgList: nil
  7288  .  .  .  .  .  .  .  HasDots: false
  7289  .  .  .  .  .  .  }
  7290  .  .  .  .  .  }
  7291  .  .  .  .  .  7: *syntax.AssignStmt {
  7292  .  .  .  .  .  .  Op: -
  7293  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7294  .  .  .  .  .  .  .  X: p @ parser.go:945:2
  7295  .  .  .  .  .  .  .  Sel: xnest @ parser.go:945:4
  7296  .  .  .  .  .  .  }
  7297  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  7298  .  .  .  .  .  }
  7299  .  .  .  .  .  8: *syntax.ExprStmt {
  7300  .  .  .  .  .  .  X: *syntax.CallExpr {
  7301  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7302  .  .  .  .  .  .  .  .  X: p @ parser.go:946:2
  7303  .  .  .  .  .  .  .  .  Sel: want @ parser.go:946:4
  7304  .  .  .  .  .  .  .  }
  7305  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7306  .  .  .  .  .  .  .  .  0: _Rbrace @ parser.go:946:9
  7307  .  .  .  .  .  .  .  }
  7308  .  .  .  .  .  .  .  HasDots: false
  7309  .  .  .  .  .  .  }
  7310  .  .  .  .  .  }
  7311  .  .  .  .  .  9: *syntax.ReturnStmt {
  7312  .  .  .  .  .  .  Results: x @ parser.go:948:9
  7313  .  .  .  .  .  }
  7314  .  .  .  .  }
  7315  .  .  .  .  Rbrace: src.Pos {}
  7316  .  .  .  }
  7317  .  .  .  Pragma: 0
  7318  .  .  }
  7319  .  .  39: *syntax.FuncDecl {
  7320  .  .  .  Attr: map[]
  7321  .  .  .  Recv: *syntax.Field {
  7322  .  .  .  .  Name: p @ parser.go:954:7
  7323  .  .  .  .  Type: *syntax.Operation {
  7324  .  .  .  .  .  Op: *
  7325  .  .  .  .  .  X: parser @ parser.go:954:10
  7326  .  .  .  .  .  Y: nil
  7327  .  .  .  .  }
  7328  .  .  .  }
  7329  .  .  .  Name: type_ @ parser.go:954:18
  7330  .  .  .  Type: *syntax.FuncType {
  7331  .  .  .  .  ParamList: nil
  7332  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  7333  .  .  .  .  .  0: *syntax.Field {
  7334  .  .  .  .  .  .  Name: nil
  7335  .  .  .  .  .  .  Type: Expr @ parser.go:954:26
  7336  .  .  .  .  .  }
  7337  .  .  .  .  }
  7338  .  .  .  }
  7339  .  .  .  Body: *syntax.BlockStmt {
  7340  .  .  .  .  List: []syntax.Stmt (4 entries) {
  7341  .  .  .  .  .  0: *syntax.IfStmt {
  7342  .  .  .  .  .  .  Init: nil
  7343  .  .  .  .  .  .  Cond: trace @ parser.go:955:5
  7344  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  7345  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  7346  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  7347  .  .  .  .  .  .  .  .  .  Tok: defer
  7348  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  7349  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  7350  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7351  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:956:9
  7352  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:956:11
  7353  .  .  .  .  .  .  .  .  .  .  .  }
  7354  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7355  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  7356  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"type_\""
  7357  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  7358  .  .  .  .  .  .  .  .  .  .  .  .  }
  7359  .  .  .  .  .  .  .  .  .  .  .  }
  7360  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7361  .  .  .  .  .  .  .  .  .  .  }
  7362  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7363  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7364  .  .  .  .  .  .  .  .  .  }
  7365  .  .  .  .  .  .  .  .  }
  7366  .  .  .  .  .  .  .  }
  7367  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  7368  .  .  .  .  .  .  }
  7369  .  .  .  .  .  .  Else: nil
  7370  .  .  .  .  .  }
  7371  .  .  .  .  .  1: *syntax.AssignStmt {
  7372  .  .  .  .  .  .  Op: :
  7373  .  .  .  .  .  .  Lhs: typ @ parser.go:959:2
  7374  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7375  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7376  .  .  .  .  .  .  .  .  X: p @ parser.go:959:9
  7377  .  .  .  .  .  .  .  .  Sel: typeOrNil @ parser.go:959:11
  7378  .  .  .  .  .  .  .  }
  7379  .  .  .  .  .  .  .  ArgList: nil
  7380  .  .  .  .  .  .  .  HasDots: false
  7381  .  .  .  .  .  .  }
  7382  .  .  .  .  .  }
  7383  .  .  .  .  .  2: *syntax.IfStmt {
  7384  .  .  .  .  .  .  Init: nil
  7385  .  .  .  .  .  .  Cond: *syntax.Operation {
  7386  .  .  .  .  .  .  .  Op: ==
  7387  .  .  .  .  .  .  .  X: typ @ parser.go:960:5
  7388  .  .  .  .  .  .  .  Y: nil @ parser.go:960:12
  7389  .  .  .  .  .  .  }
  7390  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  7391  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
  7392  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  7393  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7394  .  .  .  .  .  .  .  .  .  Lhs: typ @ parser.go:961:3
  7395  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7396  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7397  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:961:9
  7398  .  .  .  .  .  .  .  .  .  .  .  Sel: bad @ parser.go:961:11
  7399  .  .  .  .  .  .  .  .  .  .  }
  7400  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7401  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7402  .  .  .  .  .  .  .  .  .  }
  7403  .  .  .  .  .  .  .  .  }
  7404  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  7405  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7406  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7407  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:962:3
  7408  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:962:5
  7409  .  .  .  .  .  .  .  .  .  .  }
  7410  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7411  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  7412  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting type\""
  7413  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  7414  .  .  .  .  .  .  .  .  .  .  .  }
  7415  .  .  .  .  .  .  .  .  .  .  }
  7416  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7417  .  .  .  .  .  .  .  .  .  }
  7418  .  .  .  .  .  .  .  .  }
  7419  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  7420  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7421  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7422  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:963:3
  7423  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:963:5
  7424  .  .  .  .  .  .  .  .  .  .  }
  7425  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7426  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7427  .  .  .  .  .  .  .  .  .  }
  7428  .  .  .  .  .  .  .  .  }
  7429  .  .  .  .  .  .  .  }
  7430  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  7431  .  .  .  .  .  .  }
  7432  .  .  .  .  .  .  Else: nil
  7433  .  .  .  .  .  }
  7434  .  .  .  .  .  3: *syntax.ReturnStmt {
  7435  .  .  .  .  .  .  Results: typ @ parser.go:966:9
  7436  .  .  .  .  .  }
  7437  .  .  .  .  }
  7438  .  .  .  .  Rbrace: src.Pos {}
  7439  .  .  .  }
  7440  .  .  .  Pragma: 0
  7441  .  .  }
  7442  .  .  40: *syntax.FuncDecl {
  7443  .  .  .  Attr: map[]
  7444  .  .  .  Recv: nil
  7445  .  .  .  Name: newIndirect @ parser.go:969:6
  7446  .  .  .  Type: *syntax.FuncType {
  7447  .  .  .  .  ParamList: []*syntax.Field (2 entries) {
  7448  .  .  .  .  .  0: *syntax.Field {
  7449  .  .  .  .  .  .  Name: pos @ parser.go:969:18
  7450  .  .  .  .  .  .  Type: *syntax.SelectorExpr {
  7451  .  .  .  .  .  .  .  X: src @ parser.go:969:22
  7452  .  .  .  .  .  .  .  Sel: Pos @ parser.go:969:26
  7453  .  .  .  .  .  .  }
  7454  .  .  .  .  .  }
  7455  .  .  .  .  .  1: *syntax.Field {
  7456  .  .  .  .  .  .  Name: typ @ parser.go:969:31
  7457  .  .  .  .  .  .  Type: Expr @ parser.go:969:35
  7458  .  .  .  .  .  }
  7459  .  .  .  .  }
  7460  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  7461  .  .  .  .  .  0: *syntax.Field {
  7462  .  .  .  .  .  .  Name: nil
  7463  .  .  .  .  .  .  Type: Expr @ parser.go:969:41
  7464  .  .  .  .  .  }
  7465  .  .  .  .  }
  7466  .  .  .  }
  7467  .  .  .  Body: *syntax.BlockStmt {
  7468  .  .  .  .  List: []syntax.Stmt (5 entries) {
  7469  .  .  .  .  .  0: *syntax.AssignStmt {
  7470  .  .  .  .  .  .  Op: :
  7471  .  .  .  .  .  .  Lhs: o @ parser.go:970:2
  7472  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7473  .  .  .  .  .  .  .  Fun: new @ parser.go:970:7
  7474  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7475  .  .  .  .  .  .  .  .  0: Operation @ parser.go:970:11
  7476  .  .  .  .  .  .  .  }
  7477  .  .  .  .  .  .  .  HasDots: false
  7478  .  .  .  .  .  .  }
  7479  .  .  .  .  .  }
  7480  .  .  .  .  .  1: *syntax.AssignStmt {
  7481  .  .  .  .  .  .  Op: <op-0>
  7482  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7483  .  .  .  .  .  .  .  X: o @ parser.go:971:2
  7484  .  .  .  .  .  .  .  Sel: pos @ parser.go:971:4
  7485  .  .  .  .  .  .  }
  7486  .  .  .  .  .  .  Rhs: pos @ parser.go:971:10
  7487  .  .  .  .  .  }
  7488  .  .  .  .  .  2: *syntax.AssignStmt {
  7489  .  .  .  .  .  .  Op: <op-0>
  7490  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7491  .  .  .  .  .  .  .  X: o @ parser.go:972:2
  7492  .  .  .  .  .  .  .  Sel: Op @ parser.go:972:4
  7493  .  .  .  .  .  .  }
  7494  .  .  .  .  .  .  Rhs: Mul @ parser.go:972:9
  7495  .  .  .  .  .  }
  7496  .  .  .  .  .  3: *syntax.AssignStmt {
  7497  .  .  .  .  .  .  Op: <op-0>
  7498  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7499  .  .  .  .  .  .  .  X: o @ parser.go:973:2
  7500  .  .  .  .  .  .  .  Sel: X @ parser.go:973:4
  7501  .  .  .  .  .  .  }
  7502  .  .  .  .  .  .  Rhs: typ @ parser.go:973:8
  7503  .  .  .  .  .  }
  7504  .  .  .  .  .  4: *syntax.ReturnStmt {
  7505  .  .  .  .  .  .  Results: o @ parser.go:974:9
  7506  .  .  .  .  .  }
  7507  .  .  .  .  }
  7508  .  .  .  .  Rbrace: src.Pos {}
  7509  .  .  .  }
  7510  .  .  .  Pragma: 0
  7511  .  .  }
  7512  .  .  41: *syntax.FuncDecl {
  7513  .  .  .  Attr: map[]
  7514  .  .  .  Recv: *syntax.Field {
  7515  .  .  .  .  Name: p @ parser.go:984:7
  7516  .  .  .  .  Type: *syntax.Operation {
  7517  .  .  .  .  .  Op: *
  7518  .  .  .  .  .  X: parser @ parser.go:984:10
  7519  .  .  .  .  .  Y: nil
  7520  .  .  .  .  }
  7521  .  .  .  }
  7522  .  .  .  Name: typeOrNil @ parser.go:984:18
  7523  .  .  .  Type: *syntax.FuncType {
  7524  .  .  .  .  ParamList: nil
  7525  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  7526  .  .  .  .  .  0: *syntax.Field {
  7527  .  .  .  .  .  .  Name: nil
  7528  .  .  .  .  .  .  Type: Expr @ parser.go:984:30
  7529  .  .  .  .  .  }
  7530  .  .  .  .  }
  7531  .  .  .  }
  7532  .  .  .  Body: *syntax.BlockStmt {
  7533  .  .  .  .  List: []syntax.Stmt (4 entries) {
  7534  .  .  .  .  .  0: *syntax.IfStmt {
  7535  .  .  .  .  .  .  Init: nil
  7536  .  .  .  .  .  .  Cond: trace @ parser.go:985:5
  7537  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  7538  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  7539  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  7540  .  .  .  .  .  .  .  .  .  Tok: defer
  7541  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  7542  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  7543  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7544  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:986:9
  7545  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:986:11
  7546  .  .  .  .  .  .  .  .  .  .  .  }
  7547  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7548  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  7549  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"typeOrNil\""
  7550  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  7551  .  .  .  .  .  .  .  .  .  .  .  .  }
  7552  .  .  .  .  .  .  .  .  .  .  .  }
  7553  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7554  .  .  .  .  .  .  .  .  .  .  }
  7555  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7556  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7557  .  .  .  .  .  .  .  .  .  }
  7558  .  .  .  .  .  .  .  .  }
  7559  .  .  .  .  .  .  .  }
  7560  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  7561  .  .  .  .  .  .  }
  7562  .  .  .  .  .  .  Else: nil
  7563  .  .  .  .  .  }
  7564  .  .  .  .  .  1: *syntax.AssignStmt {
  7565  .  .  .  .  .  .  Op: :
  7566  .  .  .  .  .  .  Lhs: pos @ parser.go:989:2
  7567  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7568  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7569  .  .  .  .  .  .  .  .  X: p @ parser.go:989:9
  7570  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:989:11
  7571  .  .  .  .  .  .  .  }
  7572  .  .  .  .  .  .  .  ArgList: nil
  7573  .  .  .  .  .  .  .  HasDots: false
  7574  .  .  .  .  .  .  }
  7575  .  .  .  .  .  }
  7576  .  .  .  .  .  2: *syntax.SwitchStmt {
  7577  .  .  .  .  .  .  Init: nil
  7578  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  7579  .  .  .  .  .  .  .  X: p @ parser.go:990:9
  7580  .  .  .  .  .  .  .  Sel: tok @ parser.go:990:11
  7581  .  .  .  .  .  .  }
  7582  .  .  .  .  .  .  Body: []*syntax.CaseClause (10 entries) {
  7583  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  7584  .  .  .  .  .  .  .  .  Cases: _Star @ parser.go:991:7
  7585  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  7586  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  7587  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7588  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7589  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:993:3
  7590  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:993:5
  7591  .  .  .  .  .  .  .  .  .  .  .  }
  7592  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7593  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7594  .  .  .  .  .  .  .  .  .  .  }
  7595  .  .  .  .  .  .  .  .  .  }
  7596  .  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
  7597  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  7598  .  .  .  .  .  .  .  .  .  .  .  Fun: newIndirect @ parser.go:994:10
  7599  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  7600  .  .  .  .  .  .  .  .  .  .  .  .  0: pos @ parser.go:994:22
  7601  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
  7602  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7603  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:994:27
  7604  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_ @ parser.go:994:29
  7605  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7606  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7607  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7608  .  .  .  .  .  .  .  .  .  .  .  .  }
  7609  .  .  .  .  .  .  .  .  .  .  .  }
  7610  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7611  .  .  .  .  .  .  .  .  .  .  }
  7612  .  .  .  .  .  .  .  .  .  }
  7613  .  .  .  .  .  .  .  .  }
  7614  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  7615  .  .  .  .  .  .  .  }
  7616  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  7617  .  .  .  .  .  .  .  .  Cases: _Arrow @ parser.go:996:7
  7618  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (7 entries) {
  7619  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  7620  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7621  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7622  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:998:3
  7623  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:998:5
  7624  .  .  .  .  .  .  .  .  .  .  .  }
  7625  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7626  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7627  .  .  .  .  .  .  .  .  .  .  }
  7628  .  .  .  .  .  .  .  .  .  }
  7629  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  7630  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7631  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7632  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:999:3
  7633  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:999:5
  7634  .  .  .  .  .  .  .  .  .  .  .  }
  7635  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7636  .  .  .  .  .  .  .  .  .  .  .  .  0: _Chan @ parser.go:999:10
  7637  .  .  .  .  .  .  .  .  .  .  .  }
  7638  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7639  .  .  .  .  .  .  .  .  .  .  }
  7640  .  .  .  .  .  .  .  .  .  }
  7641  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  7642  .  .  .  .  .  .  .  .  .  .  Op: :
  7643  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:1000:3
  7644  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7645  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1000:8
  7646  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7647  .  .  .  .  .  .  .  .  .  .  .  .  0: ChanType @ parser.go:1000:12
  7648  .  .  .  .  .  .  .  .  .  .  .  }
  7649  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7650  .  .  .  .  .  .  .  .  .  .  }
  7651  .  .  .  .  .  .  .  .  .  }
  7652  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  7653  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7654  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7655  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1001:3
  7656  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1001:5
  7657  .  .  .  .  .  .  .  .  .  .  }
  7658  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:1001:11
  7659  .  .  .  .  .  .  .  .  .  }
  7660  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  7661  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7662  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7663  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1002:3
  7664  .  .  .  .  .  .  .  .  .  .  .  Sel: Dir @ parser.go:1002:5
  7665  .  .  .  .  .  .  .  .  .  .  }
  7666  .  .  .  .  .  .  .  .  .  .  Rhs: RecvOnly @ parser.go:1002:11
  7667  .  .  .  .  .  .  .  .  .  }
  7668  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
  7669  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7670  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7671  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1003:3
  7672  .  .  .  .  .  .  .  .  .  .  .  Sel: Elem @ parser.go:1003:5
  7673  .  .  .  .  .  .  .  .  .  .  }
  7674  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7675  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7676  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1003:12
  7677  .  .  .  .  .  .  .  .  .  .  .  .  Sel: chanElem @ parser.go:1003:14
  7678  .  .  .  .  .  .  .  .  .  .  .  }
  7679  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7680  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7681  .  .  .  .  .  .  .  .  .  .  }
  7682  .  .  .  .  .  .  .  .  .  }
  7683  .  .  .  .  .  .  .  .  .  6: *syntax.ReturnStmt {
  7684  .  .  .  .  .  .  .  .  .  .  Results: t @ parser.go:1004:10
  7685  .  .  .  .  .  .  .  .  .  }
  7686  .  .  .  .  .  .  .  .  }
  7687  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  7688  .  .  .  .  .  .  .  }
  7689  .  .  .  .  .  .  .  2: *syntax.CaseClause {
  7690  .  .  .  .  .  .  .  .  Cases: _Func @ parser.go:1006:7
  7691  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  7692  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  7693  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7694  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7695  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1008:3
  7696  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1008:5
  7697  .  .  .  .  .  .  .  .  .  .  .  }
  7698  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7699  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7700  .  .  .  .  .  .  .  .  .  .  }
  7701  .  .  .  .  .  .  .  .  .  }
  7702  .  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
  7703  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  7704  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7705  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1009:10
  7706  .  .  .  .  .  .  .  .  .  .  .  .  Sel: funcType @ parser.go:1009:12
  7707  .  .  .  .  .  .  .  .  .  .  .  }
  7708  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7709  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7710  .  .  .  .  .  .  .  .  .  .  }
  7711  .  .  .  .  .  .  .  .  .  }
  7712  .  .  .  .  .  .  .  .  }
  7713  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  7714  .  .  .  .  .  .  .  }
  7715  .  .  .  .  .  .  .  3: *syntax.CaseClause {
  7716  .  .  .  .  .  .  .  .  Cases: _Lbrack @ parser.go:1011:7
  7717  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (10 entries) {
  7718  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  7719  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7720  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7721  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1014:3
  7722  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1014:5
  7723  .  .  .  .  .  .  .  .  .  .  .  }
  7724  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7725  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7726  .  .  .  .  .  .  .  .  .  .  }
  7727  .  .  .  .  .  .  .  .  .  }
  7728  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  7729  .  .  .  .  .  .  .  .  .  .  Op: +
  7730  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7731  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1015:3
  7732  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest @ parser.go:1015:5
  7733  .  .  .  .  .  .  .  .  .  .  }
  7734  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  7735  .  .  .  .  .  .  .  .  .  }
  7736  .  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
  7737  .  .  .  .  .  .  .  .  .  .  Init: nil
  7738  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  7739  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7740  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1016:6
  7741  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:1016:8
  7742  .  .  .  .  .  .  .  .  .  .  .  }
  7743  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7744  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrack @ parser.go:1016:12
  7745  .  .  .  .  .  .  .  .  .  .  .  }
  7746  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7747  .  .  .  .  .  .  .  .  .  .  }
  7748  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  7749  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (5 entries) {
  7750  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  7751  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: -
  7752  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7753  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1018:4
  7754  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest @ parser.go:1018:6
  7755  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7756  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  7757  .  .  .  .  .  .  .  .  .  .  .  .  }
  7758  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  7759  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  7760  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:1019:4
  7761  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7762  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1019:9
  7763  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7764  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: SliceType @ parser.go:1019:13
  7765  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7766  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7767  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7768  .  .  .  .  .  .  .  .  .  .  .  .  }
  7769  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  7770  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7771  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7772  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1020:4
  7773  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1020:6
  7774  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7775  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:1020:12
  7776  .  .  .  .  .  .  .  .  .  .  .  .  }
  7777  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  7778  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7779  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7780  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1021:4
  7781  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Elem @ parser.go:1021:6
  7782  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7783  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7784  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7785  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1021:13
  7786  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_ @ parser.go:1021:15
  7787  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7788  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7789  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7790  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7791  .  .  .  .  .  .  .  .  .  .  .  .  }
  7792  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.ReturnStmt {
  7793  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: t @ parser.go:1022:11
  7794  .  .  .  .  .  .  .  .  .  .  .  .  }
  7795  .  .  .  .  .  .  .  .  .  .  .  }
  7796  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  7797  .  .  .  .  .  .  .  .  .  .  }
  7798  .  .  .  .  .  .  .  .  .  .  Else: nil
  7799  .  .  .  .  .  .  .  .  .  }
  7800  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  7801  .  .  .  .  .  .  .  .  .  .  Op: :
  7802  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:1026:3
  7803  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7804  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1026:8
  7805  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7806  .  .  .  .  .  .  .  .  .  .  .  .  0: ArrayType @ parser.go:1026:12
  7807  .  .  .  .  .  .  .  .  .  .  .  }
  7808  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7809  .  .  .  .  .  .  .  .  .  .  }
  7810  .  .  .  .  .  .  .  .  .  }
  7811  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  7812  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7813  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7814  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1027:3
  7815  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1027:5
  7816  .  .  .  .  .  .  .  .  .  .  }
  7817  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:1027:11
  7818  .  .  .  .  .  .  .  .  .  }
  7819  .  .  .  .  .  .  .  .  .  5: *syntax.IfStmt {
  7820  .  .  .  .  .  .  .  .  .  .  Init: nil
  7821  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  7822  .  .  .  .  .  .  .  .  .  .  .  Op: !
  7823  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7824  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7825  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1028:7
  7826  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:1028:9
  7827  .  .  .  .  .  .  .  .  .  .  .  .  }
  7828  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7829  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _DotDotDot @ parser.go:1028:13
  7830  .  .  .  .  .  .  .  .  .  .  .  .  }
  7831  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7832  .  .  .  .  .  .  .  .  .  .  .  }
  7833  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  7834  .  .  .  .  .  .  .  .  .  .  }
  7835  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  7836  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  7837  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  7838  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7839  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7840  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1029:4
  7841  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Len @ parser.go:1029:6
  7842  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7843  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7844  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7845  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1029:12
  7846  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:1029:14
  7847  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7848  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7849  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7850  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7851  .  .  .  .  .  .  .  .  .  .  .  .  }
  7852  .  .  .  .  .  .  .  .  .  .  .  }
  7853  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  7854  .  .  .  .  .  .  .  .  .  .  }
  7855  .  .  .  .  .  .  .  .  .  .  Else: nil
  7856  .  .  .  .  .  .  .  .  .  }
  7857  .  .  .  .  .  .  .  .  .  6: *syntax.ExprStmt {
  7858  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7859  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7860  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1031:3
  7861  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1031:5
  7862  .  .  .  .  .  .  .  .  .  .  .  }
  7863  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7864  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrack @ parser.go:1031:10
  7865  .  .  .  .  .  .  .  .  .  .  .  }
  7866  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7867  .  .  .  .  .  .  .  .  .  .  }
  7868  .  .  .  .  .  .  .  .  .  }
  7869  .  .  .  .  .  .  .  .  .  7: *syntax.AssignStmt {
  7870  .  .  .  .  .  .  .  .  .  .  Op: -
  7871  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7872  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1032:3
  7873  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest @ parser.go:1032:5
  7874  .  .  .  .  .  .  .  .  .  .  }
  7875  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  7876  .  .  .  .  .  .  .  .  .  }
  7877  .  .  .  .  .  .  .  .  .  8: *syntax.AssignStmt {
  7878  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7879  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7880  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1033:3
  7881  .  .  .  .  .  .  .  .  .  .  .  Sel: Elem @ parser.go:1033:5
  7882  .  .  .  .  .  .  .  .  .  .  }
  7883  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7884  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7885  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1033:12
  7886  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_ @ parser.go:1033:14
  7887  .  .  .  .  .  .  .  .  .  .  .  }
  7888  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7889  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7890  .  .  .  .  .  .  .  .  .  .  }
  7891  .  .  .  .  .  .  .  .  .  }
  7892  .  .  .  .  .  .  .  .  .  9: *syntax.ReturnStmt {
  7893  .  .  .  .  .  .  .  .  .  .  Results: t @ parser.go:1034:10
  7894  .  .  .  .  .  .  .  .  .  }
  7895  .  .  .  .  .  .  .  .  }
  7896  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  7897  .  .  .  .  .  .  .  }
  7898  .  .  .  .  .  .  .  4: *syntax.CaseClause {
  7899  .  .  .  .  .  .  .  .  Cases: _Chan @ parser.go:1036:7
  7900  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
  7901  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  7902  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7903  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7904  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1039:3
  7905  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1039:5
  7906  .  .  .  .  .  .  .  .  .  .  .  }
  7907  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7908  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7909  .  .  .  .  .  .  .  .  .  .  }
  7910  .  .  .  .  .  .  .  .  .  }
  7911  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  7912  .  .  .  .  .  .  .  .  .  .  Op: :
  7913  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:1040:3
  7914  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7915  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1040:8
  7916  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7917  .  .  .  .  .  .  .  .  .  .  .  .  0: ChanType @ parser.go:1040:12
  7918  .  .  .  .  .  .  .  .  .  .  .  }
  7919  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7920  .  .  .  .  .  .  .  .  .  .  }
  7921  .  .  .  .  .  .  .  .  .  }
  7922  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  7923  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7924  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7925  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1041:3
  7926  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1041:5
  7927  .  .  .  .  .  .  .  .  .  .  }
  7928  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:1041:11
  7929  .  .  .  .  .  .  .  .  .  }
  7930  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
  7931  .  .  .  .  .  .  .  .  .  .  Init: nil
  7932  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
  7933  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7934  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1042:6
  7935  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:1042:8
  7936  .  .  .  .  .  .  .  .  .  .  .  }
  7937  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7938  .  .  .  .  .  .  .  .  .  .  .  .  0: _Arrow @ parser.go:1042:12
  7939  .  .  .  .  .  .  .  .  .  .  .  }
  7940  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7941  .  .  .  .  .  .  .  .  .  .  }
  7942  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  7943  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  7944  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  7945  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7946  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7947  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1043:4
  7948  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Dir @ parser.go:1043:6
  7949  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  7950  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: SendOnly @ parser.go:1043:12
  7951  .  .  .  .  .  .  .  .  .  .  .  .  }
  7952  .  .  .  .  .  .  .  .  .  .  .  }
  7953  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  7954  .  .  .  .  .  .  .  .  .  .  }
  7955  .  .  .  .  .  .  .  .  .  .  Else: nil
  7956  .  .  .  .  .  .  .  .  .  }
  7957  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  7958  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  7959  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  7960  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1045:3
  7961  .  .  .  .  .  .  .  .  .  .  .  Sel: Elem @ parser.go:1045:5
  7962  .  .  .  .  .  .  .  .  .  .  }
  7963  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  7964  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7965  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1045:12
  7966  .  .  .  .  .  .  .  .  .  .  .  .  Sel: chanElem @ parser.go:1045:14
  7967  .  .  .  .  .  .  .  .  .  .  .  }
  7968  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7969  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7970  .  .  .  .  .  .  .  .  .  .  }
  7971  .  .  .  .  .  .  .  .  .  }
  7972  .  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
  7973  .  .  .  .  .  .  .  .  .  .  Results: t @ parser.go:1046:10
  7974  .  .  .  .  .  .  .  .  .  }
  7975  .  .  .  .  .  .  .  .  }
  7976  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  7977  .  .  .  .  .  .  .  }
  7978  .  .  .  .  .  .  .  5: *syntax.CaseClause {
  7979  .  .  .  .  .  .  .  .  Cases: _Map @ parser.go:1048:7
  7980  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (8 entries) {
  7981  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  7982  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7983  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7984  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1050:3
  7985  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1050:5
  7986  .  .  .  .  .  .  .  .  .  .  .  }
  7987  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  7988  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  7989  .  .  .  .  .  .  .  .  .  .  }
  7990  .  .  .  .  .  .  .  .  .  }
  7991  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  7992  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  7993  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  7994  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1051:3
  7995  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1051:5
  7996  .  .  .  .  .  .  .  .  .  .  .  }
  7997  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  7998  .  .  .  .  .  .  .  .  .  .  .  .  0: _Lbrack @ parser.go:1051:10
  7999  .  .  .  .  .  .  .  .  .  .  .  }
  8000  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8001  .  .  .  .  .  .  .  .  .  .  }
  8002  .  .  .  .  .  .  .  .  .  }
  8003  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  8004  .  .  .  .  .  .  .  .  .  .  Op: :
  8005  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:1052:3
  8006  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8007  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1052:8
  8008  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8009  .  .  .  .  .  .  .  .  .  .  .  .  0: MapType @ parser.go:1052:12
  8010  .  .  .  .  .  .  .  .  .  .  .  }
  8011  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8012  .  .  .  .  .  .  .  .  .  .  }
  8013  .  .  .  .  .  .  .  .  .  }
  8014  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  8015  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  8016  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8017  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1053:3
  8018  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1053:5
  8019  .  .  .  .  .  .  .  .  .  .  }
  8020  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:1053:11
  8021  .  .  .  .  .  .  .  .  .  }
  8022  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  8023  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  8024  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8025  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1054:3
  8026  .  .  .  .  .  .  .  .  .  .  .  Sel: Key @ parser.go:1054:5
  8027  .  .  .  .  .  .  .  .  .  .  }
  8028  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8029  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8030  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1054:11
  8031  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_ @ parser.go:1054:13
  8032  .  .  .  .  .  .  .  .  .  .  .  }
  8033  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8034  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8035  .  .  .  .  .  .  .  .  .  .  }
  8036  .  .  .  .  .  .  .  .  .  }
  8037  .  .  .  .  .  .  .  .  .  5: *syntax.ExprStmt {
  8038  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8039  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8040  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1055:3
  8041  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1055:5
  8042  .  .  .  .  .  .  .  .  .  .  .  }
  8043  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8044  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrack @ parser.go:1055:10
  8045  .  .  .  .  .  .  .  .  .  .  .  }
  8046  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8047  .  .  .  .  .  .  .  .  .  .  }
  8048  .  .  .  .  .  .  .  .  .  }
  8049  .  .  .  .  .  .  .  .  .  6: *syntax.AssignStmt {
  8050  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  8051  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8052  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1056:3
  8053  .  .  .  .  .  .  .  .  .  .  .  Sel: Value @ parser.go:1056:5
  8054  .  .  .  .  .  .  .  .  .  .  }
  8055  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8056  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8057  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1056:13
  8058  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_ @ parser.go:1056:15
  8059  .  .  .  .  .  .  .  .  .  .  .  }
  8060  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8061  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8062  .  .  .  .  .  .  .  .  .  .  }
  8063  .  .  .  .  .  .  .  .  .  }
  8064  .  .  .  .  .  .  .  .  .  7: *syntax.ReturnStmt {
  8065  .  .  .  .  .  .  .  .  .  .  Results: t @ parser.go:1057:10
  8066  .  .  .  .  .  .  .  .  .  }
  8067  .  .  .  .  .  .  .  .  }
  8068  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  8069  .  .  .  .  .  .  .  }
  8070  .  .  .  .  .  .  .  6: *syntax.CaseClause {
  8071  .  .  .  .  .  .  .  .  Cases: _Struct @ parser.go:1059:7
  8072  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  8073  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  8074  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  8075  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8076  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1060:10
  8077  .  .  .  .  .  .  .  .  .  .  .  .  Sel: structType @ parser.go:1060:12
  8078  .  .  .  .  .  .  .  .  .  .  .  }
  8079  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8080  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8081  .  .  .  .  .  .  .  .  .  .  }
  8082  .  .  .  .  .  .  .  .  .  }
  8083  .  .  .  .  .  .  .  .  }
  8084  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  8085  .  .  .  .  .  .  .  }
  8086  .  .  .  .  .  .  .  7: *syntax.CaseClause {
  8087  .  .  .  .  .  .  .  .  Cases: _Interface @ parser.go:1062:7
  8088  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  8089  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  8090  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  8091  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8092  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1063:10
  8093  .  .  .  .  .  .  .  .  .  .  .  .  Sel: interfaceType @ parser.go:1063:12
  8094  .  .  .  .  .  .  .  .  .  .  .  }
  8095  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8096  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8097  .  .  .  .  .  .  .  .  .  .  }
  8098  .  .  .  .  .  .  .  .  .  }
  8099  .  .  .  .  .  .  .  .  }
  8100  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  8101  .  .  .  .  .  .  .  }
  8102  .  .  .  .  .  .  .  8: *syntax.CaseClause {
  8103  .  .  .  .  .  .  .  .  Cases: _Name @ parser.go:1065:7
  8104  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
  8105  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  8106  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  8107  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8108  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1066:10
  8109  .  .  .  .  .  .  .  .  .  .  .  .  Sel: dotname @ parser.go:1066:12
  8110  .  .  .  .  .  .  .  .  .  .  .  }
  8111  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8112  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  8113  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8114  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1066:20
  8115  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:1066:22
  8116  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8117  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8118  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8119  .  .  .  .  .  .  .  .  .  .  .  .  }
  8120  .  .  .  .  .  .  .  .  .  .  .  }
  8121  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8122  .  .  .  .  .  .  .  .  .  .  }
  8123  .  .  .  .  .  .  .  .  .  }
  8124  .  .  .  .  .  .  .  .  }
  8125  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  8126  .  .  .  .  .  .  .  }
  8127  .  .  .  .  .  .  .  9: *syntax.CaseClause {
  8128  .  .  .  .  .  .  .  .  Cases: _Lparen @ parser.go:1068:7
  8129  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (4 entries) {
  8130  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  8131  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8132  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8133  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1069:3
  8134  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1069:5
  8135  .  .  .  .  .  .  .  .  .  .  .  }
  8136  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8137  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8138  .  .  .  .  .  .  .  .  .  .  }
  8139  .  .  .  .  .  .  .  .  .  }
  8140  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  8141  .  .  .  .  .  .  .  .  .  .  Op: :
  8142  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:1070:3
  8143  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8144  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8145  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1070:8
  8146  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_ @ parser.go:1070:10
  8147  .  .  .  .  .  .  .  .  .  .  .  }
  8148  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8149  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8150  .  .  .  .  .  .  .  .  .  .  }
  8151  .  .  .  .  .  .  .  .  .  }
  8152  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  8153  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8154  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8155  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1071:3
  8156  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1071:5
  8157  .  .  .  .  .  .  .  .  .  .  .  }
  8158  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8159  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:1071:10
  8160  .  .  .  .  .  .  .  .  .  .  .  }
  8161  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8162  .  .  .  .  .  .  .  .  .  .  }
  8163  .  .  .  .  .  .  .  .  .  }
  8164  .  .  .  .  .  .  .  .  .  3: *syntax.ReturnStmt {
  8165  .  .  .  .  .  .  .  .  .  .  Results: t @ parser.go:1072:10
  8166  .  .  .  .  .  .  .  .  .  }
  8167  .  .  .  .  .  .  .  .  }
  8168  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  8169  .  .  .  .  .  .  .  }
  8170  .  .  .  .  .  .  }
  8171  .  .  .  .  .  .  Rbrace: src.Pos {}
  8172  .  .  .  .  .  }
  8173  .  .  .  .  .  3: *syntax.ReturnStmt {
  8174  .  .  .  .  .  .  Results: nil @ parser.go:1075:9
  8175  .  .  .  .  .  }
  8176  .  .  .  .  }
  8177  .  .  .  .  Rbrace: src.Pos {}
  8178  .  .  .  }
  8179  .  .  .  Pragma: 0
  8180  .  .  }
  8181  .  .  42: *syntax.FuncDecl {
  8182  .  .  .  Attr: map[]
  8183  .  .  .  Recv: *syntax.Field {
  8184  .  .  .  .  Name: p @ parser.go:1078:7
  8185  .  .  .  .  Type: *syntax.Operation {
  8186  .  .  .  .  .  Op: *
  8187  .  .  .  .  .  X: parser @ parser.go:1078:10
  8188  .  .  .  .  .  Y: nil
  8189  .  .  .  .  }
  8190  .  .  .  }
  8191  .  .  .  Name: funcType @ parser.go:1078:18
  8192  .  .  .  Type: *syntax.FuncType {
  8193  .  .  .  .  ParamList: nil
  8194  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  8195  .  .  .  .  .  0: *syntax.Field {
  8196  .  .  .  .  .  .  Name: nil
  8197  .  .  .  .  .  .  Type: *syntax.Operation {
  8198  .  .  .  .  .  .  .  Op: *
  8199  .  .  .  .  .  .  .  X: FuncType @ parser.go:1078:30
  8200  .  .  .  .  .  .  .  Y: nil
  8201  .  .  .  .  .  .  }
  8202  .  .  .  .  .  }
  8203  .  .  .  .  }
  8204  .  .  .  }
  8205  .  .  .  Body: *syntax.BlockStmt {
  8206  .  .  .  .  List: []syntax.Stmt (6 entries) {
  8207  .  .  .  .  .  0: *syntax.IfStmt {
  8208  .  .  .  .  .  .  Init: nil
  8209  .  .  .  .  .  .  Cond: trace @ parser.go:1079:5
  8210  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  8211  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  8212  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  8213  .  .  .  .  .  .  .  .  .  Tok: defer
  8214  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  8215  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  8216  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8217  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1080:9
  8218  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1080:11
  8219  .  .  .  .  .  .  .  .  .  .  .  }
  8220  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8221  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  8222  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"funcType\""
  8223  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  8224  .  .  .  .  .  .  .  .  .  .  .  .  }
  8225  .  .  .  .  .  .  .  .  .  .  .  }
  8226  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8227  .  .  .  .  .  .  .  .  .  .  }
  8228  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8229  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8230  .  .  .  .  .  .  .  .  .  }
  8231  .  .  .  .  .  .  .  .  }
  8232  .  .  .  .  .  .  .  }
  8233  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  8234  .  .  .  .  .  .  }
  8235  .  .  .  .  .  .  Else: nil
  8236  .  .  .  .  .  }
  8237  .  .  .  .  .  1: *syntax.AssignStmt {
  8238  .  .  .  .  .  .  Op: :
  8239  .  .  .  .  .  .  Lhs: typ @ parser.go:1083:2
  8240  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8241  .  .  .  .  .  .  .  Fun: new @ parser.go:1083:9
  8242  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8243  .  .  .  .  .  .  .  .  0: FuncType @ parser.go:1083:13
  8244  .  .  .  .  .  .  .  }
  8245  .  .  .  .  .  .  .  HasDots: false
  8246  .  .  .  .  .  .  }
  8247  .  .  .  .  .  }
  8248  .  .  .  .  .  2: *syntax.AssignStmt {
  8249  .  .  .  .  .  .  Op: <op-0>
  8250  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8251  .  .  .  .  .  .  .  X: typ @ parser.go:1084:2
  8252  .  .  .  .  .  .  .  Sel: pos @ parser.go:1084:6
  8253  .  .  .  .  .  .  }
  8254  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8255  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8256  .  .  .  .  .  .  .  .  X: p @ parser.go:1084:12
  8257  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1084:14
  8258  .  .  .  .  .  .  .  }
  8259  .  .  .  .  .  .  .  ArgList: nil
  8260  .  .  .  .  .  .  .  HasDots: false
  8261  .  .  .  .  .  .  }
  8262  .  .  .  .  .  }
  8263  .  .  .  .  .  3: *syntax.AssignStmt {
  8264  .  .  .  .  .  .  Op: <op-0>
  8265  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8266  .  .  .  .  .  .  .  X: typ @ parser.go:1085:2
  8267  .  .  .  .  .  .  .  Sel: ParamList @ parser.go:1085:6
  8268  .  .  .  .  .  .  }
  8269  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8270  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8271  .  .  .  .  .  .  .  .  X: p @ parser.go:1085:18
  8272  .  .  .  .  .  .  .  .  Sel: paramList @ parser.go:1085:20
  8273  .  .  .  .  .  .  .  }
  8274  .  .  .  .  .  .  .  ArgList: nil
  8275  .  .  .  .  .  .  .  HasDots: false
  8276  .  .  .  .  .  .  }
  8277  .  .  .  .  .  }
  8278  .  .  .  .  .  4: *syntax.AssignStmt {
  8279  .  .  .  .  .  .  Op: <op-0>
  8280  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8281  .  .  .  .  .  .  .  X: typ @ parser.go:1086:2
  8282  .  .  .  .  .  .  .  Sel: ResultList @ parser.go:1086:6
  8283  .  .  .  .  .  .  }
  8284  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8285  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8286  .  .  .  .  .  .  .  .  X: p @ parser.go:1086:19
  8287  .  .  .  .  .  .  .  .  Sel: funcResult @ parser.go:1086:21
  8288  .  .  .  .  .  .  .  }
  8289  .  .  .  .  .  .  .  ArgList: nil
  8290  .  .  .  .  .  .  .  HasDots: false
  8291  .  .  .  .  .  .  }
  8292  .  .  .  .  .  }
  8293  .  .  .  .  .  5: *syntax.ReturnStmt {
  8294  .  .  .  .  .  .  Results: typ @ parser.go:1088:9
  8295  .  .  .  .  .  }
  8296  .  .  .  .  }
  8297  .  .  .  .  Rbrace: src.Pos {}
  8298  .  .  .  }
  8299  .  .  .  Pragma: 0
  8300  .  .  }
  8301  .  .  43: *syntax.FuncDecl {
  8302  .  .  .  Attr: map[]
  8303  .  .  .  Recv: *syntax.Field {
  8304  .  .  .  .  Name: p @ parser.go:1091:7
  8305  .  .  .  .  Type: *syntax.Operation {
  8306  .  .  .  .  .  Op: *
  8307  .  .  .  .  .  X: parser @ parser.go:1091:10
  8308  .  .  .  .  .  Y: nil
  8309  .  .  .  .  }
  8310  .  .  .  }
  8311  .  .  .  Name: chanElem @ parser.go:1091:18
  8312  .  .  .  Type: *syntax.FuncType {
  8313  .  .  .  .  ParamList: nil
  8314  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  8315  .  .  .  .  .  0: *syntax.Field {
  8316  .  .  .  .  .  .  Name: nil
  8317  .  .  .  .  .  .  Type: Expr @ parser.go:1091:29
  8318  .  .  .  .  .  }
  8319  .  .  .  .  }
  8320  .  .  .  }
  8321  .  .  .  Body: *syntax.BlockStmt {
  8322  .  .  .  .  List: []syntax.Stmt (4 entries) {
  8323  .  .  .  .  .  0: *syntax.IfStmt {
  8324  .  .  .  .  .  .  Init: nil
  8325  .  .  .  .  .  .  Cond: trace @ parser.go:1092:5
  8326  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  8327  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  8328  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  8329  .  .  .  .  .  .  .  .  .  Tok: defer
  8330  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  8331  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  8332  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8333  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1093:9
  8334  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1093:11
  8335  .  .  .  .  .  .  .  .  .  .  .  }
  8336  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8337  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  8338  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"chanElem\""
  8339  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  8340  .  .  .  .  .  .  .  .  .  .  .  .  }
  8341  .  .  .  .  .  .  .  .  .  .  .  }
  8342  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8343  .  .  .  .  .  .  .  .  .  .  }
  8344  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8345  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8346  .  .  .  .  .  .  .  .  .  }
  8347  .  .  .  .  .  .  .  .  }
  8348  .  .  .  .  .  .  .  }
  8349  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  8350  .  .  .  .  .  .  }
  8351  .  .  .  .  .  .  Else: nil
  8352  .  .  .  .  .  }
  8353  .  .  .  .  .  1: *syntax.AssignStmt {
  8354  .  .  .  .  .  .  Op: :
  8355  .  .  .  .  .  .  Lhs: typ @ parser.go:1096:2
  8356  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8357  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8358  .  .  .  .  .  .  .  .  X: p @ parser.go:1096:9
  8359  .  .  .  .  .  .  .  .  Sel: typeOrNil @ parser.go:1096:11
  8360  .  .  .  .  .  .  .  }
  8361  .  .  .  .  .  .  .  ArgList: nil
  8362  .  .  .  .  .  .  .  HasDots: false
  8363  .  .  .  .  .  .  }
  8364  .  .  .  .  .  }
  8365  .  .  .  .  .  2: *syntax.IfStmt {
  8366  .  .  .  .  .  .  Init: nil
  8367  .  .  .  .  .  .  Cond: *syntax.Operation {
  8368  .  .  .  .  .  .  .  Op: ==
  8369  .  .  .  .  .  .  .  X: typ @ parser.go:1097:5
  8370  .  .  .  .  .  .  .  Y: nil @ parser.go:1097:12
  8371  .  .  .  .  .  .  }
  8372  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  8373  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  8374  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  8375  .  .  .  .  .  .  .  .  .  Op: <op-0>
  8376  .  .  .  .  .  .  .  .  .  Lhs: typ @ parser.go:1098:3
  8377  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8378  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8379  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1098:9
  8380  .  .  .  .  .  .  .  .  .  .  .  Sel: bad @ parser.go:1098:11
  8381  .  .  .  .  .  .  .  .  .  .  }
  8382  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8383  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8384  .  .  .  .  .  .  .  .  .  }
  8385  .  .  .  .  .  .  .  .  }
  8386  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  8387  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8388  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8389  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1099:3
  8390  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1099:5
  8391  .  .  .  .  .  .  .  .  .  .  }
  8392  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8393  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  8394  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"missing channel element type\""
  8395  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  8396  .  .  .  .  .  .  .  .  .  .  .  }
  8397  .  .  .  .  .  .  .  .  .  .  }
  8398  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8399  .  .  .  .  .  .  .  .  .  }
  8400  .  .  .  .  .  .  .  .  }
  8401  .  .  .  .  .  .  .  }
  8402  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  8403  .  .  .  .  .  .  }
  8404  .  .  .  .  .  .  Else: nil
  8405  .  .  .  .  .  }
  8406  .  .  .  .  .  3: *syntax.ReturnStmt {
  8407  .  .  .  .  .  .  Results: typ @ parser.go:1103:9
  8408  .  .  .  .  .  }
  8409  .  .  .  .  }
  8410  .  .  .  .  Rbrace: src.Pos {}
  8411  .  .  .  }
  8412  .  .  .  Pragma: 0
  8413  .  .  }
  8414  .  .  44: *syntax.FuncDecl {
  8415  .  .  .  Attr: map[]
  8416  .  .  .  Recv: *syntax.Field {
  8417  .  .  .  .  Name: p @ parser.go:1106:7
  8418  .  .  .  .  Type: *syntax.Operation {
  8419  .  .  .  .  .  Op: *
  8420  .  .  .  .  .  X: parser @ parser.go:1106:10
  8421  .  .  .  .  .  Y: nil
  8422  .  .  .  .  }
  8423  .  .  .  }
  8424  .  .  .  Name: dotname @ parser.go:1106:18
  8425  .  .  .  Type: *syntax.FuncType {
  8426  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  8427  .  .  .  .  .  0: *syntax.Field {
  8428  .  .  .  .  .  .  Name: name @ parser.go:1106:26
  8429  .  .  .  .  .  .  Type: *syntax.Operation {
  8430  .  .  .  .  .  .  .  Op: *
  8431  .  .  .  .  .  .  .  X: Name @ parser.go:1106:32
  8432  .  .  .  .  .  .  .  Y: nil
  8433  .  .  .  .  .  .  }
  8434  .  .  .  .  .  }
  8435  .  .  .  .  }
  8436  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  8437  .  .  .  .  .  0: *syntax.Field {
  8438  .  .  .  .  .  .  Name: nil
  8439  .  .  .  .  .  .  Type: Expr @ parser.go:1106:38
  8440  .  .  .  .  .  }
  8441  .  .  .  .  }
  8442  .  .  .  }
  8443  .  .  .  Body: *syntax.BlockStmt {
  8444  .  .  .  .  List: []syntax.Stmt (3 entries) {
  8445  .  .  .  .  .  0: *syntax.IfStmt {
  8446  .  .  .  .  .  .  Init: nil
  8447  .  .  .  .  .  .  Cond: trace @ parser.go:1107:5
  8448  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  8449  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  8450  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  8451  .  .  .  .  .  .  .  .  .  Tok: defer
  8452  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  8453  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  8454  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8455  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1108:9
  8456  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1108:11
  8457  .  .  .  .  .  .  .  .  .  .  .  }
  8458  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8459  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  8460  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"dotname\""
  8461  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  8462  .  .  .  .  .  .  .  .  .  .  .  .  }
  8463  .  .  .  .  .  .  .  .  .  .  .  }
  8464  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8465  .  .  .  .  .  .  .  .  .  .  }
  8466  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8467  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8468  .  .  .  .  .  .  .  .  .  }
  8469  .  .  .  .  .  .  .  .  }
  8470  .  .  .  .  .  .  .  }
  8471  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  8472  .  .  .  .  .  .  }
  8473  .  .  .  .  .  .  Else: nil
  8474  .  .  .  .  .  }
  8475  .  .  .  .  .  1: *syntax.IfStmt {
  8476  .  .  .  .  .  .  Init: nil
  8477  .  .  .  .  .  .  Cond: *syntax.Operation {
  8478  .  .  .  .  .  .  .  Op: ==
  8479  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  8480  .  .  .  .  .  .  .  .  X: p @ parser.go:1111:5
  8481  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1111:7
  8482  .  .  .  .  .  .  .  }
  8483  .  .  .  .  .  .  .  Y: _Dot @ parser.go:1111:14
  8484  .  .  .  .  .  .  }
  8485  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  8486  .  .  .  .  .  .  .  List: []syntax.Stmt (6 entries) {
  8487  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  8488  .  .  .  .  .  .  .  .  .  Op: :
  8489  .  .  .  .  .  .  .  .  .  Lhs: s @ parser.go:1112:3
  8490  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8491  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1112:8
  8492  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8493  .  .  .  .  .  .  .  .  .  .  .  0: SelectorExpr @ parser.go:1112:12
  8494  .  .  .  .  .  .  .  .  .  .  }
  8495  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8496  .  .  .  .  .  .  .  .  .  }
  8497  .  .  .  .  .  .  .  .  }
  8498  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  8499  .  .  .  .  .  .  .  .  .  Op: <op-0>
  8500  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8501  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1113:3
  8502  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1113:5
  8503  .  .  .  .  .  .  .  .  .  }
  8504  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8505  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8506  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1113:11
  8507  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1113:13
  8508  .  .  .  .  .  .  .  .  .  .  }
  8509  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8510  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8511  .  .  .  .  .  .  .  .  .  }
  8512  .  .  .  .  .  .  .  .  }
  8513  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  8514  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8515  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8516  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1114:3
  8517  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1114:5
  8518  .  .  .  .  .  .  .  .  .  .  }
  8519  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8520  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8521  .  .  .  .  .  .  .  .  .  }
  8522  .  .  .  .  .  .  .  .  }
  8523  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  8524  .  .  .  .  .  .  .  .  .  Op: <op-0>
  8525  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8526  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1115:3
  8527  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:1115:5
  8528  .  .  .  .  .  .  .  .  .  }
  8529  .  .  .  .  .  .  .  .  .  Rhs: name @ parser.go:1115:9
  8530  .  .  .  .  .  .  .  .  }
  8531  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  8532  .  .  .  .  .  .  .  .  .  Op: <op-0>
  8533  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8534  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1116:3
  8535  .  .  .  .  .  .  .  .  .  .  Sel: Sel @ parser.go:1116:5
  8536  .  .  .  .  .  .  .  .  .  }
  8537  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8538  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8539  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1116:11
  8540  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:1116:13
  8541  .  .  .  .  .  .  .  .  .  .  }
  8542  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8543  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8544  .  .  .  .  .  .  .  .  .  }
  8545  .  .  .  .  .  .  .  .  }
  8546  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
  8547  .  .  .  .  .  .  .  .  .  Results: s @ parser.go:1117:10
  8548  .  .  .  .  .  .  .  .  }
  8549  .  .  .  .  .  .  .  }
  8550  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  8551  .  .  .  .  .  .  }
  8552  .  .  .  .  .  .  Else: nil
  8553  .  .  .  .  .  }
  8554  .  .  .  .  .  2: *syntax.ReturnStmt {
  8555  .  .  .  .  .  .  Results: name @ parser.go:1119:9
  8556  .  .  .  .  .  }
  8557  .  .  .  .  }
  8558  .  .  .  .  Rbrace: src.Pos {}
  8559  .  .  .  }
  8560  .  .  .  Pragma: 0
  8561  .  .  }
  8562  .  .  45: *syntax.FuncDecl {
  8563  .  .  .  Attr: map[]
  8564  .  .  .  Recv: *syntax.Field {
  8565  .  .  .  .  Name: p @ parser.go:1123:7
  8566  .  .  .  .  Type: *syntax.Operation {
  8567  .  .  .  .  .  Op: *
  8568  .  .  .  .  .  X: parser @ parser.go:1123:10
  8569  .  .  .  .  .  Y: nil
  8570  .  .  .  .  }
  8571  .  .  .  }
  8572  .  .  .  Name: structType @ parser.go:1123:18
  8573  .  .  .  Type: *syntax.FuncType {
  8574  .  .  .  .  ParamList: nil
  8575  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  8576  .  .  .  .  .  0: *syntax.Field {
  8577  .  .  .  .  .  .  Name: nil
  8578  .  .  .  .  .  .  Type: *syntax.Operation {
  8579  .  .  .  .  .  .  .  Op: *
  8580  .  .  .  .  .  .  .  X: StructType @ parser.go:1123:32
  8581  .  .  .  .  .  .  .  Y: nil
  8582  .  .  .  .  .  .  }
  8583  .  .  .  .  .  }
  8584  .  .  .  .  }
  8585  .  .  .  }
  8586  .  .  .  Body: *syntax.BlockStmt {
  8587  .  .  .  .  List: []syntax.Stmt (8 entries) {
  8588  .  .  .  .  .  0: *syntax.IfStmt {
  8589  .  .  .  .  .  .  Init: nil
  8590  .  .  .  .  .  .  Cond: trace @ parser.go:1124:5
  8591  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  8592  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  8593  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  8594  .  .  .  .  .  .  .  .  .  Tok: defer
  8595  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  8596  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  8597  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8598  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1125:9
  8599  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1125:11
  8600  .  .  .  .  .  .  .  .  .  .  .  }
  8601  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8602  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  8603  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"structType\""
  8604  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  8605  .  .  .  .  .  .  .  .  .  .  .  .  }
  8606  .  .  .  .  .  .  .  .  .  .  .  }
  8607  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8608  .  .  .  .  .  .  .  .  .  .  }
  8609  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8610  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8611  .  .  .  .  .  .  .  .  .  }
  8612  .  .  .  .  .  .  .  .  }
  8613  .  .  .  .  .  .  .  }
  8614  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  8615  .  .  .  .  .  .  }
  8616  .  .  .  .  .  .  Else: nil
  8617  .  .  .  .  .  }
  8618  .  .  .  .  .  1: *syntax.AssignStmt {
  8619  .  .  .  .  .  .  Op: :
  8620  .  .  .  .  .  .  Lhs: typ @ parser.go:1128:2
  8621  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8622  .  .  .  .  .  .  .  Fun: new @ parser.go:1128:9
  8623  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8624  .  .  .  .  .  .  .  .  0: StructType @ parser.go:1128:13
  8625  .  .  .  .  .  .  .  }
  8626  .  .  .  .  .  .  .  HasDots: false
  8627  .  .  .  .  .  .  }
  8628  .  .  .  .  .  }
  8629  .  .  .  .  .  2: *syntax.AssignStmt {
  8630  .  .  .  .  .  .  Op: <op-0>
  8631  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8632  .  .  .  .  .  .  .  X: typ @ parser.go:1129:2
  8633  .  .  .  .  .  .  .  Sel: pos @ parser.go:1129:6
  8634  .  .  .  .  .  .  }
  8635  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8636  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8637  .  .  .  .  .  .  .  .  X: p @ parser.go:1129:12
  8638  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1129:14
  8639  .  .  .  .  .  .  .  }
  8640  .  .  .  .  .  .  .  ArgList: nil
  8641  .  .  .  .  .  .  .  HasDots: false
  8642  .  .  .  .  .  .  }
  8643  .  .  .  .  .  }
  8644  .  .  .  .  .  3: *syntax.ExprStmt {
  8645  .  .  .  .  .  .  X: *syntax.CallExpr {
  8646  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8647  .  .  .  .  .  .  .  .  X: p @ parser.go:1131:2
  8648  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1131:4
  8649  .  .  .  .  .  .  .  }
  8650  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8651  .  .  .  .  .  .  .  .  0: _Struct @ parser.go:1131:9
  8652  .  .  .  .  .  .  .  }
  8653  .  .  .  .  .  .  .  HasDots: false
  8654  .  .  .  .  .  .  }
  8655  .  .  .  .  .  }
  8656  .  .  .  .  .  4: *syntax.ExprStmt {
  8657  .  .  .  .  .  .  X: *syntax.CallExpr {
  8658  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8659  .  .  .  .  .  .  .  .  X: p @ parser.go:1132:2
  8660  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1132:4
  8661  .  .  .  .  .  .  .  }
  8662  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8663  .  .  .  .  .  .  .  .  0: _Lbrace @ parser.go:1132:9
  8664  .  .  .  .  .  .  .  }
  8665  .  .  .  .  .  .  .  HasDots: false
  8666  .  .  .  .  .  .  }
  8667  .  .  .  .  .  }
  8668  .  .  .  .  .  5: *syntax.ForStmt {
  8669  .  .  .  .  .  .  Init: nil
  8670  .  .  .  .  .  .  Cond: *syntax.Operation {
  8671  .  .  .  .  .  .  .  Op: &&
  8672  .  .  .  .  .  .  .  X: *syntax.Operation {
  8673  .  .  .  .  .  .  .  .  Op: !=
  8674  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  8675  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1133:6
  8676  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1133:8
  8677  .  .  .  .  .  .  .  .  }
  8678  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:1133:15
  8679  .  .  .  .  .  .  .  }
  8680  .  .  .  .  .  .  .  Y: *syntax.Operation {
  8681  .  .  .  .  .  .  .  .  Op: !=
  8682  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  8683  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1133:23
  8684  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1133:25
  8685  .  .  .  .  .  .  .  .  }
  8686  .  .  .  .  .  .  .  .  Y: _Rbrace @ parser.go:1133:32
  8687  .  .  .  .  .  .  .  }
  8688  .  .  .  .  .  .  }
  8689  .  .  .  .  .  .  Post: nil
  8690  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  8691  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  8692  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  8693  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8694  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8695  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1134:3
  8696  .  .  .  .  .  .  .  .  .  .  .  Sel: fieldDecl @ parser.go:1134:5
  8697  .  .  .  .  .  .  .  .  .  .  }
  8698  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8699  .  .  .  .  .  .  .  .  .  .  .  0: typ @ parser.go:1134:15
  8700  .  .  .  .  .  .  .  .  .  .  }
  8701  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8702  .  .  .  .  .  .  .  .  .  }
  8703  .  .  .  .  .  .  .  .  }
  8704  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  8705  .  .  .  .  .  .  .  .  .  Init: nil
  8706  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  8707  .  .  .  .  .  .  .  .  .  .  Op: !
  8708  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8709  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8710  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1135:7
  8711  .  .  .  .  .  .  .  .  .  .  .  .  Sel: osemi @ parser.go:1135:9
  8712  .  .  .  .  .  .  .  .  .  .  .  }
  8713  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8714  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrace @ parser.go:1135:15
  8715  .  .  .  .  .  .  .  .  .  .  .  }
  8716  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8717  .  .  .  .  .  .  .  .  .  .  }
  8718  .  .  .  .  .  .  .  .  .  .  Y: nil
  8719  .  .  .  .  .  .  .  .  .  }
  8720  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  8721  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  8722  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  8723  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  8724  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
  8725  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 8668)
  8726  .  .  .  .  .  .  .  .  .  .  .  }
  8727  .  .  .  .  .  .  .  .  .  .  }
  8728  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  8729  .  .  .  .  .  .  .  .  .  }
  8730  .  .  .  .  .  .  .  .  .  Else: nil
  8731  .  .  .  .  .  .  .  .  }
  8732  .  .  .  .  .  .  .  }
  8733  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  8734  .  .  .  .  .  .  }
  8735  .  .  .  .  .  }
  8736  .  .  .  .  .  6: *syntax.ExprStmt {
  8737  .  .  .  .  .  .  X: *syntax.CallExpr {
  8738  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8739  .  .  .  .  .  .  .  .  X: p @ parser.go:1139:2
  8740  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1139:4
  8741  .  .  .  .  .  .  .  }
  8742  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8743  .  .  .  .  .  .  .  .  0: _Rbrace @ parser.go:1139:9
  8744  .  .  .  .  .  .  .  }
  8745  .  .  .  .  .  .  .  HasDots: false
  8746  .  .  .  .  .  .  }
  8747  .  .  .  .  .  }
  8748  .  .  .  .  .  7: *syntax.ReturnStmt {
  8749  .  .  .  .  .  .  Results: typ @ parser.go:1141:9
  8750  .  .  .  .  .  }
  8751  .  .  .  .  }
  8752  .  .  .  .  Rbrace: src.Pos {}
  8753  .  .  .  }
  8754  .  .  .  Pragma: 0
  8755  .  .  }
  8756  .  .  46: *syntax.FuncDecl {
  8757  .  .  .  Attr: map[]
  8758  .  .  .  Recv: *syntax.Field {
  8759  .  .  .  .  Name: p @ parser.go:1145:7
  8760  .  .  .  .  Type: *syntax.Operation {
  8761  .  .  .  .  .  Op: *
  8762  .  .  .  .  .  X: parser @ parser.go:1145:10
  8763  .  .  .  .  .  Y: nil
  8764  .  .  .  .  }
  8765  .  .  .  }
  8766  .  .  .  Name: interfaceType @ parser.go:1145:18
  8767  .  .  .  Type: *syntax.FuncType {
  8768  .  .  .  .  ParamList: nil
  8769  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  8770  .  .  .  .  .  0: *syntax.Field {
  8771  .  .  .  .  .  .  Name: nil
  8772  .  .  .  .  .  .  Type: *syntax.Operation {
  8773  .  .  .  .  .  .  .  Op: *
  8774  .  .  .  .  .  .  .  X: InterfaceType @ parser.go:1145:35
  8775  .  .  .  .  .  .  .  Y: nil
  8776  .  .  .  .  .  .  }
  8777  .  .  .  .  .  }
  8778  .  .  .  .  }
  8779  .  .  .  }
  8780  .  .  .  Body: *syntax.BlockStmt {
  8781  .  .  .  .  List: []syntax.Stmt (8 entries) {
  8782  .  .  .  .  .  0: *syntax.IfStmt {
  8783  .  .  .  .  .  .  Init: nil
  8784  .  .  .  .  .  .  Cond: trace @ parser.go:1146:5
  8785  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  8786  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  8787  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  8788  .  .  .  .  .  .  .  .  .  Tok: defer
  8789  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  8790  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  8791  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8792  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1147:9
  8793  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1147:11
  8794  .  .  .  .  .  .  .  .  .  .  .  }
  8795  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8796  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  8797  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"interfaceType\""
  8798  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  8799  .  .  .  .  .  .  .  .  .  .  .  .  }
  8800  .  .  .  .  .  .  .  .  .  .  .  }
  8801  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8802  .  .  .  .  .  .  .  .  .  .  }
  8803  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8804  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8805  .  .  .  .  .  .  .  .  .  }
  8806  .  .  .  .  .  .  .  .  }
  8807  .  .  .  .  .  .  .  }
  8808  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  8809  .  .  .  .  .  .  }
  8810  .  .  .  .  .  .  Else: nil
  8811  .  .  .  .  .  }
  8812  .  .  .  .  .  1: *syntax.AssignStmt {
  8813  .  .  .  .  .  .  Op: :
  8814  .  .  .  .  .  .  Lhs: typ @ parser.go:1150:2
  8815  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8816  .  .  .  .  .  .  .  Fun: new @ parser.go:1150:9
  8817  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8818  .  .  .  .  .  .  .  .  0: InterfaceType @ parser.go:1150:13
  8819  .  .  .  .  .  .  .  }
  8820  .  .  .  .  .  .  .  HasDots: false
  8821  .  .  .  .  .  .  }
  8822  .  .  .  .  .  }
  8823  .  .  .  .  .  2: *syntax.AssignStmt {
  8824  .  .  .  .  .  .  Op: <op-0>
  8825  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8826  .  .  .  .  .  .  .  X: typ @ parser.go:1151:2
  8827  .  .  .  .  .  .  .  Sel: pos @ parser.go:1151:6
  8828  .  .  .  .  .  .  }
  8829  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8830  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8831  .  .  .  .  .  .  .  .  X: p @ parser.go:1151:12
  8832  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1151:14
  8833  .  .  .  .  .  .  .  }
  8834  .  .  .  .  .  .  .  ArgList: nil
  8835  .  .  .  .  .  .  .  HasDots: false
  8836  .  .  .  .  .  .  }
  8837  .  .  .  .  .  }
  8838  .  .  .  .  .  3: *syntax.ExprStmt {
  8839  .  .  .  .  .  .  X: *syntax.CallExpr {
  8840  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8841  .  .  .  .  .  .  .  .  X: p @ parser.go:1153:2
  8842  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1153:4
  8843  .  .  .  .  .  .  .  }
  8844  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8845  .  .  .  .  .  .  .  .  0: _Interface @ parser.go:1153:9
  8846  .  .  .  .  .  .  .  }
  8847  .  .  .  .  .  .  .  HasDots: false
  8848  .  .  .  .  .  .  }
  8849  .  .  .  .  .  }
  8850  .  .  .  .  .  4: *syntax.ExprStmt {
  8851  .  .  .  .  .  .  X: *syntax.CallExpr {
  8852  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8853  .  .  .  .  .  .  .  .  X: p @ parser.go:1154:2
  8854  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1154:4
  8855  .  .  .  .  .  .  .  }
  8856  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8857  .  .  .  .  .  .  .  .  0: _Lbrace @ parser.go:1154:9
  8858  .  .  .  .  .  .  .  }
  8859  .  .  .  .  .  .  .  HasDots: false
  8860  .  .  .  .  .  .  }
  8861  .  .  .  .  .  }
  8862  .  .  .  .  .  5: *syntax.ForStmt {
  8863  .  .  .  .  .  .  Init: nil
  8864  .  .  .  .  .  .  Cond: *syntax.Operation {
  8865  .  .  .  .  .  .  .  Op: &&
  8866  .  .  .  .  .  .  .  X: *syntax.Operation {
  8867  .  .  .  .  .  .  .  .  Op: !=
  8868  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  8869  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1155:6
  8870  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1155:8
  8871  .  .  .  .  .  .  .  .  }
  8872  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:1155:15
  8873  .  .  .  .  .  .  .  }
  8874  .  .  .  .  .  .  .  Y: *syntax.Operation {
  8875  .  .  .  .  .  .  .  .  Op: !=
  8876  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  8877  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1155:23
  8878  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1155:25
  8879  .  .  .  .  .  .  .  .  }
  8880  .  .  .  .  .  .  .  .  Y: _Rbrace @ parser.go:1155:32
  8881  .  .  .  .  .  .  .  }
  8882  .  .  .  .  .  .  }
  8883  .  .  .  .  .  .  Post: nil
  8884  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  8885  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  8886  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
  8887  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
  8888  .  .  .  .  .  .  .  .  .  .  Op: :
  8889  .  .  .  .  .  .  .  .  .  .  Lhs: m @ parser.go:1156:6
  8890  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8891  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8892  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1156:11
  8893  .  .  .  .  .  .  .  .  .  .  .  .  Sel: methodDecl @ parser.go:1156:13
  8894  .  .  .  .  .  .  .  .  .  .  .  }
  8895  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  8896  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8897  .  .  .  .  .  .  .  .  .  .  }
  8898  .  .  .  .  .  .  .  .  .  }
  8899  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  8900  .  .  .  .  .  .  .  .  .  .  Op: !=
  8901  .  .  .  .  .  .  .  .  .  .  X: m @ parser.go:1156:27
  8902  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1156:32
  8903  .  .  .  .  .  .  .  .  .  }
  8904  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  8905  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  8906  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  8907  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  8908  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  8909  .  .  .  .  .  .  .  .  .  .  .  .  .  X: typ @ parser.go:1157:4
  8910  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: MethodList @ parser.go:1157:8
  8911  .  .  .  .  .  .  .  .  .  .  .  .  }
  8912  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  8913  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:1157:21
  8914  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  8915  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  8916  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: typ @ parser.go:1157:28
  8917  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: MethodList @ parser.go:1157:32
  8918  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8919  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: m @ parser.go:1157:44
  8920  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  8921  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8922  .  .  .  .  .  .  .  .  .  .  .  .  }
  8923  .  .  .  .  .  .  .  .  .  .  .  }
  8924  .  .  .  .  .  .  .  .  .  .  }
  8925  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  8926  .  .  .  .  .  .  .  .  .  }
  8927  .  .  .  .  .  .  .  .  .  Else: nil
  8928  .  .  .  .  .  .  .  .  }
  8929  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  8930  .  .  .  .  .  .  .  .  .  Init: nil
  8931  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  8932  .  .  .  .  .  .  .  .  .  .  Op: !
  8933  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  8934  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8935  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1159:7
  8936  .  .  .  .  .  .  .  .  .  .  .  .  Sel: osemi @ parser.go:1159:9
  8937  .  .  .  .  .  .  .  .  .  .  .  }
  8938  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8939  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rbrace @ parser.go:1159:15
  8940  .  .  .  .  .  .  .  .  .  .  .  }
  8941  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  8942  .  .  .  .  .  .  .  .  .  .  }
  8943  .  .  .  .  .  .  .  .  .  .  Y: nil
  8944  .  .  .  .  .  .  .  .  .  }
  8945  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  8946  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  8947  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
  8948  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
  8949  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
  8950  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 8862)
  8951  .  .  .  .  .  .  .  .  .  .  .  }
  8952  .  .  .  .  .  .  .  .  .  .  }
  8953  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  8954  .  .  .  .  .  .  .  .  .  }
  8955  .  .  .  .  .  .  .  .  .  Else: nil
  8956  .  .  .  .  .  .  .  .  }
  8957  .  .  .  .  .  .  .  }
  8958  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  8959  .  .  .  .  .  .  }
  8960  .  .  .  .  .  }
  8961  .  .  .  .  .  6: *syntax.ExprStmt {
  8962  .  .  .  .  .  .  X: *syntax.CallExpr {
  8963  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  8964  .  .  .  .  .  .  .  .  X: p @ parser.go:1163:2
  8965  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1163:4
  8966  .  .  .  .  .  .  .  }
  8967  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  8968  .  .  .  .  .  .  .  .  0: _Rbrace @ parser.go:1163:9
  8969  .  .  .  .  .  .  .  }
  8970  .  .  .  .  .  .  .  HasDots: false
  8971  .  .  .  .  .  .  }
  8972  .  .  .  .  .  }
  8973  .  .  .  .  .  7: *syntax.ReturnStmt {
  8974  .  .  .  .  .  .  Results: typ @ parser.go:1165:9
  8975  .  .  .  .  .  }
  8976  .  .  .  .  }
  8977  .  .  .  .  Rbrace: src.Pos {}
  8978  .  .  .  }
  8979  .  .  .  Pragma: 0
  8980  .  .  }
  8981  .  .  47: *syntax.FuncDecl {
  8982  .  .  .  Attr: map[]
  8983  .  .  .  Recv: *syntax.Field {
  8984  .  .  .  .  Name: p @ parser.go:1169:7
  8985  .  .  .  .  Type: *syntax.Operation {
  8986  .  .  .  .  .  Op: *
  8987  .  .  .  .  .  X: parser @ parser.go:1169:10
  8988  .  .  .  .  .  Y: nil
  8989  .  .  .  .  }
  8990  .  .  .  }
  8991  .  .  .  Name: funcBody @ parser.go:1169:18
  8992  .  .  .  Type: *syntax.FuncType {
  8993  .  .  .  .  ParamList: nil
  8994  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  8995  .  .  .  .  .  0: *syntax.Field {
  8996  .  .  .  .  .  .  Name: nil
  8997  .  .  .  .  .  .  Type: *syntax.SliceType {
  8998  .  .  .  .  .  .  .  Elem: Stmt @ parser.go:1169:31
  8999  .  .  .  .  .  .  }
  9000  .  .  .  .  .  }
  9001  .  .  .  .  }
  9002  .  .  .  }
  9003  .  .  .  Body: *syntax.BlockStmt {
  9004  .  .  .  .  List: []syntax.Stmt (6 entries) {
  9005  .  .  .  .  .  0: *syntax.IfStmt {
  9006  .  .  .  .  .  .  Init: nil
  9007  .  .  .  .  .  .  Cond: trace @ parser.go:1170:5
  9008  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  9009  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  9010  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  9011  .  .  .  .  .  .  .  .  .  Tok: defer
  9012  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  9013  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  9014  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9015  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1171:9
  9016  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1171:11
  9017  .  .  .  .  .  .  .  .  .  .  .  }
  9018  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9019  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9020  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"funcBody\""
  9021  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9022  .  .  .  .  .  .  .  .  .  .  .  .  }
  9023  .  .  .  .  .  .  .  .  .  .  .  }
  9024  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9025  .  .  .  .  .  .  .  .  .  .  }
  9026  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9027  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9028  .  .  .  .  .  .  .  .  .  }
  9029  .  .  .  .  .  .  .  .  }
  9030  .  .  .  .  .  .  .  }
  9031  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9032  .  .  .  .  .  .  }
  9033  .  .  .  .  .  .  Else: nil
  9034  .  .  .  .  .  }
  9035  .  .  .  .  .  1: *syntax.AssignStmt {
  9036  .  .  .  .  .  .  Op: +
  9037  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9038  .  .  .  .  .  .  .  X: p @ parser.go:1174:2
  9039  .  .  .  .  .  .  .  Sel: fnest @ parser.go:1174:4
  9040  .  .  .  .  .  .  }
  9041  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  9042  .  .  .  .  .  }
  9043  .  .  .  .  .  2: *syntax.AssignStmt {
  9044  .  .  .  .  .  .  Op: :
  9045  .  .  .  .  .  .  Lhs: body @ parser.go:1175:2
  9046  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9047  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9048  .  .  .  .  .  .  .  .  X: p @ parser.go:1175:10
  9049  .  .  .  .  .  .  .  .  Sel: stmtList @ parser.go:1175:12
  9050  .  .  .  .  .  .  .  }
  9051  .  .  .  .  .  .  .  ArgList: nil
  9052  .  .  .  .  .  .  .  HasDots: false
  9053  .  .  .  .  .  .  }
  9054  .  .  .  .  .  }
  9055  .  .  .  .  .  3: *syntax.AssignStmt {
  9056  .  .  .  .  .  .  Op: -
  9057  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9058  .  .  .  .  .  .  .  X: p @ parser.go:1176:2
  9059  .  .  .  .  .  .  .  Sel: fnest @ parser.go:1176:4
  9060  .  .  .  .  .  .  }
  9061  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  9062  .  .  .  .  .  }
  9063  .  .  .  .  .  4: *syntax.IfStmt {
  9064  .  .  .  .  .  .  Init: nil
  9065  .  .  .  .  .  .  Cond: *syntax.Operation {
  9066  .  .  .  .  .  .  .  Op: ==
  9067  .  .  .  .  .  .  .  X: body @ parser.go:1178:5
  9068  .  .  .  .  .  .  .  Y: nil @ parser.go:1178:13
  9069  .  .  .  .  .  .  }
  9070  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  9071  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  9072  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9073  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9074  .  .  .  .  .  .  .  .  .  Lhs: body @ parser.go:1179:3
  9075  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CompositeLit {
  9076  .  .  .  .  .  .  .  .  .  .  Type: *syntax.SliceType {
  9077  .  .  .  .  .  .  .  .  .  .  .  Elem: Stmt @ parser.go:1179:12
  9078  .  .  .  .  .  .  .  .  .  .  }
  9079  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (1 entries) {
  9080  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
  9081  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1179:17
  9082  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9083  .  .  .  .  .  .  .  .  .  .  .  .  .  0: EmptyStmt @ parser.go:1179:21
  9084  .  .  .  .  .  .  .  .  .  .  .  .  }
  9085  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9086  .  .  .  .  .  .  .  .  .  .  .  }
  9087  .  .  .  .  .  .  .  .  .  .  }
  9088  .  .  .  .  .  .  .  .  .  .  NKeys: 0
  9089  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9090  .  .  .  .  .  .  .  .  .  }
  9091  .  .  .  .  .  .  .  .  }
  9092  .  .  .  .  .  .  .  }
  9093  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9094  .  .  .  .  .  .  }
  9095  .  .  .  .  .  .  Else: nil
  9096  .  .  .  .  .  }
  9097  .  .  .  .  .  5: *syntax.ReturnStmt {
  9098  .  .  .  .  .  .  Results: body @ parser.go:1181:9
  9099  .  .  .  .  .  }
  9100  .  .  .  .  }
  9101  .  .  .  .  Rbrace: src.Pos {}
  9102  .  .  .  }
  9103  .  .  .  Pragma: 0
  9104  .  .  }
  9105  .  .  48: *syntax.FuncDecl {
  9106  .  .  .  Attr: map[]
  9107  .  .  .  Recv: *syntax.Field {
  9108  .  .  .  .  Name: p @ parser.go:1185:7
  9109  .  .  .  .  Type: *syntax.Operation {
  9110  .  .  .  .  .  Op: *
  9111  .  .  .  .  .  X: parser @ parser.go:1185:10
  9112  .  .  .  .  .  Y: nil
  9113  .  .  .  .  }
  9114  .  .  .  }
  9115  .  .  .  Name: funcResult @ parser.go:1185:18
  9116  .  .  .  Type: *syntax.FuncType {
  9117  .  .  .  .  ParamList: nil
  9118  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
  9119  .  .  .  .  .  0: *syntax.Field {
  9120  .  .  .  .  .  .  Name: nil
  9121  .  .  .  .  .  .  Type: *syntax.SliceType {
  9122  .  .  .  .  .  .  .  Elem: *syntax.Operation {
  9123  .  .  .  .  .  .  .  .  Op: *
  9124  .  .  .  .  .  .  .  .  X: Field @ parser.go:1185:34
  9125  .  .  .  .  .  .  .  .  Y: nil
  9126  .  .  .  .  .  .  .  }
  9127  .  .  .  .  .  .  }
  9128  .  .  .  .  .  }
  9129  .  .  .  .  }
  9130  .  .  .  }
  9131  .  .  .  Body: *syntax.BlockStmt {
  9132  .  .  .  .  List: []syntax.Stmt (5 entries) {
  9133  .  .  .  .  .  0: *syntax.IfStmt {
  9134  .  .  .  .  .  .  Init: nil
  9135  .  .  .  .  .  .  Cond: trace @ parser.go:1186:5
  9136  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  9137  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  9138  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  9139  .  .  .  .  .  .  .  .  .  Tok: defer
  9140  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  9141  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  9142  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9143  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1187:9
  9144  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1187:11
  9145  .  .  .  .  .  .  .  .  .  .  .  }
  9146  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9147  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9148  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"funcResult\""
  9149  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9150  .  .  .  .  .  .  .  .  .  .  .  .  }
  9151  .  .  .  .  .  .  .  .  .  .  .  }
  9152  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9153  .  .  .  .  .  .  .  .  .  .  }
  9154  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9155  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9156  .  .  .  .  .  .  .  .  .  }
  9157  .  .  .  .  .  .  .  .  }
  9158  .  .  .  .  .  .  .  }
  9159  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9160  .  .  .  .  .  .  }
  9161  .  .  .  .  .  .  Else: nil
  9162  .  .  .  .  .  }
  9163  .  .  .  .  .  1: *syntax.IfStmt {
  9164  .  .  .  .  .  .  Init: nil
  9165  .  .  .  .  .  .  Cond: *syntax.Operation {
  9166  .  .  .  .  .  .  .  Op: ==
  9167  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9168  .  .  .  .  .  .  .  .  X: p @ parser.go:1190:5
  9169  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1190:7
  9170  .  .  .  .  .  .  .  }
  9171  .  .  .  .  .  .  .  Y: _Lparen @ parser.go:1190:14
  9172  .  .  .  .  .  .  }
  9173  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  9174  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  9175  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
  9176  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
  9177  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9178  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1191:10
  9179  .  .  .  .  .  .  .  .  .  .  .  Sel: paramList @ parser.go:1191:12
  9180  .  .  .  .  .  .  .  .  .  .  }
  9181  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9182  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9183  .  .  .  .  .  .  .  .  .  }
  9184  .  .  .  .  .  .  .  .  }
  9185  .  .  .  .  .  .  .  }
  9186  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9187  .  .  .  .  .  .  }
  9188  .  .  .  .  .  .  Else: nil
  9189  .  .  .  .  .  }
  9190  .  .  .  .  .  2: *syntax.AssignStmt {
  9191  .  .  .  .  .  .  Op: :
  9192  .  .  .  .  .  .  Lhs: pos @ parser.go:1194:2
  9193  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9194  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9195  .  .  .  .  .  .  .  .  X: p @ parser.go:1194:9
  9196  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1194:11
  9197  .  .  .  .  .  .  .  }
  9198  .  .  .  .  .  .  .  ArgList: nil
  9199  .  .  .  .  .  .  .  HasDots: false
  9200  .  .  .  .  .  .  }
  9201  .  .  .  .  .  }
  9202  .  .  .  .  .  3: *syntax.IfStmt {
  9203  .  .  .  .  .  .  Init: *syntax.AssignStmt {
  9204  .  .  .  .  .  .  .  Op: :
  9205  .  .  .  .  .  .  .  Lhs: typ @ parser.go:1195:5
  9206  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9207  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9208  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1195:12
  9209  .  .  .  .  .  .  .  .  .  Sel: typeOrNil @ parser.go:1195:14
  9210  .  .  .  .  .  .  .  .  }
  9211  .  .  .  .  .  .  .  .  ArgList: nil
  9212  .  .  .  .  .  .  .  .  HasDots: false
  9213  .  .  .  .  .  .  .  }
  9214  .  .  .  .  .  .  }
  9215  .  .  .  .  .  .  Cond: *syntax.Operation {
  9216  .  .  .  .  .  .  .  Op: !=
  9217  .  .  .  .  .  .  .  X: typ @ parser.go:1195:27
  9218  .  .  .  .  .  .  .  Y: nil @ parser.go:1195:34
  9219  .  .  .  .  .  .  }
  9220  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  9221  .  .  .  .  .  .  .  List: []syntax.Stmt (4 entries) {
  9222  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9223  .  .  .  .  .  .  .  .  .  Op: :
  9224  .  .  .  .  .  .  .  .  .  Lhs: f @ parser.go:1196:3
  9225  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9226  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1196:8
  9227  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9228  .  .  .  .  .  .  .  .  .  .  .  0: Field @ parser.go:1196:12
  9229  .  .  .  .  .  .  .  .  .  .  }
  9230  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9231  .  .  .  .  .  .  .  .  .  }
  9232  .  .  .  .  .  .  .  .  }
  9233  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  9234  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9235  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9236  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1197:3
  9237  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1197:5
  9238  .  .  .  .  .  .  .  .  .  }
  9239  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:1197:11
  9240  .  .  .  .  .  .  .  .  }
  9241  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  9242  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9243  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9244  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1198:3
  9245  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1198:5
  9246  .  .  .  .  .  .  .  .  .  }
  9247  .  .  .  .  .  .  .  .  .  Rhs: typ @ parser.go:1198:12
  9248  .  .  .  .  .  .  .  .  }
  9249  .  .  .  .  .  .  .  .  3: *syntax.ReturnStmt {
  9250  .  .  .  .  .  .  .  .  .  Results: *syntax.CompositeLit {
  9251  .  .  .  .  .  .  .  .  .  .  Type: *syntax.SliceType {
  9252  .  .  .  .  .  .  .  .  .  .  .  Elem: *syntax.Operation {
  9253  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
  9254  .  .  .  .  .  .  .  .  .  .  .  .  X: Field @ parser.go:1199:13
  9255  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
  9256  .  .  .  .  .  .  .  .  .  .  .  }
  9257  .  .  .  .  .  .  .  .  .  .  }
  9258  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (1 entries) {
  9259  .  .  .  .  .  .  .  .  .  .  .  0: f @ parser.go:1199:19
  9260  .  .  .  .  .  .  .  .  .  .  }
  9261  .  .  .  .  .  .  .  .  .  .  NKeys: 0
  9262  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9263  .  .  .  .  .  .  .  .  .  }
  9264  .  .  .  .  .  .  .  .  }
  9265  .  .  .  .  .  .  .  }
  9266  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9267  .  .  .  .  .  .  }
  9268  .  .  .  .  .  .  Else: nil
  9269  .  .  .  .  .  }
  9270  .  .  .  .  .  4: *syntax.ReturnStmt {
  9271  .  .  .  .  .  .  Results: nil @ parser.go:1202:9
  9272  .  .  .  .  .  }
  9273  .  .  .  .  }
  9274  .  .  .  .  Rbrace: src.Pos {}
  9275  .  .  .  }
  9276  .  .  .  Pragma: 0
  9277  .  .  }
  9278  .  .  49: *syntax.FuncDecl {
  9279  .  .  .  Attr: map[]
  9280  .  .  .  Recv: *syntax.Field {
  9281  .  .  .  .  Name: p @ parser.go:1205:7
  9282  .  .  .  .  Type: *syntax.Operation {
  9283  .  .  .  .  .  Op: *
  9284  .  .  .  .  .  X: parser @ parser.go:1205:10
  9285  .  .  .  .  .  Y: nil
  9286  .  .  .  .  }
  9287  .  .  .  }
  9288  .  .  .  Name: addField @ parser.go:1205:18
  9289  .  .  .  Type: *syntax.FuncType {
  9290  .  .  .  .  ParamList: []*syntax.Field (5 entries) {
  9291  .  .  .  .  .  0: *syntax.Field {
  9292  .  .  .  .  .  .  Name: styp @ parser.go:1205:27
  9293  .  .  .  .  .  .  Type: *syntax.Operation {
  9294  .  .  .  .  .  .  .  Op: *
  9295  .  .  .  .  .  .  .  X: StructType @ parser.go:1205:33
  9296  .  .  .  .  .  .  .  Y: nil
  9297  .  .  .  .  .  .  }
  9298  .  .  .  .  .  }
  9299  .  .  .  .  .  1: *syntax.Field {
  9300  .  .  .  .  .  .  Name: pos @ parser.go:1205:45
  9301  .  .  .  .  .  .  Type: *syntax.SelectorExpr {
  9302  .  .  .  .  .  .  .  X: src @ parser.go:1205:49
  9303  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1205:53
  9304  .  .  .  .  .  .  }
  9305  .  .  .  .  .  }
  9306  .  .  .  .  .  2: *syntax.Field {
  9307  .  .  .  .  .  .  Name: name @ parser.go:1205:58
  9308  .  .  .  .  .  .  Type: *syntax.Operation {
  9309  .  .  .  .  .  .  .  Op: *
  9310  .  .  .  .  .  .  .  X: Name @ parser.go:1205:64
  9311  .  .  .  .  .  .  .  Y: nil
  9312  .  .  .  .  .  .  }
  9313  .  .  .  .  .  }
  9314  .  .  .  .  .  3: *syntax.Field {
  9315  .  .  .  .  .  .  Name: typ @ parser.go:1205:70
  9316  .  .  .  .  .  .  Type: Expr @ parser.go:1205:74
  9317  .  .  .  .  .  }
  9318  .  .  .  .  .  4: *syntax.Field {
  9319  .  .  .  .  .  .  Name: tag @ parser.go:1205:80
  9320  .  .  .  .  .  .  Type: *syntax.Operation {
  9321  .  .  .  .  .  .  .  Op: *
  9322  .  .  .  .  .  .  .  X: BasicLit @ parser.go:1205:85
  9323  .  .  .  .  .  .  .  Y: nil
  9324  .  .  .  .  .  .  }
  9325  .  .  .  .  .  }
  9326  .  .  .  .  }
  9327  .  .  .  .  ResultList: nil
  9328  .  .  .  }
  9329  .  .  .  Body: *syntax.BlockStmt {
  9330  .  .  .  .  List: []syntax.Stmt (7 entries) {
  9331  .  .  .  .  .  0: *syntax.IfStmt {
  9332  .  .  .  .  .  .  Init: nil
  9333  .  .  .  .  .  .  Cond: *syntax.Operation {
  9334  .  .  .  .  .  .  .  Op: !=
  9335  .  .  .  .  .  .  .  X: tag @ parser.go:1206:5
  9336  .  .  .  .  .  .  .  Y: nil @ parser.go:1206:12
  9337  .  .  .  .  .  .  }
  9338  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  9339  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
  9340  .  .  .  .  .  .  .  .  0: *syntax.ForStmt {
  9341  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
  9342  .  .  .  .  .  .  .  .  .  .  Op: :
  9343  .  .  .  .  .  .  .  .  .  .  Lhs: i @ parser.go:1207:7
  9344  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
  9345  .  .  .  .  .  .  .  .  .  .  .  Op: -
  9346  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9347  .  .  .  .  .  .  .  .  .  .  .  .  Fun: len @ parser.go:1207:12
  9348  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9349  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  9350  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: styp @ parser.go:1207:16
  9351  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: FieldList @ parser.go:1207:21
  9352  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9353  .  .  .  .  .  .  .  .  .  .  .  .  }
  9354  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9355  .  .  .  .  .  .  .  .  .  .  .  }
  9356  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
  9357  .  .  .  .  .  .  .  .  .  .  .  .  Fun: len @ parser.go:1207:34
  9358  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9359  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  9360  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: styp @ parser.go:1207:38
  9361  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: TagList @ parser.go:1207:43
  9362  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9363  .  .  .  .  .  .  .  .  .  .  .  .  }
  9364  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9365  .  .  .  .  .  .  .  .  .  .  .  }
  9366  .  .  .  .  .  .  .  .  .  .  }
  9367  .  .  .  .  .  .  .  .  .  }
  9368  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  9369  .  .  .  .  .  .  .  .  .  .  Op: >
  9370  .  .  .  .  .  .  .  .  .  .  X: i @ parser.go:1207:53
  9371  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
  9372  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
  9373  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
  9374  .  .  .  .  .  .  .  .  .  .  }
  9375  .  .  .  .  .  .  .  .  .  }
  9376  .  .  .  .  .  .  .  .  .  Post: *syntax.AssignStmt {
  9377  .  .  .  .  .  .  .  .  .  .  Op: -
  9378  .  .  .  .  .  .  .  .  .  .  Lhs: i @ parser.go:1207:60
  9379  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
  9380  .  .  .  .  .  .  .  .  .  }
  9381  .  .  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  9382  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  9383  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9384  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9385  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9386  .  .  .  .  .  .  .  .  .  .  .  .  .  X: styp @ parser.go:1208:4
  9387  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: TagList @ parser.go:1208:9
  9388  .  .  .  .  .  .  .  .  .  .  .  .  }
  9389  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9390  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:1208:19
  9391  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  9392  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  9393  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: styp @ parser.go:1208:26
  9394  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: TagList @ parser.go:1208:31
  9395  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9396  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: nil @ parser.go:1208:40
  9397  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9398  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9399  .  .  .  .  .  .  .  .  .  .  .  .  }
  9400  .  .  .  .  .  .  .  .  .  .  .  }
  9401  .  .  .  .  .  .  .  .  .  .  }
  9402  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9403  .  .  .  .  .  .  .  .  .  }
  9404  .  .  .  .  .  .  .  .  }
  9405  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  9406  .  .  .  .  .  .  .  .  .  Op: <op-0>
  9407  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9408  .  .  .  .  .  .  .  .  .  .  X: styp @ parser.go:1210:3
  9409  .  .  .  .  .  .  .  .  .  .  Sel: TagList @ parser.go:1210:8
  9410  .  .  .  .  .  .  .  .  .  }
  9411  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9412  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:1210:18
  9413  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  9414  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  9415  .  .  .  .  .  .  .  .  .  .  .  .  X: styp @ parser.go:1210:25
  9416  .  .  .  .  .  .  .  .  .  .  .  .  Sel: TagList @ parser.go:1210:30
  9417  .  .  .  .  .  .  .  .  .  .  .  }
  9418  .  .  .  .  .  .  .  .  .  .  .  1: tag @ parser.go:1210:39
  9419  .  .  .  .  .  .  .  .  .  .  }
  9420  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9421  .  .  .  .  .  .  .  .  .  }
  9422  .  .  .  .  .  .  .  .  }
  9423  .  .  .  .  .  .  .  }
  9424  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9425  .  .  .  .  .  .  }
  9426  .  .  .  .  .  .  Else: nil
  9427  .  .  .  .  .  }
  9428  .  .  .  .  .  1: *syntax.AssignStmt {
  9429  .  .  .  .  .  .  Op: :
  9430  .  .  .  .  .  .  Lhs: f @ parser.go:1213:2
  9431  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9432  .  .  .  .  .  .  .  Fun: new @ parser.go:1213:7
  9433  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9434  .  .  .  .  .  .  .  .  0: Field @ parser.go:1213:11
  9435  .  .  .  .  .  .  .  }
  9436  .  .  .  .  .  .  .  HasDots: false
  9437  .  .  .  .  .  .  }
  9438  .  .  .  .  .  }
  9439  .  .  .  .  .  2: *syntax.AssignStmt {
  9440  .  .  .  .  .  .  Op: <op-0>
  9441  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9442  .  .  .  .  .  .  .  X: f @ parser.go:1214:2
  9443  .  .  .  .  .  .  .  Sel: pos @ parser.go:1214:4
  9444  .  .  .  .  .  .  }
  9445  .  .  .  .  .  .  Rhs: pos @ parser.go:1214:10
  9446  .  .  .  .  .  }
  9447  .  .  .  .  .  3: *syntax.AssignStmt {
  9448  .  .  .  .  .  .  Op: <op-0>
  9449  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9450  .  .  .  .  .  .  .  X: f @ parser.go:1215:2
  9451  .  .  .  .  .  .  .  Sel: Name @ parser.go:1215:4
  9452  .  .  .  .  .  .  }
  9453  .  .  .  .  .  .  Rhs: name @ parser.go:1215:11
  9454  .  .  .  .  .  }
  9455  .  .  .  .  .  4: *syntax.AssignStmt {
  9456  .  .  .  .  .  .  Op: <op-0>
  9457  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9458  .  .  .  .  .  .  .  X: f @ parser.go:1216:2
  9459  .  .  .  .  .  .  .  Sel: Type @ parser.go:1216:4
  9460  .  .  .  .  .  .  }
  9461  .  .  .  .  .  .  Rhs: typ @ parser.go:1216:11
  9462  .  .  .  .  .  }
  9463  .  .  .  .  .  5: *syntax.AssignStmt {
  9464  .  .  .  .  .  .  Op: <op-0>
  9465  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
  9466  .  .  .  .  .  .  .  X: styp @ parser.go:1217:2
  9467  .  .  .  .  .  .  .  Sel: FieldList @ parser.go:1217:7
  9468  .  .  .  .  .  .  }
  9469  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9470  .  .  .  .  .  .  .  Fun: append @ parser.go:1217:19
  9471  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  9472  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  9473  .  .  .  .  .  .  .  .  .  X: styp @ parser.go:1217:26
  9474  .  .  .  .  .  .  .  .  .  Sel: FieldList @ parser.go:1217:31
  9475  .  .  .  .  .  .  .  .  }
  9476  .  .  .  .  .  .  .  .  1: f @ parser.go:1217:42
  9477  .  .  .  .  .  .  .  }
  9478  .  .  .  .  .  .  .  HasDots: false
  9479  .  .  .  .  .  .  }
  9480  .  .  .  .  .  }
  9481  .  .  .  .  .  6: *syntax.IfStmt {
  9482  .  .  .  .  .  .  Init: nil
  9483  .  .  .  .  .  .  Cond: *syntax.Operation {
  9484  .  .  .  .  .  .  .  Op: &&
  9485  .  .  .  .  .  .  .  X: *syntax.Operation {
  9486  .  .  .  .  .  .  .  .  Op: &&
  9487  .  .  .  .  .  .  .  .  X: debug @ parser.go:1219:5
  9488  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  9489  .  .  .  .  .  .  .  .  .  Op: !=
  9490  .  .  .  .  .  .  .  .  .  X: tag @ parser.go:1219:14
  9491  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1219:21
  9492  .  .  .  .  .  .  .  .  }
  9493  .  .  .  .  .  .  .  }
  9494  .  .  .  .  .  .  .  Y: *syntax.Operation {
  9495  .  .  .  .  .  .  .  .  Op: !=
  9496  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9497  .  .  .  .  .  .  .  .  .  Fun: len @ parser.go:1219:28
  9498  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9499  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  9500  .  .  .  .  .  .  .  .  .  .  .  X: styp @ parser.go:1219:32
  9501  .  .  .  .  .  .  .  .  .  .  .  Sel: FieldList @ parser.go:1219:37
  9502  .  .  .  .  .  .  .  .  .  .  }
  9503  .  .  .  .  .  .  .  .  .  }
  9504  .  .  .  .  .  .  .  .  .  HasDots: false
  9505  .  .  .  .  .  .  .  .  }
  9506  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
  9507  .  .  .  .  .  .  .  .  .  Fun: len @ parser.go:1219:51
  9508  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9509  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
  9510  .  .  .  .  .  .  .  .  .  .  .  X: styp @ parser.go:1219:55
  9511  .  .  .  .  .  .  .  .  .  .  .  Sel: TagList @ parser.go:1219:60
  9512  .  .  .  .  .  .  .  .  .  .  }
  9513  .  .  .  .  .  .  .  .  .  }
  9514  .  .  .  .  .  .  .  .  .  HasDots: false
  9515  .  .  .  .  .  .  .  .  }
  9516  .  .  .  .  .  .  .  }
  9517  .  .  .  .  .  .  }
  9518  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  9519  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  9520  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  9521  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9522  .  .  .  .  .  .  .  .  .  .  Fun: panic @ parser.go:1220:3
  9523  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9524  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9525  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"inconsistent struct field list\""
  9526  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9527  .  .  .  .  .  .  .  .  .  .  .  }
  9528  .  .  .  .  .  .  .  .  .  .  }
  9529  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9530  .  .  .  .  .  .  .  .  .  }
  9531  .  .  .  .  .  .  .  .  }
  9532  .  .  .  .  .  .  .  }
  9533  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9534  .  .  .  .  .  .  }
  9535  .  .  .  .  .  .  Else: nil
  9536  .  .  .  .  .  }
  9537  .  .  .  .  }
  9538  .  .  .  .  Rbrace: src.Pos {}
  9539  .  .  .  }
  9540  .  .  .  Pragma: 0
  9541  .  .  }
  9542  .  .  50: *syntax.FuncDecl {
  9543  .  .  .  Attr: map[]
  9544  .  .  .  Recv: *syntax.Field {
  9545  .  .  .  .  Name: p @ parser.go:1227:7
  9546  .  .  .  .  Type: *syntax.Operation {
  9547  .  .  .  .  .  Op: *
  9548  .  .  .  .  .  X: parser @ parser.go:1227:10
  9549  .  .  .  .  .  Y: nil
  9550  .  .  .  .  }
  9551  .  .  .  }
  9552  .  .  .  Name: fieldDecl @ parser.go:1227:18
  9553  .  .  .  Type: *syntax.FuncType {
  9554  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
  9555  .  .  .  .  .  0: *syntax.Field {
  9556  .  .  .  .  .  .  Name: styp @ parser.go:1227:28
  9557  .  .  .  .  .  .  Type: *syntax.Operation {
  9558  .  .  .  .  .  .  .  Op: *
  9559  .  .  .  .  .  .  .  X: StructType @ parser.go:1227:34
  9560  .  .  .  .  .  .  .  Y: nil
  9561  .  .  .  .  .  .  }
  9562  .  .  .  .  .  }
  9563  .  .  .  .  }
  9564  .  .  .  .  ResultList: nil
  9565  .  .  .  }
  9566  .  .  .  Body: *syntax.BlockStmt {
  9567  .  .  .  .  List: []syntax.Stmt (3 entries) {
  9568  .  .  .  .  .  0: *syntax.IfStmt {
  9569  .  .  .  .  .  .  Init: nil
  9570  .  .  .  .  .  .  Cond: trace @ parser.go:1228:5
  9571  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  9572  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  9573  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
  9574  .  .  .  .  .  .  .  .  .  Tok: defer
  9575  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
  9576  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
  9577  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9578  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1229:9
  9579  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1229:11
  9580  .  .  .  .  .  .  .  .  .  .  .  }
  9581  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9582  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9583  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"fieldDecl\""
  9584  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9585  .  .  .  .  .  .  .  .  .  .  .  .  }
  9586  .  .  .  .  .  .  .  .  .  .  .  }
  9587  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9588  .  .  .  .  .  .  .  .  .  .  }
  9589  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9590  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9591  .  .  .  .  .  .  .  .  .  }
  9592  .  .  .  .  .  .  .  .  }
  9593  .  .  .  .  .  .  .  }
  9594  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9595  .  .  .  .  .  .  }
  9596  .  .  .  .  .  .  Else: nil
  9597  .  .  .  .  .  }
  9598  .  .  .  .  .  1: *syntax.AssignStmt {
  9599  .  .  .  .  .  .  Op: :
  9600  .  .  .  .  .  .  Lhs: pos @ parser.go:1232:2
  9601  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9602  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9603  .  .  .  .  .  .  .  .  X: p @ parser.go:1232:9
  9604  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1232:11
  9605  .  .  .  .  .  .  .  }
  9606  .  .  .  .  .  .  .  ArgList: nil
  9607  .  .  .  .  .  .  .  HasDots: false
  9608  .  .  .  .  .  .  }
  9609  .  .  .  .  .  }
  9610  .  .  .  .  .  2: *syntax.SwitchStmt {
  9611  .  .  .  .  .  .  Init: nil
  9612  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
  9613  .  .  .  .  .  .  .  X: p @ parser.go:1233:9
  9614  .  .  .  .  .  .  .  Sel: tok @ parser.go:1233:11
  9615  .  .  .  .  .  .  }
  9616  .  .  .  .  .  .  Body: []*syntax.CaseClause (4 entries) {
  9617  .  .  .  .  .  .  .  0: *syntax.CaseClause {
  9618  .  .  .  .  .  .  .  .  Cases: _Name @ parser.go:1234:7
  9619  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
  9620  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9621  .  .  .  .  .  .  .  .  .  .  Op: :
  9622  .  .  .  .  .  .  .  .  .  .  Lhs: name @ parser.go:1235:3
  9623  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9624  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9625  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1235:11
  9626  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:1235:13
  9627  .  .  .  .  .  .  .  .  .  .  .  }
  9628  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9629  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9630  .  .  .  .  .  .  .  .  .  .  }
  9631  .  .  .  .  .  .  .  .  .  }
  9632  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  9633  .  .  .  .  .  .  .  .  .  .  Init: nil
  9634  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  9635  .  .  .  .  .  .  .  .  .  .  .  Op: ||
  9636  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  9637  .  .  .  .  .  .  .  .  .  .  .  .  Op: ||
  9638  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  9639  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ||
  9640  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
  9641  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  9642  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9643  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1236:6
  9644  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1236:8
  9645  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9646  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Dot @ parser.go:1236:15
  9647  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9648  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  9649  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  9650  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9651  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1236:23
  9652  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1236:25
  9653  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9654  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Literal @ parser.go:1236:32
  9655  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9656  .  .  .  .  .  .  .  .  .  .  .  .  }
  9657  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  9658  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  9659  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9660  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1236:44
  9661  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1236:46
  9662  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9663  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Semi @ parser.go:1236:53
  9664  .  .  .  .  .  .  .  .  .  .  .  .  }
  9665  .  .  .  .  .  .  .  .  .  .  .  }
  9666  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
  9667  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  9668  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9669  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1236:62
  9670  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1236:64
  9671  .  .  .  .  .  .  .  .  .  .  .  .  }
  9672  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Rbrace @ parser.go:1236:71
  9673  .  .  .  .  .  .  .  .  .  .  .  }
  9674  .  .  .  .  .  .  .  .  .  .  }
  9675  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  9676  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (4 entries) {
  9677  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9678  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  9679  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ @ parser.go:1238:4
  9680  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9681  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9682  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1238:11
  9683  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName @ parser.go:1238:13
  9684  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9685  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9686  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: name @ parser.go:1238:27
  9687  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9688  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9689  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9690  .  .  .  .  .  .  .  .  .  .  .  .  }
  9691  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
  9692  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  9693  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: tag @ parser.go:1239:4
  9694  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9695  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9696  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1239:11
  9697  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral @ parser.go:1239:13
  9698  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9699  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9700  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9701  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9702  .  .  .  .  .  .  .  .  .  .  .  .  }
  9703  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
  9704  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9705  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9706  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1240:4
  9707  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: addField @ parser.go:1240:6
  9708  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9709  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (5 entries) {
  9710  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: styp @ parser.go:1240:15
  9711  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: pos @ parser.go:1240:21
  9712  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: nil @ parser.go:1240:26
  9713  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: typ @ parser.go:1240:31
  9714  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: tag @ parser.go:1240:36
  9715  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9716  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9717  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9718  .  .  .  .  .  .  .  .  .  .  .  .  }
  9719  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.ReturnStmt {
  9720  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: nil
  9721  .  .  .  .  .  .  .  .  .  .  .  .  }
  9722  .  .  .  .  .  .  .  .  .  .  .  }
  9723  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9724  .  .  .  .  .  .  .  .  .  .  }
  9725  .  .  .  .  .  .  .  .  .  .  Else: nil
  9726  .  .  .  .  .  .  .  .  .  }
  9727  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  9728  .  .  .  .  .  .  .  .  .  .  Op: :
  9729  .  .  .  .  .  .  .  .  .  .  Lhs: names @ parser.go:1245:3
  9730  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9731  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9732  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1245:12
  9733  .  .  .  .  .  .  .  .  .  .  .  .  Sel: nameList @ parser.go:1245:14
  9734  .  .  .  .  .  .  .  .  .  .  .  }
  9735  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9736  .  .  .  .  .  .  .  .  .  .  .  .  0: name @ parser.go:1245:23
  9737  .  .  .  .  .  .  .  .  .  .  .  }
  9738  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9739  .  .  .  .  .  .  .  .  .  .  }
  9740  .  .  .  .  .  .  .  .  .  }
  9741  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
  9742  .  .  .  .  .  .  .  .  .  .  Op: :
  9743  .  .  .  .  .  .  .  .  .  .  Lhs: typ @ parser.go:1246:3
  9744  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9745  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9746  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1246:10
  9747  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_ @ parser.go:1246:12
  9748  .  .  .  .  .  .  .  .  .  .  .  }
  9749  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9750  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9751  .  .  .  .  .  .  .  .  .  .  }
  9752  .  .  .  .  .  .  .  .  .  }
  9753  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  9754  .  .  .  .  .  .  .  .  .  .  Op: :
  9755  .  .  .  .  .  .  .  .  .  .  Lhs: tag @ parser.go:1247:3
  9756  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9757  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9758  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1247:10
  9759  .  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral @ parser.go:1247:12
  9760  .  .  .  .  .  .  .  .  .  .  .  }
  9761  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9762  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9763  .  .  .  .  .  .  .  .  .  .  }
  9764  .  .  .  .  .  .  .  .  .  }
  9765  .  .  .  .  .  .  .  .  .  5: *syntax.ForStmt {
  9766  .  .  .  .  .  .  .  .  .  .  Init: *syntax.RangeClause {
  9767  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
  9768  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
  9769  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _ @ parser.go:1249:7
  9770  .  .  .  .  .  .  .  .  .  .  .  .  .  1: name @ parser.go:1249:10
  9771  .  .  .  .  .  .  .  .  .  .  .  .  }
  9772  .  .  .  .  .  .  .  .  .  .  .  }
  9773  .  .  .  .  .  .  .  .  .  .  .  Def: true
  9774  .  .  .  .  .  .  .  .  .  .  .  X: names @ parser.go:1249:24
  9775  .  .  .  .  .  .  .  .  .  .  }
  9776  .  .  .  .  .  .  .  .  .  .  Cond: nil
  9777  .  .  .  .  .  .  .  .  .  .  Post: nil
  9778  .  .  .  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
  9779  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
  9780  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  9781  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9782  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9783  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1250:4
  9784  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: addField @ parser.go:1250:6
  9785  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9786  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (5 entries) {
  9787  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: styp @ parser.go:1250:15
  9788  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
  9789  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9790  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: name @ parser.go:1250:21
  9791  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1250:26
  9792  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9793  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9794  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9795  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9796  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: name @ parser.go:1250:33
  9797  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: typ @ parser.go:1250:39
  9798  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: tag @ parser.go:1250:44
  9799  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9800  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9801  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9802  .  .  .  .  .  .  .  .  .  .  .  .  }
  9803  .  .  .  .  .  .  .  .  .  .  .  }
  9804  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9805  .  .  .  .  .  .  .  .  .  .  }
  9806  .  .  .  .  .  .  .  .  .  }
  9807  .  .  .  .  .  .  .  .  }
  9808  .  .  .  .  .  .  .  .  Colon: src.Pos {}
  9809  .  .  .  .  .  .  .  }
  9810  .  .  .  .  .  .  .  1: *syntax.CaseClause {
  9811  .  .  .  .  .  .  .  .  Cases: _Lparen @ parser.go:1253:7
  9812  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
  9813  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
  9814  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9815  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9816  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1254:3
  9817  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1254:5
  9818  .  .  .  .  .  .  .  .  .  .  .  }
  9819  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9820  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9821  .  .  .  .  .  .  .  .  .  .  }
  9822  .  .  .  .  .  .  .  .  .  }
  9823  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
  9824  .  .  .  .  .  .  .  .  .  .  Init: nil
  9825  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
  9826  .  .  .  .  .  .  .  .  .  .  .  Op: ==
  9827  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
  9828  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1255:6
  9829  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1255:8
  9830  .  .  .  .  .  .  .  .  .  .  .  }
  9831  .  .  .  .  .  .  .  .  .  .  .  Y: _Star @ parser.go:1255:15
  9832  .  .  .  .  .  .  .  .  .  .  }
  9833  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
  9834  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (7 entries) {
  9835  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9836  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  9837  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: pos @ parser.go:1257:4
  9838  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9839  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9840  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1257:11
  9841  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1257:13
  9842  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9843  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9844  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9845  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9846  .  .  .  .  .  .  .  .  .  .  .  .  }
  9847  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  9848  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9849  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9850  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1258:4
  9851  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1258:6
  9852  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9853  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9854  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9855  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9856  .  .  .  .  .  .  .  .  .  .  .  .  }
  9857  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  9858  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  9859  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ @ parser.go:1259:4
  9860  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9861  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: newIndirect @ parser.go:1259:11
  9862  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
  9863  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: pos @ parser.go:1259:23
  9864  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
  9865  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9866  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1259:28
  9867  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName @ parser.go:1259:30
  9868  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9869  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9870  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1259:44
  9871  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9872  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9873  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9874  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9875  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9876  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9877  .  .  .  .  .  .  .  .  .  .  .  .  }
  9878  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
  9879  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9880  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9881  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1260:4
  9882  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1260:6
  9883  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9884  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9885  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:1260:11
  9886  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9887  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9888  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9889  .  .  .  .  .  .  .  .  .  .  .  .  }
  9890  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
  9891  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  9892  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: tag @ parser.go:1261:4
  9893  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9894  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9895  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1261:11
  9896  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral @ parser.go:1261:13
  9897  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9898  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9899  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9900  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9901  .  .  .  .  .  .  .  .  .  .  .  .  }
  9902  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.ExprStmt {
  9903  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9904  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9905  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1262:4
  9906  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: addField @ parser.go:1262:6
  9907  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9908  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (5 entries) {
  9909  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: styp @ parser.go:1262:15
  9910  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: pos @ parser.go:1262:21
  9911  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: nil @ parser.go:1262:26
  9912  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: typ @ parser.go:1262:31
  9913  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: tag @ parser.go:1262:36
  9914  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9915  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9916  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9917  .  .  .  .  .  .  .  .  .  .  .  .  }
  9918  .  .  .  .  .  .  .  .  .  .  .  .  6: *syntax.ExprStmt {
  9919  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9920  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9921  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1263:4
  9922  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1263:6
  9923  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9924  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9925  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
  9926  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"cannot parenthesize embedded type\""
  9927  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
  9928  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9929  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9930  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9931  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9932  .  .  .  .  .  .  .  .  .  .  .  .  }
  9933  .  .  .  .  .  .  .  .  .  .  .  }
  9934  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
  9935  .  .  .  .  .  .  .  .  .  .  }
  9936  .  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
  9937  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (5 entries) {
  9938  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
  9939  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  9940  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ @ parser.go:1267:4
  9941  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9942  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9943  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1267:11
  9944  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName @ parser.go:1267:13
  9945  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9946  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9947  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1267:27
  9948  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9949  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9950  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9951  .  .  .  .  .  .  .  .  .  .  .  .  }
  9952  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
  9953  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9954  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9955  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1268:4
  9956  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1268:6
  9957  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9958  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9959  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:1268:11
  9960  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9961  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9962  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9963  .  .  .  .  .  .  .  .  .  .  .  .  }
  9964  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
  9965  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
  9966  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: tag @ parser.go:1269:4
  9967  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
  9968  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9969  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1269:11
  9970  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral @ parser.go:1269:13
  9971  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9972  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
  9973  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9974  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9975  .  .  .  .  .  .  .  .  .  .  .  .  }
  9976  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
  9977  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9978  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9979  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1270:4
  9980  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: addField @ parser.go:1270:6
  9981  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9982  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (5 entries) {
  9983  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: styp @ parser.go:1270:15
  9984  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: pos @ parser.go:1270:21
  9985  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: nil @ parser.go:1270:26
  9986  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: typ @ parser.go:1270:31
  9987  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: tag @ parser.go:1270:36
  9988  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9989  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
  9990  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9991  .  .  .  .  .  .  .  .  .  .  .  .  }
  9992  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.ExprStmt {
  9993  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
  9994  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
  9995  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1271:4
  9996  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1271:6
  9997  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
  9998  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
  9999  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10000  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"cannot parenthesize embedded type\""
 10001  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10002  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10003  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10004  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10005  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10006  .  .  .  .  .  .  .  .  .  .  .  .  }
 10007  .  .  .  .  .  .  .  .  .  .  .  }
 10008  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 10009  .  .  .  .  .  .  .  .  .  .  }
 10010  .  .  .  .  .  .  .  .  .  }
 10011  .  .  .  .  .  .  .  .  }
 10012  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10013  .  .  .  .  .  .  .  }
 10014  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 10015  .  .  .  .  .  .  .  .  Cases: _Star @ parser.go:1274:7
 10016  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 10017  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10018  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10019  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10020  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1275:3
 10021  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1275:5
 10022  .  .  .  .  .  .  .  .  .  .  .  }
 10023  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10024  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10025  .  .  .  .  .  .  .  .  .  .  }
 10026  .  .  .  .  .  .  .  .  .  }
 10027  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 10028  .  .  .  .  .  .  .  .  .  .  Init: nil
 10029  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
 10030  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10031  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1276:6
 10032  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:1276:8
 10033  .  .  .  .  .  .  .  .  .  .  .  }
 10034  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10035  .  .  .  .  .  .  .  .  .  .  .  .  0: _Lparen @ parser.go:1276:12
 10036  .  .  .  .  .  .  .  .  .  .  .  }
 10037  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10038  .  .  .  .  .  .  .  .  .  .  }
 10039  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 10040  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (5 entries) {
 10041  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10042  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 10043  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ @ parser.go:1278:4
 10044  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10045  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: newIndirect @ parser.go:1278:11
 10046  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 10047  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: pos @ parser.go:1278:23
 10048  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 10049  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10050  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1278:28
 10051  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName @ parser.go:1278:30
 10052  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10053  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10054  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1278:44
 10055  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10056  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10057  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10058  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10059  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10060  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10061  .  .  .  .  .  .  .  .  .  .  .  .  }
 10062  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 10063  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10064  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10065  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1279:4
 10066  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1279:6
 10067  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10068  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10069  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:1279:11
 10070  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10071  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10072  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10073  .  .  .  .  .  .  .  .  .  .  .  .  }
 10074  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 10075  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 10076  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: tag @ parser.go:1280:4
 10077  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10078  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10079  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1280:11
 10080  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral @ parser.go:1280:13
 10081  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10082  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10083  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10084  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10085  .  .  .  .  .  .  .  .  .  .  .  .  }
 10086  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
 10087  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10088  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10089  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1281:4
 10090  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: addField @ parser.go:1281:6
 10091  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10092  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (5 entries) {
 10093  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: styp @ parser.go:1281:15
 10094  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: pos @ parser.go:1281:21
 10095  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: nil @ parser.go:1281:26
 10096  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: typ @ parser.go:1281:31
 10097  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: tag @ parser.go:1281:36
 10098  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10099  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10100  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10101  .  .  .  .  .  .  .  .  .  .  .  .  }
 10102  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.ExprStmt {
 10103  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10104  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10105  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1282:4
 10106  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1282:6
 10107  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10108  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10109  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10110  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"cannot parenthesize embedded type\""
 10111  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10112  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10113  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10114  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10115  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10116  .  .  .  .  .  .  .  .  .  .  .  .  }
 10117  .  .  .  .  .  .  .  .  .  .  .  }
 10118  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 10119  .  .  .  .  .  .  .  .  .  .  }
 10120  .  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
 10121  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
 10122  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10123  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 10124  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ @ parser.go:1286:4
 10125  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10126  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: newIndirect @ parser.go:1286:11
 10127  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 10128  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: pos @ parser.go:1286:23
 10129  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 10130  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10131  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1286:28
 10132  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName @ parser.go:1286:30
 10133  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10134  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10135  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1286:44
 10136  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10137  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10138  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10139  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10140  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10141  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10142  .  .  .  .  .  .  .  .  .  .  .  .  }
 10143  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 10144  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 10145  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: tag @ parser.go:1287:4
 10146  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10147  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10148  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1287:11
 10149  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: oliteral @ parser.go:1287:13
 10150  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10151  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10152  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10153  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10154  .  .  .  .  .  .  .  .  .  .  .  .  }
 10155  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 10156  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10157  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10158  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1288:4
 10159  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: addField @ parser.go:1288:6
 10160  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10161  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (5 entries) {
 10162  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: styp @ parser.go:1288:15
 10163  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: pos @ parser.go:1288:21
 10164  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: nil @ parser.go:1288:26
 10165  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: typ @ parser.go:1288:31
 10166  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: tag @ parser.go:1288:36
 10167  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10168  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10169  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10170  .  .  .  .  .  .  .  .  .  .  .  .  }
 10171  .  .  .  .  .  .  .  .  .  .  .  }
 10172  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 10173  .  .  .  .  .  .  .  .  .  .  }
 10174  .  .  .  .  .  .  .  .  .  }
 10175  .  .  .  .  .  .  .  .  }
 10176  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10177  .  .  .  .  .  .  .  }
 10178  .  .  .  .  .  .  .  3: *syntax.CaseClause {
 10179  .  .  .  .  .  .  .  .  Cases: nil
 10180  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 10181  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10182  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10183  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10184  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1292:3
 10185  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1292:5
 10186  .  .  .  .  .  .  .  .  .  .  .  }
 10187  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10188  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10189  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting field name or embedded type\""
 10190  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10191  .  .  .  .  .  .  .  .  .  .  .  .  }
 10192  .  .  .  .  .  .  .  .  .  .  .  }
 10193  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10194  .  .  .  .  .  .  .  .  .  .  }
 10195  .  .  .  .  .  .  .  .  .  }
 10196  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 10197  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10198  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10199  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1293:3
 10200  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:1293:5
 10201  .  .  .  .  .  .  .  .  .  .  .  }
 10202  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 10203  .  .  .  .  .  .  .  .  .  .  .  .  0: _Semi @ parser.go:1293:13
 10204  .  .  .  .  .  .  .  .  .  .  .  .  1: _Rbrace @ parser.go:1293:20
 10205  .  .  .  .  .  .  .  .  .  .  .  }
 10206  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10207  .  .  .  .  .  .  .  .  .  .  }
 10208  .  .  .  .  .  .  .  .  .  }
 10209  .  .  .  .  .  .  .  .  }
 10210  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10211  .  .  .  .  .  .  .  }
 10212  .  .  .  .  .  .  }
 10213  .  .  .  .  .  .  Rbrace: src.Pos {}
 10214  .  .  .  .  .  }
 10215  .  .  .  .  }
 10216  .  .  .  .  Rbrace: src.Pos {}
 10217  .  .  .  }
 10218  .  .  .  Pragma: 0
 10219  .  .  }
 10220  .  .  51: *syntax.FuncDecl {
 10221  .  .  .  Attr: map[]
 10222  .  .  .  Recv: *syntax.Field {
 10223  .  .  .  .  Name: p @ parser.go:1297:7
 10224  .  .  .  .  Type: *syntax.Operation {
 10225  .  .  .  .  .  Op: *
 10226  .  .  .  .  .  X: parser @ parser.go:1297:10
 10227  .  .  .  .  .  Y: nil
 10228  .  .  .  .  }
 10229  .  .  .  }
 10230  .  .  .  Name: oliteral @ parser.go:1297:18
 10231  .  .  .  Type: *syntax.FuncType {
 10232  .  .  .  .  ParamList: nil
 10233  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 10234  .  .  .  .  .  0: *syntax.Field {
 10235  .  .  .  .  .  .  Name: nil
 10236  .  .  .  .  .  .  Type: *syntax.Operation {
 10237  .  .  .  .  .  .  .  Op: *
 10238  .  .  .  .  .  .  .  X: BasicLit @ parser.go:1297:30
 10239  .  .  .  .  .  .  .  Y: nil
 10240  .  .  .  .  .  .  }
 10241  .  .  .  .  .  }
 10242  .  .  .  .  }
 10243  .  .  .  }
 10244  .  .  .  Body: *syntax.BlockStmt {
 10245  .  .  .  .  List: []syntax.Stmt (2 entries) {
 10246  .  .  .  .  .  0: *syntax.IfStmt {
 10247  .  .  .  .  .  .  Init: nil
 10248  .  .  .  .  .  .  Cond: *syntax.Operation {
 10249  .  .  .  .  .  .  .  Op: ==
 10250  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 10251  .  .  .  .  .  .  .  .  X: p @ parser.go:1298:5
 10252  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1298:7
 10253  .  .  .  .  .  .  .  }
 10254  .  .  .  .  .  .  .  Y: _Literal @ parser.go:1298:14
 10255  .  .  .  .  .  .  }
 10256  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 10257  .  .  .  .  .  .  .  List: []syntax.Stmt (6 entries) {
 10258  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10259  .  .  .  .  .  .  .  .  .  Op: :
 10260  .  .  .  .  .  .  .  .  .  Lhs: b @ parser.go:1299:3
 10261  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10262  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1299:8
 10263  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10264  .  .  .  .  .  .  .  .  .  .  .  0: BasicLit @ parser.go:1299:12
 10265  .  .  .  .  .  .  .  .  .  .  }
 10266  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10267  .  .  .  .  .  .  .  .  .  }
 10268  .  .  .  .  .  .  .  .  }
 10269  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 10270  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10271  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10272  .  .  .  .  .  .  .  .  .  .  X: b @ parser.go:1300:3
 10273  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1300:5
 10274  .  .  .  .  .  .  .  .  .  }
 10275  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10276  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10277  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1300:11
 10278  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1300:13
 10279  .  .  .  .  .  .  .  .  .  .  }
 10280  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10281  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10282  .  .  .  .  .  .  .  .  .  }
 10283  .  .  .  .  .  .  .  .  }
 10284  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 10285  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10286  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10287  .  .  .  .  .  .  .  .  .  .  X: b @ parser.go:1301:3
 10288  .  .  .  .  .  .  .  .  .  .  Sel: Value @ parser.go:1301:5
 10289  .  .  .  .  .  .  .  .  .  }
 10290  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 10291  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1301:13
 10292  .  .  .  .  .  .  .  .  .  .  Sel: lit @ parser.go:1301:15
 10293  .  .  .  .  .  .  .  .  .  }
 10294  .  .  .  .  .  .  .  .  }
 10295  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
 10296  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10297  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10298  .  .  .  .  .  .  .  .  .  .  X: b @ parser.go:1302:3
 10299  .  .  .  .  .  .  .  .  .  .  Sel: Kind @ parser.go:1302:5
 10300  .  .  .  .  .  .  .  .  .  }
 10301  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 10302  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1302:12
 10303  .  .  .  .  .  .  .  .  .  .  Sel: kind @ parser.go:1302:14
 10304  .  .  .  .  .  .  .  .  .  }
 10305  .  .  .  .  .  .  .  .  }
 10306  .  .  .  .  .  .  .  .  4: *syntax.ExprStmt {
 10307  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10308  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10309  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1303:3
 10310  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1303:5
 10311  .  .  .  .  .  .  .  .  .  .  }
 10312  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10313  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10314  .  .  .  .  .  .  .  .  .  }
 10315  .  .  .  .  .  .  .  .  }
 10316  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
 10317  .  .  .  .  .  .  .  .  .  Results: b @ parser.go:1304:10
 10318  .  .  .  .  .  .  .  .  }
 10319  .  .  .  .  .  .  .  }
 10320  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 10321  .  .  .  .  .  .  }
 10322  .  .  .  .  .  .  Else: nil
 10323  .  .  .  .  .  }
 10324  .  .  .  .  .  1: *syntax.ReturnStmt {
 10325  .  .  .  .  .  .  Results: nil @ parser.go:1306:9
 10326  .  .  .  .  .  }
 10327  .  .  .  .  }
 10328  .  .  .  .  Rbrace: src.Pos {}
 10329  .  .  .  }
 10330  .  .  .  Pragma: 0
 10331  .  .  }
 10332  .  .  52: *syntax.FuncDecl {
 10333  .  .  .  Attr: map[]
 10334  .  .  .  Recv: *syntax.Field {
 10335  .  .  .  .  Name: p @ parser.go:1312:7
 10336  .  .  .  .  Type: *syntax.Operation {
 10337  .  .  .  .  .  Op: *
 10338  .  .  .  .  .  X: parser @ parser.go:1312:10
 10339  .  .  .  .  .  Y: nil
 10340  .  .  .  .  }
 10341  .  .  .  }
 10342  .  .  .  Name: methodDecl @ parser.go:1312:18
 10343  .  .  .  Type: *syntax.FuncType {
 10344  .  .  .  .  ParamList: nil
 10345  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 10346  .  .  .  .  .  0: *syntax.Field {
 10347  .  .  .  .  .  .  Name: nil
 10348  .  .  .  .  .  .  Type: *syntax.Operation {
 10349  .  .  .  .  .  .  .  Op: *
 10350  .  .  .  .  .  .  .  X: Field @ parser.go:1312:32
 10351  .  .  .  .  .  .  .  Y: nil
 10352  .  .  .  .  .  .  }
 10353  .  .  .  .  .  }
 10354  .  .  .  .  }
 10355  .  .  .  }
 10356  .  .  .  Body: *syntax.BlockStmt {
 10357  .  .  .  .  List: []syntax.Stmt (2 entries) {
 10358  .  .  .  .  .  0: *syntax.IfStmt {
 10359  .  .  .  .  .  .  Init: nil
 10360  .  .  .  .  .  .  Cond: trace @ parser.go:1313:5
 10361  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 10362  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 10363  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 10364  .  .  .  .  .  .  .  .  .  Tok: defer
 10365  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 10366  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 10367  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10368  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1314:9
 10369  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1314:11
 10370  .  .  .  .  .  .  .  .  .  .  .  }
 10371  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10372  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10373  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"methodDecl\""
 10374  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10375  .  .  .  .  .  .  .  .  .  .  .  .  }
 10376  .  .  .  .  .  .  .  .  .  .  .  }
 10377  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10378  .  .  .  .  .  .  .  .  .  .  }
 10379  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10380  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10381  .  .  .  .  .  .  .  .  .  }
 10382  .  .  .  .  .  .  .  .  }
 10383  .  .  .  .  .  .  .  }
 10384  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 10385  .  .  .  .  .  .  }
 10386  .  .  .  .  .  .  Else: nil
 10387  .  .  .  .  .  }
 10388  .  .  .  .  .  1: *syntax.SwitchStmt {
 10389  .  .  .  .  .  .  Init: nil
 10390  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 10391  .  .  .  .  .  .  .  X: p @ parser.go:1317:9
 10392  .  .  .  .  .  .  .  Sel: tok @ parser.go:1317:11
 10393  .  .  .  .  .  .  }
 10394  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 10395  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 10396  .  .  .  .  .  .  .  .  Cases: _Name @ parser.go:1318:7
 10397  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (10 entries) {
 10398  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10399  .  .  .  .  .  .  .  .  .  .  Op: :
 10400  .  .  .  .  .  .  .  .  .  .  Lhs: name @ parser.go:1319:3
 10401  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10402  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10403  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1319:11
 10404  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:1319:13
 10405  .  .  .  .  .  .  .  .  .  .  .  }
 10406  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10407  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10408  .  .  .  .  .  .  .  .  .  .  }
 10409  .  .  .  .  .  .  .  .  .  }
 10410  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 10411  .  .  .  .  .  .  .  .  .  .  Op: :
 10412  .  .  .  .  .  .  .  .  .  .  Lhs: hasNameList @ parser.go:1322:3
 10413  .  .  .  .  .  .  .  .  .  .  Rhs: false @ parser.go:1322:18
 10414  .  .  .  .  .  .  .  .  .  }
 10415  .  .  .  .  .  .  .  .  .  2: *syntax.ForStmt {
 10416  .  .  .  .  .  .  .  .  .  .  Init: nil
 10417  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
 10418  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10419  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1323:7
 10420  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:1323:9
 10421  .  .  .  .  .  .  .  .  .  .  .  }
 10422  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10423  .  .  .  .  .  .  .  .  .  .  .  .  0: _Comma @ parser.go:1323:13
 10424  .  .  .  .  .  .  .  .  .  .  .  }
 10425  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10426  .  .  .  .  .  .  .  .  .  .  }
 10427  .  .  .  .  .  .  .  .  .  .  Post: nil
 10428  .  .  .  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
 10429  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 10430  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10431  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10432  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10433  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1324:4
 10434  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:1324:6
 10435  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10436  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10437  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10438  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10439  .  .  .  .  .  .  .  .  .  .  .  .  }
 10440  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 10441  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10442  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: hasNameList @ parser.go:1325:4
 10443  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: true @ parser.go:1325:18
 10444  .  .  .  .  .  .  .  .  .  .  .  .  }
 10445  .  .  .  .  .  .  .  .  .  .  .  }
 10446  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 10447  .  .  .  .  .  .  .  .  .  .  }
 10448  .  .  .  .  .  .  .  .  .  }
 10449  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
 10450  .  .  .  .  .  .  .  .  .  .  Init: nil
 10451  .  .  .  .  .  .  .  .  .  .  Cond: hasNameList @ parser.go:1327:6
 10452  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 10453  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 10454  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10455  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10456  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10457  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1328:4
 10458  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1328:6
 10459  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10460  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10461  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10462  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"name list not allowed in interface type\""
 10463  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10464  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10465  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10466  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10467  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10468  .  .  .  .  .  .  .  .  .  .  .  .  }
 10469  .  .  .  .  .  .  .  .  .  .  .  }
 10470  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 10471  .  .  .  .  .  .  .  .  .  .  }
 10472  .  .  .  .  .  .  .  .  .  .  Else: nil
 10473  .  .  .  .  .  .  .  .  .  }
 10474  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
 10475  .  .  .  .  .  .  .  .  .  .  Op: :
 10476  .  .  .  .  .  .  .  .  .  .  Lhs: f @ parser.go:1332:3
 10477  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10478  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1332:8
 10479  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10480  .  .  .  .  .  .  .  .  .  .  .  .  0: Field @ parser.go:1332:12
 10481  .  .  .  .  .  .  .  .  .  .  .  }
 10482  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10483  .  .  .  .  .  .  .  .  .  .  }
 10484  .  .  .  .  .  .  .  .  .  }
 10485  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
 10486  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10487  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10488  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1333:3
 10489  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1333:5
 10490  .  .  .  .  .  .  .  .  .  .  }
 10491  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10492  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10493  .  .  .  .  .  .  .  .  .  .  .  .  X: name @ parser.go:1333:11
 10494  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1333:16
 10495  .  .  .  .  .  .  .  .  .  .  .  }
 10496  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10497  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10498  .  .  .  .  .  .  .  .  .  .  }
 10499  .  .  .  .  .  .  .  .  .  }
 10500  .  .  .  .  .  .  .  .  .  6: *syntax.IfStmt {
 10501  .  .  .  .  .  .  .  .  .  .  Init: nil
 10502  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 10503  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 10504  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 10505  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1334:6
 10506  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1334:8
 10507  .  .  .  .  .  .  .  .  .  .  .  }
 10508  .  .  .  .  .  .  .  .  .  .  .  Y: _Lparen @ parser.go:1334:15
 10509  .  .  .  .  .  .  .  .  .  .  }
 10510  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 10511  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 10512  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10513  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10514  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10515  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1336:4
 10516  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1336:6
 10517  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10518  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10519  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10520  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1336:13
 10521  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName @ parser.go:1336:15
 10522  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10523  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10524  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: name @ parser.go:1336:29
 10525  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10526  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10527  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10528  .  .  .  .  .  .  .  .  .  .  .  .  }
 10529  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
 10530  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: f @ parser.go:1337:11
 10531  .  .  .  .  .  .  .  .  .  .  .  .  }
 10532  .  .  .  .  .  .  .  .  .  .  .  }
 10533  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 10534  .  .  .  .  .  .  .  .  .  .  }
 10535  .  .  .  .  .  .  .  .  .  .  Else: nil
 10536  .  .  .  .  .  .  .  .  .  }
 10537  .  .  .  .  .  .  .  .  .  7: *syntax.AssignStmt {
 10538  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10539  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10540  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1340:3
 10541  .  .  .  .  .  .  .  .  .  .  .  Sel: Name @ parser.go:1340:5
 10542  .  .  .  .  .  .  .  .  .  .  }
 10543  .  .  .  .  .  .  .  .  .  .  Rhs: name @ parser.go:1340:12
 10544  .  .  .  .  .  .  .  .  .  }
 10545  .  .  .  .  .  .  .  .  .  8: *syntax.AssignStmt {
 10546  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10547  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10548  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1341:3
 10549  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1341:5
 10550  .  .  .  .  .  .  .  .  .  .  }
 10551  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10552  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10553  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1341:12
 10554  .  .  .  .  .  .  .  .  .  .  .  .  Sel: funcType @ parser.go:1341:14
 10555  .  .  .  .  .  .  .  .  .  .  .  }
 10556  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10557  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10558  .  .  .  .  .  .  .  .  .  .  }
 10559  .  .  .  .  .  .  .  .  .  }
 10560  .  .  .  .  .  .  .  .  .  9: *syntax.ReturnStmt {
 10561  .  .  .  .  .  .  .  .  .  .  Results: f @ parser.go:1342:10
 10562  .  .  .  .  .  .  .  .  .  }
 10563  .  .  .  .  .  .  .  .  }
 10564  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10565  .  .  .  .  .  .  .  }
 10566  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 10567  .  .  .  .  .  .  .  .  Cases: _Lparen @ parser.go:1344:7
 10568  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (7 entries) {
 10569  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10570  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10571  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10572  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1345:3
 10573  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1345:5
 10574  .  .  .  .  .  .  .  .  .  .  .  }
 10575  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10576  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10577  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"cannot parenthesize embedded type\""
 10578  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10579  .  .  .  .  .  .  .  .  .  .  .  .  }
 10580  .  .  .  .  .  .  .  .  .  .  .  }
 10581  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10582  .  .  .  .  .  .  .  .  .  .  }
 10583  .  .  .  .  .  .  .  .  .  }
 10584  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 10585  .  .  .  .  .  .  .  .  .  .  Op: :
 10586  .  .  .  .  .  .  .  .  .  .  Lhs: f @ parser.go:1346:3
 10587  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10588  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1346:8
 10589  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10590  .  .  .  .  .  .  .  .  .  .  .  .  0: Field @ parser.go:1346:12
 10591  .  .  .  .  .  .  .  .  .  .  .  }
 10592  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10593  .  .  .  .  .  .  .  .  .  .  }
 10594  .  .  .  .  .  .  .  .  .  }
 10595  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 10596  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10597  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10598  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1347:3
 10599  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1347:5
 10600  .  .  .  .  .  .  .  .  .  .  }
 10601  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10602  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10603  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1347:11
 10604  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1347:13
 10605  .  .  .  .  .  .  .  .  .  .  .  }
 10606  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10607  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10608  .  .  .  .  .  .  .  .  .  .  }
 10609  .  .  .  .  .  .  .  .  .  }
 10610  .  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
 10611  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10612  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10613  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1348:3
 10614  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1348:5
 10615  .  .  .  .  .  .  .  .  .  .  .  }
 10616  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10617  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10618  .  .  .  .  .  .  .  .  .  .  }
 10619  .  .  .  .  .  .  .  .  .  }
 10620  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
 10621  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10622  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10623  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1349:3
 10624  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1349:5
 10625  .  .  .  .  .  .  .  .  .  .  }
 10626  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10627  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10628  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1349:12
 10629  .  .  .  .  .  .  .  .  .  .  .  .  Sel: qualifiedName @ parser.go:1349:14
 10630  .  .  .  .  .  .  .  .  .  .  .  }
 10631  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10632  .  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1349:28
 10633  .  .  .  .  .  .  .  .  .  .  .  }
 10634  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10635  .  .  .  .  .  .  .  .  .  .  }
 10636  .  .  .  .  .  .  .  .  .  }
 10637  .  .  .  .  .  .  .  .  .  5: *syntax.ExprStmt {
 10638  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10639  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10640  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1350:3
 10641  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1350:5
 10642  .  .  .  .  .  .  .  .  .  .  .  }
 10643  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10644  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:1350:10
 10645  .  .  .  .  .  .  .  .  .  .  .  }
 10646  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10647  .  .  .  .  .  .  .  .  .  .  }
 10648  .  .  .  .  .  .  .  .  .  }
 10649  .  .  .  .  .  .  .  .  .  6: *syntax.ReturnStmt {
 10650  .  .  .  .  .  .  .  .  .  .  Results: f @ parser.go:1351:10
 10651  .  .  .  .  .  .  .  .  .  }
 10652  .  .  .  .  .  .  .  .  }
 10653  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10654  .  .  .  .  .  .  .  }
 10655  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 10656  .  .  .  .  .  .  .  .  Cases: nil
 10657  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 10658  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10659  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10660  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10661  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1354:3
 10662  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1354:5
 10663  .  .  .  .  .  .  .  .  .  .  .  }
 10664  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10665  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10666  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting method or interface name\""
 10667  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10668  .  .  .  .  .  .  .  .  .  .  .  .  }
 10669  .  .  .  .  .  .  .  .  .  .  .  }
 10670  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10671  .  .  .  .  .  .  .  .  .  .  }
 10672  .  .  .  .  .  .  .  .  .  }
 10673  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 10674  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10675  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10676  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1355:3
 10677  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:1355:5
 10678  .  .  .  .  .  .  .  .  .  .  .  }
 10679  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 10680  .  .  .  .  .  .  .  .  .  .  .  .  0: _Semi @ parser.go:1355:13
 10681  .  .  .  .  .  .  .  .  .  .  .  .  1: _Rbrace @ parser.go:1355:20
 10682  .  .  .  .  .  .  .  .  .  .  .  }
 10683  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10684  .  .  .  .  .  .  .  .  .  .  }
 10685  .  .  .  .  .  .  .  .  .  }
 10686  .  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 10687  .  .  .  .  .  .  .  .  .  .  Results: nil @ parser.go:1356:10
 10688  .  .  .  .  .  .  .  .  .  }
 10689  .  .  .  .  .  .  .  .  }
 10690  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10691  .  .  .  .  .  .  .  }
 10692  .  .  .  .  .  .  }
 10693  .  .  .  .  .  .  Rbrace: src.Pos {}
 10694  .  .  .  .  .  }
 10695  .  .  .  .  }
 10696  .  .  .  .  Rbrace: src.Pos {}
 10697  .  .  .  }
 10698  .  .  .  Pragma: 0
 10699  .  .  }
 10700  .  .  53: *syntax.FuncDecl {
 10701  .  .  .  Attr: map[]
 10702  .  .  .  Recv: *syntax.Field {
 10703  .  .  .  .  Name: p @ parser.go:1361:7
 10704  .  .  .  .  Type: *syntax.Operation {
 10705  .  .  .  .  .  Op: *
 10706  .  .  .  .  .  X: parser @ parser.go:1361:10
 10707  .  .  .  .  .  Y: nil
 10708  .  .  .  .  }
 10709  .  .  .  }
 10710  .  .  .  Name: paramDeclOrNil @ parser.go:1361:18
 10711  .  .  .  Type: *syntax.FuncType {
 10712  .  .  .  .  ParamList: nil
 10713  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 10714  .  .  .  .  .  0: *syntax.Field {
 10715  .  .  .  .  .  .  Name: nil
 10716  .  .  .  .  .  .  Type: *syntax.Operation {
 10717  .  .  .  .  .  .  .  Op: *
 10718  .  .  .  .  .  .  .  X: Field @ parser.go:1361:36
 10719  .  .  .  .  .  .  .  Y: nil
 10720  .  .  .  .  .  .  }
 10721  .  .  .  .  .  }
 10722  .  .  .  .  }
 10723  .  .  .  }
 10724  .  .  .  Body: *syntax.BlockStmt {
 10725  .  .  .  .  List: []syntax.Stmt (5 entries) {
 10726  .  .  .  .  .  0: *syntax.IfStmt {
 10727  .  .  .  .  .  .  Init: nil
 10728  .  .  .  .  .  .  Cond: trace @ parser.go:1362:5
 10729  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 10730  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 10731  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 10732  .  .  .  .  .  .  .  .  .  Tok: defer
 10733  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 10734  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 10735  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10736  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1363:9
 10737  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1363:11
 10738  .  .  .  .  .  .  .  .  .  .  .  }
 10739  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10740  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10741  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"paramDecl\""
 10742  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10743  .  .  .  .  .  .  .  .  .  .  .  .  }
 10744  .  .  .  .  .  .  .  .  .  .  .  }
 10745  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10746  .  .  .  .  .  .  .  .  .  .  }
 10747  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10748  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10749  .  .  .  .  .  .  .  .  .  }
 10750  .  .  .  .  .  .  .  .  }
 10751  .  .  .  .  .  .  .  }
 10752  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 10753  .  .  .  .  .  .  }
 10754  .  .  .  .  .  .  Else: nil
 10755  .  .  .  .  .  }
 10756  .  .  .  .  .  1: *syntax.AssignStmt {
 10757  .  .  .  .  .  .  Op: :
 10758  .  .  .  .  .  .  Lhs: f @ parser.go:1366:2
 10759  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10760  .  .  .  .  .  .  .  Fun: new @ parser.go:1366:7
 10761  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10762  .  .  .  .  .  .  .  .  0: Field @ parser.go:1366:11
 10763  .  .  .  .  .  .  .  }
 10764  .  .  .  .  .  .  .  HasDots: false
 10765  .  .  .  .  .  .  }
 10766  .  .  .  .  .  }
 10767  .  .  .  .  .  2: *syntax.AssignStmt {
 10768  .  .  .  .  .  .  Op: <op-0>
 10769  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10770  .  .  .  .  .  .  .  X: f @ parser.go:1367:2
 10771  .  .  .  .  .  .  .  Sel: pos @ parser.go:1367:4
 10772  .  .  .  .  .  .  }
 10773  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10774  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10775  .  .  .  .  .  .  .  .  X: p @ parser.go:1367:10
 10776  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1367:12
 10777  .  .  .  .  .  .  .  }
 10778  .  .  .  .  .  .  .  ArgList: nil
 10779  .  .  .  .  .  .  .  HasDots: false
 10780  .  .  .  .  .  .  }
 10781  .  .  .  .  .  }
 10782  .  .  .  .  .  3: *syntax.SwitchStmt {
 10783  .  .  .  .  .  .  Init: nil
 10784  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 10785  .  .  .  .  .  .  .  X: p @ parser.go:1369:9
 10786  .  .  .  .  .  .  .  Sel: tok @ parser.go:1369:11
 10787  .  .  .  .  .  .  }
 10788  .  .  .  .  .  .  Body: []*syntax.CaseClause (4 entries) {
 10789  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 10790  .  .  .  .  .  .  .  .  Cases: _Name @ parser.go:1370:7
 10791  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 10792  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10793  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10794  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10795  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1371:3
 10796  .  .  .  .  .  .  .  .  .  .  .  Sel: Name @ parser.go:1371:5
 10797  .  .  .  .  .  .  .  .  .  .  }
 10798  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10799  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10800  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1371:12
 10801  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:1371:14
 10802  .  .  .  .  .  .  .  .  .  .  .  }
 10803  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10804  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10805  .  .  .  .  .  .  .  .  .  .  }
 10806  .  .  .  .  .  .  .  .  .  }
 10807  .  .  .  .  .  .  .  .  .  1: *syntax.SwitchStmt {
 10808  .  .  .  .  .  .  .  .  .  .  Init: nil
 10809  .  .  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 10810  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1372:10
 10811  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1372:12
 10812  .  .  .  .  .  .  .  .  .  .  }
 10813  .  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 10814  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 10815  .  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 10816  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (10 entries) {
 10817  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Name @ parser.go:1373:8
 10818  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: _Star @ parser.go:1373:15
 10819  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: _Arrow @ parser.go:1373:22
 10820  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: _Func @ parser.go:1373:30
 10821  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: _Lbrack @ parser.go:1373:37
 10822  .  .  .  .  .  .  .  .  .  .  .  .  .  .  5: _Chan @ parser.go:1373:46
 10823  .  .  .  .  .  .  .  .  .  .  .  .  .  .  6: _Map @ parser.go:1373:53
 10824  .  .  .  .  .  .  .  .  .  .  .  .  .  .  7: _Struct @ parser.go:1373:59
 10825  .  .  .  .  .  .  .  .  .  .  .  .  .  .  8: _Interface @ parser.go:1373:68
 10826  .  .  .  .  .  .  .  .  .  .  .  .  .  .  9: _Lparen @ parser.go:1373:80
 10827  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10828  .  .  .  .  .  .  .  .  .  .  .  .  }
 10829  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 10830  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10831  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10832  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10833  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1375:4
 10834  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1375:6
 10835  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10836  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10837  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10838  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1375:13
 10839  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_ @ parser.go:1375:15
 10840  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10841  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10842  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10843  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10844  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10845  .  .  .  .  .  .  .  .  .  .  .  .  }
 10846  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10847  .  .  .  .  .  .  .  .  .  .  .  }
 10848  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 10849  .  .  .  .  .  .  .  .  .  .  .  .  Cases: _DotDotDot @ parser.go:1377:8
 10850  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 10851  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10852  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10853  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10854  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1379:4
 10855  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1379:6
 10856  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10857  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10858  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10859  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1379:13
 10860  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: dotsType @ parser.go:1379:15
 10861  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10862  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10863  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10864  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10865  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10866  .  .  .  .  .  .  .  .  .  .  .  .  }
 10867  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10868  .  .  .  .  .  .  .  .  .  .  .  }
 10869  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 10870  .  .  .  .  .  .  .  .  .  .  .  .  Cases: _Dot @ parser.go:1381:8
 10871  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 10872  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10873  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10874  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10875  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1384:4
 10876  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1384:6
 10877  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10878  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10879  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10880  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1384:13
 10881  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: dotname @ parser.go:1384:15
 10882  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10883  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10884  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 10885  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1384:23
 10886  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name @ parser.go:1384:25
 10887  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10888  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10889  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10890  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10891  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10892  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 10893  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10894  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10895  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1385:4
 10896  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name @ parser.go:1385:6
 10897  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10898  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: nil @ parser.go:1385:13
 10899  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 10900  .  .  .  .  .  .  .  .  .  .  .  .  }
 10901  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10902  .  .  .  .  .  .  .  .  .  .  .  }
 10903  .  .  .  .  .  .  .  .  .  .  }
 10904  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 10905  .  .  .  .  .  .  .  .  .  }
 10906  .  .  .  .  .  .  .  .  }
 10907  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10908  .  .  .  .  .  .  .  }
 10909  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 10910  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 10911  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (9 entries) {
 10912  .  .  .  .  .  .  .  .  .  .  0: _Arrow @ parser.go:1388:7
 10913  .  .  .  .  .  .  .  .  .  .  1: _Star @ parser.go:1388:15
 10914  .  .  .  .  .  .  .  .  .  .  2: _Func @ parser.go:1388:22
 10915  .  .  .  .  .  .  .  .  .  .  3: _Lbrack @ parser.go:1388:29
 10916  .  .  .  .  .  .  .  .  .  .  4: _Chan @ parser.go:1388:38
 10917  .  .  .  .  .  .  .  .  .  .  5: _Map @ parser.go:1388:45
 10918  .  .  .  .  .  .  .  .  .  .  6: _Struct @ parser.go:1388:51
 10919  .  .  .  .  .  .  .  .  .  .  7: _Interface @ parser.go:1388:60
 10920  .  .  .  .  .  .  .  .  .  .  8: _Lparen @ parser.go:1388:72
 10921  .  .  .  .  .  .  .  .  .  }
 10922  .  .  .  .  .  .  .  .  }
 10923  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 10924  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10925  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10926  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10927  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1390:3
 10928  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1390:5
 10929  .  .  .  .  .  .  .  .  .  .  }
 10930  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10931  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10932  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1390:12
 10933  .  .  .  .  .  .  .  .  .  .  .  .  Sel: type_ @ parser.go:1390:14
 10934  .  .  .  .  .  .  .  .  .  .  .  }
 10935  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10936  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10937  .  .  .  .  .  .  .  .  .  .  }
 10938  .  .  .  .  .  .  .  .  .  }
 10939  .  .  .  .  .  .  .  .  }
 10940  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10941  .  .  .  .  .  .  .  }
 10942  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 10943  .  .  .  .  .  .  .  .  Cases: _DotDotDot @ parser.go:1392:7
 10944  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 10945  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 10946  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 10947  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 10948  .  .  .  .  .  .  .  .  .  .  .  X: f @ parser.go:1394:3
 10949  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1394:5
 10950  .  .  .  .  .  .  .  .  .  .  }
 10951  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 10952  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10953  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1394:12
 10954  .  .  .  .  .  .  .  .  .  .  .  .  Sel: dotsType @ parser.go:1394:14
 10955  .  .  .  .  .  .  .  .  .  .  .  }
 10956  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 10957  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10958  .  .  .  .  .  .  .  .  .  .  }
 10959  .  .  .  .  .  .  .  .  .  }
 10960  .  .  .  .  .  .  .  .  }
 10961  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10962  .  .  .  .  .  .  .  }
 10963  .  .  .  .  .  .  .  3: *syntax.CaseClause {
 10964  .  .  .  .  .  .  .  .  Cases: nil
 10965  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 10966  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 10967  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10968  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10969  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1397:3
 10970  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1397:5
 10971  .  .  .  .  .  .  .  .  .  .  .  }
 10972  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 10973  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 10974  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting )\""
 10975  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 10976  .  .  .  .  .  .  .  .  .  .  .  .  }
 10977  .  .  .  .  .  .  .  .  .  .  .  }
 10978  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10979  .  .  .  .  .  .  .  .  .  .  }
 10980  .  .  .  .  .  .  .  .  .  }
 10981  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 10982  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 10983  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 10984  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1398:3
 10985  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:1398:5
 10986  .  .  .  .  .  .  .  .  .  .  .  }
 10987  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 10988  .  .  .  .  .  .  .  .  .  .  .  .  0: _Comma @ parser.go:1398:13
 10989  .  .  .  .  .  .  .  .  .  .  .  .  1: _Rparen @ parser.go:1398:21
 10990  .  .  .  .  .  .  .  .  .  .  .  }
 10991  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 10992  .  .  .  .  .  .  .  .  .  .  }
 10993  .  .  .  .  .  .  .  .  .  }
 10994  .  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 10995  .  .  .  .  .  .  .  .  .  .  Results: nil @ parser.go:1399:10
 10996  .  .  .  .  .  .  .  .  .  }
 10997  .  .  .  .  .  .  .  .  }
 10998  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 10999  .  .  .  .  .  .  .  }
 11000  .  .  .  .  .  .  }
 11001  .  .  .  .  .  .  Rbrace: src.Pos {}
 11002  .  .  .  .  .  }
 11003  .  .  .  .  .  4: *syntax.ReturnStmt {
 11004  .  .  .  .  .  .  Results: f @ parser.go:1402:9
 11005  .  .  .  .  .  }
 11006  .  .  .  .  }
 11007  .  .  .  .  Rbrace: src.Pos {}
 11008  .  .  .  }
 11009  .  .  .  Pragma: 0
 11010  .  .  }
 11011  .  .  54: *syntax.FuncDecl {
 11012  .  .  .  Attr: map[]
 11013  .  .  .  Recv: *syntax.Field {
 11014  .  .  .  .  Name: p @ parser.go:1406:7
 11015  .  .  .  .  Type: *syntax.Operation {
 11016  .  .  .  .  .  Op: *
 11017  .  .  .  .  .  X: parser @ parser.go:1406:10
 11018  .  .  .  .  .  Y: nil
 11019  .  .  .  .  }
 11020  .  .  .  }
 11021  .  .  .  Name: dotsType @ parser.go:1406:18
 11022  .  .  .  Type: *syntax.FuncType {
 11023  .  .  .  .  ParamList: nil
 11024  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 11025  .  .  .  .  .  0: *syntax.Field {
 11026  .  .  .  .  .  .  Name: nil
 11027  .  .  .  .  .  .  Type: *syntax.Operation {
 11028  .  .  .  .  .  .  .  Op: *
 11029  .  .  .  .  .  .  .  X: DotsType @ parser.go:1406:30
 11030  .  .  .  .  .  .  .  Y: nil
 11031  .  .  .  .  .  .  }
 11032  .  .  .  .  .  }
 11033  .  .  .  .  }
 11034  .  .  .  }
 11035  .  .  .  Body: *syntax.BlockStmt {
 11036  .  .  .  .  List: []syntax.Stmt (7 entries) {
 11037  .  .  .  .  .  0: *syntax.IfStmt {
 11038  .  .  .  .  .  .  Init: nil
 11039  .  .  .  .  .  .  Cond: trace @ parser.go:1407:5
 11040  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11041  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 11042  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 11043  .  .  .  .  .  .  .  .  .  Tok: defer
 11044  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 11045  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 11046  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11047  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1408:9
 11048  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1408:11
 11049  .  .  .  .  .  .  .  .  .  .  .  }
 11050  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11051  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11052  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"dotsType\""
 11053  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11054  .  .  .  .  .  .  .  .  .  .  .  .  }
 11055  .  .  .  .  .  .  .  .  .  .  .  }
 11056  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11057  .  .  .  .  .  .  .  .  .  .  }
 11058  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 11059  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11060  .  .  .  .  .  .  .  .  .  }
 11061  .  .  .  .  .  .  .  .  }
 11062  .  .  .  .  .  .  .  }
 11063  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11064  .  .  .  .  .  .  }
 11065  .  .  .  .  .  .  Else: nil
 11066  .  .  .  .  .  }
 11067  .  .  .  .  .  1: *syntax.AssignStmt {
 11068  .  .  .  .  .  .  Op: :
 11069  .  .  .  .  .  .  Lhs: t @ parser.go:1411:2
 11070  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11071  .  .  .  .  .  .  .  Fun: new @ parser.go:1411:7
 11072  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11073  .  .  .  .  .  .  .  .  0: DotsType @ parser.go:1411:11
 11074  .  .  .  .  .  .  .  }
 11075  .  .  .  .  .  .  .  HasDots: false
 11076  .  .  .  .  .  .  }
 11077  .  .  .  .  .  }
 11078  .  .  .  .  .  2: *syntax.AssignStmt {
 11079  .  .  .  .  .  .  Op: <op-0>
 11080  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11081  .  .  .  .  .  .  .  X: t @ parser.go:1412:2
 11082  .  .  .  .  .  .  .  Sel: pos @ parser.go:1412:4
 11083  .  .  .  .  .  .  }
 11084  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11085  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11086  .  .  .  .  .  .  .  .  X: p @ parser.go:1412:10
 11087  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1412:12
 11088  .  .  .  .  .  .  .  }
 11089  .  .  .  .  .  .  .  ArgList: nil
 11090  .  .  .  .  .  .  .  HasDots: false
 11091  .  .  .  .  .  .  }
 11092  .  .  .  .  .  }
 11093  .  .  .  .  .  3: *syntax.ExprStmt {
 11094  .  .  .  .  .  .  X: *syntax.CallExpr {
 11095  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11096  .  .  .  .  .  .  .  .  X: p @ parser.go:1414:2
 11097  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1414:4
 11098  .  .  .  .  .  .  .  }
 11099  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11100  .  .  .  .  .  .  .  .  0: _DotDotDot @ parser.go:1414:9
 11101  .  .  .  .  .  .  .  }
 11102  .  .  .  .  .  .  .  HasDots: false
 11103  .  .  .  .  .  .  }
 11104  .  .  .  .  .  }
 11105  .  .  .  .  .  4: *syntax.AssignStmt {
 11106  .  .  .  .  .  .  Op: <op-0>
 11107  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11108  .  .  .  .  .  .  .  X: t @ parser.go:1415:2
 11109  .  .  .  .  .  .  .  Sel: Elem @ parser.go:1415:4
 11110  .  .  .  .  .  .  }
 11111  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11112  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11113  .  .  .  .  .  .  .  .  X: p @ parser.go:1415:11
 11114  .  .  .  .  .  .  .  .  Sel: typeOrNil @ parser.go:1415:13
 11115  .  .  .  .  .  .  .  }
 11116  .  .  .  .  .  .  .  ArgList: nil
 11117  .  .  .  .  .  .  .  HasDots: false
 11118  .  .  .  .  .  .  }
 11119  .  .  .  .  .  }
 11120  .  .  .  .  .  5: *syntax.IfStmt {
 11121  .  .  .  .  .  .  Init: nil
 11122  .  .  .  .  .  .  Cond: *syntax.Operation {
 11123  .  .  .  .  .  .  .  Op: ==
 11124  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11125  .  .  .  .  .  .  .  .  X: t @ parser.go:1416:5
 11126  .  .  .  .  .  .  .  .  Sel: Elem @ parser.go:1416:7
 11127  .  .  .  .  .  .  .  }
 11128  .  .  .  .  .  .  .  Y: nil @ parser.go:1416:15
 11129  .  .  .  .  .  .  }
 11130  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11131  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 11132  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 11133  .  .  .  .  .  .  .  .  .  Op: <op-0>
 11134  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11135  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1417:3
 11136  .  .  .  .  .  .  .  .  .  .  Sel: Elem @ parser.go:1417:5
 11137  .  .  .  .  .  .  .  .  .  }
 11138  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11139  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11140  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1417:12
 11141  .  .  .  .  .  .  .  .  .  .  .  Sel: bad @ parser.go:1417:14
 11142  .  .  .  .  .  .  .  .  .  .  }
 11143  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 11144  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11145  .  .  .  .  .  .  .  .  .  }
 11146  .  .  .  .  .  .  .  .  }
 11147  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 11148  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 11149  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11150  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1418:3
 11151  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1418:5
 11152  .  .  .  .  .  .  .  .  .  .  }
 11153  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11154  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11155  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"final argument in variadic function missing type\""
 11156  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11157  .  .  .  .  .  .  .  .  .  .  .  }
 11158  .  .  .  .  .  .  .  .  .  .  }
 11159  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11160  .  .  .  .  .  .  .  .  .  }
 11161  .  .  .  .  .  .  .  .  }
 11162  .  .  .  .  .  .  .  }
 11163  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11164  .  .  .  .  .  .  }
 11165  .  .  .  .  .  .  Else: nil
 11166  .  .  .  .  .  }
 11167  .  .  .  .  .  6: *syntax.ReturnStmt {
 11168  .  .  .  .  .  .  Results: t @ parser.go:1421:9
 11169  .  .  .  .  .  }
 11170  .  .  .  .  }
 11171  .  .  .  .  Rbrace: src.Pos {}
 11172  .  .  .  }
 11173  .  .  .  Pragma: 0
 11174  .  .  }
 11175  .  .  55: *syntax.FuncDecl {
 11176  .  .  .  Attr: map[]
 11177  .  .  .  Recv: *syntax.Field {
 11178  .  .  .  .  Name: p @ parser.go:1426:7
 11179  .  .  .  .  Type: *syntax.Operation {
 11180  .  .  .  .  .  Op: *
 11181  .  .  .  .  .  X: parser @ parser.go:1426:10
 11182  .  .  .  .  .  Y: nil
 11183  .  .  .  .  }
 11184  .  .  .  }
 11185  .  .  .  Name: paramList @ parser.go:1426:18
 11186  .  .  .  Type: *syntax.FuncType {
 11187  .  .  .  .  ParamList: nil
 11188  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 11189  .  .  .  .  .  0: *syntax.Field {
 11190  .  .  .  .  .  .  Name: list @ parser.go:1426:31
 11191  .  .  .  .  .  .  Type: *syntax.SliceType {
 11192  .  .  .  .  .  .  .  Elem: *syntax.Operation {
 11193  .  .  .  .  .  .  .  .  Op: *
 11194  .  .  .  .  .  .  .  .  X: Field @ parser.go:1426:39
 11195  .  .  .  .  .  .  .  .  Y: nil
 11196  .  .  .  .  .  .  .  }
 11197  .  .  .  .  .  .  }
 11198  .  .  .  .  .  }
 11199  .  .  .  .  }
 11200  .  .  .  }
 11201  .  .  .  Body: *syntax.BlockStmt {
 11202  .  .  .  .  List: []syntax.Stmt (8 entries) {
 11203  .  .  .  .  .  0: *syntax.IfStmt {
 11204  .  .  .  .  .  .  Init: nil
 11205  .  .  .  .  .  .  Cond: trace @ parser.go:1427:5
 11206  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11207  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 11208  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 11209  .  .  .  .  .  .  .  .  .  Tok: defer
 11210  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 11211  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 11212  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11213  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1428:9
 11214  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1428:11
 11215  .  .  .  .  .  .  .  .  .  .  .  }
 11216  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11217  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11218  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"paramList\""
 11219  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11220  .  .  .  .  .  .  .  .  .  .  .  .  }
 11221  .  .  .  .  .  .  .  .  .  .  .  }
 11222  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11223  .  .  .  .  .  .  .  .  .  .  }
 11224  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 11225  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11226  .  .  .  .  .  .  .  .  .  }
 11227  .  .  .  .  .  .  .  .  }
 11228  .  .  .  .  .  .  .  }
 11229  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11230  .  .  .  .  .  .  }
 11231  .  .  .  .  .  .  Else: nil
 11232  .  .  .  .  .  }
 11233  .  .  .  .  .  1: *syntax.AssignStmt {
 11234  .  .  .  .  .  .  Op: :
 11235  .  .  .  .  .  .  Lhs: pos @ parser.go:1431:2
 11236  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11237  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11238  .  .  .  .  .  .  .  .  X: p @ parser.go:1431:9
 11239  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1431:11
 11240  .  .  .  .  .  .  .  }
 11241  .  .  .  .  .  .  .  ArgList: nil
 11242  .  .  .  .  .  .  .  HasDots: false
 11243  .  .  .  .  .  .  }
 11244  .  .  .  .  .  }
 11245  .  .  .  .  .  2: *syntax.ExprStmt {
 11246  .  .  .  .  .  .  X: *syntax.CallExpr {
 11247  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11248  .  .  .  .  .  .  .  .  X: p @ parser.go:1432:2
 11249  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1432:4
 11250  .  .  .  .  .  .  .  }
 11251  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11252  .  .  .  .  .  .  .  .  0: _Lparen @ parser.go:1432:9
 11253  .  .  .  .  .  .  .  }
 11254  .  .  .  .  .  .  .  HasDots: false
 11255  .  .  .  .  .  .  }
 11256  .  .  .  .  .  }
 11257  .  .  .  .  .  3: *syntax.DeclStmt {
 11258  .  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
 11259  .  .  .  .  .  .  .  0: *syntax.VarDecl {
 11260  .  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
 11261  .  .  .  .  .  .  .  .  .  0: named @ parser.go:1434:6
 11262  .  .  .  .  .  .  .  .  }
 11263  .  .  .  .  .  .  .  .  Type: int @ parser.go:1434:12
 11264  .  .  .  .  .  .  .  .  Values: nil
 11265  .  .  .  .  .  .  .  .  Group: nil
 11266  .  .  .  .  .  .  .  }
 11267  .  .  .  .  .  .  }
 11268  .  .  .  .  .  }
 11269  .  .  .  .  .  4: *syntax.ForStmt {
 11270  .  .  .  .  .  .  Init: nil
 11271  .  .  .  .  .  .  Cond: *syntax.Operation {
 11272  .  .  .  .  .  .  .  Op: &&
 11273  .  .  .  .  .  .  .  X: *syntax.Operation {
 11274  .  .  .  .  .  .  .  .  Op: !=
 11275  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11276  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1435:6
 11277  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1435:8
 11278  .  .  .  .  .  .  .  .  }
 11279  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:1435:15
 11280  .  .  .  .  .  .  .  }
 11281  .  .  .  .  .  .  .  Y: *syntax.Operation {
 11282  .  .  .  .  .  .  .  .  Op: !=
 11283  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11284  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1435:23
 11285  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1435:25
 11286  .  .  .  .  .  .  .  .  }
 11287  .  .  .  .  .  .  .  .  Y: _Rparen @ parser.go:1435:32
 11288  .  .  .  .  .  .  .  }
 11289  .  .  .  .  .  .  }
 11290  .  .  .  .  .  .  Post: nil
 11291  .  .  .  .  .  .  Body: *syntax.BlockStmt {
 11292  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 11293  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 11294  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 11295  .  .  .  .  .  .  .  .  .  .  Op: :
 11296  .  .  .  .  .  .  .  .  .  .  Lhs: par @ parser.go:1436:6
 11297  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11298  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11299  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1436:13
 11300  .  .  .  .  .  .  .  .  .  .  .  .  Sel: paramDeclOrNil @ parser.go:1436:15
 11301  .  .  .  .  .  .  .  .  .  .  .  }
 11302  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 11303  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11304  .  .  .  .  .  .  .  .  .  .  }
 11305  .  .  .  .  .  .  .  .  .  }
 11306  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11307  .  .  .  .  .  .  .  .  .  .  Op: !=
 11308  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1436:33
 11309  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1436:40
 11310  .  .  .  .  .  .  .  .  .  }
 11311  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11312  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
 11313  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 11314  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 11315  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11316  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: &&
 11317  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 11318  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: &&
 11319  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: debug @ parser.go:1437:7
 11320  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 11321  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 11322  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11323  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1437:16
 11324  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name @ parser.go:1437:20
 11325  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11326  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1437:28
 11327  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11328  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11329  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 11330  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 11331  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11332  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1437:35
 11333  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1437:39
 11334  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11335  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1437:47
 11336  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11337  .  .  .  .  .  .  .  .  .  .  .  .  }
 11338  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11339  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 11340  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 11341  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 11342  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: panic @ parser.go:1438:5
 11343  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11344  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11345  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"parameter without name or type\""
 11346  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11347  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11348  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11349  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11350  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11351  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11352  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11353  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11354  .  .  .  .  .  .  .  .  .  .  .  .  }
 11355  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
 11356  .  .  .  .  .  .  .  .  .  .  .  }
 11357  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 11358  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 11359  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11360  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: &&
 11361  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 11362  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 11363  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11364  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1440:7
 11365  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name @ parser.go:1440:11
 11366  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11367  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1440:19
 11368  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11369  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 11370  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 11371  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11372  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1440:26
 11373  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1440:30
 11374  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11375  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1440:38
 11376  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11377  .  .  .  .  .  .  .  .  .  .  .  .  }
 11378  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11379  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 11380  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 11381  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
 11382  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: named @ parser.go:1441:5
 11383  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
 11384  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11385  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11386  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11387  .  .  .  .  .  .  .  .  .  .  .  .  }
 11388  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
 11389  .  .  .  .  .  .  .  .  .  .  .  }
 11390  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 11391  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 11392  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: list @ parser.go:1443:4
 11393  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11394  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:1443:11
 11395  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 11396  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: list @ parser.go:1443:18
 11397  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: par @ parser.go:1443:24
 11398  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11399  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11400  .  .  .  .  .  .  .  .  .  .  .  .  }
 11401  .  .  .  .  .  .  .  .  .  .  .  }
 11402  .  .  .  .  .  .  .  .  .  .  }
 11403  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11404  .  .  .  .  .  .  .  .  .  }
 11405  .  .  .  .  .  .  .  .  .  Else: nil
 11406  .  .  .  .  .  .  .  .  }
 11407  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 11408  .  .  .  .  .  .  .  .  .  Init: nil
 11409  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11410  .  .  .  .  .  .  .  .  .  .  Op: !
 11411  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 11412  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11413  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1445:7
 11414  .  .  .  .  .  .  .  .  .  .  .  .  Sel: ocomma @ parser.go:1445:9
 11415  .  .  .  .  .  .  .  .  .  .  .  }
 11416  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11417  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:1445:16
 11418  .  .  .  .  .  .  .  .  .  .  .  }
 11419  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11420  .  .  .  .  .  .  .  .  .  .  }
 11421  .  .  .  .  .  .  .  .  .  .  Y: nil
 11422  .  .  .  .  .  .  .  .  .  }
 11423  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11424  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 11425  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
 11426  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
 11427  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
 11428  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 11269)
 11429  .  .  .  .  .  .  .  .  .  .  .  }
 11430  .  .  .  .  .  .  .  .  .  .  }
 11431  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11432  .  .  .  .  .  .  .  .  .  }
 11433  .  .  .  .  .  .  .  .  .  Else: nil
 11434  .  .  .  .  .  .  .  .  }
 11435  .  .  .  .  .  .  .  }
 11436  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11437  .  .  .  .  .  .  }
 11438  .  .  .  .  .  }
 11439  .  .  .  .  .  5: *syntax.IfStmt {
 11440  .  .  .  .  .  .  Init: nil
 11441  .  .  .  .  .  .  Cond: *syntax.Operation {
 11442  .  .  .  .  .  .  .  Op: ==
 11443  .  .  .  .  .  .  .  X: named @ parser.go:1451:5
 11444  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
 11445  .  .  .  .  .  .  .  .  Value: "0"
 11446  .  .  .  .  .  .  .  .  Kind: 0
 11447  .  .  .  .  .  .  .  }
 11448  .  .  .  .  .  .  }
 11449  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11450  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 11451  .  .  .  .  .  .  .  .  0: *syntax.ForStmt {
 11452  .  .  .  .  .  .  .  .  .  Init: *syntax.RangeClause {
 11453  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 11454  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 11455  .  .  .  .  .  .  .  .  .  .  .  .  0: _ @ parser.go:1453:7
 11456  .  .  .  .  .  .  .  .  .  .  .  .  1: par @ parser.go:1453:10
 11457  .  .  .  .  .  .  .  .  .  .  .  }
 11458  .  .  .  .  .  .  .  .  .  .  }
 11459  .  .  .  .  .  .  .  .  .  .  Def: true
 11460  .  .  .  .  .  .  .  .  .  .  X: list @ parser.go:1453:23
 11461  .  .  .  .  .  .  .  .  .  }
 11462  .  .  .  .  .  .  .  .  .  Cond: nil
 11463  .  .  .  .  .  .  .  .  .  Post: nil
 11464  .  .  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
 11465  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 11466  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 11467  .  .  .  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 11468  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 11469  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ @ parser.go:1454:7
 11470  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 11471  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1454:14
 11472  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name @ parser.go:1454:18
 11473  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11474  .  .  .  .  .  .  .  .  .  .  .  .  }
 11475  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11476  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 11477  .  .  .  .  .  .  .  .  .  .  .  .  .  X: typ @ parser.go:1454:24
 11478  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1454:31
 11479  .  .  .  .  .  .  .  .  .  .  .  .  }
 11480  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11481  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 11482  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 11483  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 11484  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11485  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1455:5
 11486  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1455:9
 11487  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11488  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: typ @ parser.go:1455:16
 11489  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11490  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 11491  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 11492  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11493  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1456:5
 11494  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name @ parser.go:1456:9
 11495  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11496  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: nil @ parser.go:1456:16
 11497  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11498  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11499  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11500  .  .  .  .  .  .  .  .  .  .  .  .  }
 11501  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
 11502  .  .  .  .  .  .  .  .  .  .  .  }
 11503  .  .  .  .  .  .  .  .  .  .  }
 11504  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11505  .  .  .  .  .  .  .  .  .  }
 11506  .  .  .  .  .  .  .  .  }
 11507  .  .  .  .  .  .  .  }
 11508  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11509  .  .  .  .  .  .  }
 11510  .  .  .  .  .  .  Else: *syntax.IfStmt {
 11511  .  .  .  .  .  .  .  Init: nil
 11512  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11513  .  .  .  .  .  .  .  .  Op: !=
 11514  .  .  .  .  .  .  .  .  X: named @ parser.go:1459:12
 11515  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
 11516  .  .  .  .  .  .  .  .  .  Fun: len @ parser.go:1459:21
 11517  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11518  .  .  .  .  .  .  .  .  .  .  0: list @ parser.go:1459:25
 11519  .  .  .  .  .  .  .  .  .  }
 11520  .  .  .  .  .  .  .  .  .  HasDots: false
 11521  .  .  .  .  .  .  .  .  }
 11522  .  .  .  .  .  .  .  }
 11523  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11524  .  .  .  .  .  .  .  .  List: []syntax.Stmt (4 entries) {
 11525  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 11526  .  .  .  .  .  .  .  .  .  .  Op: :
 11527  .  .  .  .  .  .  .  .  .  .  Lhs: ok @ parser.go:1461:3
 11528  .  .  .  .  .  .  .  .  .  .  Rhs: true @ parser.go:1461:9
 11529  .  .  .  .  .  .  .  .  .  }
 11530  .  .  .  .  .  .  .  .  .  1: *syntax.DeclStmt {
 11531  .  .  .  .  .  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
 11532  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.VarDecl {
 11533  .  .  .  .  .  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
 11534  .  .  .  .  .  .  .  .  .  .  .  .  .  0: typ @ parser.go:1462:7
 11535  .  .  .  .  .  .  .  .  .  .  .  .  }
 11536  .  .  .  .  .  .  .  .  .  .  .  .  Type: Expr @ parser.go:1462:11
 11537  .  .  .  .  .  .  .  .  .  .  .  .  Values: nil
 11538  .  .  .  .  .  .  .  .  .  .  .  .  Group: nil
 11539  .  .  .  .  .  .  .  .  .  .  .  }
 11540  .  .  .  .  .  .  .  .  .  .  }
 11541  .  .  .  .  .  .  .  .  .  }
 11542  .  .  .  .  .  .  .  .  .  2: *syntax.ForStmt {
 11543  .  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 11544  .  .  .  .  .  .  .  .  .  .  .  Op: :
 11545  .  .  .  .  .  .  .  .  .  .  .  Lhs: i @ parser.go:1463:7
 11546  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.Operation {
 11547  .  .  .  .  .  .  .  .  .  .  .  .  Op: -
 11548  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 11549  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: len @ parser.go:1463:12
 11550  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11551  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: list @ parser.go:1463:16
 11552  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11553  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11554  .  .  .  .  .  .  .  .  .  .  .  .  }
 11555  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
 11556  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "1"
 11557  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
 11558  .  .  .  .  .  .  .  .  .  .  .  .  }
 11559  .  .  .  .  .  .  .  .  .  .  .  }
 11560  .  .  .  .  .  .  .  .  .  .  }
 11561  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11562  .  .  .  .  .  .  .  .  .  .  .  Op: >=
 11563  .  .  .  .  .  .  .  .  .  .  .  X: i @ parser.go:1463:27
 11564  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
 11565  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
 11566  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
 11567  .  .  .  .  .  .  .  .  .  .  .  }
 11568  .  .  .  .  .  .  .  .  .  .  }
 11569  .  .  .  .  .  .  .  .  .  .  Post: *syntax.AssignStmt {
 11570  .  .  .  .  .  .  .  .  .  .  .  Op: -
 11571  .  .  .  .  .  .  .  .  .  .  .  Lhs: i @ parser.go:1463:35
 11572  .  .  .  .  .  .  .  .  .  .  .  Rhs: *(Node @ 5597)
 11573  .  .  .  .  .  .  .  .  .  .  }
 11574  .  .  .  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
 11575  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 11576  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 11577  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 11578  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 11579  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: par @ parser.go:1464:7
 11580  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.IndexExpr {
 11581  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: list @ parser.go:1464:14
 11582  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: i @ parser.go:1464:19
 11583  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11584  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11585  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11586  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 11587  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11588  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1464:23
 11589  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1464:27
 11590  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11591  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1464:35
 11592  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11593  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11594  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 11595  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 11596  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 11597  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: typ @ parser.go:1465:5
 11598  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 11599  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1465:11
 11600  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1465:15
 11601  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11602  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11603  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 11604  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 11605  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11606  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 11607  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11608  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1466:8
 11609  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name @ parser.go:1466:12
 11610  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11611  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1466:20
 11612  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11613  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11614  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (4 entries) {
 11615  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 11616  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 11617  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: ok @ parser.go:1467:6
 11618  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: false @ parser.go:1467:11
 11619  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11620  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 11621  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 11622  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: n @ parser.go:1468:6
 11623  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11624  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11625  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1468:11
 11626  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: newName @ parser.go:1468:13
 11627  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11628  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11629  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11630  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"_\""
 11631  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11632  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11633  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11634  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11635  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11636  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11637  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 11638  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 11639  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11640  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: n @ parser.go:1469:6
 11641  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1469:8
 11642  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11643  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11644  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11645  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: typ @ parser.go:1469:14
 11646  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1469:18
 11647  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11648  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 11649  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11650  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11651  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11652  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
 11653  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 11654  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11655  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1470:6
 11656  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name @ parser.go:1470:10
 11657  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11658  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: n @ parser.go:1470:17
 11659  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11660  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11661  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11662  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11663  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
 11664  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11665  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11666  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11667  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11668  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: *syntax.IfStmt {
 11669  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 11670  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11671  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 11672  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: typ @ parser.go:1472:14
 11673  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1472:21
 11674  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11675  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11676  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 11677  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 11678  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 11679  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11680  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1473:5
 11681  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1473:9
 11682  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11683  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: typ @ parser.go:1473:16
 11684  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11685  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11686  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11687  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11688  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
 11689  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (4 entries) {
 11690  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 11691  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 11692  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: ok @ parser.go:1476:5
 11693  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: false @ parser.go:1476:10
 11694  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11695  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 11696  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 11697  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:1477:5
 11698  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11699  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11700  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1477:10
 11701  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: bad @ parser.go:1477:12
 11702  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11703  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 11704  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11705  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11706  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11707  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 11708  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 11709  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11710  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:1478:5
 11711  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1478:7
 11712  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11713  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11714  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11715  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11716  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1478:13
 11717  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Name @ parser.go:1478:17
 11718  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11719  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1478:22
 11720  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11721  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 11722  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11723  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11724  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11725  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
 11726  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 11727  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11728  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: par @ parser.go:1479:5
 11729  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Type @ parser.go:1479:9
 11730  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11731  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: t @ parser.go:1479:16
 11732  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11733  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11734  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11735  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11736  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11737  .  .  .  .  .  .  .  .  .  .  .  .  }
 11738  .  .  .  .  .  .  .  .  .  .  .  }
 11739  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11740  .  .  .  .  .  .  .  .  .  .  }
 11741  .  .  .  .  .  .  .  .  .  }
 11742  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
 11743  .  .  .  .  .  .  .  .  .  .  Init: nil
 11744  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11745  .  .  .  .  .  .  .  .  .  .  .  Op: !
 11746  .  .  .  .  .  .  .  .  .  .  .  X: ok @ parser.go:1482:7
 11747  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 11748  .  .  .  .  .  .  .  .  .  .  }
 11749  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11750  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 11751  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 11752  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 11753  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11754  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1483:4
 11755  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error_at @ parser.go:1483:6
 11756  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11757  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 11758  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: pos @ parser.go:1483:22
 11759  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
 11760  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"mixed named and unnamed function parameters\""
 11761  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11762  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11763  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11764  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11765  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11766  .  .  .  .  .  .  .  .  .  .  .  .  }
 11767  .  .  .  .  .  .  .  .  .  .  .  }
 11768  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11769  .  .  .  .  .  .  .  .  .  .  }
 11770  .  .  .  .  .  .  .  .  .  .  Else: nil
 11771  .  .  .  .  .  .  .  .  .  }
 11772  .  .  .  .  .  .  .  .  }
 11773  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11774  .  .  .  .  .  .  .  }
 11775  .  .  .  .  .  .  .  Else: nil
 11776  .  .  .  .  .  .  }
 11777  .  .  .  .  .  }
 11778  .  .  .  .  .  6: *syntax.ExprStmt {
 11779  .  .  .  .  .  .  X: *syntax.CallExpr {
 11780  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11781  .  .  .  .  .  .  .  .  X: p @ parser.go:1487:2
 11782  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1487:4
 11783  .  .  .  .  .  .  .  }
 11784  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11785  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:1487:9
 11786  .  .  .  .  .  .  .  }
 11787  .  .  .  .  .  .  .  HasDots: false
 11788  .  .  .  .  .  .  }
 11789  .  .  .  .  .  }
 11790  .  .  .  .  .  7: *syntax.ReturnStmt {
 11791  .  .  .  .  .  .  Results: nil
 11792  .  .  .  .  .  }
 11793  .  .  .  .  }
 11794  .  .  .  .  Rbrace: src.Pos {}
 11795  .  .  .  }
 11796  .  .  .  Pragma: 0
 11797  .  .  }
 11798  .  .  56: *syntax.FuncDecl {
 11799  .  .  .  Attr: map[]
 11800  .  .  .  Recv: *syntax.Field {
 11801  .  .  .  .  Name: p @ parser.go:1491:7
 11802  .  .  .  .  Type: *syntax.Operation {
 11803  .  .  .  .  .  Op: *
 11804  .  .  .  .  .  X: parser @ parser.go:1491:10
 11805  .  .  .  .  .  Y: nil
 11806  .  .  .  .  }
 11807  .  .  .  }
 11808  .  .  .  Name: bad @ parser.go:1491:18
 11809  .  .  .  Type: *syntax.FuncType {
 11810  .  .  .  .  ParamList: nil
 11811  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 11812  .  .  .  .  .  0: *syntax.Field {
 11813  .  .  .  .  .  .  Name: nil
 11814  .  .  .  .  .  .  Type: *syntax.Operation {
 11815  .  .  .  .  .  .  .  Op: *
 11816  .  .  .  .  .  .  .  X: BadExpr @ parser.go:1491:25
 11817  .  .  .  .  .  .  .  Y: nil
 11818  .  .  .  .  .  .  }
 11819  .  .  .  .  .  }
 11820  .  .  .  .  }
 11821  .  .  .  }
 11822  .  .  .  Body: *syntax.BlockStmt {
 11823  .  .  .  .  List: []syntax.Stmt (3 entries) {
 11824  .  .  .  .  .  0: *syntax.AssignStmt {
 11825  .  .  .  .  .  .  Op: :
 11826  .  .  .  .  .  .  Lhs: b @ parser.go:1492:2
 11827  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11828  .  .  .  .  .  .  .  Fun: new @ parser.go:1492:7
 11829  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11830  .  .  .  .  .  .  .  .  0: BadExpr @ parser.go:1492:11
 11831  .  .  .  .  .  .  .  }
 11832  .  .  .  .  .  .  .  HasDots: false
 11833  .  .  .  .  .  .  }
 11834  .  .  .  .  .  }
 11835  .  .  .  .  .  1: *syntax.AssignStmt {
 11836  .  .  .  .  .  .  Op: <op-0>
 11837  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 11838  .  .  .  .  .  .  .  X: b @ parser.go:1493:2
 11839  .  .  .  .  .  .  .  Sel: pos @ parser.go:1493:4
 11840  .  .  .  .  .  .  }
 11841  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 11842  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11843  .  .  .  .  .  .  .  .  X: p @ parser.go:1493:10
 11844  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1493:12
 11845  .  .  .  .  .  .  .  }
 11846  .  .  .  .  .  .  .  ArgList: nil
 11847  .  .  .  .  .  .  .  HasDots: false
 11848  .  .  .  .  .  .  }
 11849  .  .  .  .  .  }
 11850  .  .  .  .  .  2: *syntax.ReturnStmt {
 11851  .  .  .  .  .  .  Results: b @ parser.go:1494:9
 11852  .  .  .  .  .  }
 11853  .  .  .  .  }
 11854  .  .  .  .  Rbrace: src.Pos {}
 11855  .  .  .  }
 11856  .  .  .  Pragma: 0
 11857  .  .  }
 11858  .  .  57: *syntax.VarDecl {
 11859  .  .  .  NameList: []*syntax.Name (1 entries) {
 11860  .  .  .  .  0: ImplicitOne @ parser.go:1502:5
 11861  .  .  .  }
 11862  .  .  .  Type: nil
 11863  .  .  .  Values: *syntax.Operation {
 11864  .  .  .  .  Op: &
 11865  .  .  .  .  X: *syntax.CompositeLit {
 11866  .  .  .  .  .  Type: BasicLit @ parser.go:1502:20
 11867  .  .  .  .  .  ElemList: []syntax.Expr (1 entries) {
 11868  .  .  .  .  .  .  0: *syntax.KeyValueExpr {
 11869  .  .  .  .  .  .  .  Key: Value @ parser.go:1502:29
 11870  .  .  .  .  .  .  .  Value: *syntax.BasicLit {
 11871  .  .  .  .  .  .  .  .  Value: "\"1\""
 11872  .  .  .  .  .  .  .  .  Kind: 4
 11873  .  .  .  .  .  .  .  }
 11874  .  .  .  .  .  .  }
 11875  .  .  .  .  .  }
 11876  .  .  .  .  .  NKeys: 1
 11877  .  .  .  .  .  Rbrace: src.Pos {}
 11878  .  .  .  .  }
 11879  .  .  .  .  Y: nil
 11880  .  .  .  }
 11881  .  .  .  Group: nil
 11882  .  .  }
 11883  .  .  58: *syntax.FuncDecl {
 11884  .  .  .  Attr: map[]
 11885  .  .  .  Recv: *syntax.Field {
 11886  .  .  .  .  Name: p @ parser.go:1505:7
 11887  .  .  .  .  Type: *syntax.Operation {
 11888  .  .  .  .  .  Op: *
 11889  .  .  .  .  .  X: parser @ parser.go:1505:10
 11890  .  .  .  .  .  Y: nil
 11891  .  .  .  .  }
 11892  .  .  .  }
 11893  .  .  .  Name: simpleStmt @ parser.go:1505:18
 11894  .  .  .  Type: *syntax.FuncType {
 11895  .  .  .  .  ParamList: []*syntax.Field (2 entries) {
 11896  .  .  .  .  .  0: *syntax.Field {
 11897  .  .  .  .  .  .  Name: lhs @ parser.go:1505:29
 11898  .  .  .  .  .  .  Type: Expr @ parser.go:1505:33
 11899  .  .  .  .  .  }
 11900  .  .  .  .  .  1: *syntax.Field {
 11901  .  .  .  .  .  .  Name: rangeOk @ parser.go:1505:39
 11902  .  .  .  .  .  .  Type: bool @ parser.go:1505:47
 11903  .  .  .  .  .  }
 11904  .  .  .  .  }
 11905  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 11906  .  .  .  .  .  0: *syntax.Field {
 11907  .  .  .  .  .  .  Name: nil
 11908  .  .  .  .  .  .  Type: SimpleStmt @ parser.go:1505:53
 11909  .  .  .  .  .  }
 11910  .  .  .  .  }
 11911  .  .  .  }
 11912  .  .  .  Body: *syntax.BlockStmt {
 11913  .  .  .  .  List: []syntax.Stmt (6 entries) {
 11914  .  .  .  .  .  0: *syntax.IfStmt {
 11915  .  .  .  .  .  .  Init: nil
 11916  .  .  .  .  .  .  Cond: trace @ parser.go:1506:5
 11917  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11918  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 11919  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 11920  .  .  .  .  .  .  .  .  .  Tok: defer
 11921  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 11922  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 11923  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11924  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1507:9
 11925  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1507:11
 11926  .  .  .  .  .  .  .  .  .  .  .  }
 11927  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11928  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11929  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"simpleStmt\""
 11930  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11931  .  .  .  .  .  .  .  .  .  .  .  .  }
 11932  .  .  .  .  .  .  .  .  .  .  .  }
 11933  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11934  .  .  .  .  .  .  .  .  .  .  }
 11935  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 11936  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11937  .  .  .  .  .  .  .  .  .  }
 11938  .  .  .  .  .  .  .  .  }
 11939  .  .  .  .  .  .  .  }
 11940  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11941  .  .  .  .  .  .  }
 11942  .  .  .  .  .  .  Else: nil
 11943  .  .  .  .  .  }
 11944  .  .  .  .  .  1: *syntax.IfStmt {
 11945  .  .  .  .  .  .  Init: nil
 11946  .  .  .  .  .  .  Cond: *syntax.Operation {
 11947  .  .  .  .  .  .  .  Op: &&
 11948  .  .  .  .  .  .  .  X: rangeOk @ parser.go:1510:5
 11949  .  .  .  .  .  .  .  Y: *syntax.Operation {
 11950  .  .  .  .  .  .  .  .  Op: ==
 11951  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 11952  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1510:16
 11953  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1510:18
 11954  .  .  .  .  .  .  .  .  }
 11955  .  .  .  .  .  .  .  .  Y: _Range @ parser.go:1510:25
 11956  .  .  .  .  .  .  .  }
 11957  .  .  .  .  .  .  }
 11958  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11959  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 11960  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 11961  .  .  .  .  .  .  .  .  .  Init: nil
 11962  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 11963  .  .  .  .  .  .  .  .  .  .  Op: &&
 11964  .  .  .  .  .  .  .  .  .  .  X: debug @ parser.go:1512:6
 11965  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 11966  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 11967  .  .  .  .  .  .  .  .  .  .  .  X: lhs @ parser.go:1512:15
 11968  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1512:22
 11969  .  .  .  .  .  .  .  .  .  .  }
 11970  .  .  .  .  .  .  .  .  .  }
 11971  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 11972  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 11973  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 11974  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 11975  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: panic @ parser.go:1513:4
 11976  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 11977  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 11978  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"invalid call of simpleStmt\""
 11979  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 11980  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11981  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 11982  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 11983  .  .  .  .  .  .  .  .  .  .  .  .  }
 11984  .  .  .  .  .  .  .  .  .  .  .  }
 11985  .  .  .  .  .  .  .  .  .  .  }
 11986  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 11987  .  .  .  .  .  .  .  .  .  }
 11988  .  .  .  .  .  .  .  .  .  Else: nil
 11989  .  .  .  .  .  .  .  .  }
 11990  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
 11991  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 11992  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 11993  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1515:10
 11994  .  .  .  .  .  .  .  .  .  .  .  Sel: newRangeClause @ parser.go:1515:12
 11995  .  .  .  .  .  .  .  .  .  .  }
 11996  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 11997  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1515:27
 11998  .  .  .  .  .  .  .  .  .  .  .  1: false @ parser.go:1515:32
 11999  .  .  .  .  .  .  .  .  .  .  }
 12000  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12001  .  .  .  .  .  .  .  .  .  }
 12002  .  .  .  .  .  .  .  .  }
 12003  .  .  .  .  .  .  .  }
 12004  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 12005  .  .  .  .  .  .  }
 12006  .  .  .  .  .  .  Else: nil
 12007  .  .  .  .  .  }
 12008  .  .  .  .  .  2: *syntax.IfStmt {
 12009  .  .  .  .  .  .  Init: nil
 12010  .  .  .  .  .  .  Cond: *syntax.Operation {
 12011  .  .  .  .  .  .  .  Op: ==
 12012  .  .  .  .  .  .  .  X: lhs @ parser.go:1518:5
 12013  .  .  .  .  .  .  .  Y: nil @ parser.go:1518:12
 12014  .  .  .  .  .  .  }
 12015  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 12016  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 12017  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12018  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12019  .  .  .  .  .  .  .  .  .  Lhs: lhs @ parser.go:1519:3
 12020  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12021  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12022  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1519:9
 12023  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList @ parser.go:1519:11
 12024  .  .  .  .  .  .  .  .  .  .  }
 12025  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12026  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12027  .  .  .  .  .  .  .  .  .  }
 12028  .  .  .  .  .  .  .  .  }
 12029  .  .  .  .  .  .  .  }
 12030  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 12031  .  .  .  .  .  .  }
 12032  .  .  .  .  .  .  Else: nil
 12033  .  .  .  .  .  }
 12034  .  .  .  .  .  3: *syntax.IfStmt {
 12035  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 12036  .  .  .  .  .  .  .  Op: :
 12037  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 12038  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 12039  .  .  .  .  .  .  .  .  .  0: _ @ parser.go:1522:5
 12040  .  .  .  .  .  .  .  .  .  1: ok @ parser.go:1522:8
 12041  .  .  .  .  .  .  .  .  }
 12042  .  .  .  .  .  .  .  }
 12043  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 12044  .  .  .  .  .  .  .  .  X: lhs @ parser.go:1522:14
 12045  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 12046  .  .  .  .  .  .  .  .  .  Op: *
 12047  .  .  .  .  .  .  .  .  .  X: ListExpr @ parser.go:1522:20
 12048  .  .  .  .  .  .  .  .  .  Y: nil
 12049  .  .  .  .  .  .  .  .  }
 12050  .  .  .  .  .  .  .  }
 12051  .  .  .  .  .  .  }
 12052  .  .  .  .  .  .  Cond: *syntax.Operation {
 12053  .  .  .  .  .  .  .  Op: &&
 12054  .  .  .  .  .  .  .  X: *syntax.Operation {
 12055  .  .  .  .  .  .  .  .  Op: &&
 12056  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 12057  .  .  .  .  .  .  .  .  .  Op: !
 12058  .  .  .  .  .  .  .  .  .  X: ok @ parser.go:1522:32
 12059  .  .  .  .  .  .  .  .  .  Y: nil
 12060  .  .  .  .  .  .  .  .  }
 12061  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 12062  .  .  .  .  .  .  .  .  .  Op: !=
 12063  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12064  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1522:38
 12065  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1522:40
 12066  .  .  .  .  .  .  .  .  .  }
 12067  .  .  .  .  .  .  .  .  .  Y: _Assign @ parser.go:1522:47
 12068  .  .  .  .  .  .  .  .  }
 12069  .  .  .  .  .  .  .  }
 12070  .  .  .  .  .  .  .  Y: *syntax.Operation {
 12071  .  .  .  .  .  .  .  .  Op: !=
 12072  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12073  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1522:58
 12074  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1522:60
 12075  .  .  .  .  .  .  .  .  }
 12076  .  .  .  .  .  .  .  .  Y: _Define @ parser.go:1522:67
 12077  .  .  .  .  .  .  .  }
 12078  .  .  .  .  .  .  }
 12079  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 12080  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 12081  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12082  .  .  .  .  .  .  .  .  .  Op: :
 12083  .  .  .  .  .  .  .  .  .  Lhs: pos @ parser.go:1524:3
 12084  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12085  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12086  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1524:10
 12087  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1524:12
 12088  .  .  .  .  .  .  .  .  .  .  }
 12089  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12090  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12091  .  .  .  .  .  .  .  .  .  }
 12092  .  .  .  .  .  .  .  .  }
 12093  .  .  .  .  .  .  .  .  1: *syntax.SwitchStmt {
 12094  .  .  .  .  .  .  .  .  .  Init: nil
 12095  .  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 12096  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1525:10
 12097  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1525:12
 12098  .  .  .  .  .  .  .  .  .  }
 12099  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (4 entries) {
 12100  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 12101  .  .  .  .  .  .  .  .  .  .  .  Cases: _AssignOp @ parser.go:1526:8
 12102  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 12103  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12104  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 12105  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: op @ parser.go:1528:4
 12106  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 12107  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1528:10
 12108  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: op @ parser.go:1528:12
 12109  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12110  .  .  .  .  .  .  .  .  .  .  .  .  }
 12111  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 12112  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12113  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12114  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1529:4
 12115  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1529:6
 12116  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12117  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12118  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12119  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12120  .  .  .  .  .  .  .  .  .  .  .  .  }
 12121  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 12122  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 12123  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12124  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1530:11
 12125  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: newAssignStmt @ parser.go:1530:13
 12126  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12127  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
 12128  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: pos @ parser.go:1530:27
 12129  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: op @ parser.go:1530:32
 12130  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: lhs @ parser.go:1530:36
 12131  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.CallExpr {
 12132  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12133  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1530:41
 12134  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:1530:43
 12135  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12136  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12137  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12138  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12139  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12140  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12141  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12142  .  .  .  .  .  .  .  .  .  .  .  .  }
 12143  .  .  .  .  .  .  .  .  .  .  .  }
 12144  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 12145  .  .  .  .  .  .  .  .  .  .  }
 12146  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 12147  .  .  .  .  .  .  .  .  .  .  .  Cases: _IncOp @ parser.go:1532:8
 12148  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 12149  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12150  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 12151  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: op @ parser.go:1534:4
 12152  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 12153  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1534:10
 12154  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: op @ parser.go:1534:12
 12155  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12156  .  .  .  .  .  .  .  .  .  .  .  .  }
 12157  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 12158  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12159  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12160  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1535:4
 12161  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1535:6
 12162  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12163  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12164  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12165  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12166  .  .  .  .  .  .  .  .  .  .  .  .  }
 12167  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 12168  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 12169  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12170  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1536:11
 12171  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: newAssignStmt @ parser.go:1536:13
 12172  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12173  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
 12174  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: pos @ parser.go:1536:27
 12175  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: op @ parser.go:1536:32
 12176  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: lhs @ parser.go:1536:36
 12177  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: ImplicitOne @ parser.go:1536:41
 12178  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12179  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12180  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12181  .  .  .  .  .  .  .  .  .  .  .  .  }
 12182  .  .  .  .  .  .  .  .  .  .  .  }
 12183  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 12184  .  .  .  .  .  .  .  .  .  .  }
 12185  .  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 12186  .  .  .  .  .  .  .  .  .  .  .  Cases: _Arrow @ parser.go:1538:8
 12187  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
 12188  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12189  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 12190  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: s @ parser.go:1540:4
 12191  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12192  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1540:9
 12193  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12194  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: SendStmt @ parser.go:1540:13
 12195  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12196  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12197  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12198  .  .  .  .  .  .  .  .  .  .  .  .  }
 12199  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 12200  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12201  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12202  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1541:4
 12203  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1541:6
 12204  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12205  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: pos @ parser.go:1541:12
 12206  .  .  .  .  .  .  .  .  .  .  .  .  }
 12207  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 12208  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12209  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12210  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1542:4
 12211  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1542:6
 12212  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12213  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12214  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12215  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12216  .  .  .  .  .  .  .  .  .  .  .  .  }
 12217  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
 12218  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12219  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12220  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1543:4
 12221  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Chan @ parser.go:1543:6
 12222  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12223  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: lhs @ parser.go:1543:13
 12224  .  .  .  .  .  .  .  .  .  .  .  .  }
 12225  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
 12226  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12227  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12228  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1544:4
 12229  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Value @ parser.go:1544:6
 12230  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12231  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12232  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12233  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1544:14
 12234  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:1544:16
 12235  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12236  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12237  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12238  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12239  .  .  .  .  .  .  .  .  .  .  .  .  }
 12240  .  .  .  .  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
 12241  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: s @ parser.go:1545:11
 12242  .  .  .  .  .  .  .  .  .  .  .  .  }
 12243  .  .  .  .  .  .  .  .  .  .  .  }
 12244  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 12245  .  .  .  .  .  .  .  .  .  .  }
 12246  .  .  .  .  .  .  .  .  .  .  3: *syntax.CaseClause {
 12247  .  .  .  .  .  .  .  .  .  .  .  Cases: nil
 12248  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (4 entries) {
 12249  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12250  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 12251  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: s @ parser.go:1549:4
 12252  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12253  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1549:9
 12254  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12255  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: ExprStmt @ parser.go:1549:13
 12256  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12257  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12258  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12259  .  .  .  .  .  .  .  .  .  .  .  .  }
 12260  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 12261  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12262  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12263  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1550:4
 12264  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1550:6
 12265  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12266  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12267  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12268  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: lhs @ parser.go:1550:12
 12269  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1550:16
 12270  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12271  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12272  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12273  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12274  .  .  .  .  .  .  .  .  .  .  .  .  }
 12275  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 12276  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12277  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12278  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1551:4
 12279  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:1551:6
 12280  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12281  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: lhs @ parser.go:1551:10
 12282  .  .  .  .  .  .  .  .  .  .  .  .  }
 12283  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.ReturnStmt {
 12284  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: s @ parser.go:1552:11
 12285  .  .  .  .  .  .  .  .  .  .  .  .  }
 12286  .  .  .  .  .  .  .  .  .  .  .  }
 12287  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 12288  .  .  .  .  .  .  .  .  .  .  }
 12289  .  .  .  .  .  .  .  .  .  }
 12290  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 12291  .  .  .  .  .  .  .  .  }
 12292  .  .  .  .  .  .  .  }
 12293  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 12294  .  .  .  .  .  .  }
 12295  .  .  .  .  .  .  Else: nil
 12296  .  .  .  .  .  }
 12297  .  .  .  .  .  4: *syntax.AssignStmt {
 12298  .  .  .  .  .  .  Op: :
 12299  .  .  .  .  .  .  Lhs: pos @ parser.go:1557:2
 12300  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12301  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12302  .  .  .  .  .  .  .  .  X: p @ parser.go:1557:9
 12303  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1557:11
 12304  .  .  .  .  .  .  .  }
 12305  .  .  .  .  .  .  .  ArgList: nil
 12306  .  .  .  .  .  .  .  HasDots: false
 12307  .  .  .  .  .  .  }
 12308  .  .  .  .  .  }
 12309  .  .  .  .  .  5: *syntax.SwitchStmt {
 12310  .  .  .  .  .  .  Init: nil
 12311  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 12312  .  .  .  .  .  .  .  X: p @ parser.go:1558:9
 12313  .  .  .  .  .  .  .  Sel: tok @ parser.go:1558:11
 12314  .  .  .  .  .  .  }
 12315  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 12316  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 12317  .  .  .  .  .  .  .  .  Cases: _Assign @ parser.go:1559:7
 12318  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 12319  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 12320  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12321  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12322  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1560:3
 12323  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1560:5
 12324  .  .  .  .  .  .  .  .  .  .  .  }
 12325  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12326  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12327  .  .  .  .  .  .  .  .  .  .  }
 12328  .  .  .  .  .  .  .  .  .  }
 12329  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 12330  .  .  .  .  .  .  .  .  .  .  Init: nil
 12331  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 12332  .  .  .  .  .  .  .  .  .  .  .  Op: &&
 12333  .  .  .  .  .  .  .  .  .  .  .  X: rangeOk @ parser.go:1562:6
 12334  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 12335  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 12336  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12337  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1562:17
 12338  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1562:19
 12339  .  .  .  .  .  .  .  .  .  .  .  .  }
 12340  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Range @ parser.go:1562:26
 12341  .  .  .  .  .  .  .  .  .  .  .  }
 12342  .  .  .  .  .  .  .  .  .  .  }
 12343  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 12344  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 12345  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 12346  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 12347  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12348  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1564:11
 12349  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: newRangeClause @ parser.go:1564:13
 12350  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12351  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12352  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: lhs @ parser.go:1564:28
 12353  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: false @ parser.go:1564:33
 12354  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12355  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12356  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12357  .  .  .  .  .  .  .  .  .  .  .  .  }
 12358  .  .  .  .  .  .  .  .  .  .  .  }
 12359  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 12360  .  .  .  .  .  .  .  .  .  .  }
 12361  .  .  .  .  .  .  .  .  .  .  Else: nil
 12362  .  .  .  .  .  .  .  .  .  }
 12363  .  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 12364  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 12365  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12366  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1568:10
 12367  .  .  .  .  .  .  .  .  .  .  .  .  Sel: newAssignStmt @ parser.go:1568:12
 12368  .  .  .  .  .  .  .  .  .  .  .  }
 12369  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
 12370  .  .  .  .  .  .  .  .  .  .  .  .  0: pos @ parser.go:1568:26
 12371  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
 12372  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
 12373  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
 12374  .  .  .  .  .  .  .  .  .  .  .  .  }
 12375  .  .  .  .  .  .  .  .  .  .  .  .  2: lhs @ parser.go:1568:34
 12376  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.CallExpr {
 12377  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12378  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1568:39
 12379  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList @ parser.go:1568:41
 12380  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12381  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12382  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12383  .  .  .  .  .  .  .  .  .  .  .  .  }
 12384  .  .  .  .  .  .  .  .  .  .  .  }
 12385  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12386  .  .  .  .  .  .  .  .  .  .  }
 12387  .  .  .  .  .  .  .  .  .  }
 12388  .  .  .  .  .  .  .  .  }
 12389  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 12390  .  .  .  .  .  .  .  }
 12391  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 12392  .  .  .  .  .  .  .  .  Cases: _Define @ parser.go:1570:7
 12393  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
 12394  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 12395  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12396  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12397  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1571:3
 12398  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1571:5
 12399  .  .  .  .  .  .  .  .  .  .  .  }
 12400  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12401  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12402  .  .  .  .  .  .  .  .  .  .  }
 12403  .  .  .  .  .  .  .  .  .  }
 12404  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 12405  .  .  .  .  .  .  .  .  .  .  Init: nil
 12406  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 12407  .  .  .  .  .  .  .  .  .  .  .  Op: &&
 12408  .  .  .  .  .  .  .  .  .  .  .  X: rangeOk @ parser.go:1573:6
 12409  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 12410  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 12411  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12412  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1573:17
 12413  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1573:19
 12414  .  .  .  .  .  .  .  .  .  .  .  .  }
 12415  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Range @ parser.go:1573:26
 12416  .  .  .  .  .  .  .  .  .  .  .  }
 12417  .  .  .  .  .  .  .  .  .  .  }
 12418  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 12419  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 12420  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 12421  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 12422  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12423  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1575:11
 12424  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: newRangeClause @ parser.go:1575:13
 12425  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12426  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12427  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: lhs @ parser.go:1575:28
 12428  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: true @ parser.go:1575:33
 12429  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12430  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12431  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12432  .  .  .  .  .  .  .  .  .  .  .  .  }
 12433  .  .  .  .  .  .  .  .  .  .  .  }
 12434  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 12435  .  .  .  .  .  .  .  .  .  .  }
 12436  .  .  .  .  .  .  .  .  .  .  Else: nil
 12437  .  .  .  .  .  .  .  .  .  }
 12438  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 12439  .  .  .  .  .  .  .  .  .  .  Op: :
 12440  .  .  .  .  .  .  .  .  .  .  Lhs: rhs @ parser.go:1579:3
 12441  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12442  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12443  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1579:10
 12444  .  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList @ parser.go:1579:12
 12445  .  .  .  .  .  .  .  .  .  .  .  }
 12446  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12447  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12448  .  .  .  .  .  .  .  .  .  .  }
 12449  .  .  .  .  .  .  .  .  .  }
 12450  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
 12451  .  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 12452  .  .  .  .  .  .  .  .  .  .  .  Op: :
 12453  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 12454  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 12455  .  .  .  .  .  .  .  .  .  .  .  .  .  0: x @ parser.go:1581:6
 12456  .  .  .  .  .  .  .  .  .  .  .  .  .  1: ok @ parser.go:1581:9
 12457  .  .  .  .  .  .  .  .  .  .  .  .  }
 12458  .  .  .  .  .  .  .  .  .  .  .  }
 12459  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 12460  .  .  .  .  .  .  .  .  .  .  .  .  X: rhs @ parser.go:1581:15
 12461  .  .  .  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 12462  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
 12463  .  .  .  .  .  .  .  .  .  .  .  .  .  X: TypeSwitchGuard @ parser.go:1581:21
 12464  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 12465  .  .  .  .  .  .  .  .  .  .  .  .  }
 12466  .  .  .  .  .  .  .  .  .  .  .  }
 12467  .  .  .  .  .  .  .  .  .  .  }
 12468  .  .  .  .  .  .  .  .  .  .  Cond: ok @ parser.go:1581:39
 12469  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 12470  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (5 entries) {
 12471  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SwitchStmt {
 12472  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 12473  .  .  .  .  .  .  .  .  .  .  .  .  .  Tag: *syntax.TypeSwitchGuard {
 12474  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: lhs @ parser.go:1582:11
 12475  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: lhs @ parser.go:1582:18
 12476  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12477  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 12478  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 12479  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.Operation {
 12480  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
 12481  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: Name @ parser.go:1583:10
 12482  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 12483  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12484  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 12485  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12486  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12487  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12488  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:1584:5
 12489  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Lhs @ parser.go:1584:7
 12490  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12491  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: lhs @ parser.go:1584:13
 12492  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12493  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12494  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 12495  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12496  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 12497  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.Operation {
 12498  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
 12499  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: ListExpr @ parser.go:1585:10
 12500  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 12501  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12502  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 12503  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 12504  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12505  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12506  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1586:5
 12507  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error_at @ parser.go:1586:7
 12508  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12509  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12510  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
 12511  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12512  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: lhs @ parser.go:1586:16
 12513  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1586:20
 12514  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12515  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12516  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12517  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12518  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 12519  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12520  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt @ parser.go:1586:27
 12521  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf @ parser.go:1586:31
 12522  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12523  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12524  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 12525  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"cannot assign 1 value to %d variables\""
 12526  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 12527  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12528  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 12529  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: len @ parser.go:1586:80
 12530  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12531  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 12532  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: lhs @ parser.go:1586:84
 12533  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: ElemList @ parser.go:1586:88
 12534  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12535  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12536  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12537  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12538  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12539  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12540  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12541  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12542  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12543  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12544  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12545  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 12546  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 12547  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 12548  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 12549  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 12550  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: lhs @ parser.go:1588:8
 12551  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: ok @ parser.go:1588:13
 12552  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12553  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12554  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 12555  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.IndexExpr {
 12556  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12557  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: lhs @ parser.go:1588:19
 12558  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: ElemList @ parser.go:1588:23
 12559  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12560  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.BasicLit {
 12561  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
 12562  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
 12563  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12564  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12565  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 12566  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
 12567  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: Name @ parser.go:1588:37
 12568  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 12569  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12570  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12571  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12572  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: ok @ parser.go:1588:44
 12573  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 12574  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 12575  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12576  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12577  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12578  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:1589:6
 12579  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Lhs @ parser.go:1589:8
 12580  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12581  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: lhs @ parser.go:1589:14
 12582  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12583  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12584  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 12585  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12586  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
 12587  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12588  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12589  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 12590  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12591  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 12592  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: nil
 12593  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 12594  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 12595  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12596  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12597  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1592:5
 12598  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: error_at @ parser.go:1592:7
 12599  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12600  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12601  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
 12602  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12603  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: lhs @ parser.go:1592:16
 12604  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1592:20
 12605  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12606  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12607  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12608  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12609  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 12610  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12611  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt @ parser.go:1592:27
 12612  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf @ parser.go:1592:31
 12613  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12614  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12615  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 12616  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"invalid variable name %s in type switch\""
 12617  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 12618  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12619  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 12620  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: String @ parser.go:1592:82
 12621  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12622  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: lhs @ parser.go:1592:89
 12623  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12624  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12625  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12626  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12627  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12628  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12629  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12630  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12631  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12632  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12633  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12634  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 12635  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12636  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12637  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 12638  .  .  .  .  .  .  .  .  .  .  .  .  }
 12639  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 12640  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 12641  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: s @ parser.go:1594:4
 12642  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12643  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1594:9
 12644  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12645  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: ExprStmt @ parser.go:1594:13
 12646  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12647  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12648  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12649  .  .  .  .  .  .  .  .  .  .  .  .  }
 12650  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 12651  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12652  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12653  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1595:4
 12654  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1595:6
 12655  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12656  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12657  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12658  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:1595:12
 12659  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1595:14
 12660  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12661  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12662  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12663  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12664  .  .  .  .  .  .  .  .  .  .  .  .  }
 12665  .  .  .  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
 12666  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12667  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12668  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1596:4
 12669  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:1596:6
 12670  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12671  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: x @ parser.go:1596:10
 12672  .  .  .  .  .  .  .  .  .  .  .  .  }
 12673  .  .  .  .  .  .  .  .  .  .  .  .  4: *syntax.ReturnStmt {
 12674  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: s @ parser.go:1597:11
 12675  .  .  .  .  .  .  .  .  .  .  .  .  }
 12676  .  .  .  .  .  .  .  .  .  .  .  }
 12677  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 12678  .  .  .  .  .  .  .  .  .  .  }
 12679  .  .  .  .  .  .  .  .  .  .  Else: nil
 12680  .  .  .  .  .  .  .  .  .  }
 12681  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
 12682  .  .  .  .  .  .  .  .  .  .  Op: :
 12683  .  .  .  .  .  .  .  .  .  .  Lhs: as @ parser.go:1600:3
 12684  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12685  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12686  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1600:9
 12687  .  .  .  .  .  .  .  .  .  .  .  .  Sel: newAssignStmt @ parser.go:1600:11
 12688  .  .  .  .  .  .  .  .  .  .  .  }
 12689  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
 12690  .  .  .  .  .  .  .  .  .  .  .  .  0: pos @ parser.go:1600:25
 12691  .  .  .  .  .  .  .  .  .  .  .  .  1: Def @ parser.go:1600:30
 12692  .  .  .  .  .  .  .  .  .  .  .  .  2: lhs @ parser.go:1600:35
 12693  .  .  .  .  .  .  .  .  .  .  .  .  3: rhs @ parser.go:1600:40
 12694  .  .  .  .  .  .  .  .  .  .  .  }
 12695  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12696  .  .  .  .  .  .  .  .  .  .  }
 12697  .  .  .  .  .  .  .  .  .  }
 12698  .  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
 12699  .  .  .  .  .  .  .  .  .  .  Results: as @ parser.go:1601:10
 12700  .  .  .  .  .  .  .  .  .  }
 12701  .  .  .  .  .  .  .  .  }
 12702  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 12703  .  .  .  .  .  .  .  }
 12704  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 12705  .  .  .  .  .  .  .  .  Cases: nil
 12706  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (7 entries) {
 12707  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 12708  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12709  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12710  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1604:3
 12711  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1604:5
 12712  .  .  .  .  .  .  .  .  .  .  .  }
 12713  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12714  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 12715  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting := or = or comma\""
 12716  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 12717  .  .  .  .  .  .  .  .  .  .  .  .  }
 12718  .  .  .  .  .  .  .  .  .  .  .  }
 12719  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12720  .  .  .  .  .  .  .  .  .  .  }
 12721  .  .  .  .  .  .  .  .  .  }
 12722  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 12723  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 12724  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12725  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1605:3
 12726  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:1605:5
 12727  .  .  .  .  .  .  .  .  .  .  .  }
 12728  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 12729  .  .  .  .  .  .  .  .  .  .  .  .  0: _Semi @ parser.go:1605:13
 12730  .  .  .  .  .  .  .  .  .  .  .  .  1: _Rbrace @ parser.go:1605:20
 12731  .  .  .  .  .  .  .  .  .  .  .  }
 12732  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12733  .  .  .  .  .  .  .  .  .  .  }
 12734  .  .  .  .  .  .  .  .  .  }
 12735  .  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
 12736  .  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 12737  .  .  .  .  .  .  .  .  .  .  .  Op: :
 12738  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 12739  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 12740  .  .  .  .  .  .  .  .  .  .  .  .  .  0: x @ parser.go:1607:6
 12741  .  .  .  .  .  .  .  .  .  .  .  .  .  1: ok @ parser.go:1607:9
 12742  .  .  .  .  .  .  .  .  .  .  .  .  }
 12743  .  .  .  .  .  .  .  .  .  .  .  }
 12744  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 12745  .  .  .  .  .  .  .  .  .  .  .  .  X: lhs @ parser.go:1607:15
 12746  .  .  .  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 12747  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
 12748  .  .  .  .  .  .  .  .  .  .  .  .  .  X: ListExpr @ parser.go:1607:21
 12749  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 12750  .  .  .  .  .  .  .  .  .  .  .  .  }
 12751  .  .  .  .  .  .  .  .  .  .  .  }
 12752  .  .  .  .  .  .  .  .  .  .  }
 12753  .  .  .  .  .  .  .  .  .  .  Cond: ok @ parser.go:1607:32
 12754  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 12755  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 12756  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 12757  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12758  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: lhs @ parser.go:1608:4
 12759  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.IndexExpr {
 12760  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 12761  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:1608:10
 12762  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: ElemList @ parser.go:1608:12
 12763  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12764  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Index: *syntax.BasicLit {
 12765  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "0"
 12766  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 0
 12767  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12768  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 12769  .  .  .  .  .  .  .  .  .  .  .  .  }
 12770  .  .  .  .  .  .  .  .  .  .  .  }
 12771  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 12772  .  .  .  .  .  .  .  .  .  .  }
 12773  .  .  .  .  .  .  .  .  .  .  Else: nil
 12774  .  .  .  .  .  .  .  .  .  }
 12775  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
 12776  .  .  .  .  .  .  .  .  .  .  Op: :
 12777  .  .  .  .  .  .  .  .  .  .  Lhs: s @ parser.go:1610:3
 12778  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12779  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1610:8
 12780  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12781  .  .  .  .  .  .  .  .  .  .  .  .  0: ExprStmt @ parser.go:1610:12
 12782  .  .  .  .  .  .  .  .  .  .  .  }
 12783  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12784  .  .  .  .  .  .  .  .  .  .  }
 12785  .  .  .  .  .  .  .  .  .  }
 12786  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
 12787  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12788  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12789  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1611:3
 12790  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1611:5
 12791  .  .  .  .  .  .  .  .  .  .  }
 12792  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12793  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12794  .  .  .  .  .  .  .  .  .  .  .  .  X: lhs @ parser.go:1611:11
 12795  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1611:15
 12796  .  .  .  .  .  .  .  .  .  .  .  }
 12797  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 12798  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 12799  .  .  .  .  .  .  .  .  .  .  }
 12800  .  .  .  .  .  .  .  .  .  }
 12801  .  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
 12802  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 12803  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12804  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1612:3
 12805  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:1612:5
 12806  .  .  .  .  .  .  .  .  .  .  }
 12807  .  .  .  .  .  .  .  .  .  .  Rhs: lhs @ parser.go:1612:9
 12808  .  .  .  .  .  .  .  .  .  }
 12809  .  .  .  .  .  .  .  .  .  6: *syntax.ReturnStmt {
 12810  .  .  .  .  .  .  .  .  .  .  Results: s @ parser.go:1613:10
 12811  .  .  .  .  .  .  .  .  .  }
 12812  .  .  .  .  .  .  .  .  }
 12813  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 12814  .  .  .  .  .  .  .  }
 12815  .  .  .  .  .  .  }
 12816  .  .  .  .  .  .  Rbrace: src.Pos {}
 12817  .  .  .  .  .  }
 12818  .  .  .  .  }
 12819  .  .  .  .  Rbrace: src.Pos {}
 12820  .  .  .  }
 12821  .  .  .  Pragma: 0
 12822  .  .  }
 12823  .  .  59: *syntax.FuncDecl {
 12824  .  .  .  Attr: map[]
 12825  .  .  .  Recv: *syntax.Field {
 12826  .  .  .  .  Name: p @ parser.go:1617:7
 12827  .  .  .  .  Type: *syntax.Operation {
 12828  .  .  .  .  .  Op: *
 12829  .  .  .  .  .  X: parser @ parser.go:1617:10
 12830  .  .  .  .  .  Y: nil
 12831  .  .  .  .  }
 12832  .  .  .  }
 12833  .  .  .  Name: newRangeClause @ parser.go:1617:18
 12834  .  .  .  Type: *syntax.FuncType {
 12835  .  .  .  .  ParamList: []*syntax.Field (2 entries) {
 12836  .  .  .  .  .  0: *syntax.Field {
 12837  .  .  .  .  .  .  Name: lhs @ parser.go:1617:33
 12838  .  .  .  .  .  .  Type: Expr @ parser.go:1617:37
 12839  .  .  .  .  .  }
 12840  .  .  .  .  .  1: *syntax.Field {
 12841  .  .  .  .  .  .  Name: def @ parser.go:1617:43
 12842  .  .  .  .  .  .  Type: bool @ parser.go:1617:47
 12843  .  .  .  .  .  }
 12844  .  .  .  .  }
 12845  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 12846  .  .  .  .  .  0: *syntax.Field {
 12847  .  .  .  .  .  .  Name: nil
 12848  .  .  .  .  .  .  Type: *syntax.Operation {
 12849  .  .  .  .  .  .  .  Op: *
 12850  .  .  .  .  .  .  .  X: RangeClause @ parser.go:1617:54
 12851  .  .  .  .  .  .  .  Y: nil
 12852  .  .  .  .  .  .  }
 12853  .  .  .  .  .  }
 12854  .  .  .  .  }
 12855  .  .  .  }
 12856  .  .  .  Body: *syntax.BlockStmt {
 12857  .  .  .  .  List: []syntax.Stmt (7 entries) {
 12858  .  .  .  .  .  0: *syntax.AssignStmt {
 12859  .  .  .  .  .  .  Op: :
 12860  .  .  .  .  .  .  Lhs: r @ parser.go:1618:2
 12861  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12862  .  .  .  .  .  .  .  Fun: new @ parser.go:1618:7
 12863  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12864  .  .  .  .  .  .  .  .  0: RangeClause @ parser.go:1618:11
 12865  .  .  .  .  .  .  .  }
 12866  .  .  .  .  .  .  .  HasDots: false
 12867  .  .  .  .  .  .  }
 12868  .  .  .  .  .  }
 12869  .  .  .  .  .  1: *syntax.AssignStmt {
 12870  .  .  .  .  .  .  Op: <op-0>
 12871  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12872  .  .  .  .  .  .  .  X: r @ parser.go:1619:2
 12873  .  .  .  .  .  .  .  Sel: pos @ parser.go:1619:4
 12874  .  .  .  .  .  .  }
 12875  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12876  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12877  .  .  .  .  .  .  .  .  X: p @ parser.go:1619:10
 12878  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1619:12
 12879  .  .  .  .  .  .  .  }
 12880  .  .  .  .  .  .  .  ArgList: nil
 12881  .  .  .  .  .  .  .  HasDots: false
 12882  .  .  .  .  .  .  }
 12883  .  .  .  .  .  }
 12884  .  .  .  .  .  2: *syntax.ExprStmt {
 12885  .  .  .  .  .  .  X: *syntax.CallExpr {
 12886  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12887  .  .  .  .  .  .  .  .  X: p @ parser.go:1620:2
 12888  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1620:4
 12889  .  .  .  .  .  .  .  }
 12890  .  .  .  .  .  .  .  ArgList: nil
 12891  .  .  .  .  .  .  .  HasDots: false
 12892  .  .  .  .  .  .  }
 12893  .  .  .  .  .  }
 12894  .  .  .  .  .  3: *syntax.AssignStmt {
 12895  .  .  .  .  .  .  Op: <op-0>
 12896  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12897  .  .  .  .  .  .  .  X: r @ parser.go:1621:2
 12898  .  .  .  .  .  .  .  Sel: Lhs @ parser.go:1621:4
 12899  .  .  .  .  .  .  }
 12900  .  .  .  .  .  .  Rhs: lhs @ parser.go:1621:10
 12901  .  .  .  .  .  }
 12902  .  .  .  .  .  4: *syntax.AssignStmt {
 12903  .  .  .  .  .  .  Op: <op-0>
 12904  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12905  .  .  .  .  .  .  .  X: r @ parser.go:1622:2
 12906  .  .  .  .  .  .  .  Sel: Def @ parser.go:1622:4
 12907  .  .  .  .  .  .  }
 12908  .  .  .  .  .  .  Rhs: def @ parser.go:1622:10
 12909  .  .  .  .  .  }
 12910  .  .  .  .  .  5: *syntax.AssignStmt {
 12911  .  .  .  .  .  .  Op: <op-0>
 12912  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12913  .  .  .  .  .  .  .  X: r @ parser.go:1623:2
 12914  .  .  .  .  .  .  .  Sel: X @ parser.go:1623:4
 12915  .  .  .  .  .  .  }
 12916  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12917  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 12918  .  .  .  .  .  .  .  .  X: p @ parser.go:1623:8
 12919  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:1623:10
 12920  .  .  .  .  .  .  .  }
 12921  .  .  .  .  .  .  .  ArgList: nil
 12922  .  .  .  .  .  .  .  HasDots: false
 12923  .  .  .  .  .  .  }
 12924  .  .  .  .  .  }
 12925  .  .  .  .  .  6: *syntax.ReturnStmt {
 12926  .  .  .  .  .  .  Results: r @ parser.go:1624:9
 12927  .  .  .  .  .  }
 12928  .  .  .  .  }
 12929  .  .  .  .  Rbrace: src.Pos {}
 12930  .  .  .  }
 12931  .  .  .  Pragma: 0
 12932  .  .  }
 12933  .  .  60: *syntax.FuncDecl {
 12934  .  .  .  Attr: map[]
 12935  .  .  .  Recv: *syntax.Field {
 12936  .  .  .  .  Name: p @ parser.go:1627:7
 12937  .  .  .  .  Type: *syntax.Operation {
 12938  .  .  .  .  .  Op: *
 12939  .  .  .  .  .  X: parser @ parser.go:1627:10
 12940  .  .  .  .  .  Y: nil
 12941  .  .  .  .  }
 12942  .  .  .  }
 12943  .  .  .  Name: newAssignStmt @ parser.go:1627:18
 12944  .  .  .  Type: *syntax.FuncType {
 12945  .  .  .  .  ParamList: []*syntax.Field (4 entries) {
 12946  .  .  .  .  .  0: *syntax.Field {
 12947  .  .  .  .  .  .  Name: pos @ parser.go:1627:32
 12948  .  .  .  .  .  .  Type: *syntax.SelectorExpr {
 12949  .  .  .  .  .  .  .  X: src @ parser.go:1627:36
 12950  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1627:40
 12951  .  .  .  .  .  .  }
 12952  .  .  .  .  .  }
 12953  .  .  .  .  .  1: *syntax.Field {
 12954  .  .  .  .  .  .  Name: op @ parser.go:1627:45
 12955  .  .  .  .  .  .  Type: Operator @ parser.go:1627:48
 12956  .  .  .  .  .  }
 12957  .  .  .  .  .  2: *syntax.Field {
 12958  .  .  .  .  .  .  Name: lhs @ parser.go:1627:58
 12959  .  .  .  .  .  .  Type: Expr @ parser.go:1627:67
 12960  .  .  .  .  .  }
 12961  .  .  .  .  .  3: *syntax.Field {
 12962  .  .  .  .  .  .  Name: rhs @ parser.go:1627:63
 12963  .  .  .  .  .  .  Type: Expr @ parser.go:1627:67
 12964  .  .  .  .  .  }
 12965  .  .  .  .  }
 12966  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 12967  .  .  .  .  .  0: *syntax.Field {
 12968  .  .  .  .  .  .  Name: nil
 12969  .  .  .  .  .  .  Type: *syntax.Operation {
 12970  .  .  .  .  .  .  .  Op: *
 12971  .  .  .  .  .  .  .  X: AssignStmt @ parser.go:1627:74
 12972  .  .  .  .  .  .  .  Y: nil
 12973  .  .  .  .  .  .  }
 12974  .  .  .  .  .  }
 12975  .  .  .  .  }
 12976  .  .  .  }
 12977  .  .  .  Body: *syntax.BlockStmt {
 12978  .  .  .  .  List: []syntax.Stmt (6 entries) {
 12979  .  .  .  .  .  0: *syntax.AssignStmt {
 12980  .  .  .  .  .  .  Op: :
 12981  .  .  .  .  .  .  Lhs: a @ parser.go:1628:2
 12982  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 12983  .  .  .  .  .  .  .  Fun: new @ parser.go:1628:7
 12984  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 12985  .  .  .  .  .  .  .  .  0: AssignStmt @ parser.go:1628:11
 12986  .  .  .  .  .  .  .  }
 12987  .  .  .  .  .  .  .  HasDots: false
 12988  .  .  .  .  .  .  }
 12989  .  .  .  .  .  }
 12990  .  .  .  .  .  1: *syntax.AssignStmt {
 12991  .  .  .  .  .  .  Op: <op-0>
 12992  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 12993  .  .  .  .  .  .  .  X: a @ parser.go:1629:2
 12994  .  .  .  .  .  .  .  Sel: pos @ parser.go:1629:4
 12995  .  .  .  .  .  .  }
 12996  .  .  .  .  .  .  Rhs: pos @ parser.go:1629:10
 12997  .  .  .  .  .  }
 12998  .  .  .  .  .  2: *syntax.AssignStmt {
 12999  .  .  .  .  .  .  Op: <op-0>
 13000  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13001  .  .  .  .  .  .  .  X: a @ parser.go:1630:2
 13002  .  .  .  .  .  .  .  Sel: Op @ parser.go:1630:4
 13003  .  .  .  .  .  .  }
 13004  .  .  .  .  .  .  Rhs: op @ parser.go:1630:9
 13005  .  .  .  .  .  }
 13006  .  .  .  .  .  3: *syntax.AssignStmt {
 13007  .  .  .  .  .  .  Op: <op-0>
 13008  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13009  .  .  .  .  .  .  .  X: a @ parser.go:1631:2
 13010  .  .  .  .  .  .  .  Sel: Lhs @ parser.go:1631:4
 13011  .  .  .  .  .  .  }
 13012  .  .  .  .  .  .  Rhs: lhs @ parser.go:1631:10
 13013  .  .  .  .  .  }
 13014  .  .  .  .  .  4: *syntax.AssignStmt {
 13015  .  .  .  .  .  .  Op: <op-0>
 13016  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13017  .  .  .  .  .  .  .  X: a @ parser.go:1632:2
 13018  .  .  .  .  .  .  .  Sel: Rhs @ parser.go:1632:4
 13019  .  .  .  .  .  .  }
 13020  .  .  .  .  .  .  Rhs: rhs @ parser.go:1632:10
 13021  .  .  .  .  .  }
 13022  .  .  .  .  .  5: *syntax.ReturnStmt {
 13023  .  .  .  .  .  .  Results: a @ parser.go:1633:9
 13024  .  .  .  .  .  }
 13025  .  .  .  .  }
 13026  .  .  .  .  Rbrace: src.Pos {}
 13027  .  .  .  }
 13028  .  .  .  Pragma: 0
 13029  .  .  }
 13030  .  .  61: *syntax.FuncDecl {
 13031  .  .  .  Attr: map[]
 13032  .  .  .  Recv: *syntax.Field {
 13033  .  .  .  .  Name: p @ parser.go:1636:7
 13034  .  .  .  .  Type: *syntax.Operation {
 13035  .  .  .  .  .  Op: *
 13036  .  .  .  .  .  X: parser @ parser.go:1636:10
 13037  .  .  .  .  .  Y: nil
 13038  .  .  .  .  }
 13039  .  .  .  }
 13040  .  .  .  Name: labeledStmtOrNil @ parser.go:1636:18
 13041  .  .  .  Type: *syntax.FuncType {
 13042  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 13043  .  .  .  .  .  0: *syntax.Field {
 13044  .  .  .  .  .  .  Name: label @ parser.go:1636:35
 13045  .  .  .  .  .  .  Type: *syntax.Operation {
 13046  .  .  .  .  .  .  .  Op: *
 13047  .  .  .  .  .  .  .  X: Name @ parser.go:1636:42
 13048  .  .  .  .  .  .  .  Y: nil
 13049  .  .  .  .  .  .  }
 13050  .  .  .  .  .  }
 13051  .  .  .  .  }
 13052  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 13053  .  .  .  .  .  0: *syntax.Field {
 13054  .  .  .  .  .  .  Name: nil
 13055  .  .  .  .  .  .  Type: Stmt @ parser.go:1636:48
 13056  .  .  .  .  .  }
 13057  .  .  .  .  }
 13058  .  .  .  }
 13059  .  .  .  Body: *syntax.BlockStmt {
 13060  .  .  .  .  List: []syntax.Stmt (10 entries) {
 13061  .  .  .  .  .  0: *syntax.IfStmt {
 13062  .  .  .  .  .  .  Init: nil
 13063  .  .  .  .  .  .  Cond: trace @ parser.go:1637:5
 13064  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 13065  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 13066  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 13067  .  .  .  .  .  .  .  .  .  Tok: defer
 13068  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 13069  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 13070  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13071  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1638:9
 13072  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1638:11
 13073  .  .  .  .  .  .  .  .  .  .  .  }
 13074  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13075  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 13076  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"labeledStmt\""
 13077  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13078  .  .  .  .  .  .  .  .  .  .  .  .  }
 13079  .  .  .  .  .  .  .  .  .  .  .  }
 13080  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13081  .  .  .  .  .  .  .  .  .  .  }
 13082  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13083  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13084  .  .  .  .  .  .  .  .  .  }
 13085  .  .  .  .  .  .  .  .  }
 13086  .  .  .  .  .  .  .  }
 13087  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 13088  .  .  .  .  .  .  }
 13089  .  .  .  .  .  .  Else: nil
 13090  .  .  .  .  .  }
 13091  .  .  .  .  .  1: *syntax.AssignStmt {
 13092  .  .  .  .  .  .  Op: :
 13093  .  .  .  .  .  .  Lhs: s @ parser.go:1641:2
 13094  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13095  .  .  .  .  .  .  .  Fun: new @ parser.go:1641:7
 13096  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13097  .  .  .  .  .  .  .  .  0: LabeledStmt @ parser.go:1641:11
 13098  .  .  .  .  .  .  .  }
 13099  .  .  .  .  .  .  .  HasDots: false
 13100  .  .  .  .  .  .  }
 13101  .  .  .  .  .  }
 13102  .  .  .  .  .  2: *syntax.AssignStmt {
 13103  .  .  .  .  .  .  Op: <op-0>
 13104  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13105  .  .  .  .  .  .  .  X: s @ parser.go:1642:2
 13106  .  .  .  .  .  .  .  Sel: pos @ parser.go:1642:4
 13107  .  .  .  .  .  .  }
 13108  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13109  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13110  .  .  .  .  .  .  .  .  X: p @ parser.go:1642:10
 13111  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1642:12
 13112  .  .  .  .  .  .  .  }
 13113  .  .  .  .  .  .  .  ArgList: nil
 13114  .  .  .  .  .  .  .  HasDots: false
 13115  .  .  .  .  .  .  }
 13116  .  .  .  .  .  }
 13117  .  .  .  .  .  3: *syntax.AssignStmt {
 13118  .  .  .  .  .  .  Op: <op-0>
 13119  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13120  .  .  .  .  .  .  .  X: s @ parser.go:1643:2
 13121  .  .  .  .  .  .  .  Sel: Label @ parser.go:1643:4
 13122  .  .  .  .  .  .  }
 13123  .  .  .  .  .  .  Rhs: label @ parser.go:1643:12
 13124  .  .  .  .  .  }
 13125  .  .  .  .  .  4: *syntax.ExprStmt {
 13126  .  .  .  .  .  .  X: *syntax.CallExpr {
 13127  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13128  .  .  .  .  .  .  .  .  X: p @ parser.go:1645:2
 13129  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1645:4
 13130  .  .  .  .  .  .  .  }
 13131  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13132  .  .  .  .  .  .  .  .  0: _Colon @ parser.go:1645:9
 13133  .  .  .  .  .  .  .  }
 13134  .  .  .  .  .  .  .  HasDots: false
 13135  .  .  .  .  .  .  }
 13136  .  .  .  .  .  }
 13137  .  .  .  .  .  5: *syntax.IfStmt {
 13138  .  .  .  .  .  .  Init: nil
 13139  .  .  .  .  .  .  Cond: *syntax.Operation {
 13140  .  .  .  .  .  .  .  Op: ==
 13141  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 13142  .  .  .  .  .  .  .  .  X: p @ parser.go:1647:5
 13143  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1647:7
 13144  .  .  .  .  .  .  .  }
 13145  .  .  .  .  .  .  .  Y: _Rbrace @ parser.go:1647:14
 13146  .  .  .  .  .  .  }
 13147  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 13148  .  .  .  .  .  .  .  List: []syntax.Stmt (4 entries) {
 13149  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 13150  .  .  .  .  .  .  .  .  .  Op: :
 13151  .  .  .  .  .  .  .  .  .  Lhs: e @ parser.go:1651:3
 13152  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13153  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1651:8
 13154  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13155  .  .  .  .  .  .  .  .  .  .  .  0: EmptyStmt @ parser.go:1651:12
 13156  .  .  .  .  .  .  .  .  .  .  }
 13157  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13158  .  .  .  .  .  .  .  .  .  }
 13159  .  .  .  .  .  .  .  .  }
 13160  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 13161  .  .  .  .  .  .  .  .  .  Op: <op-0>
 13162  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13163  .  .  .  .  .  .  .  .  .  .  X: e @ parser.go:1652:3
 13164  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1652:5
 13165  .  .  .  .  .  .  .  .  .  }
 13166  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13167  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13168  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1652:11
 13169  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1652:13
 13170  .  .  .  .  .  .  .  .  .  .  }
 13171  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13172  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13173  .  .  .  .  .  .  .  .  .  }
 13174  .  .  .  .  .  .  .  .  }
 13175  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 13176  .  .  .  .  .  .  .  .  .  Op: <op-0>
 13177  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13178  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1653:3
 13179  .  .  .  .  .  .  .  .  .  .  Sel: Stmt @ parser.go:1653:5
 13180  .  .  .  .  .  .  .  .  .  }
 13181  .  .  .  .  .  .  .  .  .  Rhs: e @ parser.go:1653:12
 13182  .  .  .  .  .  .  .  .  }
 13183  .  .  .  .  .  .  .  .  3: *syntax.ReturnStmt {
 13184  .  .  .  .  .  .  .  .  .  Results: s @ parser.go:1654:10
 13185  .  .  .  .  .  .  .  .  }
 13186  .  .  .  .  .  .  .  }
 13187  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 13188  .  .  .  .  .  .  }
 13189  .  .  .  .  .  .  Else: nil
 13190  .  .  .  .  .  }
 13191  .  .  .  .  .  6: *syntax.AssignStmt {
 13192  .  .  .  .  .  .  Op: <op-0>
 13193  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13194  .  .  .  .  .  .  .  X: s @ parser.go:1657:2
 13195  .  .  .  .  .  .  .  Sel: Stmt @ parser.go:1657:4
 13196  .  .  .  .  .  .  }
 13197  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13198  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13199  .  .  .  .  .  .  .  .  X: p @ parser.go:1657:11
 13200  .  .  .  .  .  .  .  .  Sel: stmtOrNil @ parser.go:1657:13
 13201  .  .  .  .  .  .  .  }
 13202  .  .  .  .  .  .  .  ArgList: nil
 13203  .  .  .  .  .  .  .  HasDots: false
 13204  .  .  .  .  .  .  }
 13205  .  .  .  .  .  }
 13206  .  .  .  .  .  7: *syntax.IfStmt {
 13207  .  .  .  .  .  .  Init: nil
 13208  .  .  .  .  .  .  Cond: *syntax.Operation {
 13209  .  .  .  .  .  .  .  Op: !=
 13210  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 13211  .  .  .  .  .  .  .  .  X: s @ parser.go:1658:5
 13212  .  .  .  .  .  .  .  .  Sel: Stmt @ parser.go:1658:7
 13213  .  .  .  .  .  .  .  }
 13214  .  .  .  .  .  .  .  Y: nil @ parser.go:1658:15
 13215  .  .  .  .  .  .  }
 13216  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 13217  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 13218  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 13219  .  .  .  .  .  .  .  .  .  Results: s @ parser.go:1659:10
 13220  .  .  .  .  .  .  .  .  }
 13221  .  .  .  .  .  .  .  }
 13222  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 13223  .  .  .  .  .  .  }
 13224  .  .  .  .  .  .  Else: nil
 13225  .  .  .  .  .  }
 13226  .  .  .  .  .  8: *syntax.ExprStmt {
 13227  .  .  .  .  .  .  X: *syntax.CallExpr {
 13228  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13229  .  .  .  .  .  .  .  .  X: p @ parser.go:1663:2
 13230  .  .  .  .  .  .  .  .  Sel: syntax_error_at @ parser.go:1663:4
 13231  .  .  .  .  .  .  .  }
 13232  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 13233  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 13234  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1663:20
 13235  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1663:22
 13236  .  .  .  .  .  .  .  .  }
 13237  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
 13238  .  .  .  .  .  .  .  .  .  Value: "\"missing statement after label\""
 13239  .  .  .  .  .  .  .  .  .  Kind: 4
 13240  .  .  .  .  .  .  .  .  }
 13241  .  .  .  .  .  .  .  }
 13242  .  .  .  .  .  .  .  HasDots: false
 13243  .  .  .  .  .  .  }
 13244  .  .  .  .  .  }
 13245  .  .  .  .  .  9: *syntax.ReturnStmt {
 13246  .  .  .  .  .  .  Results: nil @ parser.go:1665:9
 13247  .  .  .  .  .  }
 13248  .  .  .  .  }
 13249  .  .  .  .  Rbrace: src.Pos {}
 13250  .  .  .  }
 13251  .  .  .  Pragma: 0
 13252  .  .  }
 13253  .  .  62: *syntax.FuncDecl {
 13254  .  .  .  Attr: map[]
 13255  .  .  .  Recv: *syntax.Field {
 13256  .  .  .  .  Name: p @ parser.go:1668:7
 13257  .  .  .  .  Type: *syntax.Operation {
 13258  .  .  .  .  .  Op: *
 13259  .  .  .  .  .  X: parser @ parser.go:1668:10
 13260  .  .  .  .  .  Y: nil
 13261  .  .  .  .  }
 13262  .  .  .  }
 13263  .  .  .  Name: blockStmt @ parser.go:1668:18
 13264  .  .  .  Type: *syntax.FuncType {
 13265  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 13266  .  .  .  .  .  0: *syntax.Field {
 13267  .  .  .  .  .  .  Name: context @ parser.go:1668:28
 13268  .  .  .  .  .  .  Type: string @ parser.go:1668:36
 13269  .  .  .  .  .  }
 13270  .  .  .  .  }
 13271  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 13272  .  .  .  .  .  0: *syntax.Field {
 13273  .  .  .  .  .  .  Name: nil
 13274  .  .  .  .  .  .  Type: *syntax.Operation {
 13275  .  .  .  .  .  .  .  Op: *
 13276  .  .  .  .  .  .  .  X: BlockStmt @ parser.go:1668:45
 13277  .  .  .  .  .  .  .  Y: nil
 13278  .  .  .  .  .  .  }
 13279  .  .  .  .  .  }
 13280  .  .  .  .  }
 13281  .  .  .  }
 13282  .  .  .  Body: *syntax.BlockStmt {
 13283  .  .  .  .  List: []syntax.Stmt (8 entries) {
 13284  .  .  .  .  .  0: *syntax.IfStmt {
 13285  .  .  .  .  .  .  Init: nil
 13286  .  .  .  .  .  .  Cond: trace @ parser.go:1669:5
 13287  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 13288  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 13289  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 13290  .  .  .  .  .  .  .  .  .  Tok: defer
 13291  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 13292  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 13293  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13294  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1670:9
 13295  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1670:11
 13296  .  .  .  .  .  .  .  .  .  .  .  }
 13297  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13298  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 13299  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"blockStmt\""
 13300  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13301  .  .  .  .  .  .  .  .  .  .  .  .  }
 13302  .  .  .  .  .  .  .  .  .  .  .  }
 13303  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13304  .  .  .  .  .  .  .  .  .  .  }
 13305  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13306  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13307  .  .  .  .  .  .  .  .  .  }
 13308  .  .  .  .  .  .  .  .  }
 13309  .  .  .  .  .  .  .  }
 13310  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 13311  .  .  .  .  .  .  }
 13312  .  .  .  .  .  .  Else: nil
 13313  .  .  .  .  .  }
 13314  .  .  .  .  .  1: *syntax.AssignStmt {
 13315  .  .  .  .  .  .  Op: :
 13316  .  .  .  .  .  .  Lhs: s @ parser.go:1673:2
 13317  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13318  .  .  .  .  .  .  .  Fun: new @ parser.go:1673:7
 13319  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13320  .  .  .  .  .  .  .  .  0: BlockStmt @ parser.go:1673:11
 13321  .  .  .  .  .  .  .  }
 13322  .  .  .  .  .  .  .  HasDots: false
 13323  .  .  .  .  .  .  }
 13324  .  .  .  .  .  }
 13325  .  .  .  .  .  2: *syntax.AssignStmt {
 13326  .  .  .  .  .  .  Op: <op-0>
 13327  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13328  .  .  .  .  .  .  .  X: s @ parser.go:1674:2
 13329  .  .  .  .  .  .  .  Sel: pos @ parser.go:1674:4
 13330  .  .  .  .  .  .  }
 13331  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13332  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13333  .  .  .  .  .  .  .  .  X: p @ parser.go:1674:10
 13334  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1674:12
 13335  .  .  .  .  .  .  .  }
 13336  .  .  .  .  .  .  .  ArgList: nil
 13337  .  .  .  .  .  .  .  HasDots: false
 13338  .  .  .  .  .  .  }
 13339  .  .  .  .  .  }
 13340  .  .  .  .  .  3: *syntax.IfStmt {
 13341  .  .  .  .  .  .  Init: nil
 13342  .  .  .  .  .  .  Cond: *syntax.Operation {
 13343  .  .  .  .  .  .  .  Op: !
 13344  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13345  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13346  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1676:6
 13347  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:1676:8
 13348  .  .  .  .  .  .  .  .  }
 13349  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13350  .  .  .  .  .  .  .  .  .  0: _Lbrace @ parser.go:1676:12
 13351  .  .  .  .  .  .  .  .  }
 13352  .  .  .  .  .  .  .  .  HasDots: false
 13353  .  .  .  .  .  .  .  }
 13354  .  .  .  .  .  .  .  Y: nil
 13355  .  .  .  .  .  .  }
 13356  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 13357  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 13358  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13359  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13360  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13361  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1677:3
 13362  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1677:5
 13363  .  .  .  .  .  .  .  .  .  .  }
 13364  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13365  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
 13366  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
 13367  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
 13368  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting { after \""
 13369  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13370  .  .  .  .  .  .  .  .  .  .  .  .  }
 13371  .  .  .  .  .  .  .  .  .  .  .  .  Y: context @ parser.go:1677:41
 13372  .  .  .  .  .  .  .  .  .  .  .  }
 13373  .  .  .  .  .  .  .  .  .  .  }
 13374  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13375  .  .  .  .  .  .  .  .  .  }
 13376  .  .  .  .  .  .  .  .  }
 13377  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 13378  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13379  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13380  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1678:3
 13381  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:1678:5
 13382  .  .  .  .  .  .  .  .  .  .  }
 13383  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 13384  .  .  .  .  .  .  .  .  .  .  .  0: _Name @ parser.go:1678:13
 13385  .  .  .  .  .  .  .  .  .  .  .  1: _Rbrace @ parser.go:1678:20
 13386  .  .  .  .  .  .  .  .  .  .  }
 13387  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13388  .  .  .  .  .  .  .  .  .  }
 13389  .  .  .  .  .  .  .  .  }
 13390  .  .  .  .  .  .  .  }
 13391  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 13392  .  .  .  .  .  .  }
 13393  .  .  .  .  .  .  Else: nil
 13394  .  .  .  .  .  }
 13395  .  .  .  .  .  4: *syntax.AssignStmt {
 13396  .  .  .  .  .  .  Op: <op-0>
 13397  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13398  .  .  .  .  .  .  .  X: s @ parser.go:1682:2
 13399  .  .  .  .  .  .  .  Sel: List @ parser.go:1682:4
 13400  .  .  .  .  .  .  }
 13401  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13402  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13403  .  .  .  .  .  .  .  .  X: p @ parser.go:1682:11
 13404  .  .  .  .  .  .  .  .  Sel: stmtList @ parser.go:1682:13
 13405  .  .  .  .  .  .  .  }
 13406  .  .  .  .  .  .  .  ArgList: nil
 13407  .  .  .  .  .  .  .  HasDots: false
 13408  .  .  .  .  .  .  }
 13409  .  .  .  .  .  }
 13410  .  .  .  .  .  5: *syntax.AssignStmt {
 13411  .  .  .  .  .  .  Op: <op-0>
 13412  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13413  .  .  .  .  .  .  .  X: s @ parser.go:1683:2
 13414  .  .  .  .  .  .  .  Sel: Rbrace @ parser.go:1683:4
 13415  .  .  .  .  .  .  }
 13416  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13417  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13418  .  .  .  .  .  .  .  .  X: p @ parser.go:1683:13
 13419  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1683:15
 13420  .  .  .  .  .  .  .  }
 13421  .  .  .  .  .  .  .  ArgList: nil
 13422  .  .  .  .  .  .  .  HasDots: false
 13423  .  .  .  .  .  .  }
 13424  .  .  .  .  .  }
 13425  .  .  .  .  .  6: *syntax.ExprStmt {
 13426  .  .  .  .  .  .  X: *syntax.CallExpr {
 13427  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13428  .  .  .  .  .  .  .  .  X: p @ parser.go:1684:2
 13429  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1684:4
 13430  .  .  .  .  .  .  .  }
 13431  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13432  .  .  .  .  .  .  .  .  0: _Rbrace @ parser.go:1684:9
 13433  .  .  .  .  .  .  .  }
 13434  .  .  .  .  .  .  .  HasDots: false
 13435  .  .  .  .  .  .  }
 13436  .  .  .  .  .  }
 13437  .  .  .  .  .  7: *syntax.ReturnStmt {
 13438  .  .  .  .  .  .  Results: s @ parser.go:1686:9
 13439  .  .  .  .  .  }
 13440  .  .  .  .  }
 13441  .  .  .  .  Rbrace: src.Pos {}
 13442  .  .  .  }
 13443  .  .  .  Pragma: 0
 13444  .  .  }
 13445  .  .  63: *syntax.FuncDecl {
 13446  .  .  .  Attr: map[]
 13447  .  .  .  Recv: *syntax.Field {
 13448  .  .  .  .  Name: p @ parser.go:1689:7
 13449  .  .  .  .  Type: *syntax.Operation {
 13450  .  .  .  .  .  Op: *
 13451  .  .  .  .  .  X: parser @ parser.go:1689:10
 13452  .  .  .  .  .  Y: nil
 13453  .  .  .  .  }
 13454  .  .  .  }
 13455  .  .  .  Name: declStmt @ parser.go:1689:18
 13456  .  .  .  Type: *syntax.FuncType {
 13457  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 13458  .  .  .  .  .  0: *syntax.Field {
 13459  .  .  .  .  .  .  Name: f @ parser.go:1689:27
 13460  .  .  .  .  .  .  Type: *syntax.FuncType {
 13461  .  .  .  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 13462  .  .  .  .  .  .  .  .  0: *syntax.Field {
 13463  .  .  .  .  .  .  .  .  .  Name: nil
 13464  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 13465  .  .  .  .  .  .  .  .  .  .  Op: *
 13466  .  .  .  .  .  .  .  .  .  .  X: Group @ parser.go:1689:35
 13467  .  .  .  .  .  .  .  .  .  .  Y: nil
 13468  .  .  .  .  .  .  .  .  .  }
 13469  .  .  .  .  .  .  .  .  }
 13470  .  .  .  .  .  .  .  }
 13471  .  .  .  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 13472  .  .  .  .  .  .  .  .  0: *syntax.Field {
 13473  .  .  .  .  .  .  .  .  .  Name: nil
 13474  .  .  .  .  .  .  .  .  .  Type: Decl @ parser.go:1689:42
 13475  .  .  .  .  .  .  .  .  }
 13476  .  .  .  .  .  .  .  }
 13477  .  .  .  .  .  .  }
 13478  .  .  .  .  .  }
 13479  .  .  .  .  }
 13480  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 13481  .  .  .  .  .  0: *syntax.Field {
 13482  .  .  .  .  .  .  Name: nil
 13483  .  .  .  .  .  .  Type: *syntax.Operation {
 13484  .  .  .  .  .  .  .  Op: *
 13485  .  .  .  .  .  .  .  X: DeclStmt @ parser.go:1689:49
 13486  .  .  .  .  .  .  .  Y: nil
 13487  .  .  .  .  .  .  }
 13488  .  .  .  .  .  }
 13489  .  .  .  .  }
 13490  .  .  .  }
 13491  .  .  .  Body: *syntax.BlockStmt {
 13492  .  .  .  .  List: []syntax.Stmt (6 entries) {
 13493  .  .  .  .  .  0: *syntax.IfStmt {
 13494  .  .  .  .  .  .  Init: nil
 13495  .  .  .  .  .  .  Cond: trace @ parser.go:1690:5
 13496  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 13497  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 13498  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 13499  .  .  .  .  .  .  .  .  .  Tok: defer
 13500  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 13501  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 13502  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13503  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1691:9
 13504  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1691:11
 13505  .  .  .  .  .  .  .  .  .  .  .  }
 13506  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13507  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 13508  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"declStmt\""
 13509  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13510  .  .  .  .  .  .  .  .  .  .  .  .  }
 13511  .  .  .  .  .  .  .  .  .  .  .  }
 13512  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13513  .  .  .  .  .  .  .  .  .  .  }
 13514  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13515  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13516  .  .  .  .  .  .  .  .  .  }
 13517  .  .  .  .  .  .  .  .  }
 13518  .  .  .  .  .  .  .  }
 13519  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 13520  .  .  .  .  .  .  }
 13521  .  .  .  .  .  .  Else: nil
 13522  .  .  .  .  .  }
 13523  .  .  .  .  .  1: *syntax.AssignStmt {
 13524  .  .  .  .  .  .  Op: :
 13525  .  .  .  .  .  .  Lhs: s @ parser.go:1694:2
 13526  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13527  .  .  .  .  .  .  .  Fun: new @ parser.go:1694:7
 13528  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13529  .  .  .  .  .  .  .  .  0: DeclStmt @ parser.go:1694:11
 13530  .  .  .  .  .  .  .  }
 13531  .  .  .  .  .  .  .  HasDots: false
 13532  .  .  .  .  .  .  }
 13533  .  .  .  .  .  }
 13534  .  .  .  .  .  2: *syntax.AssignStmt {
 13535  .  .  .  .  .  .  Op: <op-0>
 13536  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13537  .  .  .  .  .  .  .  X: s @ parser.go:1695:2
 13538  .  .  .  .  .  .  .  Sel: pos @ parser.go:1695:4
 13539  .  .  .  .  .  .  }
 13540  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13541  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13542  .  .  .  .  .  .  .  .  X: p @ parser.go:1695:10
 13543  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1695:12
 13544  .  .  .  .  .  .  .  }
 13545  .  .  .  .  .  .  .  ArgList: nil
 13546  .  .  .  .  .  .  .  HasDots: false
 13547  .  .  .  .  .  .  }
 13548  .  .  .  .  .  }
 13549  .  .  .  .  .  3: *syntax.ExprStmt {
 13550  .  .  .  .  .  .  X: *syntax.CallExpr {
 13551  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13552  .  .  .  .  .  .  .  .  X: p @ parser.go:1697:2
 13553  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1697:4
 13554  .  .  .  .  .  .  .  }
 13555  .  .  .  .  .  .  .  ArgList: nil
 13556  .  .  .  .  .  .  .  HasDots: false
 13557  .  .  .  .  .  .  }
 13558  .  .  .  .  .  }
 13559  .  .  .  .  .  4: *syntax.AssignStmt {
 13560  .  .  .  .  .  .  Op: <op-0>
 13561  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13562  .  .  .  .  .  .  .  X: s @ parser.go:1698:2
 13563  .  .  .  .  .  .  .  Sel: DeclList @ parser.go:1698:4
 13564  .  .  .  .  .  .  }
 13565  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13566  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13567  .  .  .  .  .  .  .  .  X: p @ parser.go:1698:15
 13568  .  .  .  .  .  .  .  .  Sel: appendGroup @ parser.go:1698:17
 13569  .  .  .  .  .  .  .  }
 13570  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 13571  .  .  .  .  .  .  .  .  0: nil @ parser.go:1698:29
 13572  .  .  .  .  .  .  .  .  1: f @ parser.go:1698:34
 13573  .  .  .  .  .  .  .  }
 13574  .  .  .  .  .  .  .  HasDots: false
 13575  .  .  .  .  .  .  }
 13576  .  .  .  .  .  }
 13577  .  .  .  .  .  5: *syntax.ReturnStmt {
 13578  .  .  .  .  .  .  Results: s @ parser.go:1700:9
 13579  .  .  .  .  .  }
 13580  .  .  .  .  }
 13581  .  .  .  .  Rbrace: src.Pos {}
 13582  .  .  .  }
 13583  .  .  .  Pragma: 0
 13584  .  .  }
 13585  .  .  64: *syntax.FuncDecl {
 13586  .  .  .  Attr: map[]
 13587  .  .  .  Recv: *syntax.Field {
 13588  .  .  .  .  Name: p @ parser.go:1703:7
 13589  .  .  .  .  Type: *syntax.Operation {
 13590  .  .  .  .  .  Op: *
 13591  .  .  .  .  .  X: parser @ parser.go:1703:10
 13592  .  .  .  .  .  Y: nil
 13593  .  .  .  .  }
 13594  .  .  .  }
 13595  .  .  .  Name: forStmt @ parser.go:1703:18
 13596  .  .  .  Type: *syntax.FuncType {
 13597  .  .  .  .  ParamList: nil
 13598  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 13599  .  .  .  .  .  0: *syntax.Field {
 13600  .  .  .  .  .  .  Name: nil
 13601  .  .  .  .  .  .  Type: Stmt @ parser.go:1703:28
 13602  .  .  .  .  .  }
 13603  .  .  .  .  }
 13604  .  .  .  }
 13605  .  .  .  Body: *syntax.BlockStmt {
 13606  .  .  .  .  List: []syntax.Stmt (6 entries) {
 13607  .  .  .  .  .  0: *syntax.IfStmt {
 13608  .  .  .  .  .  .  Init: nil
 13609  .  .  .  .  .  .  Cond: trace @ parser.go:1704:5
 13610  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 13611  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 13612  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 13613  .  .  .  .  .  .  .  .  .  Tok: defer
 13614  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 13615  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 13616  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13617  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1705:9
 13618  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1705:11
 13619  .  .  .  .  .  .  .  .  .  .  .  }
 13620  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13621  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 13622  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"forStmt\""
 13623  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13624  .  .  .  .  .  .  .  .  .  .  .  .  }
 13625  .  .  .  .  .  .  .  .  .  .  .  }
 13626  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13627  .  .  .  .  .  .  .  .  .  .  }
 13628  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13629  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13630  .  .  .  .  .  .  .  .  .  }
 13631  .  .  .  .  .  .  .  .  }
 13632  .  .  .  .  .  .  .  }
 13633  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 13634  .  .  .  .  .  .  }
 13635  .  .  .  .  .  .  Else: nil
 13636  .  .  .  .  .  }
 13637  .  .  .  .  .  1: *syntax.AssignStmt {
 13638  .  .  .  .  .  .  Op: :
 13639  .  .  .  .  .  .  Lhs: s @ parser.go:1708:2
 13640  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13641  .  .  .  .  .  .  .  Fun: new @ parser.go:1708:7
 13642  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13643  .  .  .  .  .  .  .  .  0: ForStmt @ parser.go:1708:11
 13644  .  .  .  .  .  .  .  }
 13645  .  .  .  .  .  .  .  HasDots: false
 13646  .  .  .  .  .  .  }
 13647  .  .  .  .  .  }
 13648  .  .  .  .  .  2: *syntax.AssignStmt {
 13649  .  .  .  .  .  .  Op: <op-0>
 13650  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13651  .  .  .  .  .  .  .  X: s @ parser.go:1709:2
 13652  .  .  .  .  .  .  .  Sel: pos @ parser.go:1709:4
 13653  .  .  .  .  .  .  }
 13654  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13655  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13656  .  .  .  .  .  .  .  .  X: p @ parser.go:1709:10
 13657  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1709:12
 13658  .  .  .  .  .  .  .  }
 13659  .  .  .  .  .  .  .  ArgList: nil
 13660  .  .  .  .  .  .  .  HasDots: false
 13661  .  .  .  .  .  .  }
 13662  .  .  .  .  .  }
 13663  .  .  .  .  .  3: *syntax.AssignStmt {
 13664  .  .  .  .  .  .  Op: <op-0>
 13665  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 13666  .  .  .  .  .  .  .  ElemList: []syntax.Expr (3 entries) {
 13667  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 13668  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1711:2
 13669  .  .  .  .  .  .  .  .  .  Sel: Init @ parser.go:1711:4
 13670  .  .  .  .  .  .  .  .  }
 13671  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
 13672  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1711:10
 13673  .  .  .  .  .  .  .  .  .  Sel: Cond @ parser.go:1711:12
 13674  .  .  .  .  .  .  .  .  }
 13675  .  .  .  .  .  .  .  .  2: *syntax.SelectorExpr {
 13676  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1711:18
 13677  .  .  .  .  .  .  .  .  .  Sel: Post @ parser.go:1711:20
 13678  .  .  .  .  .  .  .  .  }
 13679  .  .  .  .  .  .  .  }
 13680  .  .  .  .  .  .  }
 13681  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13682  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13683  .  .  .  .  .  .  .  .  X: p @ parser.go:1711:27
 13684  .  .  .  .  .  .  .  .  Sel: header @ parser.go:1711:29
 13685  .  .  .  .  .  .  .  }
 13686  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13687  .  .  .  .  .  .  .  .  0: _For @ parser.go:1711:36
 13688  .  .  .  .  .  .  .  }
 13689  .  .  .  .  .  .  .  HasDots: false
 13690  .  .  .  .  .  .  }
 13691  .  .  .  .  .  }
 13692  .  .  .  .  .  4: *syntax.AssignStmt {
 13693  .  .  .  .  .  .  Op: <op-0>
 13694  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13695  .  .  .  .  .  .  .  X: s @ parser.go:1712:2
 13696  .  .  .  .  .  .  .  Sel: Body @ parser.go:1712:4
 13697  .  .  .  .  .  .  }
 13698  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13699  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13700  .  .  .  .  .  .  .  .  X: p @ parser.go:1712:11
 13701  .  .  .  .  .  .  .  .  Sel: blockStmt @ parser.go:1712:13
 13702  .  .  .  .  .  .  .  }
 13703  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13704  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 13705  .  .  .  .  .  .  .  .  .  Value: "\"for clause\""
 13706  .  .  .  .  .  .  .  .  .  Kind: 4
 13707  .  .  .  .  .  .  .  .  }
 13708  .  .  .  .  .  .  .  }
 13709  .  .  .  .  .  .  .  HasDots: false
 13710  .  .  .  .  .  .  }
 13711  .  .  .  .  .  }
 13712  .  .  .  .  .  5: *syntax.ReturnStmt {
 13713  .  .  .  .  .  .  Results: s @ parser.go:1714:9
 13714  .  .  .  .  .  }
 13715  .  .  .  .  }
 13716  .  .  .  .  Rbrace: src.Pos {}
 13717  .  .  .  }
 13718  .  .  .  Pragma: 0
 13719  .  .  }
 13720  .  .  65: *syntax.FuncDecl {
 13721  .  .  .  Attr: map[]
 13722  .  .  .  Recv: *syntax.Field {
 13723  .  .  .  .  Name: p @ parser.go:1720:7
 13724  .  .  .  .  Type: *syntax.Operation {
 13725  .  .  .  .  .  Op: *
 13726  .  .  .  .  .  X: parser @ parser.go:1720:10
 13727  .  .  .  .  .  Y: nil
 13728  .  .  .  .  }
 13729  .  .  .  }
 13730  .  .  .  Name: header @ parser.go:1720:18
 13731  .  .  .  Type: *syntax.FuncType {
 13732  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 13733  .  .  .  .  .  0: *syntax.Field {
 13734  .  .  .  .  .  .  Name: keyword @ parser.go:1720:25
 13735  .  .  .  .  .  .  Type: token @ parser.go:1720:33
 13736  .  .  .  .  .  }
 13737  .  .  .  .  }
 13738  .  .  .  .  ResultList: []*syntax.Field (3 entries) {
 13739  .  .  .  .  .  0: *syntax.Field {
 13740  .  .  .  .  .  .  Name: init @ parser.go:1720:41
 13741  .  .  .  .  .  .  Type: SimpleStmt @ parser.go:1720:46
 13742  .  .  .  .  .  }
 13743  .  .  .  .  .  1: *syntax.Field {
 13744  .  .  .  .  .  .  Name: cond @ parser.go:1720:58
 13745  .  .  .  .  .  .  Type: Expr @ parser.go:1720:63
 13746  .  .  .  .  .  }
 13747  .  .  .  .  .  2: *syntax.Field {
 13748  .  .  .  .  .  .  Name: post @ parser.go:1720:69
 13749  .  .  .  .  .  .  Type: SimpleStmt @ parser.go:1720:74
 13750  .  .  .  .  .  }
 13751  .  .  .  .  }
 13752  .  .  .  }
 13753  .  .  .  Body: *syntax.BlockStmt {
 13754  .  .  .  .  List: []syntax.Stmt (11 entries) {
 13755  .  .  .  .  .  0: *syntax.ExprStmt {
 13756  .  .  .  .  .  .  X: *syntax.CallExpr {
 13757  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13758  .  .  .  .  .  .  .  .  X: p @ parser.go:1721:2
 13759  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1721:4
 13760  .  .  .  .  .  .  .  }
 13761  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13762  .  .  .  .  .  .  .  .  0: keyword @ parser.go:1721:9
 13763  .  .  .  .  .  .  .  }
 13764  .  .  .  .  .  .  .  HasDots: false
 13765  .  .  .  .  .  .  }
 13766  .  .  .  .  .  }
 13767  .  .  .  .  .  1: *syntax.IfStmt {
 13768  .  .  .  .  .  .  Init: nil
 13769  .  .  .  .  .  .  Cond: *syntax.Operation {
 13770  .  .  .  .  .  .  .  Op: ==
 13771  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 13772  .  .  .  .  .  .  .  .  X: p @ parser.go:1723:5
 13773  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1723:7
 13774  .  .  .  .  .  .  .  }
 13775  .  .  .  .  .  .  .  Y: _Lbrace @ parser.go:1723:14
 13776  .  .  .  .  .  .  }
 13777  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 13778  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 13779  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 13780  .  .  .  .  .  .  .  .  .  Init: nil
 13781  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 13782  .  .  .  .  .  .  .  .  .  .  Op: ==
 13783  .  .  .  .  .  .  .  .  .  .  X: keyword @ parser.go:1724:6
 13784  .  .  .  .  .  .  .  .  .  .  Y: _If @ parser.go:1724:17
 13785  .  .  .  .  .  .  .  .  .  }
 13786  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 13787  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 13788  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13789  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13790  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13791  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1725:4
 13792  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1725:6
 13793  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13794  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13795  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 13796  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"missing condition in if statement\""
 13797  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13798  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13799  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13800  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13801  .  .  .  .  .  .  .  .  .  .  .  .  }
 13802  .  .  .  .  .  .  .  .  .  .  .  }
 13803  .  .  .  .  .  .  .  .  .  .  }
 13804  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 13805  .  .  .  .  .  .  .  .  .  }
 13806  .  .  .  .  .  .  .  .  .  Else: nil
 13807  .  .  .  .  .  .  .  .  }
 13808  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
 13809  .  .  .  .  .  .  .  .  .  Results: nil
 13810  .  .  .  .  .  .  .  .  }
 13811  .  .  .  .  .  .  .  }
 13812  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 13813  .  .  .  .  .  .  }
 13814  .  .  .  .  .  .  Else: nil
 13815  .  .  .  .  .  }
 13816  .  .  .  .  .  2: *syntax.AssignStmt {
 13817  .  .  .  .  .  .  Op: :
 13818  .  .  .  .  .  .  Lhs: outer @ parser.go:1731:2
 13819  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 13820  .  .  .  .  .  .  .  X: p @ parser.go:1731:11
 13821  .  .  .  .  .  .  .  Sel: xnest @ parser.go:1731:13
 13822  .  .  .  .  .  .  }
 13823  .  .  .  .  .  }
 13824  .  .  .  .  .  3: *syntax.AssignStmt {
 13825  .  .  .  .  .  .  Op: <op-0>
 13826  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13827  .  .  .  .  .  .  .  X: p @ parser.go:1732:2
 13828  .  .  .  .  .  .  .  Sel: xnest @ parser.go:1732:4
 13829  .  .  .  .  .  .  }
 13830  .  .  .  .  .  .  Rhs: *syntax.Operation {
 13831  .  .  .  .  .  .  .  Op: -
 13832  .  .  .  .  .  .  .  X: *syntax.BasicLit {
 13833  .  .  .  .  .  .  .  .  Value: "1"
 13834  .  .  .  .  .  .  .  .  Kind: 0
 13835  .  .  .  .  .  .  .  }
 13836  .  .  .  .  .  .  .  Y: nil
 13837  .  .  .  .  .  .  }
 13838  .  .  .  .  .  }
 13839  .  .  .  .  .  4: *syntax.IfStmt {
 13840  .  .  .  .  .  .  Init: nil
 13841  .  .  .  .  .  .  Cond: *syntax.Operation {
 13842  .  .  .  .  .  .  .  Op: !=
 13843  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 13844  .  .  .  .  .  .  .  .  X: p @ parser.go:1734:5
 13845  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1734:7
 13846  .  .  .  .  .  .  .  }
 13847  .  .  .  .  .  .  .  Y: _Semi @ parser.go:1734:14
 13848  .  .  .  .  .  .  }
 13849  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 13850  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
 13851  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 13852  .  .  .  .  .  .  .  .  .  Init: nil
 13853  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
 13854  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13855  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1736:6
 13856  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:1736:8
 13857  .  .  .  .  .  .  .  .  .  .  }
 13858  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13859  .  .  .  .  .  .  .  .  .  .  .  0: _Var @ parser.go:1736:12
 13860  .  .  .  .  .  .  .  .  .  .  }
 13861  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13862  .  .  .  .  .  .  .  .  .  }
 13863  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 13864  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 13865  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 13866  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 13867  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13868  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1737:4
 13869  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1737:6
 13870  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13871  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 13872  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
 13873  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13874  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt @ parser.go:1737:19
 13875  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf @ parser.go:1737:23
 13876  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13877  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 13878  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 13879  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"var declaration not allowed in %s initializer\""
 13880  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 13881  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13882  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 13883  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13884  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: keyword @ parser.go:1737:80
 13885  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: String @ parser.go:1737:88
 13886  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13887  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 13888  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13889  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13890  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13891  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13892  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13893  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 13894  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13895  .  .  .  .  .  .  .  .  .  .  .  .  }
 13896  .  .  .  .  .  .  .  .  .  .  .  }
 13897  .  .  .  .  .  .  .  .  .  .  }
 13898  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 13899  .  .  .  .  .  .  .  .  .  }
 13900  .  .  .  .  .  .  .  .  .  Else: nil
 13901  .  .  .  .  .  .  .  .  }
 13902  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 13903  .  .  .  .  .  .  .  .  .  Op: <op-0>
 13904  .  .  .  .  .  .  .  .  .  Lhs: init @ parser.go:1739:3
 13905  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 13906  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 13907  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1739:10
 13908  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt @ parser.go:1739:12
 13909  .  .  .  .  .  .  .  .  .  .  }
 13910  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 13911  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1739:23
 13912  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.Operation {
 13913  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 13914  .  .  .  .  .  .  .  .  .  .  .  .  X: keyword @ parser.go:1739:28
 13915  .  .  .  .  .  .  .  .  .  .  .  .  Y: _For @ parser.go:1739:39
 13916  .  .  .  .  .  .  .  .  .  .  .  }
 13917  .  .  .  .  .  .  .  .  .  .  }
 13918  .  .  .  .  .  .  .  .  .  .  HasDots: false
 13919  .  .  .  .  .  .  .  .  .  }
 13920  .  .  .  .  .  .  .  .  }
 13921  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
 13922  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 13923  .  .  .  .  .  .  .  .  .  .  Op: :
 13924  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 13925  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 13926  .  .  .  .  .  .  .  .  .  .  .  .  0: _ @ parser.go:1741:6
 13927  .  .  .  .  .  .  .  .  .  .  .  .  1: ok @ parser.go:1741:9
 13928  .  .  .  .  .  .  .  .  .  .  .  }
 13929  .  .  .  .  .  .  .  .  .  .  }
 13930  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 13931  .  .  .  .  .  .  .  .  .  .  .  X: init @ parser.go:1741:15
 13932  .  .  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 13933  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
 13934  .  .  .  .  .  .  .  .  .  .  .  .  X: RangeClause @ parser.go:1741:22
 13935  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 13936  .  .  .  .  .  .  .  .  .  .  .  }
 13937  .  .  .  .  .  .  .  .  .  .  }
 13938  .  .  .  .  .  .  .  .  .  }
 13939  .  .  .  .  .  .  .  .  .  Cond: ok @ parser.go:1741:36
 13940  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 13941  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 13942  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 13943  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 13944  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 13945  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1742:4
 13946  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: xnest @ parser.go:1742:6
 13947  .  .  .  .  .  .  .  .  .  .  .  .  }
 13948  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: outer @ parser.go:1742:14
 13949  .  .  .  .  .  .  .  .  .  .  .  }
 13950  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
 13951  .  .  .  .  .  .  .  .  .  .  .  .  Results: nil
 13952  .  .  .  .  .  .  .  .  .  .  .  }
 13953  .  .  .  .  .  .  .  .  .  .  }
 13954  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 13955  .  .  .  .  .  .  .  .  .  }
 13956  .  .  .  .  .  .  .  .  .  Else: nil
 13957  .  .  .  .  .  .  .  .  }
 13958  .  .  .  .  .  .  .  }
 13959  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 13960  .  .  .  .  .  .  }
 13961  .  .  .  .  .  .  Else: nil
 13962  .  .  .  .  .  }
 13963  .  .  .  .  .  5: *syntax.DeclStmt {
 13964  .  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
 13965  .  .  .  .  .  .  .  0: *syntax.VarDecl {
 13966  .  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
 13967  .  .  .  .  .  .  .  .  .  0: condStmt @ parser.go:1747:6
 13968  .  .  .  .  .  .  .  .  }
 13969  .  .  .  .  .  .  .  .  Type: SimpleStmt @ parser.go:1747:15
 13970  .  .  .  .  .  .  .  .  Values: nil
 13971  .  .  .  .  .  .  .  .  Group: nil
 13972  .  .  .  .  .  .  .  }
 13973  .  .  .  .  .  .  }
 13974  .  .  .  .  .  }
 13975  .  .  .  .  .  6: *syntax.DeclStmt {
 13976  .  .  .  .  .  .  DeclList: []syntax.Decl (1 entries) {
 13977  .  .  .  .  .  .  .  0: *syntax.VarDecl {
 13978  .  .  .  .  .  .  .  .  NameList: []*syntax.Name (1 entries) {
 13979  .  .  .  .  .  .  .  .  .  0: semi @ parser.go:1748:6
 13980  .  .  .  .  .  .  .  .  }
 13981  .  .  .  .  .  .  .  .  Type: *syntax.StructType {
 13982  .  .  .  .  .  .  .  .  .  FieldList: []*syntax.Field (2 entries) {
 13983  .  .  .  .  .  .  .  .  .  .  0: *syntax.Field {
 13984  .  .  .  .  .  .  .  .  .  .  .  Name: pos @ parser.go:1749:3
 13985  .  .  .  .  .  .  .  .  .  .  .  Type: *syntax.SelectorExpr {
 13986  .  .  .  .  .  .  .  .  .  .  .  .  X: src @ parser.go:1749:7
 13987  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1749:11
 13988  .  .  .  .  .  .  .  .  .  .  .  }
 13989  .  .  .  .  .  .  .  .  .  .  }
 13990  .  .  .  .  .  .  .  .  .  .  1: *syntax.Field {
 13991  .  .  .  .  .  .  .  .  .  .  .  Name: lit @ parser.go:1750:3
 13992  .  .  .  .  .  .  .  .  .  .  .  Type: string @ parser.go:1750:7
 13993  .  .  .  .  .  .  .  .  .  .  }
 13994  .  .  .  .  .  .  .  .  .  }
 13995  .  .  .  .  .  .  .  .  .  TagList: nil
 13996  .  .  .  .  .  .  .  .  }
 13997  .  .  .  .  .  .  .  .  Values: nil
 13998  .  .  .  .  .  .  .  .  Group: nil
 13999  .  .  .  .  .  .  .  }
 14000  .  .  .  .  .  .  }
 14001  .  .  .  .  .  }
 14002  .  .  .  .  .  7: *syntax.IfStmt {
 14003  .  .  .  .  .  .  Init: nil
 14004  .  .  .  .  .  .  Cond: *syntax.Operation {
 14005  .  .  .  .  .  .  .  Op: ==
 14006  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14007  .  .  .  .  .  .  .  .  X: p @ parser.go:1752:5
 14008  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1752:7
 14009  .  .  .  .  .  .  .  }
 14010  .  .  .  .  .  .  .  Y: _Semi @ parser.go:1752:14
 14011  .  .  .  .  .  .  }
 14012  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14013  .  .  .  .  .  .  .  List: []syntax.Stmt (4 entries) {
 14014  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14015  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14016  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14017  .  .  .  .  .  .  .  .  .  .  X: semi @ parser.go:1753:3
 14018  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1753:8
 14019  .  .  .  .  .  .  .  .  .  }
 14020  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14021  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14022  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1753:14
 14023  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1753:16
 14024  .  .  .  .  .  .  .  .  .  .  }
 14025  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14026  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14027  .  .  .  .  .  .  .  .  .  }
 14028  .  .  .  .  .  .  .  .  }
 14029  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 14030  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14031  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14032  .  .  .  .  .  .  .  .  .  .  X: semi @ parser.go:1754:3
 14033  .  .  .  .  .  .  .  .  .  .  Sel: lit @ parser.go:1754:8
 14034  .  .  .  .  .  .  .  .  .  }
 14035  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 14036  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1754:14
 14037  .  .  .  .  .  .  .  .  .  .  Sel: lit @ parser.go:1754:16
 14038  .  .  .  .  .  .  .  .  .  }
 14039  .  .  .  .  .  .  .  .  }
 14040  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 14041  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14042  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14043  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1755:3
 14044  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1755:5
 14045  .  .  .  .  .  .  .  .  .  .  }
 14046  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14047  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14048  .  .  .  .  .  .  .  .  .  }
 14049  .  .  .  .  .  .  .  .  }
 14050  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
 14051  .  .  .  .  .  .  .  .  .  Init: nil
 14052  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14053  .  .  .  .  .  .  .  .  .  .  Op: ==
 14054  .  .  .  .  .  .  .  .  .  .  X: keyword @ parser.go:1756:6
 14055  .  .  .  .  .  .  .  .  .  .  Y: _For @ parser.go:1756:17
 14056  .  .  .  .  .  .  .  .  .  }
 14057  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14058  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
 14059  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 14060  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 14061  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14062  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 14063  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14064  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1757:7
 14065  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1757:9
 14066  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14067  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Semi @ parser.go:1757:16
 14068  .  .  .  .  .  .  .  .  .  .  .  .  }
 14069  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14070  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 14071  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 14072  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 14073  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14074  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 14075  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14076  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1758:8
 14077  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1758:10
 14078  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14079  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Lbrace @ parser.go:1758:17
 14080  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14081  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14082  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 14083  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14084  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14085  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14086  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1759:6
 14087  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1759:8
 14088  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14089  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14090  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14091  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting for loop condition\""
 14092  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14093  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14094  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14095  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14096  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14097  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14098  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BranchStmt {
 14099  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Tok: goto
 14100  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Label: done @ parser.go:1760:11
 14101  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Target: *syntax.LabeledStmt {
 14102  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Label: done @ parser.go:1779:1
 14103  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Stmt: *syntax.SwitchStmt {
 14104  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 14105  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Tag: *syntax.TypeSwitchGuard {
 14106  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: s @ parser.go:1781:9
 14107  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: condStmt @ parser.go:1781:14
 14108  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14109  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 14110  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 14111  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: nil @ parser.go:1782:7
 14112  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 14113  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 14114  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 14115  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14116  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: &&
 14117  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 14118  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 14119  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: keyword @ parser.go:1783:6
 14120  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _If @ parser.go:1783:17
 14121  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14122  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
 14123  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14124  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14125  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: semi @ parser.go:1783:24
 14126  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1783:29
 14127  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14128  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: IsKnown @ parser.go:1783:33
 14129  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14130  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14131  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14132  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14133  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14134  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14135  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 14136  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.IfStmt {
 14137  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 14138  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14139  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 14140  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14141  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: semi @ parser.go:1784:7
 14142  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: lit @ parser.go:1784:12
 14143  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14144  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.BasicLit {
 14145  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"semicolon\""
 14146  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14147  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14148  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14149  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14150  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 14151  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14152  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14153  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14154  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1785:5
 14155  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error_at @ parser.go:1785:7
 14156  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14157  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14158  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 14159  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: semi @ parser.go:1785:23
 14160  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1785:28
 14161  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14162  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 14163  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14164  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt @ parser.go:1785:33
 14165  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf @ parser.go:1785:37
 14166  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14167  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14168  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14169  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"unexpected %s, expecting { after if clause\""
 14170  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14171  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14172  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
 14173  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: semi @ parser.go:1785:91
 14174  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: lit @ parser.go:1785:96
 14175  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14176  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14177  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14178  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14179  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14180  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14181  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14182  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14183  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14184  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14185  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14186  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: *syntax.BlockStmt {
 14187  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 14188  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14189  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14190  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14191  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1787:5
 14192  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error_at @ parser.go:1787:7
 14193  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14194  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14195  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 14196  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: semi @ parser.go:1787:23
 14197  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1787:28
 14198  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14199  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
 14200  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"missing condition in if statement\""
 14201  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14202  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14203  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14204  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14205  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14206  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14207  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14208  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14209  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14210  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14211  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14212  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14213  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14214  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
 14215  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14216  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14217  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 14218  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14219  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 14220  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.Operation {
 14221  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
 14222  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: ExprStmt @ parser.go:1790:8
 14223  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 14224  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14225  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 14226  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14227  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14228  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: cond @ parser.go:1791:3
 14229  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 14230  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1791:10
 14231  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:1791:12
 14232  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14233  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14234  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14235  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 14236  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14237  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 14238  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cases: nil
 14239  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 14240  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14241  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14242  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14243  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1793:3
 14244  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1793:5
 14245  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14246  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14247  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
 14248  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14249  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: fmt @ parser.go:1793:18
 14250  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Sprintf @ parser.go:1793:22
 14251  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14252  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14253  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14254  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"%s used as value\""
 14255  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14256  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14257  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 14258  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: String @ parser.go:1793:50
 14259  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14260  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: s @ parser.go:1793:57
 14261  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14262  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14263  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14264  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14265  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14266  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14267  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14268  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14269  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14270  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14271  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14272  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 14273  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14274  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14275  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14276  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14277  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14278  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14279  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14280  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14281  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14282  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
 14283  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14284  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 14285  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14286  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: condStmt @ parser.go:1762:5
 14287  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14288  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14289  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1762:16
 14290  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt @ parser.go:1762:18
 14291  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14292  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14293  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1762:29
 14294  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: false @ parser.go:1762:34
 14295  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14296  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14297  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14298  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14299  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14300  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14301  .  .  .  .  .  .  .  .  .  .  .  .  }
 14302  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
 14303  .  .  .  .  .  .  .  .  .  .  .  }
 14304  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 14305  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14306  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14307  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1764:4
 14308  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1764:6
 14309  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14310  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14311  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Semi @ parser.go:1764:11
 14312  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14313  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14314  .  .  .  .  .  .  .  .  .  .  .  .  }
 14315  .  .  .  .  .  .  .  .  .  .  .  }
 14316  .  .  .  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
 14317  .  .  .  .  .  .  .  .  .  .  .  .  Init: nil
 14318  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14319  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 14320  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14321  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1765:7
 14322  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1765:9
 14323  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14324  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Lbrace @ parser.go:1765:16
 14325  .  .  .  .  .  .  .  .  .  .  .  .  }
 14326  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14327  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 14328  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14329  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14330  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: post @ parser.go:1766:5
 14331  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14332  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14333  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1766:12
 14334  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt @ parser.go:1766:14
 14335  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14336  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14337  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1766:25
 14338  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: false @ parser.go:1766:30
 14339  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14340  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14341  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14342  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14343  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 14344  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 14345  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: :
 14346  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 14347  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 14348  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: a @ parser.go:1767:8
 14349  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: _ @ parser.go:1767:11
 14350  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14351  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14352  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 14353  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: post @ parser.go:1767:16
 14354  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 14355  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
 14356  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: AssignStmt @ parser.go:1767:23
 14357  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 14358  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14359  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14360  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14361  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14362  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: &&
 14363  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 14364  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 14365  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: a @ parser.go:1767:36
 14366  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:1767:41
 14367  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14368  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 14369  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 14370  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14371  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: a @ parser.go:1767:48
 14372  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Op @ parser.go:1767:50
 14373  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14374  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: Def @ parser.go:1767:56
 14375  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14376  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14377  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14378  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 14379  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14380  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14381  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14382  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1768:6
 14383  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error_at @ parser.go:1768:8
 14384  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14385  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14386  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CallExpr {
 14387  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14388  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: a @ parser.go:1768:24
 14389  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:1768:26
 14390  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14391  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14392  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14393  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14394  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.BasicLit {
 14395  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"cannot declare in post statement of for loop\""
 14396  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14397  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14398  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14399  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14400  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14401  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14402  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14403  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14404  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14405  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
 14406  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14407  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14408  .  .  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14409  .  .  .  .  .  .  .  .  .  .  .  .  }
 14410  .  .  .  .  .  .  .  .  .  .  .  .  Else: nil
 14411  .  .  .  .  .  .  .  .  .  .  .  }
 14412  .  .  .  .  .  .  .  .  .  .  }
 14413  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14414  .  .  .  .  .  .  .  .  .  }
 14415  .  .  .  .  .  .  .  .  .  Else: *syntax.IfStmt {
 14416  .  .  .  .  .  .  .  .  .  .  Init: nil
 14417  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 14418  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 14419  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14420  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1771:13
 14421  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1771:15
 14422  .  .  .  .  .  .  .  .  .  .  .  }
 14423  .  .  .  .  .  .  .  .  .  .  .  Y: _Lbrace @ parser.go:1771:22
 14424  .  .  .  .  .  .  .  .  .  .  }
 14425  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14426  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 14427  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14428  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14429  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: condStmt @ parser.go:1772:4
 14430  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14431  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14432  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1772:15
 14433  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt @ parser.go:1772:17
 14434  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14435  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14436  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1772:28
 14437  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: false @ parser.go:1772:33
 14438  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14439  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14440  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14441  .  .  .  .  .  .  .  .  .  .  .  .  }
 14442  .  .  .  .  .  .  .  .  .  .  .  }
 14443  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14444  .  .  .  .  .  .  .  .  .  .  }
 14445  .  .  .  .  .  .  .  .  .  .  Else: nil
 14446  .  .  .  .  .  .  .  .  .  }
 14447  .  .  .  .  .  .  .  .  }
 14448  .  .  .  .  .  .  .  }
 14449  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14450  .  .  .  .  .  .  }
 14451  .  .  .  .  .  .  Else: *syntax.BlockStmt {
 14452  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 14453  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14454  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14455  .  .  .  .  .  .  .  .  .  Lhs: condStmt @ parser.go:1775:3
 14456  .  .  .  .  .  .  .  .  .  Rhs: init @ parser.go:1775:14
 14457  .  .  .  .  .  .  .  .  }
 14458  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 14459  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14460  .  .  .  .  .  .  .  .  .  Lhs: init @ parser.go:1776:3
 14461  .  .  .  .  .  .  .  .  .  Rhs: nil @ parser.go:1776:10
 14462  .  .  .  .  .  .  .  .  }
 14463  .  .  .  .  .  .  .  }
 14464  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14465  .  .  .  .  .  .  }
 14466  .  .  .  .  .  }
 14467  .  .  .  .  .  8: *(Node @ 14101)
 14468  .  .  .  .  .  9: *syntax.AssignStmt {
 14469  .  .  .  .  .  .  Op: <op-0>
 14470  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14471  .  .  .  .  .  .  .  X: p @ parser.go:1796:2
 14472  .  .  .  .  .  .  .  Sel: xnest @ parser.go:1796:4
 14473  .  .  .  .  .  .  }
 14474  .  .  .  .  .  .  Rhs: outer @ parser.go:1796:12
 14475  .  .  .  .  .  }
 14476  .  .  .  .  .  10: *syntax.ReturnStmt {
 14477  .  .  .  .  .  .  Results: nil
 14478  .  .  .  .  .  }
 14479  .  .  .  .  }
 14480  .  .  .  .  Rbrace: src.Pos {}
 14481  .  .  .  }
 14482  .  .  .  Pragma: 0
 14483  .  .  }
 14484  .  .  66: *syntax.FuncDecl {
 14485  .  .  .  Attr: map[]
 14486  .  .  .  Recv: *syntax.Field {
 14487  .  .  .  .  Name: p @ parser.go:1800:7
 14488  .  .  .  .  Type: *syntax.Operation {
 14489  .  .  .  .  .  Op: *
 14490  .  .  .  .  .  X: parser @ parser.go:1800:10
 14491  .  .  .  .  .  Y: nil
 14492  .  .  .  .  }
 14493  .  .  .  }
 14494  .  .  .  Name: ifStmt @ parser.go:1800:18
 14495  .  .  .  Type: *syntax.FuncType {
 14496  .  .  .  .  ParamList: nil
 14497  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 14498  .  .  .  .  .  0: *syntax.Field {
 14499  .  .  .  .  .  .  Name: nil
 14500  .  .  .  .  .  .  Type: *syntax.Operation {
 14501  .  .  .  .  .  .  .  Op: *
 14502  .  .  .  .  .  .  .  X: IfStmt @ parser.go:1800:28
 14503  .  .  .  .  .  .  .  Y: nil
 14504  .  .  .  .  .  .  }
 14505  .  .  .  .  .  }
 14506  .  .  .  .  }
 14507  .  .  .  }
 14508  .  .  .  Body: *syntax.BlockStmt {
 14509  .  .  .  .  List: []syntax.Stmt (7 entries) {
 14510  .  .  .  .  .  0: *syntax.IfStmt {
 14511  .  .  .  .  .  .  Init: nil
 14512  .  .  .  .  .  .  Cond: trace @ parser.go:1801:5
 14513  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14514  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 14515  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 14516  .  .  .  .  .  .  .  .  .  Tok: defer
 14517  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 14518  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 14519  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14520  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1802:9
 14521  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1802:11
 14522  .  .  .  .  .  .  .  .  .  .  .  }
 14523  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14524  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14525  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"ifStmt\""
 14526  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14527  .  .  .  .  .  .  .  .  .  .  .  .  }
 14528  .  .  .  .  .  .  .  .  .  .  .  }
 14529  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14530  .  .  .  .  .  .  .  .  .  .  }
 14531  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14532  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14533  .  .  .  .  .  .  .  .  .  }
 14534  .  .  .  .  .  .  .  .  }
 14535  .  .  .  .  .  .  .  }
 14536  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14537  .  .  .  .  .  .  }
 14538  .  .  .  .  .  .  Else: nil
 14539  .  .  .  .  .  }
 14540  .  .  .  .  .  1: *syntax.AssignStmt {
 14541  .  .  .  .  .  .  Op: :
 14542  .  .  .  .  .  .  Lhs: s @ parser.go:1805:2
 14543  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14544  .  .  .  .  .  .  .  Fun: new @ parser.go:1805:7
 14545  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14546  .  .  .  .  .  .  .  .  0: IfStmt @ parser.go:1805:11
 14547  .  .  .  .  .  .  .  }
 14548  .  .  .  .  .  .  .  HasDots: false
 14549  .  .  .  .  .  .  }
 14550  .  .  .  .  .  }
 14551  .  .  .  .  .  2: *syntax.AssignStmt {
 14552  .  .  .  .  .  .  Op: <op-0>
 14553  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14554  .  .  .  .  .  .  .  X: s @ parser.go:1806:2
 14555  .  .  .  .  .  .  .  Sel: pos @ parser.go:1806:4
 14556  .  .  .  .  .  .  }
 14557  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14558  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14559  .  .  .  .  .  .  .  .  X: p @ parser.go:1806:10
 14560  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1806:12
 14561  .  .  .  .  .  .  .  }
 14562  .  .  .  .  .  .  .  ArgList: nil
 14563  .  .  .  .  .  .  .  HasDots: false
 14564  .  .  .  .  .  .  }
 14565  .  .  .  .  .  }
 14566  .  .  .  .  .  3: *syntax.AssignStmt {
 14567  .  .  .  .  .  .  Op: <op-0>
 14568  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 14569  .  .  .  .  .  .  .  ElemList: []syntax.Expr (3 entries) {
 14570  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 14571  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1808:2
 14572  .  .  .  .  .  .  .  .  .  Sel: Init @ parser.go:1808:4
 14573  .  .  .  .  .  .  .  .  }
 14574  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
 14575  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1808:10
 14576  .  .  .  .  .  .  .  .  .  Sel: Cond @ parser.go:1808:12
 14577  .  .  .  .  .  .  .  .  }
 14578  .  .  .  .  .  .  .  .  2: _ @ parser.go:1808:18
 14579  .  .  .  .  .  .  .  }
 14580  .  .  .  .  .  .  }
 14581  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14582  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14583  .  .  .  .  .  .  .  .  X: p @ parser.go:1808:22
 14584  .  .  .  .  .  .  .  .  Sel: header @ parser.go:1808:24
 14585  .  .  .  .  .  .  .  }
 14586  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14587  .  .  .  .  .  .  .  .  0: _If @ parser.go:1808:31
 14588  .  .  .  .  .  .  .  }
 14589  .  .  .  .  .  .  .  HasDots: false
 14590  .  .  .  .  .  .  }
 14591  .  .  .  .  .  }
 14592  .  .  .  .  .  4: *syntax.AssignStmt {
 14593  .  .  .  .  .  .  Op: <op-0>
 14594  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14595  .  .  .  .  .  .  .  X: s @ parser.go:1809:2
 14596  .  .  .  .  .  .  .  Sel: Then @ parser.go:1809:4
 14597  .  .  .  .  .  .  }
 14598  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14599  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14600  .  .  .  .  .  .  .  .  X: p @ parser.go:1809:11
 14601  .  .  .  .  .  .  .  .  Sel: blockStmt @ parser.go:1809:13
 14602  .  .  .  .  .  .  .  }
 14603  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14604  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14605  .  .  .  .  .  .  .  .  .  Value: "\"if clause\""
 14606  .  .  .  .  .  .  .  .  .  Kind: 4
 14607  .  .  .  .  .  .  .  .  }
 14608  .  .  .  .  .  .  .  }
 14609  .  .  .  .  .  .  .  HasDots: false
 14610  .  .  .  .  .  .  }
 14611  .  .  .  .  .  }
 14612  .  .  .  .  .  5: *syntax.IfStmt {
 14613  .  .  .  .  .  .  Init: nil
 14614  .  .  .  .  .  .  Cond: *syntax.CallExpr {
 14615  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14616  .  .  .  .  .  .  .  .  X: p @ parser.go:1811:5
 14617  .  .  .  .  .  .  .  .  Sel: got @ parser.go:1811:7
 14618  .  .  .  .  .  .  .  }
 14619  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14620  .  .  .  .  .  .  .  .  0: _Else @ parser.go:1811:11
 14621  .  .  .  .  .  .  .  }
 14622  .  .  .  .  .  .  .  HasDots: false
 14623  .  .  .  .  .  .  }
 14624  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14625  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 14626  .  .  .  .  .  .  .  .  0: *syntax.SwitchStmt {
 14627  .  .  .  .  .  .  .  .  .  Init: nil
 14628  .  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 14629  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1812:10
 14630  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1812:12
 14631  .  .  .  .  .  .  .  .  .  }
 14632  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 14633  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 14634  .  .  .  .  .  .  .  .  .  .  .  Cases: _If @ parser.go:1813:8
 14635  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 14636  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14637  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14638  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14639  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1814:4
 14640  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Else @ parser.go:1814:6
 14641  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14642  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14643  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14644  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1814:13
 14645  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: ifStmt @ parser.go:1814:15
 14646  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14647  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14648  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14649  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14650  .  .  .  .  .  .  .  .  .  .  .  .  }
 14651  .  .  .  .  .  .  .  .  .  .  .  }
 14652  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 14653  .  .  .  .  .  .  .  .  .  .  }
 14654  .  .  .  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 14655  .  .  .  .  .  .  .  .  .  .  .  Cases: _Lbrace @ parser.go:1815:8
 14656  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 14657  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14658  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14659  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14660  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1816:4
 14661  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Else @ parser.go:1816:6
 14662  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14663  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14664  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14665  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1816:13
 14666  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: blockStmt @ parser.go:1816:15
 14667  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14668  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14669  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14670  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"\""
 14671  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14672  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14673  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14674  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14675  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14676  .  .  .  .  .  .  .  .  .  .  .  .  }
 14677  .  .  .  .  .  .  .  .  .  .  .  }
 14678  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 14679  .  .  .  .  .  .  .  .  .  .  }
 14680  .  .  .  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 14681  .  .  .  .  .  .  .  .  .  .  .  Cases: nil
 14682  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 14683  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14684  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14685  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14686  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1818:4
 14687  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1818:6
 14688  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14689  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14690  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14691  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"else must be followed by if or statement block\""
 14692  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14693  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14694  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14695  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14696  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14697  .  .  .  .  .  .  .  .  .  .  .  .  }
 14698  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 14699  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14700  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14701  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1819:4
 14702  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:1819:6
 14703  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14704  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14705  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Name @ parser.go:1819:14
 14706  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: _Rbrace @ parser.go:1819:21
 14707  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14708  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14709  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 14710  .  .  .  .  .  .  .  .  .  .  .  .  }
 14711  .  .  .  .  .  .  .  .  .  .  .  }
 14712  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 14713  .  .  .  .  .  .  .  .  .  .  }
 14714  .  .  .  .  .  .  .  .  .  }
 14715  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14716  .  .  .  .  .  .  .  .  }
 14717  .  .  .  .  .  .  .  }
 14718  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14719  .  .  .  .  .  .  }
 14720  .  .  .  .  .  .  Else: nil
 14721  .  .  .  .  .  }
 14722  .  .  .  .  .  6: *syntax.ReturnStmt {
 14723  .  .  .  .  .  .  Results: s @ parser.go:1823:9
 14724  .  .  .  .  .  }
 14725  .  .  .  .  }
 14726  .  .  .  .  Rbrace: src.Pos {}
 14727  .  .  .  }
 14728  .  .  .  Pragma: 0
 14729  .  .  }
 14730  .  .  67: *syntax.FuncDecl {
 14731  .  .  .  Attr: map[]
 14732  .  .  .  Recv: *syntax.Field {
 14733  .  .  .  .  Name: p @ parser.go:1826:7
 14734  .  .  .  .  Type: *syntax.Operation {
 14735  .  .  .  .  .  Op: *
 14736  .  .  .  .  .  X: parser @ parser.go:1826:10
 14737  .  .  .  .  .  Y: nil
 14738  .  .  .  .  }
 14739  .  .  .  }
 14740  .  .  .  Name: switchStmt @ parser.go:1826:18
 14741  .  .  .  Type: *syntax.FuncType {
 14742  .  .  .  .  ParamList: nil
 14743  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 14744  .  .  .  .  .  0: *syntax.Field {
 14745  .  .  .  .  .  .  Name: nil
 14746  .  .  .  .  .  .  Type: *syntax.Operation {
 14747  .  .  .  .  .  .  .  Op: *
 14748  .  .  .  .  .  .  .  X: SwitchStmt @ parser.go:1826:32
 14749  .  .  .  .  .  .  .  Y: nil
 14750  .  .  .  .  .  .  }
 14751  .  .  .  .  .  }
 14752  .  .  .  .  }
 14753  .  .  .  }
 14754  .  .  .  Body: *syntax.BlockStmt {
 14755  .  .  .  .  List: []syntax.Stmt (9 entries) {
 14756  .  .  .  .  .  0: *syntax.IfStmt {
 14757  .  .  .  .  .  .  Init: nil
 14758  .  .  .  .  .  .  Cond: trace @ parser.go:1827:5
 14759  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14760  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 14761  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 14762  .  .  .  .  .  .  .  .  .  Tok: defer
 14763  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 14764  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 14765  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14766  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1828:9
 14767  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1828:11
 14768  .  .  .  .  .  .  .  .  .  .  .  }
 14769  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14770  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14771  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"switchStmt\""
 14772  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14773  .  .  .  .  .  .  .  .  .  .  .  .  }
 14774  .  .  .  .  .  .  .  .  .  .  .  }
 14775  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14776  .  .  .  .  .  .  .  .  .  .  }
 14777  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14778  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14779  .  .  .  .  .  .  .  .  .  }
 14780  .  .  .  .  .  .  .  .  }
 14781  .  .  .  .  .  .  .  }
 14782  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14783  .  .  .  .  .  .  }
 14784  .  .  .  .  .  .  Else: nil
 14785  .  .  .  .  .  }
 14786  .  .  .  .  .  1: *syntax.AssignStmt {
 14787  .  .  .  .  .  .  Op: :
 14788  .  .  .  .  .  .  Lhs: s @ parser.go:1831:2
 14789  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14790  .  .  .  .  .  .  .  Fun: new @ parser.go:1831:7
 14791  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14792  .  .  .  .  .  .  .  .  0: SwitchStmt @ parser.go:1831:11
 14793  .  .  .  .  .  .  .  }
 14794  .  .  .  .  .  .  .  HasDots: false
 14795  .  .  .  .  .  .  }
 14796  .  .  .  .  .  }
 14797  .  .  .  .  .  2: *syntax.AssignStmt {
 14798  .  .  .  .  .  .  Op: <op-0>
 14799  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14800  .  .  .  .  .  .  .  X: s @ parser.go:1832:2
 14801  .  .  .  .  .  .  .  Sel: pos @ parser.go:1832:4
 14802  .  .  .  .  .  .  }
 14803  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14804  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14805  .  .  .  .  .  .  .  .  X: p @ parser.go:1832:10
 14806  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1832:12
 14807  .  .  .  .  .  .  .  }
 14808  .  .  .  .  .  .  .  ArgList: nil
 14809  .  .  .  .  .  .  .  HasDots: false
 14810  .  .  .  .  .  .  }
 14811  .  .  .  .  .  }
 14812  .  .  .  .  .  3: *syntax.AssignStmt {
 14813  .  .  .  .  .  .  Op: <op-0>
 14814  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 14815  .  .  .  .  .  .  .  ElemList: []syntax.Expr (3 entries) {
 14816  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 14817  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1834:2
 14818  .  .  .  .  .  .  .  .  .  Sel: Init @ parser.go:1834:4
 14819  .  .  .  .  .  .  .  .  }
 14820  .  .  .  .  .  .  .  .  1: *syntax.SelectorExpr {
 14821  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1834:10
 14822  .  .  .  .  .  .  .  .  .  Sel: Tag @ parser.go:1834:12
 14823  .  .  .  .  .  .  .  .  }
 14824  .  .  .  .  .  .  .  .  2: _ @ parser.go:1834:17
 14825  .  .  .  .  .  .  .  }
 14826  .  .  .  .  .  .  }
 14827  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14828  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14829  .  .  .  .  .  .  .  .  X: p @ parser.go:1834:21
 14830  .  .  .  .  .  .  .  .  Sel: header @ parser.go:1834:23
 14831  .  .  .  .  .  .  .  }
 14832  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14833  .  .  .  .  .  .  .  .  0: _Switch @ parser.go:1834:30
 14834  .  .  .  .  .  .  .  }
 14835  .  .  .  .  .  .  .  HasDots: false
 14836  .  .  .  .  .  .  }
 14837  .  .  .  .  .  }
 14838  .  .  .  .  .  4: *syntax.IfStmt {
 14839  .  .  .  .  .  .  Init: nil
 14840  .  .  .  .  .  .  Cond: *syntax.Operation {
 14841  .  .  .  .  .  .  .  Op: !
 14842  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14843  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14844  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1836:6
 14845  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:1836:8
 14846  .  .  .  .  .  .  .  .  }
 14847  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14848  .  .  .  .  .  .  .  .  .  0: _Lbrace @ parser.go:1836:12
 14849  .  .  .  .  .  .  .  .  }
 14850  .  .  .  .  .  .  .  .  HasDots: false
 14851  .  .  .  .  .  .  .  }
 14852  .  .  .  .  .  .  .  Y: nil
 14853  .  .  .  .  .  .  }
 14854  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 14855  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 14856  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 14857  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14858  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14859  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1837:3
 14860  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1837:5
 14861  .  .  .  .  .  .  .  .  .  .  }
 14862  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14863  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 14864  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"missing { after switch clause\""
 14865  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 14866  .  .  .  .  .  .  .  .  .  .  .  }
 14867  .  .  .  .  .  .  .  .  .  .  }
 14868  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14869  .  .  .  .  .  .  .  .  .  }
 14870  .  .  .  .  .  .  .  .  }
 14871  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 14872  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 14873  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14874  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1838:3
 14875  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:1838:5
 14876  .  .  .  .  .  .  .  .  .  .  }
 14877  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 14878  .  .  .  .  .  .  .  .  .  .  .  0: _Case @ parser.go:1838:13
 14879  .  .  .  .  .  .  .  .  .  .  .  1: _Default @ parser.go:1838:20
 14880  .  .  .  .  .  .  .  .  .  .  .  2: _Rbrace @ parser.go:1838:30
 14881  .  .  .  .  .  .  .  .  .  .  }
 14882  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14883  .  .  .  .  .  .  .  .  .  }
 14884  .  .  .  .  .  .  .  .  }
 14885  .  .  .  .  .  .  .  }
 14886  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14887  .  .  .  .  .  .  }
 14888  .  .  .  .  .  .  Else: nil
 14889  .  .  .  .  .  }
 14890  .  .  .  .  .  5: *syntax.ForStmt {
 14891  .  .  .  .  .  .  Init: nil
 14892  .  .  .  .  .  .  Cond: *syntax.Operation {
 14893  .  .  .  .  .  .  .  Op: &&
 14894  .  .  .  .  .  .  .  X: *syntax.Operation {
 14895  .  .  .  .  .  .  .  .  Op: !=
 14896  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14897  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1840:6
 14898  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1840:8
 14899  .  .  .  .  .  .  .  .  }
 14900  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:1840:15
 14901  .  .  .  .  .  .  .  }
 14902  .  .  .  .  .  .  .  Y: *syntax.Operation {
 14903  .  .  .  .  .  .  .  .  Op: !=
 14904  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 14905  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1840:23
 14906  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1840:25
 14907  .  .  .  .  .  .  .  .  }
 14908  .  .  .  .  .  .  .  .  Y: _Rbrace @ parser.go:1840:32
 14909  .  .  .  .  .  .  .  }
 14910  .  .  .  .  .  .  }
 14911  .  .  .  .  .  .  Post: nil
 14912  .  .  .  .  .  .  Body: *syntax.BlockStmt {
 14913  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 14914  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 14915  .  .  .  .  .  .  .  .  .  Op: <op-0>
 14916  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14917  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1841:3
 14918  .  .  .  .  .  .  .  .  .  .  Sel: Body @ parser.go:1841:5
 14919  .  .  .  .  .  .  .  .  .  }
 14920  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14921  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:1841:12
 14922  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 14923  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 14924  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1841:19
 14925  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Body @ parser.go:1841:21
 14926  .  .  .  .  .  .  .  .  .  .  .  }
 14927  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 14928  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14929  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1841:27
 14930  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: caseClause @ parser.go:1841:29
 14931  .  .  .  .  .  .  .  .  .  .  .  .  }
 14932  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 14933  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14934  .  .  .  .  .  .  .  .  .  .  .  }
 14935  .  .  .  .  .  .  .  .  .  .  }
 14936  .  .  .  .  .  .  .  .  .  .  HasDots: false
 14937  .  .  .  .  .  .  .  .  .  }
 14938  .  .  .  .  .  .  .  .  }
 14939  .  .  .  .  .  .  .  }
 14940  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 14941  .  .  .  .  .  .  }
 14942  .  .  .  .  .  }
 14943  .  .  .  .  .  6: *syntax.AssignStmt {
 14944  .  .  .  .  .  .  Op: <op-0>
 14945  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 14946  .  .  .  .  .  .  .  X: s @ parser.go:1843:2
 14947  .  .  .  .  .  .  .  Sel: Rbrace @ parser.go:1843:4
 14948  .  .  .  .  .  .  }
 14949  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 14950  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14951  .  .  .  .  .  .  .  .  X: p @ parser.go:1843:13
 14952  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1843:15
 14953  .  .  .  .  .  .  .  }
 14954  .  .  .  .  .  .  .  ArgList: nil
 14955  .  .  .  .  .  .  .  HasDots: false
 14956  .  .  .  .  .  .  }
 14957  .  .  .  .  .  }
 14958  .  .  .  .  .  7: *syntax.ExprStmt {
 14959  .  .  .  .  .  .  X: *syntax.CallExpr {
 14960  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 14961  .  .  .  .  .  .  .  .  X: p @ parser.go:1844:2
 14962  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1844:4
 14963  .  .  .  .  .  .  .  }
 14964  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 14965  .  .  .  .  .  .  .  .  0: _Rbrace @ parser.go:1844:9
 14966  .  .  .  .  .  .  .  }
 14967  .  .  .  .  .  .  .  HasDots: false
 14968  .  .  .  .  .  .  }
 14969  .  .  .  .  .  }
 14970  .  .  .  .  .  8: *syntax.ReturnStmt {
 14971  .  .  .  .  .  .  Results: s @ parser.go:1846:9
 14972  .  .  .  .  .  }
 14973  .  .  .  .  }
 14974  .  .  .  .  Rbrace: src.Pos {}
 14975  .  .  .  }
 14976  .  .  .  Pragma: 0
 14977  .  .  }
 14978  .  .  68: *syntax.FuncDecl {
 14979  .  .  .  Attr: map[]
 14980  .  .  .  Recv: *syntax.Field {
 14981  .  .  .  .  Name: p @ parser.go:1849:7
 14982  .  .  .  .  Type: *syntax.Operation {
 14983  .  .  .  .  .  Op: *
 14984  .  .  .  .  .  X: parser @ parser.go:1849:10
 14985  .  .  .  .  .  Y: nil
 14986  .  .  .  .  }
 14987  .  .  .  }
 14988  .  .  .  Name: selectStmt @ parser.go:1849:18
 14989  .  .  .  Type: *syntax.FuncType {
 14990  .  .  .  .  ParamList: nil
 14991  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 14992  .  .  .  .  .  0: *syntax.Field {
 14993  .  .  .  .  .  .  Name: nil
 14994  .  .  .  .  .  .  Type: *syntax.Operation {
 14995  .  .  .  .  .  .  .  Op: *
 14996  .  .  .  .  .  .  .  X: SelectStmt @ parser.go:1849:32
 14997  .  .  .  .  .  .  .  Y: nil
 14998  .  .  .  .  .  .  }
 14999  .  .  .  .  .  }
 15000  .  .  .  .  }
 15001  .  .  .  }
 15002  .  .  .  Body: *syntax.BlockStmt {
 15003  .  .  .  .  List: []syntax.Stmt (9 entries) {
 15004  .  .  .  .  .  0: *syntax.IfStmt {
 15005  .  .  .  .  .  .  Init: nil
 15006  .  .  .  .  .  .  Cond: trace @ parser.go:1850:5
 15007  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 15008  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 15009  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 15010  .  .  .  .  .  .  .  .  .  Tok: defer
 15011  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 15012  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 15013  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15014  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1851:9
 15015  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1851:11
 15016  .  .  .  .  .  .  .  .  .  .  .  }
 15017  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15018  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 15019  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"selectStmt\""
 15020  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 15021  .  .  .  .  .  .  .  .  .  .  .  .  }
 15022  .  .  .  .  .  .  .  .  .  .  .  }
 15023  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15024  .  .  .  .  .  .  .  .  .  .  }
 15025  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15026  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15027  .  .  .  .  .  .  .  .  .  }
 15028  .  .  .  .  .  .  .  .  }
 15029  .  .  .  .  .  .  .  }
 15030  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 15031  .  .  .  .  .  .  }
 15032  .  .  .  .  .  .  Else: nil
 15033  .  .  .  .  .  }
 15034  .  .  .  .  .  1: *syntax.AssignStmt {
 15035  .  .  .  .  .  .  Op: :
 15036  .  .  .  .  .  .  Lhs: s @ parser.go:1854:2
 15037  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15038  .  .  .  .  .  .  .  Fun: new @ parser.go:1854:7
 15039  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15040  .  .  .  .  .  .  .  .  0: SelectStmt @ parser.go:1854:11
 15041  .  .  .  .  .  .  .  }
 15042  .  .  .  .  .  .  .  HasDots: false
 15043  .  .  .  .  .  .  }
 15044  .  .  .  .  .  }
 15045  .  .  .  .  .  2: *syntax.AssignStmt {
 15046  .  .  .  .  .  .  Op: <op-0>
 15047  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 15048  .  .  .  .  .  .  .  X: s @ parser.go:1855:2
 15049  .  .  .  .  .  .  .  Sel: pos @ parser.go:1855:4
 15050  .  .  .  .  .  .  }
 15051  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15052  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15053  .  .  .  .  .  .  .  .  X: p @ parser.go:1855:10
 15054  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1855:12
 15055  .  .  .  .  .  .  .  }
 15056  .  .  .  .  .  .  .  ArgList: nil
 15057  .  .  .  .  .  .  .  HasDots: false
 15058  .  .  .  .  .  .  }
 15059  .  .  .  .  .  }
 15060  .  .  .  .  .  3: *syntax.ExprStmt {
 15061  .  .  .  .  .  .  X: *syntax.CallExpr {
 15062  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15063  .  .  .  .  .  .  .  .  X: p @ parser.go:1857:2
 15064  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1857:4
 15065  .  .  .  .  .  .  .  }
 15066  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15067  .  .  .  .  .  .  .  .  0: _Select @ parser.go:1857:9
 15068  .  .  .  .  .  .  .  }
 15069  .  .  .  .  .  .  .  HasDots: false
 15070  .  .  .  .  .  .  }
 15071  .  .  .  .  .  }
 15072  .  .  .  .  .  4: *syntax.IfStmt {
 15073  .  .  .  .  .  .  Init: nil
 15074  .  .  .  .  .  .  Cond: *syntax.Operation {
 15075  .  .  .  .  .  .  .  Op: !
 15076  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15077  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15078  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1858:6
 15079  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:1858:8
 15080  .  .  .  .  .  .  .  .  }
 15081  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15082  .  .  .  .  .  .  .  .  .  0: _Lbrace @ parser.go:1858:12
 15083  .  .  .  .  .  .  .  .  }
 15084  .  .  .  .  .  .  .  .  HasDots: false
 15085  .  .  .  .  .  .  .  }
 15086  .  .  .  .  .  .  .  Y: nil
 15087  .  .  .  .  .  .  }
 15088  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 15089  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 15090  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 15091  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15092  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15093  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1859:3
 15094  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1859:5
 15095  .  .  .  .  .  .  .  .  .  .  }
 15096  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15097  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 15098  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"missing { after select clause\""
 15099  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 15100  .  .  .  .  .  .  .  .  .  .  .  }
 15101  .  .  .  .  .  .  .  .  .  .  }
 15102  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15103  .  .  .  .  .  .  .  .  .  }
 15104  .  .  .  .  .  .  .  .  }
 15105  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 15106  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15107  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15108  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1860:3
 15109  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:1860:5
 15110  .  .  .  .  .  .  .  .  .  .  }
 15111  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 15112  .  .  .  .  .  .  .  .  .  .  .  0: _Case @ parser.go:1860:13
 15113  .  .  .  .  .  .  .  .  .  .  .  1: _Default @ parser.go:1860:20
 15114  .  .  .  .  .  .  .  .  .  .  .  2: _Rbrace @ parser.go:1860:30
 15115  .  .  .  .  .  .  .  .  .  .  }
 15116  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15117  .  .  .  .  .  .  .  .  .  }
 15118  .  .  .  .  .  .  .  .  }
 15119  .  .  .  .  .  .  .  }
 15120  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 15121  .  .  .  .  .  .  }
 15122  .  .  .  .  .  .  Else: nil
 15123  .  .  .  .  .  }
 15124  .  .  .  .  .  5: *syntax.ForStmt {
 15125  .  .  .  .  .  .  Init: nil
 15126  .  .  .  .  .  .  Cond: *syntax.Operation {
 15127  .  .  .  .  .  .  .  Op: &&
 15128  .  .  .  .  .  .  .  X: *syntax.Operation {
 15129  .  .  .  .  .  .  .  .  Op: !=
 15130  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 15131  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1862:6
 15132  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1862:8
 15133  .  .  .  .  .  .  .  .  }
 15134  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:1862:15
 15135  .  .  .  .  .  .  .  }
 15136  .  .  .  .  .  .  .  Y: *syntax.Operation {
 15137  .  .  .  .  .  .  .  .  Op: !=
 15138  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 15139  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1862:23
 15140  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1862:25
 15141  .  .  .  .  .  .  .  .  }
 15142  .  .  .  .  .  .  .  .  Y: _Rbrace @ parser.go:1862:32
 15143  .  .  .  .  .  .  .  }
 15144  .  .  .  .  .  .  }
 15145  .  .  .  .  .  .  Post: nil
 15146  .  .  .  .  .  .  Body: *syntax.BlockStmt {
 15147  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 15148  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 15149  .  .  .  .  .  .  .  .  .  Op: <op-0>
 15150  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 15151  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1863:3
 15152  .  .  .  .  .  .  .  .  .  .  Sel: Body @ parser.go:1863:5
 15153  .  .  .  .  .  .  .  .  .  }
 15154  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15155  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:1863:12
 15156  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 15157  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 15158  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1863:19
 15159  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Body @ parser.go:1863:21
 15160  .  .  .  .  .  .  .  .  .  .  .  }
 15161  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 15162  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15163  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1863:27
 15164  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: commClause @ parser.go:1863:29
 15165  .  .  .  .  .  .  .  .  .  .  .  .  }
 15166  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15167  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15168  .  .  .  .  .  .  .  .  .  .  .  }
 15169  .  .  .  .  .  .  .  .  .  .  }
 15170  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15171  .  .  .  .  .  .  .  .  .  }
 15172  .  .  .  .  .  .  .  .  }
 15173  .  .  .  .  .  .  .  }
 15174  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 15175  .  .  .  .  .  .  }
 15176  .  .  .  .  .  }
 15177  .  .  .  .  .  6: *syntax.AssignStmt {
 15178  .  .  .  .  .  .  Op: <op-0>
 15179  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 15180  .  .  .  .  .  .  .  X: s @ parser.go:1865:2
 15181  .  .  .  .  .  .  .  Sel: Rbrace @ parser.go:1865:4
 15182  .  .  .  .  .  .  }
 15183  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15184  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15185  .  .  .  .  .  .  .  .  X: p @ parser.go:1865:13
 15186  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1865:15
 15187  .  .  .  .  .  .  .  }
 15188  .  .  .  .  .  .  .  ArgList: nil
 15189  .  .  .  .  .  .  .  HasDots: false
 15190  .  .  .  .  .  .  }
 15191  .  .  .  .  .  }
 15192  .  .  .  .  .  7: *syntax.ExprStmt {
 15193  .  .  .  .  .  .  X: *syntax.CallExpr {
 15194  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15195  .  .  .  .  .  .  .  .  X: p @ parser.go:1866:2
 15196  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1866:4
 15197  .  .  .  .  .  .  .  }
 15198  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15199  .  .  .  .  .  .  .  .  0: _Rbrace @ parser.go:1866:9
 15200  .  .  .  .  .  .  .  }
 15201  .  .  .  .  .  .  .  HasDots: false
 15202  .  .  .  .  .  .  }
 15203  .  .  .  .  .  }
 15204  .  .  .  .  .  8: *syntax.ReturnStmt {
 15205  .  .  .  .  .  .  Results: s @ parser.go:1868:9
 15206  .  .  .  .  .  }
 15207  .  .  .  .  }
 15208  .  .  .  .  Rbrace: src.Pos {}
 15209  .  .  .  }
 15210  .  .  .  Pragma: 0
 15211  .  .  }
 15212  .  .  69: *syntax.FuncDecl {
 15213  .  .  .  Attr: map[]
 15214  .  .  .  Recv: *syntax.Field {
 15215  .  .  .  .  Name: p @ parser.go:1871:7
 15216  .  .  .  .  Type: *syntax.Operation {
 15217  .  .  .  .  .  Op: *
 15218  .  .  .  .  .  X: parser @ parser.go:1871:10
 15219  .  .  .  .  .  Y: nil
 15220  .  .  .  .  }
 15221  .  .  .  }
 15222  .  .  .  Name: caseClause @ parser.go:1871:18
 15223  .  .  .  Type: *syntax.FuncType {
 15224  .  .  .  .  ParamList: nil
 15225  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 15226  .  .  .  .  .  0: *syntax.Field {
 15227  .  .  .  .  .  .  Name: nil
 15228  .  .  .  .  .  .  Type: *syntax.Operation {
 15229  .  .  .  .  .  .  .  Op: *
 15230  .  .  .  .  .  .  .  X: CaseClause @ parser.go:1871:32
 15231  .  .  .  .  .  .  .  Y: nil
 15232  .  .  .  .  .  .  }
 15233  .  .  .  .  .  }
 15234  .  .  .  .  }
 15235  .  .  .  }
 15236  .  .  .  Body: *syntax.BlockStmt {
 15237  .  .  .  .  List: []syntax.Stmt (8 entries) {
 15238  .  .  .  .  .  0: *syntax.IfStmt {
 15239  .  .  .  .  .  .  Init: nil
 15240  .  .  .  .  .  .  Cond: trace @ parser.go:1872:5
 15241  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 15242  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 15243  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 15244  .  .  .  .  .  .  .  .  .  Tok: defer
 15245  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 15246  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 15247  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15248  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1873:9
 15249  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1873:11
 15250  .  .  .  .  .  .  .  .  .  .  .  }
 15251  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15252  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 15253  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"caseClause\""
 15254  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 15255  .  .  .  .  .  .  .  .  .  .  .  .  }
 15256  .  .  .  .  .  .  .  .  .  .  .  }
 15257  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15258  .  .  .  .  .  .  .  .  .  .  }
 15259  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15260  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15261  .  .  .  .  .  .  .  .  .  }
 15262  .  .  .  .  .  .  .  .  }
 15263  .  .  .  .  .  .  .  }
 15264  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 15265  .  .  .  .  .  .  }
 15266  .  .  .  .  .  .  Else: nil
 15267  .  .  .  .  .  }
 15268  .  .  .  .  .  1: *syntax.AssignStmt {
 15269  .  .  .  .  .  .  Op: :
 15270  .  .  .  .  .  .  Lhs: c @ parser.go:1876:2
 15271  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15272  .  .  .  .  .  .  .  Fun: new @ parser.go:1876:7
 15273  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15274  .  .  .  .  .  .  .  .  0: CaseClause @ parser.go:1876:11
 15275  .  .  .  .  .  .  .  }
 15276  .  .  .  .  .  .  .  HasDots: false
 15277  .  .  .  .  .  .  }
 15278  .  .  .  .  .  }
 15279  .  .  .  .  .  2: *syntax.AssignStmt {
 15280  .  .  .  .  .  .  Op: <op-0>
 15281  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 15282  .  .  .  .  .  .  .  X: c @ parser.go:1877:2
 15283  .  .  .  .  .  .  .  Sel: pos @ parser.go:1877:4
 15284  .  .  .  .  .  .  }
 15285  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15286  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15287  .  .  .  .  .  .  .  .  X: p @ parser.go:1877:10
 15288  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1877:12
 15289  .  .  .  .  .  .  .  }
 15290  .  .  .  .  .  .  .  ArgList: nil
 15291  .  .  .  .  .  .  .  HasDots: false
 15292  .  .  .  .  .  .  }
 15293  .  .  .  .  .  }
 15294  .  .  .  .  .  3: *syntax.SwitchStmt {
 15295  .  .  .  .  .  .  Init: nil
 15296  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 15297  .  .  .  .  .  .  .  X: p @ parser.go:1879:9
 15298  .  .  .  .  .  .  .  Sel: tok @ parser.go:1879:11
 15299  .  .  .  .  .  .  }
 15300  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 15301  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 15302  .  .  .  .  .  .  .  .  Cases: _Case @ parser.go:1880:7
 15303  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 15304  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 15305  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15306  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15307  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1881:3
 15308  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1881:5
 15309  .  .  .  .  .  .  .  .  .  .  .  }
 15310  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15311  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15312  .  .  .  .  .  .  .  .  .  .  }
 15313  .  .  .  .  .  .  .  .  .  }
 15314  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 15315  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 15316  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 15317  .  .  .  .  .  .  .  .  .  .  .  X: c @ parser.go:1882:3
 15318  .  .  .  .  .  .  .  .  .  .  .  Sel: Cases @ parser.go:1882:5
 15319  .  .  .  .  .  .  .  .  .  .  }
 15320  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15321  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15322  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1882:13
 15323  .  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList @ parser.go:1882:15
 15324  .  .  .  .  .  .  .  .  .  .  .  }
 15325  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15326  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15327  .  .  .  .  .  .  .  .  .  .  }
 15328  .  .  .  .  .  .  .  .  .  }
 15329  .  .  .  .  .  .  .  .  }
 15330  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15331  .  .  .  .  .  .  .  }
 15332  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 15333  .  .  .  .  .  .  .  .  Cases: _Default @ parser.go:1884:7
 15334  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15335  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 15336  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15337  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15338  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1885:3
 15339  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1885:5
 15340  .  .  .  .  .  .  .  .  .  .  .  }
 15341  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15342  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15343  .  .  .  .  .  .  .  .  .  .  }
 15344  .  .  .  .  .  .  .  .  .  }
 15345  .  .  .  .  .  .  .  .  }
 15346  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15347  .  .  .  .  .  .  .  }
 15348  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 15349  .  .  .  .  .  .  .  .  Cases: nil
 15350  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 15351  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 15352  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15353  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15354  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1888:3
 15355  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1888:5
 15356  .  .  .  .  .  .  .  .  .  .  .  }
 15357  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15358  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 15359  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting case or default or }\""
 15360  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 15361  .  .  .  .  .  .  .  .  .  .  .  .  }
 15362  .  .  .  .  .  .  .  .  .  .  .  }
 15363  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15364  .  .  .  .  .  .  .  .  .  .  }
 15365  .  .  .  .  .  .  .  .  .  }
 15366  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 15367  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15368  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15369  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1889:3
 15370  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:1889:5
 15371  .  .  .  .  .  .  .  .  .  .  .  }
 15372  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
 15373  .  .  .  .  .  .  .  .  .  .  .  .  0: _Colon @ parser.go:1889:13
 15374  .  .  .  .  .  .  .  .  .  .  .  .  1: _Case @ parser.go:1889:21
 15375  .  .  .  .  .  .  .  .  .  .  .  .  2: _Default @ parser.go:1889:28
 15376  .  .  .  .  .  .  .  .  .  .  .  .  3: _Rbrace @ parser.go:1889:38
 15377  .  .  .  .  .  .  .  .  .  .  .  }
 15378  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15379  .  .  .  .  .  .  .  .  .  .  }
 15380  .  .  .  .  .  .  .  .  .  }
 15381  .  .  .  .  .  .  .  .  }
 15382  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15383  .  .  .  .  .  .  .  }
 15384  .  .  .  .  .  .  }
 15385  .  .  .  .  .  .  Rbrace: src.Pos {}
 15386  .  .  .  .  .  }
 15387  .  .  .  .  .  4: *syntax.AssignStmt {
 15388  .  .  .  .  .  .  Op: <op-0>
 15389  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 15390  .  .  .  .  .  .  .  X: c @ parser.go:1892:2
 15391  .  .  .  .  .  .  .  Sel: Colon @ parser.go:1892:4
 15392  .  .  .  .  .  .  }
 15393  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15394  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15395  .  .  .  .  .  .  .  .  X: p @ parser.go:1892:12
 15396  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1892:14
 15397  .  .  .  .  .  .  .  }
 15398  .  .  .  .  .  .  .  ArgList: nil
 15399  .  .  .  .  .  .  .  HasDots: false
 15400  .  .  .  .  .  .  }
 15401  .  .  .  .  .  }
 15402  .  .  .  .  .  5: *syntax.ExprStmt {
 15403  .  .  .  .  .  .  X: *syntax.CallExpr {
 15404  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15405  .  .  .  .  .  .  .  .  X: p @ parser.go:1893:2
 15406  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1893:4
 15407  .  .  .  .  .  .  .  }
 15408  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15409  .  .  .  .  .  .  .  .  0: _Colon @ parser.go:1893:9
 15410  .  .  .  .  .  .  .  }
 15411  .  .  .  .  .  .  .  HasDots: false
 15412  .  .  .  .  .  .  }
 15413  .  .  .  .  .  }
 15414  .  .  .  .  .  6: *syntax.AssignStmt {
 15415  .  .  .  .  .  .  Op: <op-0>
 15416  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 15417  .  .  .  .  .  .  .  X: c @ parser.go:1894:2
 15418  .  .  .  .  .  .  .  Sel: Body @ parser.go:1894:4
 15419  .  .  .  .  .  .  }
 15420  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15421  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15422  .  .  .  .  .  .  .  .  X: p @ parser.go:1894:11
 15423  .  .  .  .  .  .  .  .  Sel: stmtList @ parser.go:1894:13
 15424  .  .  .  .  .  .  .  }
 15425  .  .  .  .  .  .  .  ArgList: nil
 15426  .  .  .  .  .  .  .  HasDots: false
 15427  .  .  .  .  .  .  }
 15428  .  .  .  .  .  }
 15429  .  .  .  .  .  7: *syntax.ReturnStmt {
 15430  .  .  .  .  .  .  Results: c @ parser.go:1896:9
 15431  .  .  .  .  .  }
 15432  .  .  .  .  }
 15433  .  .  .  .  Rbrace: src.Pos {}
 15434  .  .  .  }
 15435  .  .  .  Pragma: 0
 15436  .  .  }
 15437  .  .  70: *syntax.FuncDecl {
 15438  .  .  .  Attr: map[]
 15439  .  .  .  Recv: *syntax.Field {
 15440  .  .  .  .  Name: p @ parser.go:1899:7
 15441  .  .  .  .  Type: *syntax.Operation {
 15442  .  .  .  .  .  Op: *
 15443  .  .  .  .  .  X: parser @ parser.go:1899:10
 15444  .  .  .  .  .  Y: nil
 15445  .  .  .  .  }
 15446  .  .  .  }
 15447  .  .  .  Name: commClause @ parser.go:1899:18
 15448  .  .  .  Type: *syntax.FuncType {
 15449  .  .  .  .  ParamList: nil
 15450  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 15451  .  .  .  .  .  0: *syntax.Field {
 15452  .  .  .  .  .  .  Name: nil
 15453  .  .  .  .  .  .  Type: *syntax.Operation {
 15454  .  .  .  .  .  .  .  Op: *
 15455  .  .  .  .  .  .  .  X: CommClause @ parser.go:1899:32
 15456  .  .  .  .  .  .  .  Y: nil
 15457  .  .  .  .  .  .  }
 15458  .  .  .  .  .  }
 15459  .  .  .  .  }
 15460  .  .  .  }
 15461  .  .  .  Body: *syntax.BlockStmt {
 15462  .  .  .  .  List: []syntax.Stmt (8 entries) {
 15463  .  .  .  .  .  0: *syntax.IfStmt {
 15464  .  .  .  .  .  .  Init: nil
 15465  .  .  .  .  .  .  Cond: trace @ parser.go:1900:5
 15466  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 15467  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 15468  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 15469  .  .  .  .  .  .  .  .  .  Tok: defer
 15470  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 15471  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 15472  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15473  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1901:9
 15474  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1901:11
 15475  .  .  .  .  .  .  .  .  .  .  .  }
 15476  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15477  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 15478  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"commClause\""
 15479  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 15480  .  .  .  .  .  .  .  .  .  .  .  .  }
 15481  .  .  .  .  .  .  .  .  .  .  .  }
 15482  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15483  .  .  .  .  .  .  .  .  .  .  }
 15484  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15485  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15486  .  .  .  .  .  .  .  .  .  }
 15487  .  .  .  .  .  .  .  .  }
 15488  .  .  .  .  .  .  .  }
 15489  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 15490  .  .  .  .  .  .  }
 15491  .  .  .  .  .  .  Else: nil
 15492  .  .  .  .  .  }
 15493  .  .  .  .  .  1: *syntax.AssignStmt {
 15494  .  .  .  .  .  .  Op: :
 15495  .  .  .  .  .  .  Lhs: c @ parser.go:1904:2
 15496  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15497  .  .  .  .  .  .  .  Fun: new @ parser.go:1904:7
 15498  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15499  .  .  .  .  .  .  .  .  0: CommClause @ parser.go:1904:11
 15500  .  .  .  .  .  .  .  }
 15501  .  .  .  .  .  .  .  HasDots: false
 15502  .  .  .  .  .  .  }
 15503  .  .  .  .  .  }
 15504  .  .  .  .  .  2: *syntax.AssignStmt {
 15505  .  .  .  .  .  .  Op: <op-0>
 15506  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 15507  .  .  .  .  .  .  .  X: c @ parser.go:1905:2
 15508  .  .  .  .  .  .  .  Sel: pos @ parser.go:1905:4
 15509  .  .  .  .  .  .  }
 15510  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15511  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15512  .  .  .  .  .  .  .  .  X: p @ parser.go:1905:10
 15513  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1905:12
 15514  .  .  .  .  .  .  .  }
 15515  .  .  .  .  .  .  .  ArgList: nil
 15516  .  .  .  .  .  .  .  HasDots: false
 15517  .  .  .  .  .  .  }
 15518  .  .  .  .  .  }
 15519  .  .  .  .  .  3: *syntax.SwitchStmt {
 15520  .  .  .  .  .  .  Init: nil
 15521  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 15522  .  .  .  .  .  .  .  X: p @ parser.go:1907:9
 15523  .  .  .  .  .  .  .  Sel: tok @ parser.go:1907:11
 15524  .  .  .  .  .  .  }
 15525  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 15526  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 15527  .  .  .  .  .  .  .  .  Cases: _Case @ parser.go:1908:7
 15528  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 15529  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 15530  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15531  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15532  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1909:3
 15533  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1909:5
 15534  .  .  .  .  .  .  .  .  .  .  .  }
 15535  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15536  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15537  .  .  .  .  .  .  .  .  .  .  }
 15538  .  .  .  .  .  .  .  .  .  }
 15539  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 15540  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 15541  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 15542  .  .  .  .  .  .  .  .  .  .  .  X: c @ parser.go:1910:3
 15543  .  .  .  .  .  .  .  .  .  .  .  Sel: Comm @ parser.go:1910:5
 15544  .  .  .  .  .  .  .  .  .  .  }
 15545  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15546  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15547  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1910:12
 15548  .  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt @ parser.go:1910:14
 15549  .  .  .  .  .  .  .  .  .  .  .  }
 15550  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 15551  .  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1910:25
 15552  .  .  .  .  .  .  .  .  .  .  .  .  1: false @ parser.go:1910:30
 15553  .  .  .  .  .  .  .  .  .  .  .  }
 15554  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15555  .  .  .  .  .  .  .  .  .  .  }
 15556  .  .  .  .  .  .  .  .  .  }
 15557  .  .  .  .  .  .  .  .  }
 15558  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15559  .  .  .  .  .  .  .  }
 15560  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 15561  .  .  .  .  .  .  .  .  Cases: _Default @ parser.go:1924:7
 15562  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15563  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 15564  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15565  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15566  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1925:3
 15567  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1925:5
 15568  .  .  .  .  .  .  .  .  .  .  .  }
 15569  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15570  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15571  .  .  .  .  .  .  .  .  .  .  }
 15572  .  .  .  .  .  .  .  .  .  }
 15573  .  .  .  .  .  .  .  .  }
 15574  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15575  .  .  .  .  .  .  .  }
 15576  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 15577  .  .  .  .  .  .  .  .  Cases: nil
 15578  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 15579  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 15580  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15581  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15582  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1928:3
 15583  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:1928:5
 15584  .  .  .  .  .  .  .  .  .  .  .  }
 15585  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15586  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 15587  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting case or default or }\""
 15588  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 15589  .  .  .  .  .  .  .  .  .  .  .  .  }
 15590  .  .  .  .  .  .  .  .  .  .  .  }
 15591  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15592  .  .  .  .  .  .  .  .  .  .  }
 15593  .  .  .  .  .  .  .  .  .  }
 15594  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 15595  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 15596  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15597  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1929:3
 15598  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:1929:5
 15599  .  .  .  .  .  .  .  .  .  .  .  }
 15600  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (4 entries) {
 15601  .  .  .  .  .  .  .  .  .  .  .  .  0: _Colon @ parser.go:1929:13
 15602  .  .  .  .  .  .  .  .  .  .  .  .  1: _Case @ parser.go:1929:21
 15603  .  .  .  .  .  .  .  .  .  .  .  .  2: _Default @ parser.go:1929:28
 15604  .  .  .  .  .  .  .  .  .  .  .  .  3: _Rbrace @ parser.go:1929:38
 15605  .  .  .  .  .  .  .  .  .  .  .  }
 15606  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15607  .  .  .  .  .  .  .  .  .  .  }
 15608  .  .  .  .  .  .  .  .  .  }
 15609  .  .  .  .  .  .  .  .  }
 15610  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15611  .  .  .  .  .  .  .  }
 15612  .  .  .  .  .  .  }
 15613  .  .  .  .  .  .  Rbrace: src.Pos {}
 15614  .  .  .  .  .  }
 15615  .  .  .  .  .  4: *syntax.AssignStmt {
 15616  .  .  .  .  .  .  Op: <op-0>
 15617  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 15618  .  .  .  .  .  .  .  X: c @ parser.go:1932:2
 15619  .  .  .  .  .  .  .  Sel: Colon @ parser.go:1932:4
 15620  .  .  .  .  .  .  }
 15621  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15622  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15623  .  .  .  .  .  .  .  .  X: p @ parser.go:1932:12
 15624  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1932:14
 15625  .  .  .  .  .  .  .  }
 15626  .  .  .  .  .  .  .  ArgList: nil
 15627  .  .  .  .  .  .  .  HasDots: false
 15628  .  .  .  .  .  .  }
 15629  .  .  .  .  .  }
 15630  .  .  .  .  .  5: *syntax.ExprStmt {
 15631  .  .  .  .  .  .  X: *syntax.CallExpr {
 15632  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15633  .  .  .  .  .  .  .  .  X: p @ parser.go:1933:2
 15634  .  .  .  .  .  .  .  .  Sel: want @ parser.go:1933:4
 15635  .  .  .  .  .  .  .  }
 15636  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15637  .  .  .  .  .  .  .  .  0: _Colon @ parser.go:1933:9
 15638  .  .  .  .  .  .  .  }
 15639  .  .  .  .  .  .  .  HasDots: false
 15640  .  .  .  .  .  .  }
 15641  .  .  .  .  .  }
 15642  .  .  .  .  .  6: *syntax.AssignStmt {
 15643  .  .  .  .  .  .  Op: <op-0>
 15644  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 15645  .  .  .  .  .  .  .  X: c @ parser.go:1934:2
 15646  .  .  .  .  .  .  .  Sel: Body @ parser.go:1934:4
 15647  .  .  .  .  .  .  }
 15648  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15649  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15650  .  .  .  .  .  .  .  .  X: p @ parser.go:1934:11
 15651  .  .  .  .  .  .  .  .  Sel: stmtList @ parser.go:1934:13
 15652  .  .  .  .  .  .  .  }
 15653  .  .  .  .  .  .  .  ArgList: nil
 15654  .  .  .  .  .  .  .  HasDots: false
 15655  .  .  .  .  .  .  }
 15656  .  .  .  .  .  }
 15657  .  .  .  .  .  7: *syntax.ReturnStmt {
 15658  .  .  .  .  .  .  Results: c @ parser.go:1936:9
 15659  .  .  .  .  .  }
 15660  .  .  .  .  }
 15661  .  .  .  .  Rbrace: src.Pos {}
 15662  .  .  .  }
 15663  .  .  .  Pragma: 0
 15664  .  .  }
 15665  .  .  71: *syntax.FuncDecl {
 15666  .  .  .  Attr: map[]
 15667  .  .  .  Recv: *syntax.Field {
 15668  .  .  .  .  Name: p @ parser.go:1944:7
 15669  .  .  .  .  Type: *syntax.Operation {
 15670  .  .  .  .  .  Op: *
 15671  .  .  .  .  .  X: parser @ parser.go:1944:10
 15672  .  .  .  .  .  Y: nil
 15673  .  .  .  .  }
 15674  .  .  .  }
 15675  .  .  .  Name: stmtOrNil @ parser.go:1944:18
 15676  .  .  .  Type: *syntax.FuncType {
 15677  .  .  .  .  ParamList: nil
 15678  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 15679  .  .  .  .  .  0: *syntax.Field {
 15680  .  .  .  .  .  .  Name: nil
 15681  .  .  .  .  .  .  Type: Stmt @ parser.go:1944:30
 15682  .  .  .  .  .  }
 15683  .  .  .  .  }
 15684  .  .  .  }
 15685  .  .  .  Body: *syntax.BlockStmt {
 15686  .  .  .  .  List: []syntax.Stmt (4 entries) {
 15687  .  .  .  .  .  0: *syntax.IfStmt {
 15688  .  .  .  .  .  .  Init: nil
 15689  .  .  .  .  .  .  Cond: trace @ parser.go:1945:5
 15690  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 15691  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 15692  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 15693  .  .  .  .  .  .  .  .  .  Tok: defer
 15694  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 15695  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 15696  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15697  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1946:9
 15698  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:1946:11
 15699  .  .  .  .  .  .  .  .  .  .  .  }
 15700  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15701  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.Operation {
 15702  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: +
 15703  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
 15704  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"stmt \""
 15705  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 15706  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 15707  .  .  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
 15708  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15709  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 15710  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1946:27
 15711  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1946:29
 15712  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 15713  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: String @ parser.go:1946:33
 15714  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 15715  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15716  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15717  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 15718  .  .  .  .  .  .  .  .  .  .  .  .  }
 15719  .  .  .  .  .  .  .  .  .  .  .  }
 15720  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15721  .  .  .  .  .  .  .  .  .  .  }
 15722  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15723  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15724  .  .  .  .  .  .  .  .  .  }
 15725  .  .  .  .  .  .  .  .  }
 15726  .  .  .  .  .  .  .  }
 15727  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 15728  .  .  .  .  .  .  }
 15729  .  .  .  .  .  .  Else: nil
 15730  .  .  .  .  .  }
 15731  .  .  .  .  .  1: *syntax.IfStmt {
 15732  .  .  .  .  .  .  Init: nil
 15733  .  .  .  .  .  .  Cond: *syntax.Operation {
 15734  .  .  .  .  .  .  .  Op: ==
 15735  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 15736  .  .  .  .  .  .  .  .  X: p @ parser.go:1951:5
 15737  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1951:7
 15738  .  .  .  .  .  .  .  }
 15739  .  .  .  .  .  .  .  Y: _Name @ parser.go:1951:14
 15740  .  .  .  .  .  .  }
 15741  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 15742  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
 15743  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 15744  .  .  .  .  .  .  .  .  .  Op: :
 15745  .  .  .  .  .  .  .  .  .  Lhs: lhs @ parser.go:1952:3
 15746  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 15747  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15748  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1952:10
 15749  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList @ parser.go:1952:12
 15750  .  .  .  .  .  .  .  .  .  .  }
 15751  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 15752  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15753  .  .  .  .  .  .  .  .  .  }
 15754  .  .  .  .  .  .  .  .  }
 15755  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 15756  .  .  .  .  .  .  .  .  .  Init: *syntax.AssignStmt {
 15757  .  .  .  .  .  .  .  .  .  .  Op: :
 15758  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 15759  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 15760  .  .  .  .  .  .  .  .  .  .  .  .  0: label @ parser.go:1953:6
 15761  .  .  .  .  .  .  .  .  .  .  .  .  1: ok @ parser.go:1953:13
 15762  .  .  .  .  .  .  .  .  .  .  .  }
 15763  .  .  .  .  .  .  .  .  .  .  }
 15764  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 15765  .  .  .  .  .  .  .  .  .  .  .  X: lhs @ parser.go:1953:19
 15766  .  .  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 15767  .  .  .  .  .  .  .  .  .  .  .  .  Op: *
 15768  .  .  .  .  .  .  .  .  .  .  .  .  X: Name @ parser.go:1953:25
 15769  .  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 15770  .  .  .  .  .  .  .  .  .  .  .  }
 15771  .  .  .  .  .  .  .  .  .  .  }
 15772  .  .  .  .  .  .  .  .  .  }
 15773  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 15774  .  .  .  .  .  .  .  .  .  .  Op: &&
 15775  .  .  .  .  .  .  .  .  .  .  X: ok @ parser.go:1953:32
 15776  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 15777  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 15778  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 15779  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1953:38
 15780  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:1953:40
 15781  .  .  .  .  .  .  .  .  .  .  .  }
 15782  .  .  .  .  .  .  .  .  .  .  .  Y: _Colon @ parser.go:1953:47
 15783  .  .  .  .  .  .  .  .  .  .  }
 15784  .  .  .  .  .  .  .  .  .  }
 15785  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 15786  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 15787  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 15788  .  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 15789  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15790  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1954:11
 15791  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: labeledStmtOrNil @ parser.go:1954:13
 15792  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 15793  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15794  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: label @ parser.go:1954:30
 15795  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 15796  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15797  .  .  .  .  .  .  .  .  .  .  .  .  }
 15798  .  .  .  .  .  .  .  .  .  .  .  }
 15799  .  .  .  .  .  .  .  .  .  .  }
 15800  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 15801  .  .  .  .  .  .  .  .  .  }
 15802  .  .  .  .  .  .  .  .  .  Else: nil
 15803  .  .  .  .  .  .  .  .  }
 15804  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 15805  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 15806  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15807  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1956:10
 15808  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt @ parser.go:1956:12
 15809  .  .  .  .  .  .  .  .  .  .  }
 15810  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 15811  .  .  .  .  .  .  .  .  .  .  .  0: lhs @ parser.go:1956:23
 15812  .  .  .  .  .  .  .  .  .  .  .  1: false @ parser.go:1956:28
 15813  .  .  .  .  .  .  .  .  .  .  }
 15814  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15815  .  .  .  .  .  .  .  .  .  }
 15816  .  .  .  .  .  .  .  .  }
 15817  .  .  .  .  .  .  .  }
 15818  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 15819  .  .  .  .  .  .  }
 15820  .  .  .  .  .  .  Else: nil
 15821  .  .  .  .  .  }
 15822  .  .  .  .  .  2: *syntax.SwitchStmt {
 15823  .  .  .  .  .  .  Init: nil
 15824  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 15825  .  .  .  .  .  .  .  X: p @ parser.go:1959:9
 15826  .  .  .  .  .  .  .  Sel: tok @ parser.go:1959:11
 15827  .  .  .  .  .  .  }
 15828  .  .  .  .  .  .  Body: []*syntax.CaseClause (16 entries) {
 15829  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 15830  .  .  .  .  .  .  .  .  Cases: _Lbrace @ parser.go:1960:7
 15831  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15832  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 15833  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 15834  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15835  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1961:10
 15836  .  .  .  .  .  .  .  .  .  .  .  .  Sel: blockStmt @ parser.go:1961:12
 15837  .  .  .  .  .  .  .  .  .  .  .  }
 15838  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15839  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 15840  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"\""
 15841  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 15842  .  .  .  .  .  .  .  .  .  .  .  .  }
 15843  .  .  .  .  .  .  .  .  .  .  .  }
 15844  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15845  .  .  .  .  .  .  .  .  .  .  }
 15846  .  .  .  .  .  .  .  .  .  }
 15847  .  .  .  .  .  .  .  .  }
 15848  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15849  .  .  .  .  .  .  .  }
 15850  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 15851  .  .  .  .  .  .  .  .  Cases: _Var @ parser.go:1963:7
 15852  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15853  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 15854  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 15855  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15856  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1964:10
 15857  .  .  .  .  .  .  .  .  .  .  .  .  Sel: declStmt @ parser.go:1964:12
 15858  .  .  .  .  .  .  .  .  .  .  .  }
 15859  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15860  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 15861  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1964:21
 15862  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: varDecl @ parser.go:1964:23
 15863  .  .  .  .  .  .  .  .  .  .  .  .  }
 15864  .  .  .  .  .  .  .  .  .  .  .  }
 15865  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15866  .  .  .  .  .  .  .  .  .  .  }
 15867  .  .  .  .  .  .  .  .  .  }
 15868  .  .  .  .  .  .  .  .  }
 15869  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15870  .  .  .  .  .  .  .  }
 15871  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 15872  .  .  .  .  .  .  .  .  Cases: _Const @ parser.go:1966:7
 15873  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15874  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 15875  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 15876  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15877  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1967:10
 15878  .  .  .  .  .  .  .  .  .  .  .  .  Sel: declStmt @ parser.go:1967:12
 15879  .  .  .  .  .  .  .  .  .  .  .  }
 15880  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15881  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 15882  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1967:21
 15883  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: constDecl @ parser.go:1967:23
 15884  .  .  .  .  .  .  .  .  .  .  .  .  }
 15885  .  .  .  .  .  .  .  .  .  .  .  }
 15886  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15887  .  .  .  .  .  .  .  .  .  .  }
 15888  .  .  .  .  .  .  .  .  .  }
 15889  .  .  .  .  .  .  .  .  }
 15890  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15891  .  .  .  .  .  .  .  }
 15892  .  .  .  .  .  .  .  3: *syntax.CaseClause {
 15893  .  .  .  .  .  .  .  .  Cases: _Type @ parser.go:1969:7
 15894  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15895  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 15896  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 15897  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15898  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1970:10
 15899  .  .  .  .  .  .  .  .  .  .  .  .  Sel: declStmt @ parser.go:1970:12
 15900  .  .  .  .  .  .  .  .  .  .  .  }
 15901  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 15902  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 15903  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1970:21
 15904  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: typeDecl @ parser.go:1970:23
 15905  .  .  .  .  .  .  .  .  .  .  .  .  }
 15906  .  .  .  .  .  .  .  .  .  .  .  }
 15907  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15908  .  .  .  .  .  .  .  .  .  .  }
 15909  .  .  .  .  .  .  .  .  .  }
 15910  .  .  .  .  .  .  .  .  }
 15911  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15912  .  .  .  .  .  .  .  }
 15913  .  .  .  .  .  .  .  4: *syntax.CaseClause {
 15914  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 15915  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 15916  .  .  .  .  .  .  .  .  .  .  0: _Operator @ parser.go:1972:7
 15917  .  .  .  .  .  .  .  .  .  .  1: _Star @ parser.go:1972:18
 15918  .  .  .  .  .  .  .  .  .  }
 15919  .  .  .  .  .  .  .  .  }
 15920  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15921  .  .  .  .  .  .  .  .  .  0: *syntax.SwitchStmt {
 15922  .  .  .  .  .  .  .  .  .  .  Init: nil
 15923  .  .  .  .  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 15924  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1973:10
 15925  .  .  .  .  .  .  .  .  .  .  .  Sel: op @ parser.go:1973:12
 15926  .  .  .  .  .  .  .  .  .  .  }
 15927  .  .  .  .  .  .  .  .  .  .  Body: []*syntax.CaseClause (1 entries) {
 15928  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 15929  .  .  .  .  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 15930  .  .  .  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (6 entries) {
 15931  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: Add @ parser.go:1974:8
 15932  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: Sub @ parser.go:1974:13
 15933  .  .  .  .  .  .  .  .  .  .  .  .  .  .  2: Mul @ parser.go:1974:18
 15934  .  .  .  .  .  .  .  .  .  .  .  .  .  .  3: And @ parser.go:1974:23
 15935  .  .  .  .  .  .  .  .  .  .  .  .  .  .  4: Xor @ parser.go:1974:28
 15936  .  .  .  .  .  .  .  .  .  .  .  .  .  .  5: Not @ parser.go:1974:33
 15937  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 15938  .  .  .  .  .  .  .  .  .  .  .  .  }
 15939  .  .  .  .  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15940  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 15941  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 15942  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15943  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1975:11
 15944  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt @ parser.go:1975:13
 15945  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 15946  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 15947  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1975:24
 15948  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: false @ parser.go:1975:29
 15949  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 15950  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15951  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 15952  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 15953  .  .  .  .  .  .  .  .  .  .  .  .  }
 15954  .  .  .  .  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15955  .  .  .  .  .  .  .  .  .  .  .  }
 15956  .  .  .  .  .  .  .  .  .  .  }
 15957  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 15958  .  .  .  .  .  .  .  .  .  }
 15959  .  .  .  .  .  .  .  .  }
 15960  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15961  .  .  .  .  .  .  .  }
 15962  .  .  .  .  .  .  .  5: *syntax.CaseClause {
 15963  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 15964  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (9 entries) {
 15965  .  .  .  .  .  .  .  .  .  .  0: _Literal @ parser.go:1978:7
 15966  .  .  .  .  .  .  .  .  .  .  1: _Func @ parser.go:1978:17
 15967  .  .  .  .  .  .  .  .  .  .  2: _Lparen @ parser.go:1978:24
 15968  .  .  .  .  .  .  .  .  .  .  3: _Lbrack @ parser.go:1979:3
 15969  .  .  .  .  .  .  .  .  .  .  4: _Struct @ parser.go:1979:12
 15970  .  .  .  .  .  .  .  .  .  .  5: _Map @ parser.go:1979:21
 15971  .  .  .  .  .  .  .  .  .  .  6: _Chan @ parser.go:1979:27
 15972  .  .  .  .  .  .  .  .  .  .  7: _Interface @ parser.go:1979:34
 15973  .  .  .  .  .  .  .  .  .  .  8: _Arrow @ parser.go:1980:3
 15974  .  .  .  .  .  .  .  .  .  }
 15975  .  .  .  .  .  .  .  .  }
 15976  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15977  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 15978  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 15979  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15980  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1981:10
 15981  .  .  .  .  .  .  .  .  .  .  .  .  Sel: simpleStmt @ parser.go:1981:12
 15982  .  .  .  .  .  .  .  .  .  .  .  }
 15983  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 15984  .  .  .  .  .  .  .  .  .  .  .  .  0: nil @ parser.go:1981:23
 15985  .  .  .  .  .  .  .  .  .  .  .  .  1: false @ parser.go:1981:28
 15986  .  .  .  .  .  .  .  .  .  .  .  }
 15987  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 15988  .  .  .  .  .  .  .  .  .  .  }
 15989  .  .  .  .  .  .  .  .  .  }
 15990  .  .  .  .  .  .  .  .  }
 15991  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 15992  .  .  .  .  .  .  .  }
 15993  .  .  .  .  .  .  .  6: *syntax.CaseClause {
 15994  .  .  .  .  .  .  .  .  Cases: _For @ parser.go:1983:7
 15995  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 15996  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 15997  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 15998  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 15999  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1984:10
 16000  .  .  .  .  .  .  .  .  .  .  .  .  Sel: forStmt @ parser.go:1984:12
 16001  .  .  .  .  .  .  .  .  .  .  .  }
 16002  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16003  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16004  .  .  .  .  .  .  .  .  .  .  }
 16005  .  .  .  .  .  .  .  .  .  }
 16006  .  .  .  .  .  .  .  .  }
 16007  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 16008  .  .  .  .  .  .  .  }
 16009  .  .  .  .  .  .  .  7: *syntax.CaseClause {
 16010  .  .  .  .  .  .  .  .  Cases: _Switch @ parser.go:1986:7
 16011  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 16012  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 16013  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 16014  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16015  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1987:10
 16016  .  .  .  .  .  .  .  .  .  .  .  .  Sel: switchStmt @ parser.go:1987:12
 16017  .  .  .  .  .  .  .  .  .  .  .  }
 16018  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16019  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16020  .  .  .  .  .  .  .  .  .  .  }
 16021  .  .  .  .  .  .  .  .  .  }
 16022  .  .  .  .  .  .  .  .  }
 16023  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 16024  .  .  .  .  .  .  .  }
 16025  .  .  .  .  .  .  .  8: *syntax.CaseClause {
 16026  .  .  .  .  .  .  .  .  Cases: _Select @ parser.go:1989:7
 16027  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 16028  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 16029  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 16030  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16031  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1990:10
 16032  .  .  .  .  .  .  .  .  .  .  .  .  Sel: selectStmt @ parser.go:1990:12
 16033  .  .  .  .  .  .  .  .  .  .  .  }
 16034  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16035  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16036  .  .  .  .  .  .  .  .  .  .  }
 16037  .  .  .  .  .  .  .  .  .  }
 16038  .  .  .  .  .  .  .  .  }
 16039  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 16040  .  .  .  .  .  .  .  }
 16041  .  .  .  .  .  .  .  9: *syntax.CaseClause {
 16042  .  .  .  .  .  .  .  .  Cases: _If @ parser.go:1992:7
 16043  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 16044  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 16045  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 16046  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16047  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1993:10
 16048  .  .  .  .  .  .  .  .  .  .  .  .  Sel: ifStmt @ parser.go:1993:12
 16049  .  .  .  .  .  .  .  .  .  .  .  }
 16050  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16051  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16052  .  .  .  .  .  .  .  .  .  .  }
 16053  .  .  .  .  .  .  .  .  .  }
 16054  .  .  .  .  .  .  .  .  }
 16055  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 16056  .  .  .  .  .  .  .  }
 16057  .  .  .  .  .  .  .  10: *syntax.CaseClause {
 16058  .  .  .  .  .  .  .  .  Cases: _Fallthrough @ parser.go:1995:7
 16059  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (5 entries) {
 16060  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 16061  .  .  .  .  .  .  .  .  .  .  Op: :
 16062  .  .  .  .  .  .  .  .  .  .  Lhs: s @ parser.go:1996:3
 16063  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16064  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:1996:8
 16065  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16066  .  .  .  .  .  .  .  .  .  .  .  .  0: BranchStmt @ parser.go:1996:12
 16067  .  .  .  .  .  .  .  .  .  .  .  }
 16068  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16069  .  .  .  .  .  .  .  .  .  .  }
 16070  .  .  .  .  .  .  .  .  .  }
 16071  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 16072  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16073  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16074  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1997:3
 16075  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1997:5
 16076  .  .  .  .  .  .  .  .  .  .  }
 16077  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16078  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16079  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1997:11
 16080  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:1997:13
 16081  .  .  .  .  .  .  .  .  .  .  .  }
 16082  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16083  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16084  .  .  .  .  .  .  .  .  .  .  }
 16085  .  .  .  .  .  .  .  .  .  }
 16086  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 16087  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 16088  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16089  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:1998:3
 16090  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:1998:5
 16091  .  .  .  .  .  .  .  .  .  .  .  }
 16092  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16093  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16094  .  .  .  .  .  .  .  .  .  .  }
 16095  .  .  .  .  .  .  .  .  .  }
 16096  .  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
 16097  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16098  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16099  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:1999:3
 16100  .  .  .  .  .  .  .  .  .  .  .  Sel: Tok @ parser.go:1999:5
 16101  .  .  .  .  .  .  .  .  .  .  }
 16102  .  .  .  .  .  .  .  .  .  .  Rhs: _Fallthrough @ parser.go:1999:11
 16103  .  .  .  .  .  .  .  .  .  }
 16104  .  .  .  .  .  .  .  .  .  4: *syntax.ReturnStmt {
 16105  .  .  .  .  .  .  .  .  .  .  Results: s @ parser.go:2000:10
 16106  .  .  .  .  .  .  .  .  .  }
 16107  .  .  .  .  .  .  .  .  }
 16108  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 16109  .  .  .  .  .  .  .  }
 16110  .  .  .  .  .  .  .  11: *syntax.CaseClause {
 16111  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 16112  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 16113  .  .  .  .  .  .  .  .  .  .  0: _Break @ parser.go:2002:7
 16114  .  .  .  .  .  .  .  .  .  .  1: _Continue @ parser.go:2002:15
 16115  .  .  .  .  .  .  .  .  .  }
 16116  .  .  .  .  .  .  .  .  }
 16117  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
 16118  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 16119  .  .  .  .  .  .  .  .  .  .  Op: :
 16120  .  .  .  .  .  .  .  .  .  .  Lhs: s @ parser.go:2003:3
 16121  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16122  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:2003:8
 16123  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16124  .  .  .  .  .  .  .  .  .  .  .  .  0: BranchStmt @ parser.go:2003:12
 16125  .  .  .  .  .  .  .  .  .  .  .  }
 16126  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16127  .  .  .  .  .  .  .  .  .  .  }
 16128  .  .  .  .  .  .  .  .  .  }
 16129  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 16130  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16131  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16132  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:2004:3
 16133  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:2004:5
 16134  .  .  .  .  .  .  .  .  .  .  }
 16135  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16136  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16137  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2004:11
 16138  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:2004:13
 16139  .  .  .  .  .  .  .  .  .  .  .  }
 16140  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16141  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16142  .  .  .  .  .  .  .  .  .  .  }
 16143  .  .  .  .  .  .  .  .  .  }
 16144  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 16145  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16146  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16147  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:2005:3
 16148  .  .  .  .  .  .  .  .  .  .  .  Sel: Tok @ parser.go:2005:5
 16149  .  .  .  .  .  .  .  .  .  .  }
 16150  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 16151  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2005:11
 16152  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2005:13
 16153  .  .  .  .  .  .  .  .  .  .  }
 16154  .  .  .  .  .  .  .  .  .  }
 16155  .  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
 16156  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 16157  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16158  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2006:3
 16159  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:2006:5
 16160  .  .  .  .  .  .  .  .  .  .  .  }
 16161  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16162  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16163  .  .  .  .  .  .  .  .  .  .  }
 16164  .  .  .  .  .  .  .  .  .  }
 16165  .  .  .  .  .  .  .  .  .  4: *syntax.IfStmt {
 16166  .  .  .  .  .  .  .  .  .  .  Init: nil
 16167  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 16168  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 16169  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 16170  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2007:6
 16171  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2007:8
 16172  .  .  .  .  .  .  .  .  .  .  .  }
 16173  .  .  .  .  .  .  .  .  .  .  .  Y: _Name @ parser.go:2007:15
 16174  .  .  .  .  .  .  .  .  .  .  }
 16175  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 16176  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 16177  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 16178  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16179  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16180  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:2008:4
 16181  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Label @ parser.go:2008:6
 16182  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 16183  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16184  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16185  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2008:14
 16186  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:2008:16
 16187  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 16188  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16189  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16190  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 16191  .  .  .  .  .  .  .  .  .  .  .  .  }
 16192  .  .  .  .  .  .  .  .  .  .  .  }
 16193  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 16194  .  .  .  .  .  .  .  .  .  .  }
 16195  .  .  .  .  .  .  .  .  .  .  Else: nil
 16196  .  .  .  .  .  .  .  .  .  }
 16197  .  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
 16198  .  .  .  .  .  .  .  .  .  .  Results: s @ parser.go:2010:10
 16199  .  .  .  .  .  .  .  .  .  }
 16200  .  .  .  .  .  .  .  .  }
 16201  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 16202  .  .  .  .  .  .  .  }
 16203  .  .  .  .  .  .  .  12: *syntax.CaseClause {
 16204  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 16205  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 16206  .  .  .  .  .  .  .  .  .  .  0: _Go @ parser.go:2012:7
 16207  .  .  .  .  .  .  .  .  .  .  1: _Defer @ parser.go:2012:12
 16208  .  .  .  .  .  .  .  .  .  }
 16209  .  .  .  .  .  .  .  .  }
 16210  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 16211  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 16212  .  .  .  .  .  .  .  .  .  .  Results: *syntax.CallExpr {
 16213  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16214  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2013:10
 16215  .  .  .  .  .  .  .  .  .  .  .  .  Sel: callStmt @ parser.go:2013:12
 16216  .  .  .  .  .  .  .  .  .  .  .  }
 16217  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16218  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16219  .  .  .  .  .  .  .  .  .  .  }
 16220  .  .  .  .  .  .  .  .  .  }
 16221  .  .  .  .  .  .  .  .  }
 16222  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 16223  .  .  .  .  .  .  .  }
 16224  .  .  .  .  .  .  .  13: *syntax.CaseClause {
 16225  .  .  .  .  .  .  .  .  Cases: _Goto @ parser.go:2015:7
 16226  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (6 entries) {
 16227  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 16228  .  .  .  .  .  .  .  .  .  .  Op: :
 16229  .  .  .  .  .  .  .  .  .  .  Lhs: s @ parser.go:2016:3
 16230  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16231  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:2016:8
 16232  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16233  .  .  .  .  .  .  .  .  .  .  .  .  0: BranchStmt @ parser.go:2016:12
 16234  .  .  .  .  .  .  .  .  .  .  .  }
 16235  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16236  .  .  .  .  .  .  .  .  .  .  }
 16237  .  .  .  .  .  .  .  .  .  }
 16238  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 16239  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16240  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16241  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:2017:3
 16242  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:2017:5
 16243  .  .  .  .  .  .  .  .  .  .  }
 16244  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16245  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16246  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2017:11
 16247  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:2017:13
 16248  .  .  .  .  .  .  .  .  .  .  .  }
 16249  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16250  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16251  .  .  .  .  .  .  .  .  .  .  }
 16252  .  .  .  .  .  .  .  .  .  }
 16253  .  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 16254  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16255  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16256  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:2018:3
 16257  .  .  .  .  .  .  .  .  .  .  .  Sel: Tok @ parser.go:2018:5
 16258  .  .  .  .  .  .  .  .  .  .  }
 16259  .  .  .  .  .  .  .  .  .  .  Rhs: _Goto @ parser.go:2018:11
 16260  .  .  .  .  .  .  .  .  .  }
 16261  .  .  .  .  .  .  .  .  .  3: *syntax.ExprStmt {
 16262  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 16263  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16264  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2019:3
 16265  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:2019:5
 16266  .  .  .  .  .  .  .  .  .  .  .  }
 16267  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16268  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16269  .  .  .  .  .  .  .  .  .  .  }
 16270  .  .  .  .  .  .  .  .  .  }
 16271  .  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
 16272  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16273  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16274  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:2020:3
 16275  .  .  .  .  .  .  .  .  .  .  .  Sel: Label @ parser.go:2020:5
 16276  .  .  .  .  .  .  .  .  .  .  }
 16277  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16278  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16279  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2020:13
 16280  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:2020:15
 16281  .  .  .  .  .  .  .  .  .  .  .  }
 16282  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16283  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16284  .  .  .  .  .  .  .  .  .  .  }
 16285  .  .  .  .  .  .  .  .  .  }
 16286  .  .  .  .  .  .  .  .  .  5: *syntax.ReturnStmt {
 16287  .  .  .  .  .  .  .  .  .  .  Results: s @ parser.go:2021:10
 16288  .  .  .  .  .  .  .  .  .  }
 16289  .  .  .  .  .  .  .  .  }
 16290  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 16291  .  .  .  .  .  .  .  }
 16292  .  .  .  .  .  .  .  14: *syntax.CaseClause {
 16293  .  .  .  .  .  .  .  .  Cases: _Return @ parser.go:2023:7
 16294  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (5 entries) {
 16295  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 16296  .  .  .  .  .  .  .  .  .  .  Op: :
 16297  .  .  .  .  .  .  .  .  .  .  Lhs: s @ parser.go:2024:3
 16298  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16299  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:2024:8
 16300  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16301  .  .  .  .  .  .  .  .  .  .  .  .  0: ReturnStmt @ parser.go:2024:12
 16302  .  .  .  .  .  .  .  .  .  .  .  }
 16303  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16304  .  .  .  .  .  .  .  .  .  .  }
 16305  .  .  .  .  .  .  .  .  .  }
 16306  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 16307  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16308  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16309  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:2025:3
 16310  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:2025:5
 16311  .  .  .  .  .  .  .  .  .  .  }
 16312  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16313  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16314  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2025:11
 16315  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:2025:13
 16316  .  .  .  .  .  .  .  .  .  .  .  }
 16317  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16318  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16319  .  .  .  .  .  .  .  .  .  .  }
 16320  .  .  .  .  .  .  .  .  .  }
 16321  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 16322  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 16323  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16324  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2026:3
 16325  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:2026:5
 16326  .  .  .  .  .  .  .  .  .  .  .  }
 16327  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16328  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16329  .  .  .  .  .  .  .  .  .  .  }
 16330  .  .  .  .  .  .  .  .  .  }
 16331  .  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
 16332  .  .  .  .  .  .  .  .  .  .  Init: nil
 16333  .  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 16334  .  .  .  .  .  .  .  .  .  .  .  Op: &&
 16335  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 16336  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 16337  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 16338  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2027:6
 16339  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2027:8
 16340  .  .  .  .  .  .  .  .  .  .  .  .  }
 16341  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Semi @ parser.go:2027:15
 16342  .  .  .  .  .  .  .  .  .  .  .  }
 16343  .  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 16344  .  .  .  .  .  .  .  .  .  .  .  .  Op: !=
 16345  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 16346  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2027:24
 16347  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2027:26
 16348  .  .  .  .  .  .  .  .  .  .  .  .  }
 16349  .  .  .  .  .  .  .  .  .  .  .  .  Y: _Rbrace @ parser.go:2027:33
 16350  .  .  .  .  .  .  .  .  .  .  .  }
 16351  .  .  .  .  .  .  .  .  .  .  }
 16352  .  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 16353  .  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 16354  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 16355  .  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16356  .  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16357  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:2028:4
 16358  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: Results @ parser.go:2028:6
 16359  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 16360  .  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16361  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16362  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2028:16
 16363  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: exprList @ parser.go:2028:18
 16364  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 16365  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16366  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16367  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 16368  .  .  .  .  .  .  .  .  .  .  .  .  }
 16369  .  .  .  .  .  .  .  .  .  .  .  }
 16370  .  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 16371  .  .  .  .  .  .  .  .  .  .  }
 16372  .  .  .  .  .  .  .  .  .  .  Else: nil
 16373  .  .  .  .  .  .  .  .  .  }
 16374  .  .  .  .  .  .  .  .  .  4: *syntax.ReturnStmt {
 16375  .  .  .  .  .  .  .  .  .  .  Results: s @ parser.go:2030:10
 16376  .  .  .  .  .  .  .  .  .  }
 16377  .  .  .  .  .  .  .  .  }
 16378  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 16379  .  .  .  .  .  .  .  }
 16380  .  .  .  .  .  .  .  15: *syntax.CaseClause {
 16381  .  .  .  .  .  .  .  .  Cases: _Semi @ parser.go:2032:7
 16382  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 16383  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 16384  .  .  .  .  .  .  .  .  .  .  Op: :
 16385  .  .  .  .  .  .  .  .  .  .  Lhs: s @ parser.go:2033:3
 16386  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16387  .  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:2033:8
 16388  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16389  .  .  .  .  .  .  .  .  .  .  .  .  0: EmptyStmt @ parser.go:2033:12
 16390  .  .  .  .  .  .  .  .  .  .  .  }
 16391  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16392  .  .  .  .  .  .  .  .  .  .  }
 16393  .  .  .  .  .  .  .  .  .  }
 16394  .  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 16395  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16396  .  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16397  .  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:2034:3
 16398  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:2034:5
 16399  .  .  .  .  .  .  .  .  .  .  }
 16400  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16401  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16402  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2034:11
 16403  .  .  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:2034:13
 16404  .  .  .  .  .  .  .  .  .  .  .  }
 16405  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16406  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16407  .  .  .  .  .  .  .  .  .  .  }
 16408  .  .  .  .  .  .  .  .  .  }
 16409  .  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 16410  .  .  .  .  .  .  .  .  .  .  Results: s @ parser.go:2035:10
 16411  .  .  .  .  .  .  .  .  .  }
 16412  .  .  .  .  .  .  .  .  }
 16413  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 16414  .  .  .  .  .  .  .  }
 16415  .  .  .  .  .  .  }
 16416  .  .  .  .  .  .  Rbrace: src.Pos {}
 16417  .  .  .  .  .  }
 16418  .  .  .  .  .  3: *syntax.ReturnStmt {
 16419  .  .  .  .  .  .  Results: nil @ parser.go:2038:9
 16420  .  .  .  .  .  }
 16421  .  .  .  .  }
 16422  .  .  .  .  Rbrace: src.Pos {}
 16423  .  .  .  }
 16424  .  .  .  Pragma: 0
 16425  .  .  }
 16426  .  .  72: *syntax.FuncDecl {
 16427  .  .  .  Attr: map[]
 16428  .  .  .  Recv: *syntax.Field {
 16429  .  .  .  .  Name: p @ parser.go:2042:7
 16430  .  .  .  .  Type: *syntax.Operation {
 16431  .  .  .  .  .  Op: *
 16432  .  .  .  .  .  X: parser @ parser.go:2042:10
 16433  .  .  .  .  .  Y: nil
 16434  .  .  .  .  }
 16435  .  .  .  }
 16436  .  .  .  Name: stmtList @ parser.go:2042:18
 16437  .  .  .  Type: *syntax.FuncType {
 16438  .  .  .  .  ParamList: nil
 16439  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 16440  .  .  .  .  .  0: *syntax.Field {
 16441  .  .  .  .  .  .  Name: l @ parser.go:2042:30
 16442  .  .  .  .  .  .  Type: *syntax.SliceType {
 16443  .  .  .  .  .  .  .  Elem: Stmt @ parser.go:2042:34
 16444  .  .  .  .  .  .  }
 16445  .  .  .  .  .  }
 16446  .  .  .  .  }
 16447  .  .  .  }
 16448  .  .  .  Body: *syntax.BlockStmt {
 16449  .  .  .  .  List: []syntax.Stmt (3 entries) {
 16450  .  .  .  .  .  0: *syntax.IfStmt {
 16451  .  .  .  .  .  .  Init: nil
 16452  .  .  .  .  .  .  Cond: trace @ parser.go:2043:5
 16453  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 16454  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 16455  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 16456  .  .  .  .  .  .  .  .  .  Tok: defer
 16457  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 16458  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 16459  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16460  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2044:9
 16461  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:2044:11
 16462  .  .  .  .  .  .  .  .  .  .  .  }
 16463  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16464  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 16465  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"stmtList\""
 16466  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 16467  .  .  .  .  .  .  .  .  .  .  .  .  }
 16468  .  .  .  .  .  .  .  .  .  .  .  }
 16469  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16470  .  .  .  .  .  .  .  .  .  .  }
 16471  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16472  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16473  .  .  .  .  .  .  .  .  .  }
 16474  .  .  .  .  .  .  .  .  }
 16475  .  .  .  .  .  .  .  }
 16476  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 16477  .  .  .  .  .  .  }
 16478  .  .  .  .  .  .  Else: nil
 16479  .  .  .  .  .  }
 16480  .  .  .  .  .  1: *syntax.ForStmt {
 16481  .  .  .  .  .  .  Init: nil
 16482  .  .  .  .  .  .  Cond: *syntax.Operation {
 16483  .  .  .  .  .  .  .  Op: &&
 16484  .  .  .  .  .  .  .  X: *syntax.Operation {
 16485  .  .  .  .  .  .  .  .  Op: &&
 16486  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 16487  .  .  .  .  .  .  .  .  .  Op: &&
 16488  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 16489  .  .  .  .  .  .  .  .  .  .  Op: !=
 16490  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 16491  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2047:6
 16492  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2047:8
 16493  .  .  .  .  .  .  .  .  .  .  }
 16494  .  .  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:2047:15
 16495  .  .  .  .  .  .  .  .  .  }
 16496  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 16497  .  .  .  .  .  .  .  .  .  .  Op: !=
 16498  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 16499  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2047:23
 16500  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2047:25
 16501  .  .  .  .  .  .  .  .  .  .  }
 16502  .  .  .  .  .  .  .  .  .  .  Y: _Rbrace @ parser.go:2047:32
 16503  .  .  .  .  .  .  .  .  .  }
 16504  .  .  .  .  .  .  .  .  }
 16505  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 16506  .  .  .  .  .  .  .  .  .  Op: !=
 16507  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 16508  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2047:43
 16509  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2047:45
 16510  .  .  .  .  .  .  .  .  .  }
 16511  .  .  .  .  .  .  .  .  .  Y: _Case @ parser.go:2047:52
 16512  .  .  .  .  .  .  .  .  }
 16513  .  .  .  .  .  .  .  }
 16514  .  .  .  .  .  .  .  Y: *syntax.Operation {
 16515  .  .  .  .  .  .  .  .  Op: !=
 16516  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 16517  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2047:61
 16518  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2047:63
 16519  .  .  .  .  .  .  .  .  }
 16520  .  .  .  .  .  .  .  .  Y: _Default @ parser.go:2047:70
 16521  .  .  .  .  .  .  .  }
 16522  .  .  .  .  .  .  }
 16523  .  .  .  .  .  .  Post: nil
 16524  .  .  .  .  .  .  Body: *syntax.BlockStmt {
 16525  .  .  .  .  .  .  .  List: []syntax.Stmt (5 entries) {
 16526  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 16527  .  .  .  .  .  .  .  .  .  Op: :
 16528  .  .  .  .  .  .  .  .  .  Lhs: s @ parser.go:2048:3
 16529  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16530  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16531  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2048:8
 16532  .  .  .  .  .  .  .  .  .  .  .  Sel: stmtOrNil @ parser.go:2048:10
 16533  .  .  .  .  .  .  .  .  .  .  }
 16534  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16535  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16536  .  .  .  .  .  .  .  .  .  }
 16537  .  .  .  .  .  .  .  .  }
 16538  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 16539  .  .  .  .  .  .  .  .  .  Init: nil
 16540  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 16541  .  .  .  .  .  .  .  .  .  .  Op: ==
 16542  .  .  .  .  .  .  .  .  .  .  X: s @ parser.go:2049:6
 16543  .  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:2049:11
 16544  .  .  .  .  .  .  .  .  .  }
 16545  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 16546  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 16547  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
 16548  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
 16549  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
 16550  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 16480)
 16551  .  .  .  .  .  .  .  .  .  .  .  }
 16552  .  .  .  .  .  .  .  .  .  .  }
 16553  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 16554  .  .  .  .  .  .  .  .  .  }
 16555  .  .  .  .  .  .  .  .  .  Else: nil
 16556  .  .  .  .  .  .  .  .  }
 16557  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 16558  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16559  .  .  .  .  .  .  .  .  .  Lhs: l @ parser.go:2052:3
 16560  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16561  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:2052:7
 16562  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 16563  .  .  .  .  .  .  .  .  .  .  .  0: l @ parser.go:2052:14
 16564  .  .  .  .  .  .  .  .  .  .  .  1: s @ parser.go:2052:17
 16565  .  .  .  .  .  .  .  .  .  .  }
 16566  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16567  .  .  .  .  .  .  .  .  .  }
 16568  .  .  .  .  .  .  .  .  }
 16569  .  .  .  .  .  .  .  .  3: *syntax.IfStmt {
 16570  .  .  .  .  .  .  .  .  .  Init: nil
 16571  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 16572  .  .  .  .  .  .  .  .  .  .  Op: ||
 16573  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 16574  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 16575  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 16576  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2055:6
 16577  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2055:8
 16578  .  .  .  .  .  .  .  .  .  .  .  }
 16579  .  .  .  .  .  .  .  .  .  .  .  Y: _Rparen @ parser.go:2055:15
 16580  .  .  .  .  .  .  .  .  .  .  }
 16581  .  .  .  .  .  .  .  .  .  .  Y: *syntax.Operation {
 16582  .  .  .  .  .  .  .  .  .  .  .  Op: ==
 16583  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 16584  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2055:26
 16585  .  .  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2055:28
 16586  .  .  .  .  .  .  .  .  .  .  .  }
 16587  .  .  .  .  .  .  .  .  .  .  .  Y: _Rbrace @ parser.go:2055:35
 16588  .  .  .  .  .  .  .  .  .  .  }
 16589  .  .  .  .  .  .  .  .  .  }
 16590  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 16591  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 16592  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
 16593  .  .  .  .  .  .  .  .  .  .  .  .  Tok: continue
 16594  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
 16595  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 16480)
 16596  .  .  .  .  .  .  .  .  .  .  .  }
 16597  .  .  .  .  .  .  .  .  .  .  }
 16598  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 16599  .  .  .  .  .  .  .  .  .  }
 16600  .  .  .  .  .  .  .  .  .  Else: nil
 16601  .  .  .  .  .  .  .  .  }
 16602  .  .  .  .  .  .  .  .  4: *syntax.IfStmt {
 16603  .  .  .  .  .  .  .  .  .  Init: nil
 16604  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 16605  .  .  .  .  .  .  .  .  .  .  Op: !
 16606  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 16607  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16608  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2058:7
 16609  .  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:2058:9
 16610  .  .  .  .  .  .  .  .  .  .  .  }
 16611  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16612  .  .  .  .  .  .  .  .  .  .  .  .  0: _Semi @ parser.go:2058:13
 16613  .  .  .  .  .  .  .  .  .  .  .  }
 16614  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16615  .  .  .  .  .  .  .  .  .  .  }
 16616  .  .  .  .  .  .  .  .  .  .  Y: nil
 16617  .  .  .  .  .  .  .  .  .  }
 16618  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 16619  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (2 entries) {
 16620  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 16621  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 16622  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16623  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2059:4
 16624  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:2059:6
 16625  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 16626  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16627  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 16628  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"at end of statement\""
 16629  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 16630  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 16631  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 16632  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16633  .  .  .  .  .  .  .  .  .  .  .  .  }
 16634  .  .  .  .  .  .  .  .  .  .  .  }
 16635  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 16636  .  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 16637  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16638  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2060:4
 16639  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:2060:6
 16640  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 16641  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 16642  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Semi @ parser.go:2060:14
 16643  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: _Rbrace @ parser.go:2060:21
 16644  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 16645  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16646  .  .  .  .  .  .  .  .  .  .  .  .  }
 16647  .  .  .  .  .  .  .  .  .  .  .  }
 16648  .  .  .  .  .  .  .  .  .  .  }
 16649  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 16650  .  .  .  .  .  .  .  .  .  }
 16651  .  .  .  .  .  .  .  .  .  Else: nil
 16652  .  .  .  .  .  .  .  .  }
 16653  .  .  .  .  .  .  .  }
 16654  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 16655  .  .  .  .  .  .  }
 16656  .  .  .  .  .  }
 16657  .  .  .  .  .  2: *syntax.ReturnStmt {
 16658  .  .  .  .  .  .  Results: nil
 16659  .  .  .  .  .  }
 16660  .  .  .  .  }
 16661  .  .  .  .  Rbrace: src.Pos {}
 16662  .  .  .  }
 16663  .  .  .  Pragma: 0
 16664  .  .  }
 16665  .  .  73: *syntax.FuncDecl {
 16666  .  .  .  Attr: map[]
 16667  .  .  .  Recv: *syntax.Field {
 16668  .  .  .  .  Name: p @ parser.go:2067:7
 16669  .  .  .  .  Type: *syntax.Operation {
 16670  .  .  .  .  .  Op: *
 16671  .  .  .  .  .  X: parser @ parser.go:2067:10
 16672  .  .  .  .  .  Y: nil
 16673  .  .  .  .  }
 16674  .  .  .  }
 16675  .  .  .  Name: call @ parser.go:2067:18
 16676  .  .  .  Type: *syntax.FuncType {
 16677  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 16678  .  .  .  .  .  0: *syntax.Field {
 16679  .  .  .  .  .  .  Name: fun @ parser.go:2067:23
 16680  .  .  .  .  .  .  Type: Expr @ parser.go:2067:27
 16681  .  .  .  .  .  }
 16682  .  .  .  .  }
 16683  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 16684  .  .  .  .  .  0: *syntax.Field {
 16685  .  .  .  .  .  .  Name: nil
 16686  .  .  .  .  .  .  Type: *syntax.Operation {
 16687  .  .  .  .  .  .  .  Op: *
 16688  .  .  .  .  .  .  .  X: CallExpr @ parser.go:2067:34
 16689  .  .  .  .  .  .  .  Y: nil
 16690  .  .  .  .  .  .  }
 16691  .  .  .  .  .  }
 16692  .  .  .  .  }
 16693  .  .  .  }
 16694  .  .  .  Body: *syntax.BlockStmt {
 16695  .  .  .  .  List: []syntax.Stmt (10 entries) {
 16696  .  .  .  .  .  0: *syntax.IfStmt {
 16697  .  .  .  .  .  .  Init: nil
 16698  .  .  .  .  .  .  Cond: trace @ parser.go:2068:5
 16699  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 16700  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 16701  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 16702  .  .  .  .  .  .  .  .  .  Tok: defer
 16703  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 16704  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 16705  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16706  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2069:9
 16707  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:2069:11
 16708  .  .  .  .  .  .  .  .  .  .  .  }
 16709  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16710  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 16711  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"call\""
 16712  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 16713  .  .  .  .  .  .  .  .  .  .  .  .  }
 16714  .  .  .  .  .  .  .  .  .  .  .  }
 16715  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16716  .  .  .  .  .  .  .  .  .  .  }
 16717  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16718  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16719  .  .  .  .  .  .  .  .  .  }
 16720  .  .  .  .  .  .  .  .  }
 16721  .  .  .  .  .  .  .  }
 16722  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 16723  .  .  .  .  .  .  }
 16724  .  .  .  .  .  .  Else: nil
 16725  .  .  .  .  .  }
 16726  .  .  .  .  .  1: *syntax.AssignStmt {
 16727  .  .  .  .  .  .  Op: :
 16728  .  .  .  .  .  .  Lhs: c @ parser.go:2074:2
 16729  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16730  .  .  .  .  .  .  .  Fun: new @ parser.go:2074:7
 16731  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16732  .  .  .  .  .  .  .  .  0: CallExpr @ parser.go:2074:11
 16733  .  .  .  .  .  .  .  }
 16734  .  .  .  .  .  .  .  HasDots: false
 16735  .  .  .  .  .  .  }
 16736  .  .  .  .  .  }
 16737  .  .  .  .  .  2: *syntax.AssignStmt {
 16738  .  .  .  .  .  .  Op: <op-0>
 16739  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16740  .  .  .  .  .  .  .  X: c @ parser.go:2075:2
 16741  .  .  .  .  .  .  .  Sel: pos @ parser.go:2075:4
 16742  .  .  .  .  .  .  }
 16743  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16744  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16745  .  .  .  .  .  .  .  .  X: p @ parser.go:2075:10
 16746  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:2075:12
 16747  .  .  .  .  .  .  .  }
 16748  .  .  .  .  .  .  .  ArgList: nil
 16749  .  .  .  .  .  .  .  HasDots: false
 16750  .  .  .  .  .  .  }
 16751  .  .  .  .  .  }
 16752  .  .  .  .  .  3: *syntax.AssignStmt {
 16753  .  .  .  .  .  .  Op: <op-0>
 16754  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16755  .  .  .  .  .  .  .  X: c @ parser.go:2076:2
 16756  .  .  .  .  .  .  .  Sel: Fun @ parser.go:2076:4
 16757  .  .  .  .  .  .  }
 16758  .  .  .  .  .  .  Rhs: fun @ parser.go:2076:10
 16759  .  .  .  .  .  }
 16760  .  .  .  .  .  4: *syntax.ExprStmt {
 16761  .  .  .  .  .  .  X: *syntax.CallExpr {
 16762  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16763  .  .  .  .  .  .  .  .  X: p @ parser.go:2078:2
 16764  .  .  .  .  .  .  .  .  Sel: want @ parser.go:2078:4
 16765  .  .  .  .  .  .  .  }
 16766  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16767  .  .  .  .  .  .  .  .  0: _Lparen @ parser.go:2078:9
 16768  .  .  .  .  .  .  .  }
 16769  .  .  .  .  .  .  .  HasDots: false
 16770  .  .  .  .  .  .  }
 16771  .  .  .  .  .  }
 16772  .  .  .  .  .  5: *syntax.AssignStmt {
 16773  .  .  .  .  .  .  Op: +
 16774  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16775  .  .  .  .  .  .  .  X: p @ parser.go:2079:2
 16776  .  .  .  .  .  .  .  Sel: xnest @ parser.go:2079:4
 16777  .  .  .  .  .  .  }
 16778  .  .  .  .  .  .  Rhs: *(Node @ 5597)
 16779  .  .  .  .  .  }
 16780  .  .  .  .  .  6: *syntax.ForStmt {
 16781  .  .  .  .  .  .  Init: nil
 16782  .  .  .  .  .  .  Cond: *syntax.Operation {
 16783  .  .  .  .  .  .  .  Op: &&
 16784  .  .  .  .  .  .  .  X: *syntax.Operation {
 16785  .  .  .  .  .  .  .  .  Op: !=
 16786  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 16787  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2081:6
 16788  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2081:8
 16789  .  .  .  .  .  .  .  .  }
 16790  .  .  .  .  .  .  .  .  Y: _EOF @ parser.go:2081:15
 16791  .  .  .  .  .  .  .  }
 16792  .  .  .  .  .  .  .  Y: *syntax.Operation {
 16793  .  .  .  .  .  .  .  .  Op: !=
 16794  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 16795  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2081:23
 16796  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2081:25
 16797  .  .  .  .  .  .  .  .  }
 16798  .  .  .  .  .  .  .  .  Y: _Rparen @ parser.go:2081:32
 16799  .  .  .  .  .  .  .  }
 16800  .  .  .  .  .  .  }
 16801  .  .  .  .  .  .  Post: nil
 16802  .  .  .  .  .  .  Body: *syntax.BlockStmt {
 16803  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
 16804  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 16805  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16806  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16807  .  .  .  .  .  .  .  .  .  .  X: c @ parser.go:2082:3
 16808  .  .  .  .  .  .  .  .  .  .  Sel: ArgList @ parser.go:2082:5
 16809  .  .  .  .  .  .  .  .  .  }
 16810  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16811  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:2082:15
 16812  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 16813  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 16814  .  .  .  .  .  .  .  .  .  .  .  .  X: c @ parser.go:2082:22
 16815  .  .  .  .  .  .  .  .  .  .  .  .  Sel: ArgList @ parser.go:2082:24
 16816  .  .  .  .  .  .  .  .  .  .  .  }
 16817  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 16818  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16819  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2082:33
 16820  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:2082:35
 16821  .  .  .  .  .  .  .  .  .  .  .  .  }
 16822  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 16823  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16824  .  .  .  .  .  .  .  .  .  .  .  }
 16825  .  .  .  .  .  .  .  .  .  .  }
 16826  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16827  .  .  .  .  .  .  .  .  .  }
 16828  .  .  .  .  .  .  .  .  }
 16829  .  .  .  .  .  .  .  .  1: *syntax.AssignStmt {
 16830  .  .  .  .  .  .  .  .  .  Op: <op-0>
 16831  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16832  .  .  .  .  .  .  .  .  .  .  X: c @ parser.go:2083:3
 16833  .  .  .  .  .  .  .  .  .  .  Sel: HasDots @ parser.go:2083:5
 16834  .  .  .  .  .  .  .  .  .  }
 16835  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16836  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16837  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2083:15
 16838  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:2083:17
 16839  .  .  .  .  .  .  .  .  .  .  }
 16840  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16841  .  .  .  .  .  .  .  .  .  .  .  0: _DotDotDot @ parser.go:2083:21
 16842  .  .  .  .  .  .  .  .  .  .  }
 16843  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16844  .  .  .  .  .  .  .  .  .  }
 16845  .  .  .  .  .  .  .  .  }
 16846  .  .  .  .  .  .  .  .  2: *syntax.IfStmt {
 16847  .  .  .  .  .  .  .  .  .  Init: nil
 16848  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 16849  .  .  .  .  .  .  .  .  .  .  Op: ||
 16850  .  .  .  .  .  .  .  .  .  .  X: *syntax.Operation {
 16851  .  .  .  .  .  .  .  .  .  .  .  Op: !
 16852  .  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 16853  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16854  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2084:7
 16855  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: ocomma @ parser.go:2084:9
 16856  .  .  .  .  .  .  .  .  .  .  .  .  }
 16857  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16858  .  .  .  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:2084:16
 16859  .  .  .  .  .  .  .  .  .  .  .  .  }
 16860  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 16861  .  .  .  .  .  .  .  .  .  .  .  }
 16862  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 16863  .  .  .  .  .  .  .  .  .  .  }
 16864  .  .  .  .  .  .  .  .  .  .  Y: *syntax.SelectorExpr {
 16865  .  .  .  .  .  .  .  .  .  .  .  X: c @ parser.go:2084:28
 16866  .  .  .  .  .  .  .  .  .  .  .  Sel: HasDots @ parser.go:2084:30
 16867  .  .  .  .  .  .  .  .  .  .  }
 16868  .  .  .  .  .  .  .  .  .  }
 16869  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 16870  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 16871  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
 16872  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
 16873  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
 16874  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 16780)
 16875  .  .  .  .  .  .  .  .  .  .  .  }
 16876  .  .  .  .  .  .  .  .  .  .  }
 16877  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 16878  .  .  .  .  .  .  .  .  .  }
 16879  .  .  .  .  .  .  .  .  .  Else: nil
 16880  .  .  .  .  .  .  .  .  }
 16881  .  .  .  .  .  .  .  }
 16882  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 16883  .  .  .  .  .  .  }
 16884  .  .  .  .  .  }
 16885  .  .  .  .  .  7: *syntax.AssignStmt {
 16886  .  .  .  .  .  .  Op: -
 16887  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16888  .  .  .  .  .  .  .  X: p @ parser.go:2089:2
 16889  .  .  .  .  .  .  .  Sel: xnest @ parser.go:2089:4
 16890  .  .  .  .  .  .  }
 16891  .  .  .  .  .  .  Rhs: *(Node @ 5597)
 16892  .  .  .  .  .  }
 16893  .  .  .  .  .  8: *syntax.ExprStmt {
 16894  .  .  .  .  .  .  X: *syntax.CallExpr {
 16895  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16896  .  .  .  .  .  .  .  .  X: p @ parser.go:2090:2
 16897  .  .  .  .  .  .  .  .  Sel: want @ parser.go:2090:4
 16898  .  .  .  .  .  .  .  }
 16899  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16900  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:2090:9
 16901  .  .  .  .  .  .  .  }
 16902  .  .  .  .  .  .  .  HasDots: false
 16903  .  .  .  .  .  .  }
 16904  .  .  .  .  .  }
 16905  .  .  .  .  .  9: *syntax.ReturnStmt {
 16906  .  .  .  .  .  .  Results: c @ parser.go:2092:9
 16907  .  .  .  .  .  }
 16908  .  .  .  .  }
 16909  .  .  .  .  Rbrace: src.Pos {}
 16910  .  .  .  }
 16911  .  .  .  Pragma: 0
 16912  .  .  }
 16913  .  .  74: *syntax.FuncDecl {
 16914  .  .  .  Attr: map[]
 16915  .  .  .  Recv: *syntax.Field {
 16916  .  .  .  .  Name: p @ parser.go:2098:7
 16917  .  .  .  .  Type: *syntax.Operation {
 16918  .  .  .  .  .  Op: *
 16919  .  .  .  .  .  X: parser @ parser.go:2098:10
 16920  .  .  .  .  .  Y: nil
 16921  .  .  .  .  }
 16922  .  .  .  }
 16923  .  .  .  Name: newName @ parser.go:2098:18
 16924  .  .  .  Type: *syntax.FuncType {
 16925  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 16926  .  .  .  .  .  0: *syntax.Field {
 16927  .  .  .  .  .  .  Name: value @ parser.go:2098:26
 16928  .  .  .  .  .  .  Type: string @ parser.go:2098:32
 16929  .  .  .  .  .  }
 16930  .  .  .  .  }
 16931  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 16932  .  .  .  .  .  0: *syntax.Field {
 16933  .  .  .  .  .  .  Name: nil
 16934  .  .  .  .  .  .  Type: *syntax.Operation {
 16935  .  .  .  .  .  .  .  Op: *
 16936  .  .  .  .  .  .  .  X: Name @ parser.go:2098:41
 16937  .  .  .  .  .  .  .  Y: nil
 16938  .  .  .  .  .  .  }
 16939  .  .  .  .  .  }
 16940  .  .  .  .  }
 16941  .  .  .  }
 16942  .  .  .  Body: *syntax.BlockStmt {
 16943  .  .  .  .  List: []syntax.Stmt (4 entries) {
 16944  .  .  .  .  .  0: *syntax.AssignStmt {
 16945  .  .  .  .  .  .  Op: :
 16946  .  .  .  .  .  .  Lhs: n @ parser.go:2099:2
 16947  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16948  .  .  .  .  .  .  .  Fun: new @ parser.go:2099:7
 16949  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 16950  .  .  .  .  .  .  .  .  0: Name @ parser.go:2099:11
 16951  .  .  .  .  .  .  .  }
 16952  .  .  .  .  .  .  .  HasDots: false
 16953  .  .  .  .  .  .  }
 16954  .  .  .  .  .  }
 16955  .  .  .  .  .  1: *syntax.AssignStmt {
 16956  .  .  .  .  .  .  Op: <op-0>
 16957  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16958  .  .  .  .  .  .  .  X: n @ parser.go:2100:2
 16959  .  .  .  .  .  .  .  Sel: pos @ parser.go:2100:4
 16960  .  .  .  .  .  .  }
 16961  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 16962  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 16963  .  .  .  .  .  .  .  .  X: p @ parser.go:2100:10
 16964  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:2100:12
 16965  .  .  .  .  .  .  .  }
 16966  .  .  .  .  .  .  .  ArgList: nil
 16967  .  .  .  .  .  .  .  HasDots: false
 16968  .  .  .  .  .  .  }
 16969  .  .  .  .  .  }
 16970  .  .  .  .  .  2: *syntax.AssignStmt {
 16971  .  .  .  .  .  .  Op: <op-0>
 16972  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 16973  .  .  .  .  .  .  .  X: n @ parser.go:2101:2
 16974  .  .  .  .  .  .  .  Sel: Value @ parser.go:2101:4
 16975  .  .  .  .  .  .  }
 16976  .  .  .  .  .  .  Rhs: value @ parser.go:2101:12
 16977  .  .  .  .  .  }
 16978  .  .  .  .  .  3: *syntax.ReturnStmt {
 16979  .  .  .  .  .  .  Results: n @ parser.go:2102:9
 16980  .  .  .  .  .  }
 16981  .  .  .  .  }
 16982  .  .  .  .  Rbrace: src.Pos {}
 16983  .  .  .  }
 16984  .  .  .  Pragma: 0
 16985  .  .  }
 16986  .  .  75: *syntax.FuncDecl {
 16987  .  .  .  Attr: map[]
 16988  .  .  .  Recv: *syntax.Field {
 16989  .  .  .  .  Name: p @ parser.go:2105:7
 16990  .  .  .  .  Type: *syntax.Operation {
 16991  .  .  .  .  .  Op: *
 16992  .  .  .  .  .  X: parser @ parser.go:2105:10
 16993  .  .  .  .  .  Y: nil
 16994  .  .  .  .  }
 16995  .  .  .  }
 16996  .  .  .  Name: name @ parser.go:2105:18
 16997  .  .  .  Type: *syntax.FuncType {
 16998  .  .  .  .  ParamList: nil
 16999  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 17000  .  .  .  .  .  0: *syntax.Field {
 17001  .  .  .  .  .  .  Name: nil
 17002  .  .  .  .  .  .  Type: *syntax.Operation {
 17003  .  .  .  .  .  .  .  Op: *
 17004  .  .  .  .  .  .  .  X: Name @ parser.go:2105:26
 17005  .  .  .  .  .  .  .  Y: nil
 17006  .  .  .  .  .  .  }
 17007  .  .  .  .  .  }
 17008  .  .  .  .  }
 17009  .  .  .  }
 17010  .  .  .  Body: *syntax.BlockStmt {
 17011  .  .  .  .  List: []syntax.Stmt (5 entries) {
 17012  .  .  .  .  .  0: *syntax.IfStmt {
 17013  .  .  .  .  .  .  Init: nil
 17014  .  .  .  .  .  .  Cond: *syntax.Operation {
 17015  .  .  .  .  .  .  .  Op: ==
 17016  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 17017  .  .  .  .  .  .  .  .  X: p @ parser.go:2108:5
 17018  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2108:7
 17019  .  .  .  .  .  .  .  }
 17020  .  .  .  .  .  .  .  Y: _Name @ parser.go:2108:14
 17021  .  .  .  .  .  .  }
 17022  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 17023  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
 17024  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 17025  .  .  .  .  .  .  .  .  .  Op: :
 17026  .  .  .  .  .  .  .  .  .  Lhs: n @ parser.go:2109:3
 17027  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 17028  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17029  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2109:8
 17030  .  .  .  .  .  .  .  .  .  .  .  Sel: newName @ parser.go:2109:10
 17031  .  .  .  .  .  .  .  .  .  .  }
 17032  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17033  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.SelectorExpr {
 17034  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2109:18
 17035  .  .  .  .  .  .  .  .  .  .  .  .  Sel: lit @ parser.go:2109:20
 17036  .  .  .  .  .  .  .  .  .  .  .  }
 17037  .  .  .  .  .  .  .  .  .  .  }
 17038  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17039  .  .  .  .  .  .  .  .  .  }
 17040  .  .  .  .  .  .  .  .  }
 17041  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 17042  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 17043  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17044  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2110:3
 17045  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:2110:5
 17046  .  .  .  .  .  .  .  .  .  .  }
 17047  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 17048  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17049  .  .  .  .  .  .  .  .  .  }
 17050  .  .  .  .  .  .  .  .  }
 17051  .  .  .  .  .  .  .  .  2: *syntax.ReturnStmt {
 17052  .  .  .  .  .  .  .  .  .  Results: n @ parser.go:2111:10
 17053  .  .  .  .  .  .  .  .  }
 17054  .  .  .  .  .  .  .  }
 17055  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 17056  .  .  .  .  .  .  }
 17057  .  .  .  .  .  .  Else: nil
 17058  .  .  .  .  .  }
 17059  .  .  .  .  .  1: *syntax.AssignStmt {
 17060  .  .  .  .  .  .  Op: :
 17061  .  .  .  .  .  .  Lhs: n @ parser.go:2114:2
 17062  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 17063  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17064  .  .  .  .  .  .  .  .  X: p @ parser.go:2114:7
 17065  .  .  .  .  .  .  .  .  Sel: newName @ parser.go:2114:9
 17066  .  .  .  .  .  .  .  }
 17067  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17068  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 17069  .  .  .  .  .  .  .  .  .  Value: "\"_\""
 17070  .  .  .  .  .  .  .  .  .  Kind: 4
 17071  .  .  .  .  .  .  .  .  }
 17072  .  .  .  .  .  .  .  }
 17073  .  .  .  .  .  .  .  HasDots: false
 17074  .  .  .  .  .  .  }
 17075  .  .  .  .  .  }
 17076  .  .  .  .  .  2: *syntax.ExprStmt {
 17077  .  .  .  .  .  .  X: *syntax.CallExpr {
 17078  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17079  .  .  .  .  .  .  .  .  X: p @ parser.go:2115:2
 17080  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:2115:4
 17081  .  .  .  .  .  .  .  }
 17082  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17083  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 17084  .  .  .  .  .  .  .  .  .  Value: "\"expecting name\""
 17085  .  .  .  .  .  .  .  .  .  Kind: 4
 17086  .  .  .  .  .  .  .  .  }
 17087  .  .  .  .  .  .  .  }
 17088  .  .  .  .  .  .  .  HasDots: false
 17089  .  .  .  .  .  .  }
 17090  .  .  .  .  .  }
 17091  .  .  .  .  .  3: *syntax.ExprStmt {
 17092  .  .  .  .  .  .  X: *syntax.CallExpr {
 17093  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17094  .  .  .  .  .  .  .  .  X: p @ parser.go:2116:2
 17095  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:2116:4
 17096  .  .  .  .  .  .  .  }
 17097  .  .  .  .  .  .  .  ArgList: nil
 17098  .  .  .  .  .  .  .  HasDots: false
 17099  .  .  .  .  .  .  }
 17100  .  .  .  .  .  }
 17101  .  .  .  .  .  4: *syntax.ReturnStmt {
 17102  .  .  .  .  .  .  Results: n @ parser.go:2117:9
 17103  .  .  .  .  .  }
 17104  .  .  .  .  }
 17105  .  .  .  .  Rbrace: src.Pos {}
 17106  .  .  .  }
 17107  .  .  .  Pragma: 0
 17108  .  .  }
 17109  .  .  76: *syntax.FuncDecl {
 17110  .  .  .  Attr: map[]
 17111  .  .  .  Recv: *syntax.Field {
 17112  .  .  .  .  Name: p @ parser.go:2122:7
 17113  .  .  .  .  Type: *syntax.Operation {
 17114  .  .  .  .  .  Op: *
 17115  .  .  .  .  .  X: parser @ parser.go:2122:10
 17116  .  .  .  .  .  Y: nil
 17117  .  .  .  .  }
 17118  .  .  .  }
 17119  .  .  .  Name: nameList @ parser.go:2122:18
 17120  .  .  .  Type: *syntax.FuncType {
 17121  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 17122  .  .  .  .  .  0: *syntax.Field {
 17123  .  .  .  .  .  .  Name: first @ parser.go:2122:27
 17124  .  .  .  .  .  .  Type: *syntax.Operation {
 17125  .  .  .  .  .  .  .  Op: *
 17126  .  .  .  .  .  .  .  X: Name @ parser.go:2122:34
 17127  .  .  .  .  .  .  .  Y: nil
 17128  .  .  .  .  .  .  }
 17129  .  .  .  .  .  }
 17130  .  .  .  .  }
 17131  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 17132  .  .  .  .  .  0: *syntax.Field {
 17133  .  .  .  .  .  .  Name: nil
 17134  .  .  .  .  .  .  Type: *syntax.SliceType {
 17135  .  .  .  .  .  .  .  Elem: *syntax.Operation {
 17136  .  .  .  .  .  .  .  .  Op: *
 17137  .  .  .  .  .  .  .  .  X: Name @ parser.go:2122:43
 17138  .  .  .  .  .  .  .  .  Y: nil
 17139  .  .  .  .  .  .  .  }
 17140  .  .  .  .  .  .  }
 17141  .  .  .  .  .  }
 17142  .  .  .  .  }
 17143  .  .  .  }
 17144  .  .  .  Body: *syntax.BlockStmt {
 17145  .  .  .  .  List: []syntax.Stmt (5 entries) {
 17146  .  .  .  .  .  0: *syntax.IfStmt {
 17147  .  .  .  .  .  .  Init: nil
 17148  .  .  .  .  .  .  Cond: trace @ parser.go:2123:5
 17149  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 17150  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 17151  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 17152  .  .  .  .  .  .  .  .  .  Tok: defer
 17153  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 17154  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 17155  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17156  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2124:9
 17157  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:2124:11
 17158  .  .  .  .  .  .  .  .  .  .  .  }
 17159  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17160  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 17161  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"nameList\""
 17162  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 17163  .  .  .  .  .  .  .  .  .  .  .  .  }
 17164  .  .  .  .  .  .  .  .  .  .  .  }
 17165  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17166  .  .  .  .  .  .  .  .  .  .  }
 17167  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 17168  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17169  .  .  .  .  .  .  .  .  .  }
 17170  .  .  .  .  .  .  .  .  }
 17171  .  .  .  .  .  .  .  }
 17172  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 17173  .  .  .  .  .  .  }
 17174  .  .  .  .  .  .  Else: nil
 17175  .  .  .  .  .  }
 17176  .  .  .  .  .  1: *syntax.IfStmt {
 17177  .  .  .  .  .  .  Init: nil
 17178  .  .  .  .  .  .  Cond: *syntax.Operation {
 17179  .  .  .  .  .  .  .  Op: &&
 17180  .  .  .  .  .  .  .  X: debug @ parser.go:2127:5
 17181  .  .  .  .  .  .  .  Y: *syntax.Operation {
 17182  .  .  .  .  .  .  .  .  Op: ==
 17183  .  .  .  .  .  .  .  .  X: first @ parser.go:2127:14
 17184  .  .  .  .  .  .  .  .  Y: nil @ parser.go:2127:23
 17185  .  .  .  .  .  .  .  }
 17186  .  .  .  .  .  .  }
 17187  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 17188  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 17189  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 17190  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 17191  .  .  .  .  .  .  .  .  .  .  Fun: panic @ parser.go:2128:3
 17192  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17193  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 17194  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"first name not provided\""
 17195  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 17196  .  .  .  .  .  .  .  .  .  .  .  }
 17197  .  .  .  .  .  .  .  .  .  .  }
 17198  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17199  .  .  .  .  .  .  .  .  .  }
 17200  .  .  .  .  .  .  .  .  }
 17201  .  .  .  .  .  .  .  }
 17202  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 17203  .  .  .  .  .  .  }
 17204  .  .  .  .  .  .  Else: nil
 17205  .  .  .  .  .  }
 17206  .  .  .  .  .  2: *syntax.AssignStmt {
 17207  .  .  .  .  .  .  Op: :
 17208  .  .  .  .  .  .  Lhs: l @ parser.go:2131:2
 17209  .  .  .  .  .  .  Rhs: *syntax.CompositeLit {
 17210  .  .  .  .  .  .  .  Type: *syntax.SliceType {
 17211  .  .  .  .  .  .  .  .  Elem: *syntax.Operation {
 17212  .  .  .  .  .  .  .  .  .  Op: *
 17213  .  .  .  .  .  .  .  .  .  X: Name @ parser.go:2131:10
 17214  .  .  .  .  .  .  .  .  .  Y: nil
 17215  .  .  .  .  .  .  .  .  }
 17216  .  .  .  .  .  .  .  }
 17217  .  .  .  .  .  .  .  ElemList: []syntax.Expr (1 entries) {
 17218  .  .  .  .  .  .  .  .  0: first @ parser.go:2131:15
 17219  .  .  .  .  .  .  .  }
 17220  .  .  .  .  .  .  .  NKeys: 0
 17221  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 17222  .  .  .  .  .  .  }
 17223  .  .  .  .  .  }
 17224  .  .  .  .  .  3: *syntax.ForStmt {
 17225  .  .  .  .  .  .  Init: nil
 17226  .  .  .  .  .  .  Cond: *syntax.CallExpr {
 17227  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17228  .  .  .  .  .  .  .  .  X: p @ parser.go:2132:6
 17229  .  .  .  .  .  .  .  .  Sel: got @ parser.go:2132:8
 17230  .  .  .  .  .  .  .  }
 17231  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17232  .  .  .  .  .  .  .  .  0: _Comma @ parser.go:2132:12
 17233  .  .  .  .  .  .  .  }
 17234  .  .  .  .  .  .  .  HasDots: false
 17235  .  .  .  .  .  .  }
 17236  .  .  .  .  .  .  Post: nil
 17237  .  .  .  .  .  .  Body: *syntax.BlockStmt {
 17238  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 17239  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 17240  .  .  .  .  .  .  .  .  .  Op: <op-0>
 17241  .  .  .  .  .  .  .  .  .  Lhs: l @ parser.go:2133:3
 17242  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 17243  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:2133:7
 17244  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 17245  .  .  .  .  .  .  .  .  .  .  .  0: l @ parser.go:2133:14
 17246  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 17247  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17248  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2133:17
 17249  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:2133:19
 17250  .  .  .  .  .  .  .  .  .  .  .  .  }
 17251  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 17252  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17253  .  .  .  .  .  .  .  .  .  .  .  }
 17254  .  .  .  .  .  .  .  .  .  .  }
 17255  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17256  .  .  .  .  .  .  .  .  .  }
 17257  .  .  .  .  .  .  .  .  }
 17258  .  .  .  .  .  .  .  }
 17259  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 17260  .  .  .  .  .  .  }
 17261  .  .  .  .  .  }
 17262  .  .  .  .  .  4: *syntax.ReturnStmt {
 17263  .  .  .  .  .  .  Results: l @ parser.go:2136:9
 17264  .  .  .  .  .  }
 17265  .  .  .  .  }
 17266  .  .  .  .  Rbrace: src.Pos {}
 17267  .  .  .  }
 17268  .  .  .  Pragma: 0
 17269  .  .  }
 17270  .  .  77: *syntax.FuncDecl {
 17271  .  .  .  Attr: map[]
 17272  .  .  .  Recv: *syntax.Field {
 17273  .  .  .  .  Name: p @ parser.go:2140:7
 17274  .  .  .  .  Type: *syntax.Operation {
 17275  .  .  .  .  .  Op: *
 17276  .  .  .  .  .  X: parser @ parser.go:2140:10
 17277  .  .  .  .  .  Y: nil
 17278  .  .  .  .  }
 17279  .  .  .  }
 17280  .  .  .  Name: qualifiedName @ parser.go:2140:18
 17281  .  .  .  Type: *syntax.FuncType {
 17282  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 17283  .  .  .  .  .  0: *syntax.Field {
 17284  .  .  .  .  .  .  Name: name @ parser.go:2140:32
 17285  .  .  .  .  .  .  Type: *syntax.Operation {
 17286  .  .  .  .  .  .  .  Op: *
 17287  .  .  .  .  .  .  .  X: Name @ parser.go:2140:38
 17288  .  .  .  .  .  .  .  Y: nil
 17289  .  .  .  .  .  .  }
 17290  .  .  .  .  .  }
 17291  .  .  .  .  }
 17292  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 17293  .  .  .  .  .  0: *syntax.Field {
 17294  .  .  .  .  .  .  Name: nil
 17295  .  .  .  .  .  .  Type: Expr @ parser.go:2140:44
 17296  .  .  .  .  .  }
 17297  .  .  .  .  }
 17298  .  .  .  }
 17299  .  .  .  Body: *syntax.BlockStmt {
 17300  .  .  .  .  List: []syntax.Stmt (3 entries) {
 17301  .  .  .  .  .  0: *syntax.IfStmt {
 17302  .  .  .  .  .  .  Init: nil
 17303  .  .  .  .  .  .  Cond: trace @ parser.go:2141:5
 17304  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 17305  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 17306  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 17307  .  .  .  .  .  .  .  .  .  Tok: defer
 17308  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 17309  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 17310  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17311  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2142:9
 17312  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:2142:11
 17313  .  .  .  .  .  .  .  .  .  .  .  }
 17314  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17315  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 17316  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"qualifiedName\""
 17317  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 17318  .  .  .  .  .  .  .  .  .  .  .  .  }
 17319  .  .  .  .  .  .  .  .  .  .  .  }
 17320  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17321  .  .  .  .  .  .  .  .  .  .  }
 17322  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 17323  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17324  .  .  .  .  .  .  .  .  .  }
 17325  .  .  .  .  .  .  .  .  }
 17326  .  .  .  .  .  .  .  }
 17327  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 17328  .  .  .  .  .  .  }
 17329  .  .  .  .  .  .  Else: nil
 17330  .  .  .  .  .  }
 17331  .  .  .  .  .  1: *syntax.SwitchStmt {
 17332  .  .  .  .  .  .  Init: nil
 17333  .  .  .  .  .  .  Tag: nil
 17334  .  .  .  .  .  .  Body: []*syntax.CaseClause (3 entries) {
 17335  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 17336  .  .  .  .  .  .  .  .  Cases: *syntax.Operation {
 17337  .  .  .  .  .  .  .  .  .  Op: !=
 17338  .  .  .  .  .  .  .  .  .  X: name @ parser.go:2146:7
 17339  .  .  .  .  .  .  .  .  .  Y: nil @ parser.go:2146:15
 17340  .  .  .  .  .  .  .  .  }
 17341  .  .  .  .  .  .  .  .  Body: nil
 17342  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 17343  .  .  .  .  .  .  .  }
 17344  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 17345  .  .  .  .  .  .  .  .  Cases: *syntax.Operation {
 17346  .  .  .  .  .  .  .  .  .  Op: ==
 17347  .  .  .  .  .  .  .  .  .  X: *syntax.SelectorExpr {
 17348  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2148:7
 17349  .  .  .  .  .  .  .  .  .  .  Sel: tok @ parser.go:2148:9
 17350  .  .  .  .  .  .  .  .  .  }
 17351  .  .  .  .  .  .  .  .  .  Y: _Name @ parser.go:2148:16
 17352  .  .  .  .  .  .  .  .  }
 17353  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 17354  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 17355  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 17356  .  .  .  .  .  .  .  .  .  .  Lhs: name @ parser.go:2149:3
 17357  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 17358  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17359  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2149:10
 17360  .  .  .  .  .  .  .  .  .  .  .  .  Sel: name @ parser.go:2149:12
 17361  .  .  .  .  .  .  .  .  .  .  .  }
 17362  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 17363  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17364  .  .  .  .  .  .  .  .  .  .  }
 17365  .  .  .  .  .  .  .  .  .  }
 17366  .  .  .  .  .  .  .  .  }
 17367  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 17368  .  .  .  .  .  .  .  }
 17369  .  .  .  .  .  .  .  2: *syntax.CaseClause {
 17370  .  .  .  .  .  .  .  .  Cases: nil
 17371  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (3 entries) {
 17372  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 17373  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 17374  .  .  .  .  .  .  .  .  .  .  Lhs: name @ parser.go:2151:3
 17375  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 17376  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17377  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2151:10
 17378  .  .  .  .  .  .  .  .  .  .  .  .  Sel: newName @ parser.go:2151:12
 17379  .  .  .  .  .  .  .  .  .  .  .  }
 17380  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17381  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 17382  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"_\""
 17383  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 17384  .  .  .  .  .  .  .  .  .  .  .  .  }
 17385  .  .  .  .  .  .  .  .  .  .  .  }
 17386  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17387  .  .  .  .  .  .  .  .  .  .  }
 17388  .  .  .  .  .  .  .  .  .  }
 17389  .  .  .  .  .  .  .  .  .  1: *syntax.ExprStmt {
 17390  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 17391  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17392  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2152:3
 17393  .  .  .  .  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:2152:5
 17394  .  .  .  .  .  .  .  .  .  .  .  }
 17395  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17396  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 17397  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting name\""
 17398  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 17399  .  .  .  .  .  .  .  .  .  .  .  .  }
 17400  .  .  .  .  .  .  .  .  .  .  .  }
 17401  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17402  .  .  .  .  .  .  .  .  .  .  }
 17403  .  .  .  .  .  .  .  .  .  }
 17404  .  .  .  .  .  .  .  .  .  2: *syntax.ExprStmt {
 17405  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 17406  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17407  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2153:3
 17408  .  .  .  .  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:2153:5
 17409  .  .  .  .  .  .  .  .  .  .  .  }
 17410  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (3 entries) {
 17411  .  .  .  .  .  .  .  .  .  .  .  .  0: _Dot @ parser.go:2153:13
 17412  .  .  .  .  .  .  .  .  .  .  .  .  1: _Semi @ parser.go:2153:19
 17413  .  .  .  .  .  .  .  .  .  .  .  .  2: _Rbrace @ parser.go:2153:26
 17414  .  .  .  .  .  .  .  .  .  .  .  }
 17415  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17416  .  .  .  .  .  .  .  .  .  .  }
 17417  .  .  .  .  .  .  .  .  .  }
 17418  .  .  .  .  .  .  .  .  }
 17419  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 17420  .  .  .  .  .  .  .  }
 17421  .  .  .  .  .  .  }
 17422  .  .  .  .  .  .  Rbrace: src.Pos {}
 17423  .  .  .  .  .  }
 17424  .  .  .  .  .  2: *syntax.ReturnStmt {
 17425  .  .  .  .  .  .  Results: *syntax.CallExpr {
 17426  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17427  .  .  .  .  .  .  .  .  X: p @ parser.go:2156:9
 17428  .  .  .  .  .  .  .  .  Sel: dotname @ parser.go:2156:11
 17429  .  .  .  .  .  .  .  }
 17430  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17431  .  .  .  .  .  .  .  .  0: name @ parser.go:2156:19
 17432  .  .  .  .  .  .  .  }
 17433  .  .  .  .  .  .  .  HasDots: false
 17434  .  .  .  .  .  .  }
 17435  .  .  .  .  .  }
 17436  .  .  .  .  }
 17437  .  .  .  .  Rbrace: src.Pos {}
 17438  .  .  .  }
 17439  .  .  .  Pragma: 0
 17440  .  .  }
 17441  .  .  78: *syntax.FuncDecl {
 17442  .  .  .  Attr: map[]
 17443  .  .  .  Recv: *syntax.Field {
 17444  .  .  .  .  Name: p @ parser.go:2160:7
 17445  .  .  .  .  Type: *syntax.Operation {
 17446  .  .  .  .  .  Op: *
 17447  .  .  .  .  .  X: parser @ parser.go:2160:10
 17448  .  .  .  .  .  Y: nil
 17449  .  .  .  .  }
 17450  .  .  .  }
 17451  .  .  .  Name: exprList @ parser.go:2160:18
 17452  .  .  .  Type: *syntax.FuncType {
 17453  .  .  .  .  ParamList: nil
 17454  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 17455  .  .  .  .  .  0: *syntax.Field {
 17456  .  .  .  .  .  .  Name: nil
 17457  .  .  .  .  .  .  Type: Expr @ parser.go:2160:29
 17458  .  .  .  .  .  }
 17459  .  .  .  .  }
 17460  .  .  .  }
 17461  .  .  .  Body: *syntax.BlockStmt {
 17462  .  .  .  .  List: []syntax.Stmt (4 entries) {
 17463  .  .  .  .  .  0: *syntax.IfStmt {
 17464  .  .  .  .  .  .  Init: nil
 17465  .  .  .  .  .  .  Cond: trace @ parser.go:2161:5
 17466  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 17467  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 17468  .  .  .  .  .  .  .  .  0: *syntax.CallStmt {
 17469  .  .  .  .  .  .  .  .  .  Tok: defer
 17470  .  .  .  .  .  .  .  .  .  Call: *syntax.CallExpr {
 17471  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.CallExpr {
 17472  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17473  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2162:9
 17474  .  .  .  .  .  .  .  .  .  .  .  .  Sel: trace @ parser.go:2162:11
 17475  .  .  .  .  .  .  .  .  .  .  .  }
 17476  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17477  .  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BasicLit {
 17478  .  .  .  .  .  .  .  .  .  .  .  .  .  Value: "\"exprList\""
 17479  .  .  .  .  .  .  .  .  .  .  .  .  .  Kind: 4
 17480  .  .  .  .  .  .  .  .  .  .  .  .  }
 17481  .  .  .  .  .  .  .  .  .  .  .  }
 17482  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17483  .  .  .  .  .  .  .  .  .  .  }
 17484  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 17485  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17486  .  .  .  .  .  .  .  .  .  }
 17487  .  .  .  .  .  .  .  .  }
 17488  .  .  .  .  .  .  .  }
 17489  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 17490  .  .  .  .  .  .  }
 17491  .  .  .  .  .  .  Else: nil
 17492  .  .  .  .  .  }
 17493  .  .  .  .  .  1: *syntax.AssignStmt {
 17494  .  .  .  .  .  .  Op: :
 17495  .  .  .  .  .  .  Lhs: x @ parser.go:2165:2
 17496  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 17497  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17498  .  .  .  .  .  .  .  .  X: p @ parser.go:2165:7
 17499  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:2165:9
 17500  .  .  .  .  .  .  .  }
 17501  .  .  .  .  .  .  .  ArgList: nil
 17502  .  .  .  .  .  .  .  HasDots: false
 17503  .  .  .  .  .  .  }
 17504  .  .  .  .  .  }
 17505  .  .  .  .  .  2: *syntax.IfStmt {
 17506  .  .  .  .  .  .  Init: nil
 17507  .  .  .  .  .  .  Cond: *syntax.CallExpr {
 17508  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17509  .  .  .  .  .  .  .  .  X: p @ parser.go:2166:5
 17510  .  .  .  .  .  .  .  .  Sel: got @ parser.go:2166:7
 17511  .  .  .  .  .  .  .  }
 17512  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17513  .  .  .  .  .  .  .  .  0: _Comma @ parser.go:2166:11
 17514  .  .  .  .  .  .  .  }
 17515  .  .  .  .  .  .  .  HasDots: false
 17516  .  .  .  .  .  .  }
 17517  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 17518  .  .  .  .  .  .  .  List: []syntax.Stmt (6 entries) {
 17519  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 17520  .  .  .  .  .  .  .  .  .  Op: :
 17521  .  .  .  .  .  .  .  .  .  Lhs: list @ parser.go:2167:3
 17522  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CompositeLit {
 17523  .  .  .  .  .  .  .  .  .  .  Type: *syntax.SliceType {
 17524  .  .  .  .  .  .  .  .  .  .  .  Elem: Expr @ parser.go:2167:13
 17525  .  .  .  .  .  .  .  .  .  .  }
 17526  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 17527  .  .  .  .  .  .  .  .  .  .  .  0: x @ parser.go:2167:18
 17528  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 17529  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17530  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2167:21
 17531  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:2167:23
 17532  .  .  .  .  .  .  .  .  .  .  .  .  }
 17533  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 17534  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17535  .  .  .  .  .  .  .  .  .  .  .  }
 17536  .  .  .  .  .  .  .  .  .  .  }
 17537  .  .  .  .  .  .  .  .  .  .  NKeys: 0
 17538  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 17539  .  .  .  .  .  .  .  .  .  }
 17540  .  .  .  .  .  .  .  .  }
 17541  .  .  .  .  .  .  .  .  1: *syntax.ForStmt {
 17542  .  .  .  .  .  .  .  .  .  Init: nil
 17543  .  .  .  .  .  .  .  .  .  Cond: *syntax.CallExpr {
 17544  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17545  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2168:7
 17546  .  .  .  .  .  .  .  .  .  .  .  Sel: got @ parser.go:2168:9
 17547  .  .  .  .  .  .  .  .  .  .  }
 17548  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17549  .  .  .  .  .  .  .  .  .  .  .  0: _Comma @ parser.go:2168:13
 17550  .  .  .  .  .  .  .  .  .  .  }
 17551  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17552  .  .  .  .  .  .  .  .  .  }
 17553  .  .  .  .  .  .  .  .  .  Post: nil
 17554  .  .  .  .  .  .  .  .  .  Body: *syntax.BlockStmt {
 17555  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 17556  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 17557  .  .  .  .  .  .  .  .  .  .  .  .  Op: <op-0>
 17558  .  .  .  .  .  .  .  .  .  .  .  .  Lhs: list @ parser.go:2169:4
 17559  .  .  .  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 17560  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: append @ parser.go:2169:11
 17561  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (2 entries) {
 17562  .  .  .  .  .  .  .  .  .  .  .  .  .  .  0: list @ parser.go:2169:18
 17563  .  .  .  .  .  .  .  .  .  .  .  .  .  .  1: *syntax.CallExpr {
 17564  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17565  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2169:24
 17566  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  Sel: expr @ parser.go:2169:26
 17567  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 17568  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 17569  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17570  .  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 17571  .  .  .  .  .  .  .  .  .  .  .  .  .  }
 17572  .  .  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17573  .  .  .  .  .  .  .  .  .  .  .  .  }
 17574  .  .  .  .  .  .  .  .  .  .  .  }
 17575  .  .  .  .  .  .  .  .  .  .  }
 17576  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 17577  .  .  .  .  .  .  .  .  .  }
 17578  .  .  .  .  .  .  .  .  }
 17579  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 17580  .  .  .  .  .  .  .  .  .  Op: :
 17581  .  .  .  .  .  .  .  .  .  Lhs: t @ parser.go:2171:3
 17582  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 17583  .  .  .  .  .  .  .  .  .  .  Fun: new @ parser.go:2171:8
 17584  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17585  .  .  .  .  .  .  .  .  .  .  .  0: ListExpr @ parser.go:2171:12
 17586  .  .  .  .  .  .  .  .  .  .  }
 17587  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17588  .  .  .  .  .  .  .  .  .  }
 17589  .  .  .  .  .  .  .  .  }
 17590  .  .  .  .  .  .  .  .  3: *syntax.AssignStmt {
 17591  .  .  .  .  .  .  .  .  .  Op: <op-0>
 17592  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 17593  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:2172:3
 17594  .  .  .  .  .  .  .  .  .  .  Sel: pos @ parser.go:2172:5
 17595  .  .  .  .  .  .  .  .  .  }
 17596  .  .  .  .  .  .  .  .  .  Rhs: *syntax.CallExpr {
 17597  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17598  .  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:2172:11
 17599  .  .  .  .  .  .  .  .  .  .  .  Sel: Pos @ parser.go:2172:13
 17600  .  .  .  .  .  .  .  .  .  .  }
 17601  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 17602  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17603  .  .  .  .  .  .  .  .  .  }
 17604  .  .  .  .  .  .  .  .  }
 17605  .  .  .  .  .  .  .  .  4: *syntax.AssignStmt {
 17606  .  .  .  .  .  .  .  .  .  Op: <op-0>
 17607  .  .  .  .  .  .  .  .  .  Lhs: *syntax.SelectorExpr {
 17608  .  .  .  .  .  .  .  .  .  .  X: t @ parser.go:2173:3
 17609  .  .  .  .  .  .  .  .  .  .  Sel: ElemList @ parser.go:2173:5
 17610  .  .  .  .  .  .  .  .  .  }
 17611  .  .  .  .  .  .  .  .  .  Rhs: list @ parser.go:2173:16
 17612  .  .  .  .  .  .  .  .  }
 17613  .  .  .  .  .  .  .  .  5: *syntax.AssignStmt {
 17614  .  .  .  .  .  .  .  .  .  Op: <op-0>
 17615  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:2174:3
 17616  .  .  .  .  .  .  .  .  .  Rhs: t @ parser.go:2174:7
 17617  .  .  .  .  .  .  .  .  }
 17618  .  .  .  .  .  .  .  }
 17619  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 17620  .  .  .  .  .  .  }
 17621  .  .  .  .  .  .  Else: nil
 17622  .  .  .  .  .  }
 17623  .  .  .  .  .  3: *syntax.ReturnStmt {
 17624  .  .  .  .  .  .  Results: x @ parser.go:2176:9
 17625  .  .  .  .  .  }
 17626  .  .  .  .  }
 17627  .  .  .  .  Rbrace: src.Pos {}
 17628  .  .  .  }
 17629  .  .  .  Pragma: 0
 17630  .  .  }
 17631  .  .  79: *syntax.FuncDecl {
 17632  .  .  .  Attr: map[]
 17633  .  .  .  Recv: *syntax.Field {
 17634  .  .  .  .  Name: p @ parser.go:2180:7
 17635  .  .  .  .  Type: *syntax.Operation {
 17636  .  .  .  .  .  Op: *
 17637  .  .  .  .  .  X: parser @ parser.go:2180:10
 17638  .  .  .  .  .  Y: nil
 17639  .  .  .  .  }
 17640  .  .  .  }
 17641  .  .  .  Name: osemi @ parser.go:2180:18
 17642  .  .  .  Type: *syntax.FuncType {
 17643  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 17644  .  .  .  .  .  0: *syntax.Field {
 17645  .  .  .  .  .  .  Name: follow @ parser.go:2180:24
 17646  .  .  .  .  .  .  Type: token @ parser.go:2180:31
 17647  .  .  .  .  .  }
 17648  .  .  .  .  }
 17649  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 17650  .  .  .  .  .  0: *syntax.Field {
 17651  .  .  .  .  .  .  Name: nil
 17652  .  .  .  .  .  .  Type: bool @ parser.go:2180:38
 17653  .  .  .  .  .  }
 17654  .  .  .  .  }
 17655  .  .  .  }
 17656  .  .  .  Body: *syntax.BlockStmt {
 17657  .  .  .  .  List: []syntax.Stmt (4 entries) {
 17658  .  .  .  .  .  0: *syntax.SwitchStmt {
 17659  .  .  .  .  .  .  Init: nil
 17660  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 17661  .  .  .  .  .  .  .  X: p @ parser.go:2181:9
 17662  .  .  .  .  .  .  .  Sel: tok @ parser.go:2181:11
 17663  .  .  .  .  .  .  }
 17664  .  .  .  .  .  .  Body: []*syntax.CaseClause (2 entries) {
 17665  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 17666  .  .  .  .  .  .  .  .  Cases: _Semi @ parser.go:2182:7
 17667  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 17668  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 17669  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 17670  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17671  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2183:3
 17672  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:2183:5
 17673  .  .  .  .  .  .  .  .  .  .  .  }
 17674  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 17675  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17676  .  .  .  .  .  .  .  .  .  .  }
 17677  .  .  .  .  .  .  .  .  .  }
 17678  .  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
 17679  .  .  .  .  .  .  .  .  .  .  Results: true @ parser.go:2184:10
 17680  .  .  .  .  .  .  .  .  .  }
 17681  .  .  .  .  .  .  .  .  }
 17682  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 17683  .  .  .  .  .  .  .  }
 17684  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 17685  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 17686  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 17687  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:2186:7
 17688  .  .  .  .  .  .  .  .  .  .  1: _Rbrace @ parser.go:2186:16
 17689  .  .  .  .  .  .  .  .  .  }
 17690  .  .  .  .  .  .  .  .  }
 17691  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 17692  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 17693  .  .  .  .  .  .  .  .  .  .  Results: true @ parser.go:2188:10
 17694  .  .  .  .  .  .  .  .  .  }
 17695  .  .  .  .  .  .  .  .  }
 17696  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 17697  .  .  .  .  .  .  .  }
 17698  .  .  .  .  .  .  }
 17699  .  .  .  .  .  .  Rbrace: src.Pos {}
 17700  .  .  .  .  .  }
 17701  .  .  .  .  .  1: *syntax.ExprStmt {
 17702  .  .  .  .  .  .  X: *syntax.CallExpr {
 17703  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17704  .  .  .  .  .  .  .  .  X: p @ parser.go:2191:2
 17705  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:2191:4
 17706  .  .  .  .  .  .  .  }
 17707  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17708  .  .  .  .  .  .  .  .  0: *syntax.Operation {
 17709  .  .  .  .  .  .  .  .  .  Op: +
 17710  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
 17711  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting semicolon, newline, or \""
 17712  .  .  .  .  .  .  .  .  .  .  Kind: 4
 17713  .  .  .  .  .  .  .  .  .  }
 17714  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
 17715  .  .  .  .  .  .  .  .  .  .  Fun: tokstring @ parser.go:2191:55
 17716  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17717  .  .  .  .  .  .  .  .  .  .  .  0: follow @ parser.go:2191:65
 17718  .  .  .  .  .  .  .  .  .  .  }
 17719  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17720  .  .  .  .  .  .  .  .  .  }
 17721  .  .  .  .  .  .  .  .  }
 17722  .  .  .  .  .  .  .  }
 17723  .  .  .  .  .  .  .  HasDots: false
 17724  .  .  .  .  .  .  }
 17725  .  .  .  .  .  }
 17726  .  .  .  .  .  2: *syntax.ExprStmt {
 17727  .  .  .  .  .  .  X: *syntax.CallExpr {
 17728  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17729  .  .  .  .  .  .  .  .  X: p @ parser.go:2192:2
 17730  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:2192:4
 17731  .  .  .  .  .  .  .  }
 17732  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17733  .  .  .  .  .  .  .  .  0: follow @ parser.go:2192:12
 17734  .  .  .  .  .  .  .  }
 17735  .  .  .  .  .  .  .  HasDots: false
 17736  .  .  .  .  .  .  }
 17737  .  .  .  .  .  }
 17738  .  .  .  .  .  3: *syntax.ReturnStmt {
 17739  .  .  .  .  .  .  Results: false @ parser.go:2193:9
 17740  .  .  .  .  .  }
 17741  .  .  .  .  }
 17742  .  .  .  .  Rbrace: src.Pos {}
 17743  .  .  .  }
 17744  .  .  .  Pragma: 0
 17745  .  .  }
 17746  .  .  80: *syntax.FuncDecl {
 17747  .  .  .  Attr: map[]
 17748  .  .  .  Recv: *syntax.Field {
 17749  .  .  .  .  Name: p @ parser.go:2197:7
 17750  .  .  .  .  Type: *syntax.Operation {
 17751  .  .  .  .  .  Op: *
 17752  .  .  .  .  .  X: parser @ parser.go:2197:10
 17753  .  .  .  .  .  Y: nil
 17754  .  .  .  .  }
 17755  .  .  .  }
 17756  .  .  .  Name: ocomma @ parser.go:2197:18
 17757  .  .  .  Type: *syntax.FuncType {
 17758  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 17759  .  .  .  .  .  0: *syntax.Field {
 17760  .  .  .  .  .  .  Name: follow @ parser.go:2197:25
 17761  .  .  .  .  .  .  Type: token @ parser.go:2197:32
 17762  .  .  .  .  .  }
 17763  .  .  .  .  }
 17764  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 17765  .  .  .  .  .  0: *syntax.Field {
 17766  .  .  .  .  .  .  Name: nil
 17767  .  .  .  .  .  .  Type: bool @ parser.go:2197:39
 17768  .  .  .  .  .  }
 17769  .  .  .  .  }
 17770  .  .  .  }
 17771  .  .  .  Body: *syntax.BlockStmt {
 17772  .  .  .  .  List: []syntax.Stmt (4 entries) {
 17773  .  .  .  .  .  0: *syntax.SwitchStmt {
 17774  .  .  .  .  .  .  Init: nil
 17775  .  .  .  .  .  .  Tag: *syntax.SelectorExpr {
 17776  .  .  .  .  .  .  .  X: p @ parser.go:2198:9
 17777  .  .  .  .  .  .  .  Sel: tok @ parser.go:2198:11
 17778  .  .  .  .  .  .  }
 17779  .  .  .  .  .  .  Body: []*syntax.CaseClause (2 entries) {
 17780  .  .  .  .  .  .  .  0: *syntax.CaseClause {
 17781  .  .  .  .  .  .  .  .  Cases: _Comma @ parser.go:2199:7
 17782  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (2 entries) {
 17783  .  .  .  .  .  .  .  .  .  0: *syntax.ExprStmt {
 17784  .  .  .  .  .  .  .  .  .  .  X: *syntax.CallExpr {
 17785  .  .  .  .  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17786  .  .  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2200:3
 17787  .  .  .  .  .  .  .  .  .  .  .  .  Sel: next @ parser.go:2200:5
 17788  .  .  .  .  .  .  .  .  .  .  .  }
 17789  .  .  .  .  .  .  .  .  .  .  .  ArgList: nil
 17790  .  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17791  .  .  .  .  .  .  .  .  .  .  }
 17792  .  .  .  .  .  .  .  .  .  }
 17793  .  .  .  .  .  .  .  .  .  1: *syntax.ReturnStmt {
 17794  .  .  .  .  .  .  .  .  .  .  Results: true @ parser.go:2201:10
 17795  .  .  .  .  .  .  .  .  .  }
 17796  .  .  .  .  .  .  .  .  }
 17797  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 17798  .  .  .  .  .  .  .  }
 17799  .  .  .  .  .  .  .  1: *syntax.CaseClause {
 17800  .  .  .  .  .  .  .  .  Cases: *syntax.ListExpr {
 17801  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 17802  .  .  .  .  .  .  .  .  .  .  0: _Rparen @ parser.go:2203:7
 17803  .  .  .  .  .  .  .  .  .  .  1: _Rbrace @ parser.go:2203:16
 17804  .  .  .  .  .  .  .  .  .  }
 17805  .  .  .  .  .  .  .  .  }
 17806  .  .  .  .  .  .  .  .  Body: []syntax.Stmt (1 entries) {
 17807  .  .  .  .  .  .  .  .  .  0: *syntax.ReturnStmt {
 17808  .  .  .  .  .  .  .  .  .  .  Results: true @ parser.go:2205:10
 17809  .  .  .  .  .  .  .  .  .  }
 17810  .  .  .  .  .  .  .  .  }
 17811  .  .  .  .  .  .  .  .  Colon: src.Pos {}
 17812  .  .  .  .  .  .  .  }
 17813  .  .  .  .  .  .  }
 17814  .  .  .  .  .  .  Rbrace: src.Pos {}
 17815  .  .  .  .  .  }
 17816  .  .  .  .  .  1: *syntax.ExprStmt {
 17817  .  .  .  .  .  .  X: *syntax.CallExpr {
 17818  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17819  .  .  .  .  .  .  .  .  X: p @ parser.go:2208:2
 17820  .  .  .  .  .  .  .  .  Sel: syntax_error @ parser.go:2208:4
 17821  .  .  .  .  .  .  .  }
 17822  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17823  .  .  .  .  .  .  .  .  0: *syntax.Operation {
 17824  .  .  .  .  .  .  .  .  .  Op: +
 17825  .  .  .  .  .  .  .  .  .  X: *syntax.BasicLit {
 17826  .  .  .  .  .  .  .  .  .  .  Value: "\"expecting comma or \""
 17827  .  .  .  .  .  .  .  .  .  .  Kind: 4
 17828  .  .  .  .  .  .  .  .  .  }
 17829  .  .  .  .  .  .  .  .  .  Y: *syntax.CallExpr {
 17830  .  .  .  .  .  .  .  .  .  .  Fun: tokstring @ parser.go:2208:41
 17831  .  .  .  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17832  .  .  .  .  .  .  .  .  .  .  .  0: follow @ parser.go:2208:51
 17833  .  .  .  .  .  .  .  .  .  .  }
 17834  .  .  .  .  .  .  .  .  .  .  HasDots: false
 17835  .  .  .  .  .  .  .  .  .  }
 17836  .  .  .  .  .  .  .  .  }
 17837  .  .  .  .  .  .  .  }
 17838  .  .  .  .  .  .  .  HasDots: false
 17839  .  .  .  .  .  .  }
 17840  .  .  .  .  .  }
 17841  .  .  .  .  .  2: *syntax.ExprStmt {
 17842  .  .  .  .  .  .  X: *syntax.CallExpr {
 17843  .  .  .  .  .  .  .  Fun: *syntax.SelectorExpr {
 17844  .  .  .  .  .  .  .  .  X: p @ parser.go:2209:2
 17845  .  .  .  .  .  .  .  .  Sel: advance @ parser.go:2209:4
 17846  .  .  .  .  .  .  .  }
 17847  .  .  .  .  .  .  .  ArgList: []syntax.Expr (1 entries) {
 17848  .  .  .  .  .  .  .  .  0: follow @ parser.go:2209:12
 17849  .  .  .  .  .  .  .  }
 17850  .  .  .  .  .  .  .  HasDots: false
 17851  .  .  .  .  .  .  }
 17852  .  .  .  .  .  }
 17853  .  .  .  .  .  3: *syntax.ReturnStmt {
 17854  .  .  .  .  .  .  Results: false @ parser.go:2210:9
 17855  .  .  .  .  .  }
 17856  .  .  .  .  }
 17857  .  .  .  .  Rbrace: src.Pos {}
 17858  .  .  .  }
 17859  .  .  .  Pragma: 0
 17860  .  .  }
 17861  .  .  81: *syntax.FuncDecl {
 17862  .  .  .  Attr: map[]
 17863  .  .  .  Recv: nil
 17864  .  .  .  Name: unparen @ parser.go:2214:6
 17865  .  .  .  Type: *syntax.FuncType {
 17866  .  .  .  .  ParamList: []*syntax.Field (1 entries) {
 17867  .  .  .  .  .  0: *syntax.Field {
 17868  .  .  .  .  .  .  Name: x @ parser.go:2214:14
 17869  .  .  .  .  .  .  Type: Expr @ parser.go:2214:16
 17870  .  .  .  .  .  }
 17871  .  .  .  .  }
 17872  .  .  .  .  ResultList: []*syntax.Field (1 entries) {
 17873  .  .  .  .  .  0: *syntax.Field {
 17874  .  .  .  .  .  .  Name: nil
 17875  .  .  .  .  .  .  Type: Expr @ parser.go:2214:22
 17876  .  .  .  .  .  }
 17877  .  .  .  .  }
 17878  .  .  .  }
 17879  .  .  .  Body: *syntax.BlockStmt {
 17880  .  .  .  .  List: []syntax.Stmt (2 entries) {
 17881  .  .  .  .  .  0: *syntax.ForStmt {
 17882  .  .  .  .  .  .  Init: nil
 17883  .  .  .  .  .  .  Cond: nil
 17884  .  .  .  .  .  .  Post: nil
 17885  .  .  .  .  .  .  Body: *syntax.BlockStmt {
 17886  .  .  .  .  .  .  .  List: []syntax.Stmt (3 entries) {
 17887  .  .  .  .  .  .  .  .  0: *syntax.AssignStmt {
 17888  .  .  .  .  .  .  .  .  .  Op: :
 17889  .  .  .  .  .  .  .  .  .  Lhs: *syntax.ListExpr {
 17890  .  .  .  .  .  .  .  .  .  .  ElemList: []syntax.Expr (2 entries) {
 17891  .  .  .  .  .  .  .  .  .  .  .  0: p @ parser.go:2216:3
 17892  .  .  .  .  .  .  .  .  .  .  .  1: ok @ parser.go:2216:6
 17893  .  .  .  .  .  .  .  .  .  .  }
 17894  .  .  .  .  .  .  .  .  .  }
 17895  .  .  .  .  .  .  .  .  .  Rhs: *syntax.AssertExpr {
 17896  .  .  .  .  .  .  .  .  .  .  X: x @ parser.go:2216:12
 17897  .  .  .  .  .  .  .  .  .  .  Type: *syntax.Operation {
 17898  .  .  .  .  .  .  .  .  .  .  .  Op: *
 17899  .  .  .  .  .  .  .  .  .  .  .  X: ParenExpr @ parser.go:2216:16
 17900  .  .  .  .  .  .  .  .  .  .  .  Y: nil
 17901  .  .  .  .  .  .  .  .  .  .  }
 17902  .  .  .  .  .  .  .  .  .  }
 17903  .  .  .  .  .  .  .  .  }
 17904  .  .  .  .  .  .  .  .  1: *syntax.IfStmt {
 17905  .  .  .  .  .  .  .  .  .  Init: nil
 17906  .  .  .  .  .  .  .  .  .  Cond: *syntax.Operation {
 17907  .  .  .  .  .  .  .  .  .  .  Op: !
 17908  .  .  .  .  .  .  .  .  .  .  X: ok @ parser.go:2217:7
 17909  .  .  .  .  .  .  .  .  .  .  Y: nil
 17910  .  .  .  .  .  .  .  .  .  }
 17911  .  .  .  .  .  .  .  .  .  Then: *syntax.BlockStmt {
 17912  .  .  .  .  .  .  .  .  .  .  List: []syntax.Stmt (1 entries) {
 17913  .  .  .  .  .  .  .  .  .  .  .  0: *syntax.BranchStmt {
 17914  .  .  .  .  .  .  .  .  .  .  .  .  Tok: break
 17915  .  .  .  .  .  .  .  .  .  .  .  .  Label: nil
 17916  .  .  .  .  .  .  .  .  .  .  .  .  Target: *(Node @ 17881)
 17917  .  .  .  .  .  .  .  .  .  .  .  }
 17918  .  .  .  .  .  .  .  .  .  .  }
 17919  .  .  .  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 17920  .  .  .  .  .  .  .  .  .  }
 17921  .  .  .  .  .  .  .  .  .  Else: nil
 17922  .  .  .  .  .  .  .  .  }
 17923  .  .  .  .  .  .  .  .  2: *syntax.AssignStmt {
 17924  .  .  .  .  .  .  .  .  .  Op: <op-0>
 17925  .  .  .  .  .  .  .  .  .  Lhs: x @ parser.go:2220:3
 17926  .  .  .  .  .  .  .  .  .  Rhs: *syntax.SelectorExpr {
 17927  .  .  .  .  .  .  .  .  .  .  X: p @ parser.go:2220:7
 17928  .  .  .  .  .  .  .  .  .  .  Sel: X @ parser.go:2220:9
 17929  .  .  .  .  .  .  .  .  .  }
 17930  .  .  .  .  .  .  .  .  }
 17931  .  .  .  .  .  .  .  }
 17932  .  .  .  .  .  .  .  Rbrace: src.Pos {}
 17933  .  .  .  .  .  .  }
 17934  .  .  .  .  .  }
 17935  .  .  .  .  .  1: *syntax.ReturnStmt {
 17936  .  .  .  .  .  .  Results: x @ parser.go:2222:9
 17937  .  .  .  .  .  }
 17938  .  .  .  .  }
 17939  .  .  .  .  Rbrace: src.Pos {}
 17940  .  .  .  }
 17941  .  .  .  Pragma: 0
 17942  .  .  }
 17943  .  }
 17944  .  Lines: 2224
 17945  }
parsed 1240806 lines (3281 files) in 1.097527987s (1130546 lines/s)
allocated 326.962Mb (297.908Mb/s)
--- FAIL: TestStdLib (1.10s)
	parser_test.go:55: /usr/local/go/blog/content/first-go-program/slist.go:29:20: syntax error: unexpected (, expecting semicolon, newline, or }
package syntax

import (
	"cmd/internal/src"
	"fmt"
	"io"
	"strconv"
	"strings"
)

const debug = false
const trace = false

type parser struct {
	base *src.PosBase
	errh ErrorHandler
	mode Mode
	scanner
	first error
	pragma Pragma
	fnest int
	xnest int
	indent []byte
}

func (p *parser) init(base *src.PosBase, r io.Reader, errh ErrorHandler, pragh PragmaHandler, mode Mode) {
	p.base = base
	p.errh = errh
	p.mode = mode
	p.scanner.init(r, func(line, col uint, msg string) {
		p.error_at(p.pos_at(line, col), msg)
	}, func(line, col uint, text string) {
		if strings.HasPrefix(text, "line ") {
			p.updateBase(line, col + 5, text[5:])
			return
		}
		if pragh != nil {
			p.pragma |= pragh(p.pos_at(line, col), text)
		}
	})
	p.first = nil
	p.pragma = 0
	p.fnest = 0
	p.xnest = 0
	p.indent = nil
}

const lineMax = 1 << 24 - 1

func (p *parser) updateBase(line, col uint, text string) {
	i := strings.LastIndex(text, ":")
	if i < 0 {
		return
	}
	nstr := text[i + 1:]
	n, err := strconv.Atoi(nstr)
	if err != nil || n <= 0 || n > lineMax {
		p.error_at(p.pos_at(line, col + uint(i + 1)), "invalid line number: " + nstr)
		return
	}
	p.base = src.NewLinePragmaBase(src.MakePos(p.base.Pos().Base(), line, col), text[:i], uint(n))
}

func (p *parser) got(tok token) bool {
	if p.tok == tok {
		p.next()
		return true
	}
	return false
}

func (p *parser) want(tok token) {
	if !p.got(tok) {
		p.syntax_error("expecting " + tok.String())
		p.advance()
	}
}

func (p *parser) pos_at(line, col uint) src.Pos {
	return src.MakePos(p.base, line, col)
}

func (p *parser) error_at(pos src.Pos, msg string) {
	err := Error{pos, msg}
	if p.first == nil {
		p.first = err
	}
	if p.errh == nil {
		panic(p.first)
	}
	p.errh(err)
}

func (p *parser) syntax_error_at(pos src.Pos, msg string) {
	if trace {
		defer p.trace("syntax_error (" + msg + ")")()
	}
	if p.tok == _EOF && p.first != nil {
		return
	}
	switch {
	case msg == "":
	case strings.HasPrefix(msg, "in"), strings.HasPrefix(msg, "at"), strings.HasPrefix(msg, "after"):
		msg = " " + msg
	case strings.HasPrefix(msg, "expecting"):
		msg = ", " + msg
	default:
		p.error_at(pos, "syntax error: " + msg)
		return
	}
	var tok string
	switch p.tok {
	case _Name, _Semi:
		tok = p.lit
	case _Literal:
		tok = "literal " + p.lit
	case _Operator:
		tok = p.op.String()
	case _AssignOp:
		tok = p.op.String() + "="
	case _IncOp:
		tok = p.op.String()
		tok += tok
	default:
		tok = tokstring(p.tok)
	}
	p.error_at(pos, "syntax error: unexpected " + tok + msg)
}

func (p *parser) pos() src.Pos {
	return p.pos_at(p.line, p.col)
}

func (p *parser) error(msg string) {
	p.error_at(p.pos(), msg)
}

func (p *parser) syntax_error(msg string) {
	p.syntax_error_at(p.pos(), msg)
}

const stopset uint64 = 1 << _Break | 1 << _Const | 1 << _Continue | 1 << _Defer | 1 << _Fallthrough | 1 << _For | 1 << _Func | 1 << _Go | 1 << _Goto | 1 << _If | 1 << _Return | 1 << _Select | 1 << _Switch | 1 << _Type | 1 << _Var

func (p *parser) advance(followlist ...token) {
	if len(followlist) == 0 {
		p.next()
		return
	}
	var followset uint64 = 1 << _EOF
	for _, tok := range followlist {
		followset |= 1 << tok
	}
	for !(contains(followset, p.tok) || p.fnest > 0 && contains(stopset, p.tok)) {
		p.next()
	}
}

func tokstring(tok token) string {
	switch tok {
	case _EOF:
		return "EOF"
	case _Comma:
		return "comma"
	case _Semi:
		return "semicolon"
	}
	return tok.String()
}

func (p *parser) trace(msg string) func() {
	fmt.Printf("%5d: %s%s (\n", p.line, p.indent, msg)
	const tab = ". "
	p.indent = append(p.indent, tab...)
	return func() {
		p.indent = p.indent[:len(p.indent) - len(tab)]
		if x := recover(); x != nil {
			panic(x)
		}
		fmt.Printf("%5d: %s)\n", p.line, p.indent)
	}
}

func (p *parser) fileOrNil() *File {
	if trace {
		defer p.trace("file")()
	}
	f := new(File)
	f.pos = p.pos()
	if !p.got(_Package) {
		p.syntax_error("package statement must be first")
		return nil
	}
	f.PkgName = p.name()
	p.want(_Semi)
	if p.first != nil {
		return nil
	}
	for p.got(_Import) {
		f.DeclList = p.appendGroup(f.DeclList, p.importDecl)
		p.want(_Semi)
	}
	for p.tok != _EOF {
		switch p.tok {
		case _Const:
			p.next()
			f.DeclList = p.appendGroup(f.DeclList, p.constDecl)
		case _Type:
			p.next()
			f.DeclList = p.appendGroup(f.DeclList, p.typeDecl)
		case _Var:
			p.next()
			f.DeclList = p.appendGroup(f.DeclList, p.varDecl)
		case _Func:
			p.next()
			if d := p.funcDeclOrNil(); d != nil {
				f.DeclList = append(f.DeclList, d)
			}
		default:
			if p.tok == _Lbrace && len(f.DeclList) > 0 && isEmptyFuncDecl(f.DeclList[len(f.DeclList) - 1]) {
				p.syntax_error("unexpected semicolon or newline before {")
			} else {
				p.syntax_error("non-declaration statement outside function body")
			}
			p.advance(_Const, _Type, _Var, _Func)
			continue
		}
		p.pragma = 0
		if p.tok != _EOF && !p.got(_Semi) {
			p.syntax_error("after top level declaration")
			p.advance(_Const, _Type, _Var, _Func)
		}
	}
	f.Lines = p.source.line
	return f
}

func isEmptyFuncDecl(dcl Decl) bool {
	f, ok := dcl.(*FuncDecl)
	return ok && f.Body == nil
}

func (p *parser) appendGroup(list []Decl, f func(*Group) Decl) []Decl {
	if p.got(_Lparen) {
		g := new(Group)
		for p.tok != _EOF && p.tok != _Rparen {
			list = append(list, f(g))
			if !p.osemi(_Rparen) {
				break
			}
		}
		p.want(_Rparen)
	} else {
		list = append(list, f(nil))
	}
	if debug {
		for _, d := range list {
			if d == nil {
				panic("nil list entry")
			}
		}
	}
	return list
}

func (p *parser) importDecl(group *Group) Decl {
	if trace {
		defer p.trace("importDecl")()
	}
	d := new(ImportDecl)
	d.pos = p.pos()
	switch p.tok {
	case _Name:
		d.LocalPkgName = p.name()
	case _Dot:
		d.LocalPkgName = p.newName(".")
		p.next()
	}
	d.Path = p.oliteral()
	if d.Path == nil {
		p.syntax_error("missing import path")
		p.advance(_Semi, _Rparen)
		return nil
	}
	d.Group = group
	return d
}

func (p *parser) constDecl(group *Group) Decl {
	if trace {
		defer p.trace("constDecl")()
	}
	d := new(ConstDecl)
	d.pos = p.pos()
	d.NameList = p.nameList(p.name())
	if p.tok != _EOF && p.tok != _Semi && p.tok != _Rparen {
		d.Type = p.typeOrNil()
		if p.got(_Assign) {
			d.Values = p.exprList()
		}
	}
	d.Group = group
	return d
}

func (p *parser) typeDecl(group *Group) Decl {
	if trace {
		defer p.trace("typeDecl")()
	}
	d := new(TypeDecl)
	d.pos = p.pos()
	d.Name = p.name()
	d.Alias = p.got(_Assign)
	d.Type = p.typeOrNil()
	if d.Type == nil {
		d.Type = p.bad()
		p.syntax_error("in type declaration")
		p.advance(_Semi, _Rparen)
	}
	d.Group = group
	d.Pragma = p.pragma
	return d
}

func (p *parser) varDecl(group *Group) Decl {
	if trace {
		defer p.trace("varDecl")()
	}
	d := new(VarDecl)
	d.pos = p.pos()
	d.NameList = p.nameList(p.name())
	if p.got(_Assign) {
		d.Values = p.exprList()
	} else {
		d.Type = p.type_()
		if p.got(_Assign) {
			d.Values = p.exprList()
		}
	}
	d.Group = group
	return d
}

func (p *parser) funcDeclOrNil() *FuncDecl {
	if trace {
		defer p.trace("funcDecl")()
	}
	f := new(FuncDecl)
	f.pos = p.pos()
	if p.tok == _Lparen {
		rcvr := p.paramList()
		switch len(rcvr) {
		case 0:
			p.error("method has no receiver")
		default:
			p.error("method has multiple receivers")
			fallthrough
		case 1:
			f.Recv = rcvr[0]
		}
	}
	if p.tok != _Name {
		p.syntax_error("expecting name or (")
		p.advance(_Lbrace, _Semi)
		return nil
	}
	f.Name = p.name()
	f.Type = p.funcType()
	if p.tok == _Lbrace {
		f.Body = p.blockStmt("")
		if p.mode & CheckBranches != 0 {
			checkBranches(f.Body, p.errh)
		}
	}
	f.Pragma = p.pragma
	return f
}

func (p *parser) expr() Expr {
	if trace {
		defer p.trace("expr")()
	}
	return p.binaryExpr(0)
}

func (p *parser) binaryExpr(prec int) Expr {
	x := p.unaryExpr()
	for (p.tok == _Operator || p.tok == _Star) && p.prec > prec {
		t := new(Operation)
		t.pos = p.pos()
		t.Op = p.op
		t.X = x
		tprec := p.prec
		p.next()
		t.Y = p.binaryExpr(tprec)
		x = t
	}
	return x
}

func (p *parser) unaryExpr() Expr {
	if trace {
		defer p.trace("unaryExpr")()
	}
	switch p.tok {
	case _Operator, _Star:
		switch p.op {
		case Mul, Add, Sub, Not, Xor:
			x := new(Operation)
			x.pos = p.pos()
			x.Op = p.op
			p.next()
			x.X = p.unaryExpr()
			return x
		case And:
			x := new(Operation)
			x.pos = p.pos()
			x.Op = And
			p.next()
			x.X = unparen(p.unaryExpr())
			return x
		}
	case _Arrow:
		pos := p.pos()
		p.next()
		x := p.unaryExpr()
		if _, ok := x.(*ChanType); ok {
			dir := SendOnly
			t := x
			for dir == SendOnly {
				c, ok := t.(*ChanType)
				if !ok {
					break
				}
				dir = c.Dir
				if dir == RecvOnly {
					p.syntax_error("unexpected <-, expecting chan")
				}
				c.Dir = RecvOnly
				t = c.Elem
			}
			if dir == SendOnly {
				p.syntax_error(fmt.Sprintf("unexpected %s, expecting chan", String(t)))
			}
			return x
		}
		o := new(Operation)
		o.pos = pos
		o.Op = Recv
		o.X = x
		return o
	}
	return p.pexpr(true)
}

func (p *parser) callStmt() *CallStmt {
	if trace {
		defer p.trace("callStmt")()
	}
	s := new(CallStmt)
	s.pos = p.pos()
	s.Tok = p.tok
	p.next()
	x := p.pexpr(p.tok == _Lparen)
	if t := unparen(x); t != x {
		p.error(fmt.Sprintf("expression in %s must not be parenthesized", s.Tok))
		x = t
	}
	cx, ok := x.(*CallExpr)
	if !ok {
		p.error(fmt.Sprintf("expression in %s must be function call", s.Tok))
		cx = new(CallExpr)
		cx.pos = x.Pos()
		cx.Fun = p.bad()
	}
	s.Call = cx
	return s
}

func (p *parser) operand(keep_parens bool) Expr {
	if trace {
		defer p.trace("operand " + p.tok.String())()
	}
	switch p.tok {
	case _Name:
		return p.name()
	case _Literal:
		return p.oliteral()
	case _Lparen:
		pos := p.pos()
		p.next()
		p.xnest++
		x := p.expr()
		p.xnest--
		p.want(_Rparen)
		if p.tok == _Lbrace {
			keep_parens = true
		}
		if keep_parens {
			px := new(ParenExpr)
			px.pos = pos
			px.X = x
			x = px
		}
		return x
	case _Func:
		pos := p.pos()
		p.next()
		t := p.funcType()
		if p.tok == _Lbrace {
			p.xnest++
			f := new(FuncLit)
			f.pos = pos
			f.Type = t
			f.Body = p.blockStmt("")
			if p.mode & CheckBranches != 0 {
				checkBranches(f.Body, p.errh)
			}
			p.xnest--
			return f
		}
		return t
	case _Lbrack, _Chan, _Map, _Struct, _Interface:
		return p.type_()
	default:
		x := p.bad()
		p.syntax_error("expecting expression")
		p.advance()
		return x
	}
}

func (p *parser) pexpr(keep_parens bool) Expr {
	if trace {
		defer p.trace("pexpr")()
	}
	x := p.operand(keep_parens)
loop:
	for {
		pos := p.pos()
		switch p.tok {
		case _Dot:
			p.next()
			switch p.tok {
			case _Name:
				t := new(SelectorExpr)
				t.pos = pos
				t.X = x
				t.Sel = p.name()
				x = t
			case _Lparen:
				p.next()
				if p.got(_Type) {
					t := new(TypeSwitchGuard)
					t.pos = pos
					t.X = x
					x = t
				} else {
					t := new(AssertExpr)
					t.pos = pos
					t.X = x
					t.Type = p.expr()
					x = t
				}
				p.want(_Rparen)
			default:
				p.syntax_error("expecting name or (")
				p.advance(_Semi, _Rparen)
			}
		case _Lbrack:
			p.next()
			p.xnest++
			var i Expr
			if p.tok != _Colon {
				i = p.expr()
				if p.got(_Rbrack) {
					t := new(IndexExpr)
					t.pos = pos
					t.X = x
					t.Index = i
					x = t
					p.xnest--
					break
				}
			}
			t := new(SliceExpr)
			t.pos = pos
			t.X = x
			t.Index[0] = i
			p.want(_Colon)
			if p.tok != _Colon && p.tok != _Rbrack {
				t.Index[1] = p.expr()
			}
			if p.got(_Colon) {
				t.Full = true
				if t.Index[1] == nil {
					p.error("middle index required in 3-index slice")
				}
				if p.tok != _Rbrack {
					t.Index[2] = p.expr()
				} else {
					p.error("final index required in 3-index slice")
				}
			}
			p.want(_Rbrack)
			x = t
			p.xnest--
		case _Lparen:
			x = p.call(x)
		case _Lbrace:
			t := unparen(x)
			complit_ok := false
			switch t.(type) {
			case *Name, *SelectorExpr:
				if p.xnest >= 0 {
					complit_ok = true
				}
			case *ArrayType, *SliceType, *StructType, *MapType:
				complit_ok = true
			}
			if !complit_ok {
				break loop
			}
			if t != x {
				p.syntax_error("cannot parenthesize type in composite literal")
			}
			n := p.complitexpr()
			n.Type = x
			x = n
		default:
			break loop
		}
	}
	return x
}

func (p *parser) bare_complitexpr() Expr {
	if trace {
		defer p.trace("bare_complitexpr")()
	}
	if p.tok == _Lbrace {
		return p.complitexpr()
	}
	return p.expr()
}

func (p *parser) complitexpr() *CompositeLit {
	if trace {
		defer p.trace("complitexpr")()
	}
	x := new(CompositeLit)
	x.pos = p.pos()
	p.want(_Lbrace)
	p.xnest++
	for p.tok != _EOF && p.tok != _Rbrace {
		e := p.bare_complitexpr()
		if p.tok == _Colon {
			l := new(KeyValueExpr)
			l.pos = p.pos()
			p.next()
			l.Key = e
			l.Value = p.bare_complitexpr()
			e = l
			x.NKeys++
		}
		x.ElemList = append(x.ElemList, e)
		if !p.ocomma(_Rbrace) {
			break
		}
	}
	x.Rbrace = p.pos()
	p.xnest--
	p.want(_Rbrace)
	return x
}

func (p *parser) type_() Expr {
	if trace {
		defer p.trace("type_")()
	}
	typ := p.typeOrNil()
	if typ == nil {
		typ = p.bad()
		p.syntax_error("expecting type")
		p.advance()
	}
	return typ
}

func newIndirect(pos src.Pos, typ Expr) Expr {
	o := new(Operation)
	o.pos = pos
	o.Op = Mul
	o.X = typ
	return o
}

func (p *parser) typeOrNil() Expr {
	if trace {
		defer p.trace("typeOrNil")()
	}
	pos := p.pos()
	switch p.tok {
	case _Star:
		p.next()
		return newIndirect(pos, p.type_())
	case _Arrow:
		p.next()
		p.want(_Chan)
		t := new(ChanType)
		t.pos = pos
		t.Dir = RecvOnly
		t.Elem = p.chanElem()
		return t
	case _Func:
		p.next()
		return p.funcType()
	case _Lbrack:
		p.next()
		p.xnest++
		if p.got(_Rbrack) {
			p.xnest--
			t := new(SliceType)
			t.pos = pos
			t.Elem = p.type_()
			return t
		}
		t := new(ArrayType)
		t.pos = pos
		if !p.got(_DotDotDot) {
			t.Len = p.expr()
		}
		p.want(_Rbrack)
		p.xnest--
		t.Elem = p.type_()
		return t
	case _Chan:
		p.next()
		t := new(ChanType)
		t.pos = pos
		if p.got(_Arrow) {
			t.Dir = SendOnly
		}
		t.Elem = p.chanElem()
		return t
	case _Map:
		p.next()
		p.want(_Lbrack)
		t := new(MapType)
		t.pos = pos
		t.Key = p.type_()
		p.want(_Rbrack)
		t.Value = p.type_()
		return t
	case _Struct:
		return p.structType()
	case _Interface:
		return p.interfaceType()
	case _Name:
		return p.dotname(p.name())
	case _Lparen:
		p.next()
		t := p.type_()
		p.want(_Rparen)
		return t
	}
	return nil
}

func (p *parser) funcType() *FuncType {
	if trace {
		defer p.trace("funcType")()
	}
	typ := new(FuncType)
	typ.pos = p.pos()
	typ.ParamList = p.paramList()
	typ.ResultList = p.funcResult()
	return typ
}

func (p *parser) chanElem() Expr {
	if trace {
		defer p.trace("chanElem")()
	}
	typ := p.typeOrNil()
	if typ == nil {
		typ = p.bad()
		p.syntax_error("missing channel element type")
	}
	return typ
}

func (p *parser) dotname(name *Name) Expr {
	if trace {
		defer p.trace("dotname")()
	}
	if p.tok == _Dot {
		s := new(SelectorExpr)
		s.pos = p.pos()
		p.next()
		s.X = name
		s.Sel = p.name()
		return s
	}
	return name
}

func (p *parser) structType() *StructType {
	if trace {
		defer p.trace("structType")()
	}
	typ := new(StructType)
	typ.pos = p.pos()
	p.want(_Struct)
	p.want(_Lbrace)
	for p.tok != _EOF && p.tok != _Rbrace {
		p.fieldDecl(typ)
		if !p.osemi(_Rbrace) {
			break
		}
	}
	p.want(_Rbrace)
	return typ
}

func (p *parser) interfaceType() *InterfaceType {
	if trace {
		defer p.trace("interfaceType")()
	}
	typ := new(InterfaceType)
	typ.pos = p.pos()
	p.want(_Interface)
	p.want(_Lbrace)
	for p.tok != _EOF && p.tok != _Rbrace {
		if m := p.methodDecl(); m != nil {
			typ.MethodList = append(typ.MethodList, m)
		}
		if !p.osemi(_Rbrace) {
			break
		}
	}
	p.want(_Rbrace)
	return typ
}

func (p *parser) funcBody() []Stmt {
	if trace {
		defer p.trace("funcBody")()
	}
	p.fnest++
	body := p.stmtList()
	p.fnest--
	if body == nil {
		body = []Stmt{new(EmptyStmt)}
	}
	return body
}

func (p *parser) funcResult() []*Field {
	if trace {
		defer p.trace("funcResult")()
	}
	if p.tok == _Lparen {
		return p.paramList()
	}
	pos := p.pos()
	if typ := p.typeOrNil(); typ != nil {
		f := new(Field)
		f.pos = pos
		f.Type = typ
		return []*Field{f}
	}
	return nil
}

func (p *parser) addField(styp *StructType, pos src.Pos, name *Name, typ Expr, tag *BasicLit) {
	if tag != nil {
		for i := len(styp.FieldList) - len(styp.TagList); i > 0; i-- {
			styp.TagList = append(styp.TagList, nil)
		}
		styp.TagList = append(styp.TagList, tag)
	}
	f := new(Field)
	f.pos = pos
	f.Name = name
	f.Type = typ
	styp.FieldList = append(styp.FieldList, f)
	if debug && tag != nil && len(styp.FieldList) != len(styp.TagList) {
		panic("inconsistent struct field list")
	}
}

func (p *parser) fieldDecl(styp *StructType) {
	if trace {
		defer p.trace("fieldDecl")()
	}
	pos := p.pos()
	switch p.tok {
	case _Name:
		name := p.name()
		if p.tok == _Dot || p.tok == _Literal || p.tok == _Semi || p.tok == _Rbrace {
			typ := p.qualifiedName(name)
			tag := p.oliteral()
			p.addField(styp, pos, nil, typ, tag)
			return
		}
		names := p.nameList(name)
		typ := p.type_()
		tag := p.oliteral()
		for _, name := range names {
			p.addField(styp, name.Pos(), name, typ, tag)
		}
	case _Lparen:
		p.next()
		if p.tok == _Star {
			pos := p.pos()
			p.next()
			typ := newIndirect(pos, p.qualifiedName(nil))
			p.want(_Rparen)
			tag := p.oliteral()
			p.addField(styp, pos, nil, typ, tag)
			p.syntax_error("cannot parenthesize embedded type")
		} else {
			typ := p.qualifiedName(nil)
			p.want(_Rparen)
			tag := p.oliteral()
			p.addField(styp, pos, nil, typ, tag)
			p.syntax_error("cannot parenthesize embedded type")
		}
	case _Star:
		p.next()
		if p.got(_Lparen) {
			typ := newIndirect(pos, p.qualifiedName(nil))
			p.want(_Rparen)
			tag := p.oliteral()
			p.addField(styp, pos, nil, typ, tag)
			p.syntax_error("cannot parenthesize embedded type")
		} else {
			typ := newIndirect(pos, p.qualifiedName(nil))
			tag := p.oliteral()
			p.addField(styp, pos, nil, typ, tag)
		}
	default:
		p.syntax_error("expecting field name or embedded type")
		p.advance(_Semi, _Rbrace)
	}
}

func (p *parser) oliteral() *BasicLit {
	if p.tok == _Literal {
		b := new(BasicLit)
		b.pos = p.pos()
		b.Value = p.lit
		b.Kind = p.kind
		p.next()
		return b
	}
	return nil
}

func (p *parser) methodDecl() *Field {
	if trace {
		defer p.trace("methodDecl")()
	}
	switch p.tok {
	case _Name:
		name := p.name()
		hasNameList := false
		for p.got(_Comma) {
			p.name()
			hasNameList = true
		}
		if hasNameList {
			p.syntax_error("name list not allowed in interface type")
		}
		f := new(Field)
		f.pos = name.Pos()
		if p.tok != _Lparen {
			f.Type = p.qualifiedName(name)
			return f
		}
		f.Name = name
		f.Type = p.funcType()
		return f
	case _Lparen:
		p.syntax_error("cannot parenthesize embedded type")
		f := new(Field)
		f.pos = p.pos()
		p.next()
		f.Type = p.qualifiedName(nil)
		p.want(_Rparen)
		return f
	default:
		p.syntax_error("expecting method or interface name")
		p.advance(_Semi, _Rbrace)
		return nil
	}
}

func (p *parser) paramDeclOrNil() *Field {
	if trace {
		defer p.trace("paramDecl")()
	}
	f := new(Field)
	f.pos = p.pos()
	switch p.tok {
	case _Name:
		f.Name = p.name()
		switch p.tok {
		case _Name, _Star, _Arrow, _Func, _Lbrack, _Chan, _Map, _Struct, _Interface, _Lparen:
			f.Type = p.type_()
		case _DotDotDot:
			f.Type = p.dotsType()
		case _Dot:
			f.Type = p.dotname(f.Name)
			f.Name = nil
		}
	case _Arrow, _Star, _Func, _Lbrack, _Chan, _Map, _Struct, _Interface, _Lparen:
		f.Type = p.type_()
	case _DotDotDot:
		f.Type = p.dotsType()
	default:
		p.syntax_error("expecting )")
		p.advance(_Comma, _Rparen)
		return nil
	}
	return f
}

func (p *parser) dotsType() *DotsType {
	if trace {
		defer p.trace("dotsType")()
	}
	t := new(DotsType)
	t.pos = p.pos()
	p.want(_DotDotDot)
	t.Elem = p.typeOrNil()
	if t.Elem == nil {
		t.Elem = p.bad()
		p.syntax_error("final argument in variadic function missing type")
	}
	return t
}

func (p *parser) paramList() (list []*Field) {
	if trace {
		defer p.trace("paramList")()
	}
	pos := p.pos()
	p.want(_Lparen)
	var named int
	for p.tok != _EOF && p.tok != _Rparen {
		if par := p.paramDeclOrNil(); par != nil {
			if debug && par.Name == nil && par.Type == nil {
				panic("parameter without name or type")
			}
			if par.Name != nil && par.Type != nil {
				named++
			}
			list = append(list, par)
		}
		if !p.ocomma(_Rparen) {
			break
		}
	}
	if named == 0 {
		for _, par := range list {
			if typ := par.Name; typ != nil {
				par.Type = typ
				par.Name = nil
			}
		}
	} else if named != len(list) {
		ok := true
		var typ Expr
		for i := len(list) - 1; i >= 0; i-- {
			if par := list[i]; par.Type != nil {
				typ = par.Type
				if par.Name == nil {
					ok = false
					n := p.newName("_")
					n.pos = typ.Pos()
					par.Name = n
				}
			} else if typ != nil {
				par.Type = typ
			} else {
				ok = false
				t := p.bad()
				t.pos = par.Name.Pos()
				par.Type = t
			}
		}
		if !ok {
			p.syntax_error_at(pos, "mixed named and unnamed function parameters")
		}
	}
	p.want(_Rparen)
	return
}

func (p *parser) bad() *BadExpr {
	b := new(BadExpr)
	b.pos = p.pos()
	return b
}

var ImplicitOne = &BasicLit{
	Value: "1",
}

func (p *parser) simpleStmt(lhs Expr, rangeOk bool) SimpleStmt {
	if trace {
		defer p.trace("simpleStmt")()
	}
	if rangeOk && p.tok == _Range {
		if debug && lhs != nil {
			panic("invalid call of simpleStmt")
		}
		return p.newRangeClause(nil, false)
	}
	if lhs == nil {
		lhs = p.exprList()
	}
	if _, ok := lhs.(*ListExpr); !ok && p.tok != _Assign && p.tok != _Define {
		pos := p.pos()
		switch p.tok {
		case _AssignOp:
			op := p.op
			p.next()
			return p.newAssignStmt(pos, op, lhs, p.expr())
		case _IncOp:
			op := p.op
			p.next()
			return p.newAssignStmt(pos, op, lhs, ImplicitOne)
		case _Arrow:
			s := new(SendStmt)
			s.pos = pos
			p.next()
			s.Chan = lhs
			s.Value = p.expr()
			return s
		default:
			s := new(ExprStmt)
			s.pos = lhs.Pos()
			s.X = lhs
			return s
		}
	}
	pos := p.pos()
	switch p.tok {
	case _Assign:
		p.next()
		if rangeOk && p.tok == _Range {
			return p.newRangeClause(lhs, false)
		}
		return p.newAssignStmt(pos, 0, lhs, p.exprList())
	case _Define:
		p.next()
		if rangeOk && p.tok == _Range {
			return p.newRangeClause(lhs, true)
		}
		rhs := p.exprList()
		if x, ok := rhs.(*TypeSwitchGuard); ok {
			switch lhs := lhs.(type) {
			case *Name:
				x.Lhs = lhs
			case *ListExpr:
				p.error_at(lhs.Pos(), fmt.Sprintf("cannot assign 1 value to %d variables", len(lhs.ElemList)))
				if lhs, ok := lhs.ElemList[0].(*Name); ok {
					x.Lhs = lhs
				}
			default:
				p.error_at(lhs.Pos(), fmt.Sprintf("invalid variable name %s in type switch", String(lhs)))
			}
			s := new(ExprStmt)
			s.pos = x.Pos()
			s.X = x
			return s
		}
		as := p.newAssignStmt(pos, Def, lhs, rhs)
		return as
	default:
		p.syntax_error("expecting := or = or comma")
		p.advance(_Semi, _Rbrace)
		if x, ok := lhs.(*ListExpr); ok {
			lhs = x.ElemList[0]
		}
		s := new(ExprStmt)
		s.pos = lhs.Pos()
		s.X = lhs
		return s
	}
}

func (p *parser) newRangeClause(lhs Expr, def bool) *RangeClause {
	r := new(RangeClause)
	r.pos = p.pos()
	p.next()
	r.Lhs = lhs
	r.Def = def
	r.X = p.expr()
	return r
}

func (p *parser) newAssignStmt(pos src.Pos, op Operator, lhs, rhs Expr) *AssignStmt {
	a := new(AssignStmt)
	a.pos = pos
	a.Op = op
	a.Lhs = lhs
	a.Rhs = rhs
	return a
}

func (p *parser) labeledStmtOrNil(label *Name) Stmt {
	if trace {
		defer p.trace("labeledStmt")()
	}
	s := new(LabeledStmt)
	s.pos = p.pos()
	s.Label = label
	p.want(_Colon)
	if p.tok == _Rbrace {
		e := new(EmptyStmt)
		e.pos = p.pos()
		s.Stmt = e
		return s
	}
	s.Stmt = p.stmtOrNil()
	if s.Stmt != nil {
		return s
	}
	p.syntax_error_at(s.pos, "missing statement after label")
	return nil
}

func (p *parser) blockStmt(context string) *BlockStmt {
	if trace {
		defer p.trace("blockStmt")()
	}
	s := new(BlockStmt)
	s.pos = p.pos()
	if !p.got(_Lbrace) {
		p.syntax_error("expecting { after " + context)
		p.advance(_Name, _Rbrace)
	}
	s.List = p.stmtList()
	s.Rbrace = p.pos()
	p.want(_Rbrace)
	return s
}

func (p *parser) declStmt(f func(*Group) Decl) *DeclStmt {
	if trace {
		defer p.trace("declStmt")()
	}
	s := new(DeclStmt)
	s.pos = p.pos()
	p.next()
	s.DeclList = p.appendGroup(nil, f)
	return s
}

func (p *parser) forStmt() Stmt {
	if trace {
		defer p.trace("forStmt")()
	}
	s := new(ForStmt)
	s.pos = p.pos()
	s.Init, s.Cond, s.Post = p.header(_For)
	s.Body = p.blockStmt("for clause")
	return s
}

func (p *parser) header(keyword token) (init SimpleStmt, cond Expr, post SimpleStmt) {
	p.want(keyword)
	if p.tok == _Lbrace {
		if keyword == _If {
			p.syntax_error("missing condition in if statement")
		}
		return
	}
	outer := p.xnest
	p.xnest = -1
	if p.tok != _Semi {
		if p.got(_Var) {
			p.syntax_error(fmt.Sprintf("var declaration not allowed in %s initializer", keyword.String()))
		}
		init = p.simpleStmt(nil, keyword == _For)
		if _, ok := init.(*RangeClause); ok {
			p.xnest = outer
			return
		}
	}
	var condStmt SimpleStmt
	var semi struct {
		pos src.Pos
		lit string
	}
	if p.tok == _Semi {
		semi.pos = p.pos()
		semi.lit = p.lit
		p.next()
		if keyword == _For {
			if p.tok != _Semi {
				if p.tok == _Lbrace {
					p.syntax_error("expecting for loop condition")
					goto done
				}
				condStmt = p.simpleStmt(nil, false)
			}
			p.want(_Semi)
			if p.tok != _Lbrace {
				post = p.simpleStmt(nil, false)
				if a, _ := post.(*AssignStmt); a != nil && a.Op == Def {
					p.syntax_error_at(a.Pos(), "cannot declare in post statement of for loop")
				}
			}
		} else if p.tok != _Lbrace {
			condStmt = p.simpleStmt(nil, false)
		}
	} else {
		condStmt = init
		init = nil
	}
done:
	switch s := condStmt.(type) {
	case nil:
		if keyword == _If && semi.pos.IsKnown() {
			if semi.lit != "semicolon" {
				p.syntax_error_at(semi.pos, fmt.Sprintf("unexpected %s, expecting { after if clause", semi.lit))
			} else {
				p.syntax_error_at(semi.pos, "missing condition in if statement")
			}
		}
	case *ExprStmt:
		cond = s.X
	default:
		p.syntax_error(fmt.Sprintf("%s used as value", String(s)))
	}
	p.xnest = outer
	return
}

func (p *parser) ifStmt() *IfStmt {
	if trace {
		defer p.trace("ifStmt")()
	}
	s := new(IfStmt)
	s.pos = p.pos()
	s.Init, s.Cond, _ = p.header(_If)
	s.Then = p.blockStmt("if clause")
	if p.got(_Else) {
		switch p.tok {
		case _If:
			s.Else = p.ifStmt()
		case _Lbrace:
			s.Else = p.blockStmt("")
		default:
			p.syntax_error("else must be followed by if or statement block")
			p.advance(_Name, _Rbrace)
		}
	}
	return s
}

func (p *parser) switchStmt() *SwitchStmt {
	if trace {
		defer p.trace("switchStmt")()
	}
	s := new(SwitchStmt)
	s.pos = p.pos()
	s.Init, s.Tag, _ = p.header(_Switch)
	if !p.got(_Lbrace) {
		p.syntax_error("missing { after switch clause")
		p.advance(_Case, _Default, _Rbrace)
	}
	for p.tok != _EOF && p.tok != _Rbrace {
		s.Body = append(s.Body, p.caseClause())
	}
	s.Rbrace = p.pos()
	p.want(_Rbrace)
	return s
}

func (p *parser) selectStmt() *SelectStmt {
	if trace {
		defer p.trace("selectStmt")()
	}
	s := new(SelectStmt)
	s.pos = p.pos()
	p.want(_Select)
	if !p.got(_Lbrace) {
		p.syntax_error("missing { after select clause")
		p.advance(_Case, _Default, _Rbrace)
	}
	for p.tok != _EOF && p.tok != _Rbrace {
		s.Body = append(s.Body, p.commClause())
	}
	s.Rbrace = p.pos()
	p.want(_Rbrace)
	return s
}

func (p *parser) caseClause() *CaseClause {
	if trace {
		defer p.trace("caseClause")()
	}
	c := new(CaseClause)
	c.pos = p.pos()
	switch p.tok {
	case _Case:
		p.next()
		c.Cases = p.exprList()
	case _Default:
		p.next()
	default:
		p.syntax_error("expecting case or default or }")
		p.advance(_Colon, _Case, _Default, _Rbrace)
	}
	c.Colon = p.pos()
	p.want(_Colon)
	c.Body = p.stmtList()
	return c
}

func (p *parser) commClause() *CommClause {
	if trace {
		defer p.trace("commClause")()
	}
	c := new(CommClause)
	c.pos = p.pos()
	switch p.tok {
	case _Case:
		p.next()
		c.Comm = p.simpleStmt(nil, false)
	case _Default:
		p.next()
	default:
		p.syntax_error("expecting case or default or }")
		p.advance(_Colon, _Case, _Default, _Rbrace)
	}
	c.Colon = p.pos()
	p.want(_Colon)
	c.Body = p.stmtList()
	return c
}

func (p *parser) stmtOrNil() Stmt {
	if trace {
		defer p.trace("stmt " + p.tok.String())()
	}
	if p.tok == _Name {
		lhs := p.exprList()
		if label, ok := lhs.(*Name); ok && p.tok == _Colon {
			return p.labeledStmtOrNil(label)
		}
		return p.simpleStmt(lhs, false)
	}
	switch p.tok {
	case _Lbrace:
		return p.blockStmt("")
	case _Var:
		return p.declStmt(p.varDecl)
	case _Const:
		return p.declStmt(p.constDecl)
	case _Type:
		return p.declStmt(p.typeDecl)
	case _Operator, _Star:
		switch p.op {
		case Add, Sub, Mul, And, Xor, Not:
			return p.simpleStmt(nil, false)
		}
	case _Literal, _Func, _Lparen, _Lbrack, _Struct, _Map, _Chan, _Interface, _Arrow:
		return p.simpleStmt(nil, false)
	case _For:
		return p.forStmt()
	case _Switch:
		return p.switchStmt()
	case _Select:
		return p.selectStmt()
	case _If:
		return p.ifStmt()
	case _Fallthrough:
		s := new(BranchStmt)
		s.pos = p.pos()
		p.next()
		s.Tok = _Fallthrough
		return s
	case _Break, _Continue:
		s := new(BranchStmt)
		s.pos = p.pos()
		s.Tok = p.tok
		p.next()
		if p.tok == _Name {
			s.Label = p.name()
		}
		return s
	case _Go, _Defer:
		return p.callStmt()
	case _Goto:
		s := new(BranchStmt)
		s.pos = p.pos()
		s.Tok = _Goto
		p.next()
		s.Label = p.name()
		return s
	case _Return:
		s := new(ReturnStmt)
		s.pos = p.pos()
		p.next()
		if p.tok != _Semi && p.tok != _Rbrace {
			s.Results = p.exprList()
		}
		return s
	case _Semi:
		s := new(EmptyStmt)
		s.pos = p.pos()
		return s
	}
	return nil
}

func (p *parser) stmtList() (l []Stmt) {
	if trace {
		defer p.trace("stmtList")()
	}
	for p.tok != _EOF && p.tok != _Rbrace && p.tok != _Case && p.tok != _Default {
		s := p.stmtOrNil()
		if s == nil {
			break
		}
		l = append(l, s)
		if p.tok == _Rparen || p.tok == _Rbrace {
			continue
		}
		if !p.got(_Semi) {
			p.syntax_error("at end of statement")
			p.advance(_Semi, _Rbrace)
		}
	}
	return
}

func (p *parser) call(fun Expr) *CallExpr {
	if trace {
		defer p.trace("call")()
	}
	c := new(CallExpr)
	c.pos = p.pos()
	c.Fun = fun
	p.want(_Lparen)
	p.xnest++
	for p.tok != _EOF && p.tok != _Rparen {
		c.ArgList = append(c.ArgList, p.expr())
		c.HasDots = p.got(_DotDotDot)
		if !p.ocomma(_Rparen) || c.HasDots {
			break
		}
	}
	p.xnest--
	p.want(_Rparen)
	return c
}

func (p *parser) newName(value string) *Name {
	n := new(Name)
	n.pos = p.pos()
	n.Value = value
	return n
}

func (p *parser) name() *Name {
	if p.tok == _Name {
		n := p.newName(p.lit)
		p.next()
		return n
	}
	n := p.newName("_")
	p.syntax_error("expecting name")
	p.advance()
	return n
}

func (p *parser) nameList(first *Name) []*Name {
	if trace {
		defer p.trace("nameList")()
	}
	if debug && first == nil {
		panic("first name not provided")
	}
	l := []*Name{first}
	for p.got(_Comma) {
		l = append(l, p.name())
	}
	return l
}

func (p *parser) qualifiedName(name *Name) Expr {
	if trace {
		defer p.trace("qualifiedName")()
	}
	switch {
	case name != nil:
	case p.tok == _Name:
		name = p.name()
	default:
		name = p.newName("_")
		p.syntax_error("expecting name")
		p.advance(_Dot, _Semi, _Rbrace)
	}
	return p.dotname(name)
}

func (p *parser) exprList() Expr {
	if trace {
		defer p.trace("exprList")()
	}
	x := p.expr()
	if p.got(_Comma) {
		list := []Expr{x, p.expr()}
		for p.got(_Comma) {
			list = append(list, p.expr())
		}
		t := new(ListExpr)
		t.pos = x.Pos()
		t.ElemList = list
		x = t
	}
	return x
}

func (p *parser) osemi(follow token) bool {
	switch p.tok {
	case _Semi:
		p.next()
		return true
	case _Rparen, _Rbrace:
		return true
	}
	p.syntax_error("expecting semicolon, newline, or " + tokstring(follow))
	p.advance(follow)
	return false
}

func (p *parser) ocomma(follow token) bool {
	switch p.tok {
	case _Comma:
		p.next()
		return true
	case _Rparen, _Rbrace:
		return true
	}
	p.syntax_error("expecting comma or " + tokstring(follow))
	p.advance(follow)
	return false
}

func unparen(x Expr) Expr {
	for {
		p, ok := x.(*ParenExpr)
		if !ok {
			break
		}
		x = p.X
	}
	return x
}
5 package
5 name => syntax
5 ;
7 import
7 (
8 literal
8 ;
9 literal
9 ;
10 literal
10 ;
11 literal
11 ;
12 literal
12 ;
13 )
13 ;
15 const
15 name => debug
15 =
15 name => false
15 ;
16 const
16 name => trace
16 =
16 name => false
16 ;
18 type
18 name => parser
18 struct
18 {
19 name => base
19 *
19 name => src
19 .
19 name => PosBase
19 ;
20 name => errh
20 name => ErrorHandler
20 ;
21 name => mode
21 name => Mode
21 ;
22 name => scanner
22 ;
24 name => first
24 name => error
24 ;
25 name => pragma
25 name => Pragma
25 ;
27 name => fnest
27 name => int
27 ;
28 name => xnest
28 name => int
28 ;
29 name => indent
29 [
29 ]
29 name => byte
29 ;
30 }
30 ;
32 func
32 (
32 name => p
32 *
32 name => parser
32 )
32 name => init
32 (
32 name => base
32 *
32 name => src
32 .
32 name => PosBase
32 ,
32 name => r
32 name => io
32 .
32 name => Reader
32 ,
32 name => errh
32 name => ErrorHandler
32 ,
32 name => pragh
32 name => PragmaHandler
32 ,
32 name => mode
32 name => Mode
32 )
32 {
33 name => p
33 .
33 name => base
33 =
33 name => base
33 ;
34 name => p
34 .
34 name => errh
34 =
34 name => errh
34 ;
35 name => p
35 .
35 name => mode
35 =
35 name => mode
35 ;
36 name => p
36 .
36 name => scanner
36 .
36 name => init
36 (
37 name => r
37 ,
43 func
43 (
43 name => line
43 ,
43 name => col
43 name => uint
43 ,
43 name => msg
43 name => string
43 )
43 {
44 name => p
44 .
44 name => error_at
44 (
44 name => p
44 .
44 name => pos_at
44 (
44 name => line
44 ,
44 name => col
44 )
44 ,
44 name => msg
44 )
44 ;
45 }
45 ,
46 func
46 (
46 name => line
46 ,
46 name => col
46 name => uint
46 ,
46 name => text
46 name => string
46 )
46 {
47 if
47 name => strings
47 .
47 name => HasPrefix
47 (
47 name => text
47 ,
47 literal
47 )
47 {
48 name => p
48 .
48 name => updateBase
48 (
48 name => line
48 ,
48 name => col
48 op => + 4
48 literal
48 ,
48 name => text
48 [
48 literal
48 :
48 ]
48 )
48 ;
49 return
49 ;
50 }
50 ;
51 if
51 name => pragh
51 op => != 3
51 name => nil
51 {
52 name => p
52 .
52 name => pragma
52 op=
52 name => pragh
52 (
52 name => p
52 .
52 name => pos_at
52 (
52 name => line
52 ,
52 name => col
52 )
52 ,
52 name => text
52 )
52 ;
53 }
53 ;
54 }
54 ,
55 )
55 ;
57 name => p
57 .
57 name => first
57 =
57 name => nil
57 ;
58 name => p
58 .
58 name => pragma
58 =
58 literal
58 ;
60 name => p
60 .
60 name => fnest
60 =
60 literal
60 ;
61 name => p
61 .
61 name => xnest
61 =
61 literal
61 ;
62 name => p
62 .
62 name => indent
62 =
62 name => nil
62 ;
63 }
63 ;
65 const
65 name => lineMax
65 =
65 literal
65 op => << 5
65 literal
65 op => - 4
65 literal
65 ;
67 func
67 (
67 name => p
67 *
67 name => parser
67 )
67 name => updateBase
67 (
67 name => line
67 ,
67 name => col
67 name => uint
67 ,
67 name => text
67 name => string
67 )
67 {
69 name => i
69 :=
69 name => strings
69 .
69 name => LastIndex
69 (
69 name => text
69 ,
69 literal
69 )
69 ;
70 if
70 name => i
70 op => < 3
70 literal
70 {
71 return
71 ;
72 }
72 ;
73 name => nstr
73 :=
73 name => text
73 [
73 name => i
73 op => + 4
73 literal
73 :
73 ]
73 ;
74 name => n
74 ,
74 name => err
74 :=
74 name => strconv
74 .
74 name => Atoi
74 (
74 name => nstr
74 )
74 ;
75 if
75 name => err
75 op => != 3
75 name => nil
75 op => || 1
75 name => n
75 op => <= 3
75 literal
75 op => || 1
75 name => n
75 op => > 3
75 name => lineMax
75 {
76 name => p
76 .
76 name => error_at
76 (
76 name => p
76 .
76 name => pos_at
76 (
76 name => line
76 ,
76 name => col
76 op => + 4
76 name => uint
76 (
76 name => i
76 op => + 4
76 literal
76 )
76 )
76 ,
76 literal
76 op => + 4
76 name => nstr
76 )
76 ;
77 return
77 ;
78 }
78 ;
79 name => p
79 .
79 name => base
79 =
79 name => src
79 .
79 name => NewLinePragmaBase
79 (
79 name => src
79 .
79 name => MakePos
79 (
79 name => p
79 .
79 name => base
79 .
79 name => Pos
79 (
79 )
79 .
79 name => Base
79 (
79 )
79 ,
79 name => line
79 ,
79 name => col
79 )
79 ,
79 name => text
79 [
79 :
79 name => i
79 ]
79 ,
79 name => uint
79 (
79 name => n
79 )
79 )
79 ;
80 }
80 ;
82 func
82 (
82 name => p
82 *
82 name => parser
82 )
82 name => got
82 (
82 name => tok
82 name => token
82 )
82 name => bool
82 {
83 if
83 name => p
83 .
83 name => tok
83 op => == 3
83 name => tok
83 {
84 name => p
84 .
84 name => next
84 (
84 )
84 ;
85 return
85 name => true
85 ;
86 }
86 ;
87 return
87 name => false
87 ;
88 }
88 ;
90 func
90 (
90 name => p
90 *
90 name => parser
90 )
90 name => want
90 (
90 name => tok
90 name => token
90 )
90 {
91 if
91 op => ! 0
91 name => p
91 .
91 name => got
91 (
91 name => tok
91 )
91 {
92 name => p
92 .
92 name => syntax_error
92 (
92 literal
92 op => + 4
92 name => tok
92 .
92 name => String
92 (
92 )
92 )
92 ;
93 name => p
93 .
93 name => advance
93 (
93 )
93 ;
94 }
94 ;
95 }
95 ;
101 func
101 (
101 name => p
101 *
101 name => parser
101 )
101 name => pos_at
101 (
101 name => line
101 ,
101 name => col
101 name => uint
101 )
101 name => src
101 .
101 name => Pos
101 {
102 return
102 name => src
102 .
102 name => MakePos
102 (
102 name => p
102 .
102 name => base
102 ,
102 name => line
102 ,
102 name => col
102 )
102 ;
103 }
103 ;
106 func
106 (
106 name => p
106 *
106 name => parser
106 )
106 name => error_at
106 (
106 name => pos
106 name => src
106 .
106 name => Pos
106 ,
106 name => msg
106 name => string
106 )
106 {
107 name => err
107 :=
107 name => Error
107 {
107 name => pos
107 ,
107 name => msg
107 }
107 ;
108 if
108 name => p
108 .
108 name => first
108 op => == 3
108 name => nil
108 {
109 name => p
109 .
109 name => first
109 =
109 name => err
109 ;
110 }
110 ;
111 if
111 name => p
111 .
111 name => errh
111 op => == 3
111 name => nil
111 {
112 name => panic
112 (
112 name => p
112 .
112 name => first
112 )
112 ;
113 }
113 ;
114 name => p
114 .
114 name => errh
114 (
114 name => err
114 )
114 ;
115 }
115 ;
118 func
118 (
118 name => p
118 *
118 name => parser
118 )
118 name => syntax_error_at
118 (
118 name => pos
118 name => src
118 .
118 name => Pos
118 ,
118 name => msg
118 name => string
118 )
118 {
119 if
119 name => trace
119 {
120 defer
120 name => p
120 .
120 name => trace
120 (
120 literal
120 op => + 4
120 name => msg
120 op => + 4
120 literal
120 )
120 (
120 )
120 ;
121 }
121 ;
123 if
123 name => p
123 .
123 name => tok
123 op => == 3
123 name => _EOF
123 op => && 2
123 name => p
123 .
123 name => first
123 op => != 3
123 name => nil
123 {
124 return
124 ;
125 }
125 ;
128 switch
128 {
129 case
129 name => msg
129 op => == 3
129 literal
129 :
131 case
131 name => strings
131 .
131 name => HasPrefix
131 (
131 name => msg
131 ,
131 literal
131 )
131 ,
131 name => strings
131 .
131 name => HasPrefix
131 (
131 name => msg
131 ,
131 literal
131 )
131 ,
131 name => strings
131 .
131 name => HasPrefix
131 (
131 name => msg
131 ,
131 literal
131 )
131 :
132 name => msg
132 =
132 literal
132 op => + 4
132 name => msg
132 ;
133 case
133 name => strings
133 .
133 name => HasPrefix
133 (
133 name => msg
133 ,
133 literal
133 )
133 :
134 name => msg
134 =
134 literal
134 op => + 4
134 name => msg
134 ;
135 default
135 :
137 name => p
137 .
137 name => error_at
137 (
137 name => pos
137 ,
137 literal
137 op => + 4
137 name => msg
137 )
137 ;
138 return
138 ;
139 }
139 ;
142 var
142 name => tok
142 name => string
142 ;
143 switch
143 name => p
143 .
143 name => tok
143 {
144 case
144 name => _Name
144 ,
144 name => _Semi
144 :
145 name => tok
145 =
145 name => p
145 .
145 name => lit
145 ;
146 case
146 name => _Literal
146 :
147 name => tok
147 =
147 literal
147 op => + 4
147 name => p
147 .
147 name => lit
147 ;
148 case
148 name => _Operator
148 :
149 name => tok
149 =
149 name => p
149 .
149 name => op
149 .
149 name => String
149 (
149 )
149 ;
150 case
150 name => _AssignOp
150 :
151 name => tok
151 =
151 name => p
151 .
151 name => op
151 .
151 name => String
151 (
151 )
151 op => + 4
151 literal
151 ;
152 case
152 name => _IncOp
152 :
153 name => tok
153 =
153 name => p
153 .
153 name => op
153 .
153 name => String
153 (
153 )
153 ;
154 name => tok
154 op=
154 name => tok
154 ;
155 default
155 :
156 name => tok
156 =
156 name => tokstring
156 (
156 name => p
156 .
156 name => tok
156 )
156 ;
157 }
157 ;
159 name => p
159 .
159 name => error_at
159 (
159 name => pos
159 ,
159 literal
159 op => + 4
159 name => tok
159 op => + 4
159 name => msg
159 )
159 ;
160 }
160 ;
163 func
163 (
163 name => p
163 *
163 name => parser
163 )
163 name => pos
163 (
163 )
163 name => src
163 .
163 name => Pos
163 {
163 return
163 name => p
163 .
163 name => pos_at
163 (
163 name => p
163 .
163 name => line
163 ,
163 name => p
163 .
163 name => col
163 )
163 }
163 ;
164 func
164 (
164 name => p
164 *
164 name => parser
164 )
164 name => error
164 (
164 name => msg
164 name => string
164 )
164 {
164 name => p
164 .
164 name => error_at
164 (
164 name => p
164 .
164 name => pos
164 (
164 )
164 ,
164 name => msg
164 )
164 }
164 ;
165 func
165 (
165 name => p
165 *
165 name => parser
165 )
165 name => syntax_error
165 (
165 name => msg
165 name => string
165 )
165 {
165 name => p
165 .
165 name => syntax_error_at
165 (
165 name => p
165 .
165 name => pos
165 (
165 )
165 ,
165 name => msg
165 )
165 }
165 ;
170 const
170 name => stopset
170 name => uint64
170 =
170 literal
170 op => << 5
170 name => _Break
170 op => | 4
171 literal
171 op => << 5
171 name => _Const
171 op => | 4
172 literal
172 op => << 5
172 name => _Continue
172 op => | 4
173 literal
173 op => << 5
173 name => _Defer
173 op => | 4
174 literal
174 op => << 5
174 name => _Fallthrough
174 op => | 4
175 literal
175 op => << 5
175 name => _For
175 op => | 4
176 literal
176 op => << 5
176 name => _Func
176 op => | 4
177 literal
177 op => << 5
177 name => _Go
177 op => | 4
178 literal
178 op => << 5
178 name => _Goto
178 op => | 4
179 literal
179 op => << 5
179 name => _If
179 op => | 4
180 literal
180 op => << 5
180 name => _Return
180 op => | 4
181 literal
181 op => << 5
181 name => _Select
181 op => | 4
182 literal
182 op => << 5
182 name => _Switch
182 op => | 4
183 literal
183 op => << 5
183 name => _Type
183 op => | 4
184 literal
184 op => << 5
184 name => _Var
184 ;
190 func
190 (
190 name => p
190 *
190 name => parser
190 )
190 name => advance
190 (
190 name => followlist
190 ...
190 name => token
190 )
190 {
191 if
191 name => len
191 (
191 name => followlist
191 )
191 op => == 3
191 literal
191 {
192 name => p
192 .
192 name => next
192 (
192 )
192 ;
193 return
193 ;
194 }
194 ;
198 var
198 name => followset
198 name => uint64
198 =
198 literal
198 op => << 5
198 name => _EOF
198 ;
199 for
199 name => _
199 ,
199 name => tok
199 :=
199 range
199 name => followlist
199 {
200 name => followset
200 op=
200 literal
200 op => << 5
200 name => tok
200 ;
201 }
201 ;
203 for
203 op => ! 0
203 (
203 name => contains
203 (
203 name => followset
203 ,
203 name => p
203 .
203 name => tok
203 )
203 op => || 1
203 name => p
203 .
203 name => fnest
203 op => > 3
203 literal
203 op => && 2
203 name => contains
203 (
203 name => stopset
203 ,
203 name => p
203 .
203 name => tok
203 )
203 )
203 {
204 name => p
204 .
204 name => next
204 (
204 )
204 ;
205 }
205 ;
206 }
206 ;
208 func
208 name => tokstring
208 (
208 name => tok
208 name => token
208 )
208 name => string
208 {
209 switch
209 name => tok
209 {
210 case
210 name => _EOF
210 :
211 return
211 literal
211 ;
212 case
212 name => _Comma
212 :
213 return
213 literal
213 ;
214 case
214 name => _Semi
214 :
215 return
215 literal
215 ;
216 }
216 ;
217 return
217 name => tok
217 .
217 name => String
217 (
217 )
217 ;
218 }
218 ;
221 func
221 (
221 name => p
221 *
221 name => parser
221 )
221 name => trace
221 (
221 name => msg
221 name => string
221 )
221 func
221 (
221 )
221 {
222 name => fmt
222 .
222 name => Printf
222 (
222 literal
222 ,
222 name => p
222 .
222 name => line
222 ,
222 name => p
222 .
222 name => indent
222 ,
222 name => msg
222 )
222 ;
223 const
223 name => tab
223 =
223 literal
223 ;
224 name => p
224 .
224 name => indent
224 =
224 name => append
224 (
224 name => p
224 .
224 name => indent
224 ,
224 name => tab
224 ...
224 )
224 ;
225 return
225 func
225 (
225 )
225 {
226 name => p
226 .
226 name => indent
226 =
226 name => p
226 .
226 name => indent
226 [
226 :
226 name => len
226 (
226 name => p
226 .
226 name => indent
226 )
226 op => - 4
226 name => len
226 (
226 name => tab
226 )
226 ]
226 ;
227 if
227 name => x
227 :=
227 name => recover
227 (
227 )
227 ;
227 name => x
227 op => != 3
227 name => nil
227 {
228 name => panic
228 (
228 name => x
228 )
228 ;
229 }
229 ;
230 name => fmt
230 .
230 name => Printf
230 (
230 literal
230 ,
230 name => p
230 .
230 name => line
230 ,
230 name => p
230 .
230 name => indent
230 )
230 ;
231 }
231 ;
232 }
232 ;
245 func
245 (
245 name => p
245 *
245 name => parser
245 )
245 name => fileOrNil
245 (
245 )
245 *
245 name => File
245 {
246 if
246 name => trace
246 {
247 defer
247 name => p
247 .
247 name => trace
247 (
247 literal
247 )
247 (
247 )
247 ;
248 }
248 ;
250 name => f
250 :=
250 name => new
250 (
250 name => File
250 )
250 ;
251 name => f
251 .
251 name => pos
251 =
251 name => p
251 .
251 name => pos
251 (
251 )
251 ;
254 if
254 op => ! 0
254 name => p
254 .
254 name => got
254 (
254 name => _Package
254 )
254 {
255 name => p
255 .
255 name => syntax_error
255 (
255 literal
255 )
255 ;
256 return
256 name => nil
256 ;
257 }
257 ;
258 name => f
258 .
258 name => PkgName
258 =
258 name => p
258 .
258 name => name
258 (
258 )
258 ;
259 name => p
259 .
259 name => want
259 (
259 name => _Semi
259 )
259 ;
262 if
262 name => p
262 .
262 name => first
262 op => != 3
262 name => nil
262 {
263 return
263 name => nil
263 ;
264 }
264 ;
267 for
267 name => p
267 .
267 name => got
267 (
267 name => _Import
267 )
267 {
268 name => f
268 .
268 name => DeclList
268 =
268 name => p
268 .
268 name => appendGroup
268 (
268 name => f
268 .
268 name => DeclList
268 ,
268 name => p
268 .
268 name => importDecl
268 )
268 ;
269 name => p
269 .
269 name => want
269 (
269 name => _Semi
269 )
269 ;
270 }
270 ;
273 for
273 name => p
273 .
273 name => tok
273 op => != 3
273 name => _EOF
273 {
274 switch
274 name => p
274 .
274 name => tok
274 {
275 case
275 name => _Const
275 :
276 name => p
276 .
276 name => next
276 (
276 )
276 ;
277 name => f
277 .
277 name => DeclList
277 =
277 name => p
277 .
277 name => appendGroup
277 (
277 name => f
277 .
277 name => DeclList
277 ,
277 name => p
277 .
277 name => constDecl
277 )
277 ;
279 case
279 name => _Type
279 :
280 name => p
280 .
280 name => next
280 (
280 )
280 ;
281 name => f
281 .
281 name => DeclList
281 =
281 name => p
281 .
281 name => appendGroup
281 (
281 name => f
281 .
281 name => DeclList
281 ,
281 name => p
281 .
281 name => typeDecl
281 )
281 ;
283 case
283 name => _Var
283 :
284 name => p
284 .
284 name => next
284 (
284 )
284 ;
285 name => f
285 .
285 name => DeclList
285 =
285 name => p
285 .
285 name => appendGroup
285 (
285 name => f
285 .
285 name => DeclList
285 ,
285 name => p
285 .
285 name => varDecl
285 )
285 ;
287 case
287 name => _Func
287 :
288 name => p
288 .
288 name => next
288 (
288 )
288 ;
289 if
289 name => d
289 :=
289 name => p
289 .
289 name => funcDeclOrNil
289 (
289 )
289 ;
289 name => d
289 op => != 3
289 name => nil
289 {
290 name => f
290 .
290 name => DeclList
290 =
290 name => append
290 (
290 name => f
290 .
290 name => DeclList
290 ,
290 name => d
290 )
290 ;
291 }
291 ;
293 default
293 :
294 if
294 name => p
294 .
294 name => tok
294 op => == 3
294 name => _Lbrace
294 op => && 2
294 name => len
294 (
294 name => f
294 .
294 name => DeclList
294 )
294 op => > 3
294 literal
294 op => && 2
294 name => isEmptyFuncDecl
294 (
294 name => f
294 .
294 name => DeclList
294 [
294 name => len
294 (
294 name => f
294 .
294 name => DeclList
294 )
294 op => - 4
294 literal
294 ]
294 )
294 {
296 name => p
296 .
296 name => syntax_error
296 (
296 literal
296 )
296 ;
297 }
297 else
297 {
298 name => p
298 .
298 name => syntax_error
298 (
298 literal
298 )
298 ;
299 }
299 ;
300 name => p
300 .
300 name => advance
300 (
300 name => _Const
300 ,
300 name => _Type
300 ,
300 name => _Var
300 ,
300 name => _Func
300 )
300 ;
301 continue
301 ;
302 }
302 ;
306 name => p
306 .
306 name => pragma
306 =
306 literal
306 ;
308 if
308 name => p
308 .
308 name => tok
308 op => != 3
308 name => _EOF
308 op => && 2
308 op => ! 0
308 name => p
308 .
308 name => got
308 (
308 name => _Semi
308 )
308 {
309 name => p
309 .
309 name => syntax_error
309 (
309 literal
309 )
309 ;
310 name => p
310 .
310 name => advance
310 (
310 name => _Const
310 ,
310 name => _Type
310 ,
310 name => _Var
310 ,
310 name => _Func
310 )
310 ;
311 }
311 ;
312 }
312 ;
315 name => f
315 .
315 name => Lines
315 =
315 name => p
315 .
315 name => source
315 .
315 name => line
315 ;
317 return
317 name => f
317 ;
318 }
318 ;
320 func
320 name => isEmptyFuncDecl
320 (
320 name => dcl
320 name => Decl
320 )
320 name => bool
320 {
321 name => f
321 ,
321 name => ok
321 :=
321 name => dcl
321 .
321 (
321 *
321 name => FuncDecl
321 )
321 ;
322 return
322 name => ok
322 op => && 2
322 name => f
322 .
322 name => Body
322 op => == 3
322 name => nil
322 ;
323 }
323 ;
329 func
329 (
329 name => p
329 *
329 name => parser
329 )
329 name => appendGroup
329 (
329 name => list
329 [
329 ]
329 name => Decl
329 ,
329 name => f
329 func
329 (
329 *
329 name => Group
329 )
329 name => Decl
329 )
329 [
329 ]
329 name => Decl
329 {
330 if
330 name => p
330 .
330 name => got
330 (
330 name => _Lparen
330 )
330 {
331 name => g
331 :=
331 name => new
331 (
331 name => Group
331 )
331 ;
332 for
332 name => p
332 .
332 name => tok
332 op => != 3
332 name => _EOF
332 op => && 2
332 name => p
332 .
332 name => tok
332 op => != 3
332 name => _Rparen
332 {
333 name => list
333 =
333 name => append
333 (
333 name => list
333 ,
333 name => f
333 (
333 name => g
333 )
333 )
333 ;
334 if
334 op => ! 0
334 name => p
334 .
334 name => osemi
334 (
334 name => _Rparen
334 )
334 {
335 break
335 ;
336 }
336 ;
337 }
337 ;
338 name => p
338 .
338 name => want
338 (
338 name => _Rparen
338 )
338 ;
339 }
339 else
339 {
340 name => list
340 =
340 name => append
340 (
340 name => list
340 ,
340 name => f
340 (
340 name => nil
340 )
340 )
340 ;
341 }
341 ;
343 if
343 name => debug
343 {
344 for
344 name => _
344 ,
344 name => d
344 :=
344 range
344 name => list
344 {
345 if
345 name => d
345 op => == 3
345 name => nil
345 {
346 name => panic
346 (
346 literal
346 )
346 ;
347 }
347 ;
348 }
348 ;
349 }
349 ;
351 return
351 name => list
351 ;
352 }
352 ;
356 func
356 (
356 name => p
356 *
356 name => parser
356 )
356 name => importDecl
356 (
356 name => group
356 *
356 name => Group
356 )
356 name => Decl
356 {
357 if
357 name => trace
357 {
358 defer
358 name => p
358 .
358 name => trace
358 (
358 literal
358 )
358 (
358 )
358 ;
359 }
359 ;
361 name => d
361 :=
361 name => new
361 (
361 name => ImportDecl
361 )
361 ;
362 name => d
362 .
362 name => pos
362 =
362 name => p
362 .
362 name => pos
362 (
362 )
362 ;
364 switch
364 name => p
364 .
364 name => tok
364 {
365 case
365 name => _Name
365 :
366 name => d
366 .
366 name => LocalPkgName
366 =
366 name => p
366 .
366 name => name
366 (
366 )
366 ;
367 case
367 name => _Dot
367 :
368 name => d
368 .
368 name => LocalPkgName
368 =
368 name => p
368 .
368 name => newName
368 (
368 literal
368 )
368 ;
369 name => p
369 .
369 name => next
369 (
369 )
369 ;
370 }
370 ;
371 name => d
371 .
371 name => Path
371 =
371 name => p
371 .
371 name => oliteral
371 (
371 )
371 ;
372 if
372 name => d
372 .
372 name => Path
372 op => == 3
372 name => nil
372 {
373 name => p
373 .
373 name => syntax_error
373 (
373 literal
373 )
373 ;
374 name => p
374 .
374 name => advance
374 (
374 name => _Semi
374 ,
374 name => _Rparen
374 )
374 ;
375 return
375 name => nil
375 ;
376 }
376 ;
377 name => d
377 .
377 name => Group
377 =
377 name => group
377 ;
379 return
379 name => d
379 ;
380 }
380 ;
383 func
383 (
383 name => p
383 *
383 name => parser
383 )
383 name => constDecl
383 (
383 name => group
383 *
383 name => Group
383 )
383 name => Decl
383 {
384 if
384 name => trace
384 {
385 defer
385 name => p
385 .
385 name => trace
385 (
385 literal
385 )
385 (
385 )
385 ;
386 }
386 ;
388 name => d
388 :=
388 name => new
388 (
388 name => ConstDecl
388 )
388 ;
389 name => d
389 .
389 name => pos
389 =
389 name => p
389 .
389 name => pos
389 (
389 )
389 ;
391 name => d
391 .
391 name => NameList
391 =
391 name => p
391 .
391 name => nameList
391 (
391 name => p
391 .
391 name => name
391 (
391 )
391 )
391 ;
392 if
392 name => p
392 .
392 name => tok
392 op => != 3
392 name => _EOF
392 op => && 2
392 name => p
392 .
392 name => tok
392 op => != 3
392 name => _Semi
392 op => && 2
392 name => p
392 .
392 name => tok
392 op => != 3
392 name => _Rparen
392 {
393 name => d
393 .
393 name => Type
393 =
393 name => p
393 .
393 name => typeOrNil
393 (
393 )
393 ;
394 if
394 name => p
394 .
394 name => got
394 (
394 name => _Assign
394 )
394 {
395 name => d
395 .
395 name => Values
395 =
395 name => p
395 .
395 name => exprList
395 (
395 )
395 ;
396 }
396 ;
397 }
397 ;
398 name => d
398 .
398 name => Group
398 =
398 name => group
398 ;
400 return
400 name => d
400 ;
401 }
401 ;
404 func
404 (
404 name => p
404 *
404 name => parser
404 )
404 name => typeDecl
404 (
404 name => group
404 *
404 name => Group
404 )
404 name => Decl
404 {
405 if
405 name => trace
405 {
406 defer
406 name => p
406 .
406 name => trace
406 (
406 literal
406 )
406 (
406 )
406 ;
407 }
407 ;
409 name => d
409 :=
409 name => new
409 (
409 name => TypeDecl
409 )
409 ;
410 name => d
410 .
410 name => pos
410 =
410 name => p
410 .
410 name => pos
410 (
410 )
410 ;
412 name => d
412 .
412 name => Name
412 =
412 name => p
412 .
412 name => name
412 (
412 )
412 ;
413 name => d
413 .
413 name => Alias
413 =
413 name => p
413 .
413 name => got
413 (
413 name => _Assign
413 )
413 ;
414 name => d
414 .
414 name => Type
414 =
414 name => p
414 .
414 name => typeOrNil
414 (
414 )
414 ;
415 if
415 name => d
415 .
415 name => Type
415 op => == 3
415 name => nil
415 {
416 name => d
416 .
416 name => Type
416 =
416 name => p
416 .
416 name => bad
416 (
416 )
416 ;
417 name => p
417 .
417 name => syntax_error
417 (
417 literal
417 )
417 ;
418 name => p
418 .
418 name => advance
418 (
418 name => _Semi
418 ,
418 name => _Rparen
418 )
418 ;
419 }
419 ;
420 name => d
420 .
420 name => Group
420 =
420 name => group
420 ;
421 name => d
421 .
421 name => Pragma
421 =
421 name => p
421 .
421 name => pragma
421 ;
423 return
423 name => d
423 ;
424 }
424 ;
427 func
427 (
427 name => p
427 *
427 name => parser
427 )
427 name => varDecl
427 (
427 name => group
427 *
427 name => Group
427 )
427 name => Decl
427 {
428 if
428 name => trace
428 {
429 defer
429 name => p
429 .
429 name => trace
429 (
429 literal
429 )
429 (
429 )
429 ;
430 }
430 ;
432 name => d
432 :=
432 name => new
432 (
432 name => VarDecl
432 )
432 ;
433 name => d
433 .
433 name => pos
433 =
433 name => p
433 .
433 name => pos
433 (
433 )
433 ;
435 name => d
435 .
435 name => NameList
435 =
435 name => p
435 .
435 name => nameList
435 (
435 name => p
435 .
435 name => name
435 (
435 )
435 )
435 ;
436 if
436 name => p
436 .
436 name => got
436 (
436 name => _Assign
436 )
436 {
437 name => d
437 .
437 name => Values
437 =
437 name => p
437 .
437 name => exprList
437 (
437 )
437 ;
438 }
438 else
438 {
439 name => d
439 .
439 name => Type
439 =
439 name => p
439 .
439 name => type_
439 (
439 )
439 ;
440 if
440 name => p
440 .
440 name => got
440 (
440 name => _Assign
440 )
440 {
441 name => d
441 .
441 name => Values
441 =
441 name => p
441 .
441 name => exprList
441 (
441 )
441 ;
442 }
442 ;
443 }
443 ;
444 name => d
444 .
444 name => Group
444 =
444 name => group
444 ;
446 return
446 name => d
446 ;
447 }
447 ;
454 func
454 (
454 name => p
454 *
454 name => parser
454 )
454 name => funcDeclOrNil
454 (
454 )
454 *
454 name => FuncDecl
454 {
455 if
455 name => trace
455 {
456 defer
456 name => p
456 .
456 name => trace
456 (
456 literal
456 )
456 (
456 )
456 ;
457 }
457 ;
459 name => f
459 :=
459 name => new
459 (
459 name => FuncDecl
459 )
459 ;
460 name => f
460 .
460 name => pos
460 =
460 name => p
460 .
460 name => pos
460 (
460 )
460 ;
462 if
462 name => p
462 .
462 name => tok
462 op => == 3
462 name => _Lparen
462 {
463 name => rcvr
463 :=
463 name => p
463 .
463 name => paramList
463 (
463 )
463 ;
464 switch
464 name => len
464 (
464 name => rcvr
464 )
464 {
465 case
465 literal
465 :
466 name => p
466 .
466 name => error
466 (
466 literal
466 )
466 ;
467 default
467 :
468 name => p
468 .
468 name => error
468 (
468 literal
468 )
468 ;
469 fallthrough
469 ;
470 case
470 literal
470 :
471 name => f
471 .
471 name => Recv
471 =
471 name => rcvr
471 [
471 literal
471 ]
471 ;
472 }
472 ;
473 }
473 ;
475 if
475 name => p
475 .
475 name => tok
475 op => != 3
475 name => _Name
475 {
476 name => p
476 .
476 name => syntax_error
476 (
476 literal
476 )
476 ;
477 name => p
477 .
477 name => advance
477 (
477 name => _Lbrace
477 ,
477 name => _Semi
477 )
477 ;
478 return
478 name => nil
478 ;
479 }
479 ;
495 name => f
495 .
495 name => Name
495 =
495 name => p
495 .
495 name => name
495 (
495 )
495 ;
496 name => f
496 .
496 name => Type
496 =
496 name => p
496 .
496 name => funcType
496 (
496 )
496 ;
497 if
497 name => p
497 .
497 name => tok
497 op => == 3
497 name => _Lbrace
497 {
498 name => f
498 .
498 name => Body
498 =
498 name => p
498 .
498 name => blockStmt
498 (
498 literal
498 )
498 ;
499 if
499 name => p
499 .
499 name => mode
499 op => & 5
499 name => CheckBranches
499 op => != 3
499 literal
499 {
500 name => checkBranches
500 (
500 name => f
500 .
500 name => Body
500 ,
500 name => p
500 .
500 name => errh
500 )
500 ;
501 }
501 ;
502 }
502 ;
504 name => f
504 .
504 name => Pragma
504 =
504 name => p
504 .
504 name => pragma
504 ;
511 return
511 name => f
511 ;
512 }
512 ;
517 func
517 (
517 name => p
517 *
517 name => parser
517 )
517 name => expr
517 (
517 )
517 name => Expr
517 {
518 if
518 name => trace
518 {
519 defer
519 name => p
519 .
519 name => trace
519 (
519 literal
519 )
519 (
519 )
519 ;
520 }
520 ;
522 return
522 name => p
522 .
522 name => binaryExpr
522 (
522 literal
522 )
522 ;
523 }
523 ;
526 func
526 (
526 name => p
526 *
526 name => parser
526 )
526 name => binaryExpr
526 (
526 name => prec
526 name => int
526 )
526 name => Expr
526 {
529 name => x
529 :=
529 name => p
529 .
529 name => unaryExpr
529 (
529 )
529 ;
530 for
530 (
530 name => p
530 .
530 name => tok
530 op => == 3
530 name => _Operator
530 op => || 1
530 name => p
530 .
530 name => tok
530 op => == 3
530 name => _Star
530 )
530 op => && 2
530 name => p
530 .
530 name => prec
530 op => > 3
530 name => prec
530 {
531 name => t
531 :=
531 name => new
531 (
531 name => Operation
531 )
531 ;
532 name => t
532 .
532 name => pos
532 =
532 name => p
532 .
532 name => pos
532 (
532 )
532 ;
533 name => t
533 .
533 name => Op
533 =
533 name => p
533 .
533 name => op
533 ;
534 name => t
534 .
534 name => X
534 =
534 name => x
534 ;
535 name => tprec
535 :=
535 name => p
535 .
535 name => prec
535 ;
536 name => p
536 .
536 name => next
536 (
536 )
536 ;
537 name => t
537 .
537 name => Y
537 =
537 name => p
537 .
537 name => binaryExpr
537 (
537 name => tprec
537 )
537 ;
538 name => x
538 =
538 name => t
538 ;
539 }
539 ;
540 return
540 name => x
540 ;
541 }
541 ;
544 func
544 (
544 name => p
544 *
544 name => parser
544 )
544 name => unaryExpr
544 (
544 )
544 name => Expr
544 {
545 if
545 name => trace
545 {
546 defer
546 name => p
546 .
546 name => trace
546 (
546 literal
546 )
546 (
546 )
546 ;
547 }
547 ;
549 switch
549 name => p
549 .
549 name => tok
549 {
550 case
550 name => _Operator
550 ,
550 name => _Star
550 :
551 switch
551 name => p
551 .
551 name => op
551 {
552 case
552 name => Mul
552 ,
552 name => Add
552 ,
552 name => Sub
552 ,
552 name => Not
552 ,
552 name => Xor
552 :
553 name => x
553 :=
553 name => new
553 (
553 name => Operation
553 )
553 ;
554 name => x
554 .
554 name => pos
554 =
554 name => p
554 .
554 name => pos
554 (
554 )
554 ;
555 name => x
555 .
555 name => Op
555 =
555 name => p
555 .
555 name => op
555 ;
556 name => p
556 .
556 name => next
556 (
556 )
556 ;
557 name => x
557 .
557 name => X
557 =
557 name => p
557 .
557 name => unaryExpr
557 (
557 )
557 ;
558 return
558 name => x
558 ;
560 case
560 name => And
560 :
561 name => x
561 :=
561 name => new
561 (
561 name => Operation
561 )
561 ;
562 name => x
562 .
562 name => pos
562 =
562 name => p
562 .
562 name => pos
562 (
562 )
562 ;
563 name => x
563 .
563 name => Op
563 =
563 name => And
563 ;
564 name => p
564 .
564 name => next
564 (
564 )
564 ;
567 name => x
567 .
567 name => X
567 =
567 name => unparen
567 (
567 name => p
567 .
567 name => unaryExpr
567 (
567 )
567 )
567 ;
568 return
568 name => x
568 ;
569 }
569 ;
571 case
571 name => _Arrow
571 :
573 name => pos
573 :=
573 name => p
573 .
573 name => pos
573 (
573 )
573 ;
574 name => p
574 .
574 name => next
574 (
574 )
574 ;
580 name => x
580 :=
580 name => p
580 .
580 name => unaryExpr
580 (
580 )
580 ;
593 if
593 name => _
593 ,
593 name => ok
593 :=
593 name => x
593 .
593 (
593 *
593 name => ChanType
593 )
593 ;
593 name => ok
593 {
595 name => dir
595 :=
595 name => SendOnly
595 ;
596 name => t
596 :=
596 name => x
596 ;
597 for
597 name => dir
597 op => == 3
597 name => SendOnly
597 {
598 name => c
598 ,
598 name => ok
598 :=
598 name => t
598 .
598 (
598 *
598 name => ChanType
598 )
598 ;
599 if
599 op => ! 0
599 name => ok
599 {
600 break
600 ;
601 }
601 ;
602 name => dir
602 =
602 name => c
602 .
602 name => Dir
602 ;
603 if
603 name => dir
603 op => == 3
603 name => RecvOnly
603 {
606 name => p
606 .
606 name => syntax_error
606 (
606 literal
606 )
606 ;
608 }
608 ;
609 name => c
609 .
609 name => Dir
609 =
609 name => RecvOnly
609 ;
610 name => t
610 =
610 name => c
610 .
610 name => Elem
610 ;
611 }
611 ;
612 if
612 name => dir
612 op => == 3
612 name => SendOnly
612 {
615 name => p
615 .
615 name => syntax_error
615 (
615 name => fmt
615 .
615 name => Sprintf
615 (
615 literal
615 ,
615 name => String
615 (
615 name => t
615 )
615 )
615 )
615 ;
617 }
617 ;
618 return
618 name => x
618 ;
619 }
619 ;
622 name => o
622 :=
622 name => new
622 (
622 name => Operation
622 )
622 ;
623 name => o
623 .
623 name => pos
623 =
623 name => pos
623 ;
624 name => o
624 .
624 name => Op
624 =
624 name => Recv
624 ;
625 name => o
625 .
625 name => X
625 =
625 name => x
625 ;
626 return
626 name => o
626 ;
627 }
627 ;
632 return
632 name => p
632 .
632 name => pexpr
632 (
632 name => true
632 )
632 ;
633 }
633 ;
636 func
636 (
636 name => p
636 *
636 name => parser
636 )
636 name => callStmt
636 (
636 )
636 *
636 name => CallStmt
636 {
637 if
637 name => trace
637 {
638 defer
638 name => p
638 .
638 name => trace
638 (
638 literal
638 )
638 (
638 )
638 ;
639 }
639 ;
641 name => s
641 :=
641 name => new
641 (
641 name => CallStmt
641 )
641 ;
642 name => s
642 .
642 name => pos
642 =
642 name => p
642 .
642 name => pos
642 (
642 )
642 ;
643 name => s
643 .
643 name => Tok
643 =
643 name => p
643 .
643 name => tok
643 ;
644 name => p
644 .
644 name => next
644 (
644 )
644 ;
646 name => x
646 :=
646 name => p
646 .
646 name => pexpr
646 (
646 name => p
646 .
646 name => tok
646 op => == 3
646 name => _Lparen
646 )
646 ;
647 if
647 name => t
647 :=
647 name => unparen
647 (
647 name => x
647 )
647 ;
647 name => t
647 op => != 3
647 name => x
647 {
648 name => p
648 .
648 name => error
648 (
648 name => fmt
648 .
648 name => Sprintf
648 (
648 literal
648 ,
648 name => s
648 .
648 name => Tok
648 )
648 )
648 ;
650 name => x
650 =
650 name => t
650 ;
651 }
651 ;
653 name => cx
653 ,
653 name => ok
653 :=
653 name => x
653 .
653 (
653 *
653 name => CallExpr
653 )
653 ;
654 if
654 op => ! 0
654 name => ok
654 {
655 name => p
655 .
655 name => error
655 (
655 name => fmt
655 .
655 name => Sprintf
655 (
655 literal
655 ,
655 name => s
655 .
655 name => Tok
655 )
655 )
655 ;
657 name => cx
657 =
657 name => new
657 (
657 name => CallExpr
657 )
657 ;
658 name => cx
658 .
658 name => pos
658 =
658 name => x
658 .
658 name => Pos
658 (
658 )
658 ;
659 name => cx
659 .
659 name => Fun
659 =
659 name => p
659 .
659 name => bad
659 (
659 )
659 ;
660 }
660 ;
662 name => s
662 .
662 name => Call
662 =
662 name => cx
662 ;
663 return
663 name => s
663 ;
664 }
664 ;
670 func
670 (
670 name => p
670 *
670 name => parser
670 )
670 name => operand
670 (
670 name => keep_parens
670 name => bool
670 )
670 name => Expr
670 {
671 if
671 name => trace
671 {
672 defer
672 name => p
672 .
672 name => trace
672 (
672 literal
672 op => + 4
672 name => p
672 .
672 name => tok
672 .
672 name => String
672 (
672 )
672 )
672 (
672 )
672 ;
673 }
673 ;
675 switch
675 name => p
675 .
675 name => tok
675 {
676 case
676 name => _Name
676 :
677 return
677 name => p
677 .
677 name => name
677 (
677 )
677 ;
679 case
679 name => _Literal
679 :
680 return
680 name => p
680 .
680 name => oliteral
680 (
680 )
680 ;
682 case
682 name => _Lparen
682 :
683 name => pos
683 :=
683 name => p
683 .
683 name => pos
683 (
683 )
683 ;
684 name => p
684 .
684 name => next
684 (
684 )
684 ;
685 name => p
685 .
685 name => xnest
685 opop
685 ;
686 name => x
686 :=
686 name => p
686 .
686 name => expr
686 (
686 )
686 ;
687 name => p
687 .
687 name => xnest
687 opop
687 ;
688 name => p
688 .
688 name => want
688 (
688 name => _Rparen
688 )
688 ;
704 if
704 name => p
704 .
704 name => tok
704 op => == 3
704 name => _Lbrace
704 {
705 name => keep_parens
705 =
705 name => true
705 ;
706 }
706 ;
711 if
711 name => keep_parens
711 {
712 name => px
712 :=
712 name => new
712 (
712 name => ParenExpr
712 )
712 ;
713 name => px
713 .
713 name => pos
713 =
713 name => pos
713 ;
714 name => px
714 .
714 name => X
714 =
714 name => x
714 ;
715 name => x
715 =
715 name => px
715 ;
716 }
716 ;
717 return
717 name => x
717 ;
719 case
719 name => _Func
719 :
720 name => pos
720 :=
720 name => p
720 .
720 name => pos
720 (
720 )
720 ;
721 name => p
721 .
721 name => next
721 (
721 )
721 ;
722 name => t
722 :=
722 name => p
722 .
722 name => funcType
722 (
722 )
722 ;
723 if
723 name => p
723 .
723 name => tok
723 op => == 3
723 name => _Lbrace
723 {
724 name => p
724 .
724 name => xnest
724 opop
724 ;
726 name => f
726 :=
726 name => new
726 (
726 name => FuncLit
726 )
726 ;
727 name => f
727 .
727 name => pos
727 =
727 name => pos
727 ;
728 name => f
728 .
728 name => Type
728 =
728 name => t
728 ;
729 name => f
729 .
729 name => Body
729 =
729 name => p
729 .
729 name => blockStmt
729 (
729 literal
729 )
729 ;
730 if
730 name => p
730 .
730 name => mode
730 op => & 5
730 name => CheckBranches
730 op => != 3
730 literal
730 {
731 name => checkBranches
731 (
731 name => f
731 .
731 name => Body
731 ,
731 name => p
731 .
731 name => errh
731 )
731 ;
732 }
732 ;
734 name => p
734 .
734 name => xnest
734 opop
734 ;
735 return
735 name => f
735 ;
736 }
736 ;
737 return
737 name => t
737 ;
739 case
739 name => _Lbrack
739 ,
739 name => _Chan
739 ,
739 name => _Map
739 ,
739 name => _Struct
739 ,
739 name => _Interface
739 :
740 return
740 name => p
740 .
740 name => type_
740 (
740 )
740 ;
742 default
742 :
743 name => x
743 :=
743 name => p
743 .
743 name => bad
743 (
743 )
743 ;
744 name => p
744 .
744 name => syntax_error
744 (
744 literal
744 )
744 ;
745 name => p
745 .
745 name => advance
745 (
745 )
745 ;
746 return
746 name => x
746 ;
747 }
747 ;
753 }
753 ;
771 func
771 (
771 name => p
771 *
771 name => parser
771 )
771 name => pexpr
771 (
771 name => keep_parens
771 name => bool
771 )
771 name => Expr
771 {
772 if
772 name => trace
772 {
773 defer
773 name => p
773 .
773 name => trace
773 (
773 literal
773 )
773 (
773 )
773 ;
774 }
774 ;
776 name => x
776 :=
776 name => p
776 .
776 name => operand
776 (
776 name => keep_parens
776 )
776 ;
778 name => loop
778 :
779 for
779 {
780 name => pos
780 :=
780 name => p
780 .
780 name => pos
780 (
780 )
780 ;
781 switch
781 name => p
781 .
781 name => tok
781 {
782 case
782 name => _Dot
782 :
783 name => p
783 .
783 name => next
783 (
783 )
783 ;
784 switch
784 name => p
784 .
784 name => tok
784 {
785 case
785 name => _Name
785 :
787 name => t
787 :=
787 name => new
787 (
787 name => SelectorExpr
787 )
787 ;
788 name => t
788 .
788 name => pos
788 =
788 name => pos
788 ;
789 name => t
789 .
789 name => X
789 =
789 name => x
789 ;
790 name => t
790 .
790 name => Sel
790 =
790 name => p
790 .
790 name => name
790 (
790 )
790 ;
791 name => x
791 =
791 name => t
791 ;
793 case
793 name => _Lparen
793 :
794 name => p
794 .
794 name => next
794 (
794 )
794 ;
795 if
795 name => p
795 .
795 name => got
795 (
795 name => _Type
795 )
795 {
796 name => t
796 :=
796 name => new
796 (
796 name => TypeSwitchGuard
796 )
796 ;
797 name => t
797 .
797 name => pos
797 =
797 name => pos
797 ;
798 name => t
798 .
798 name => X
798 =
798 name => x
798 ;
799 name => x
799 =
799 name => t
799 ;
800 }
800 else
800 {
801 name => t
801 :=
801 name => new
801 (
801 name => AssertExpr
801 )
801 ;
802 name => t
802 .
802 name => pos
802 =
802 name => pos
802 ;
803 name => t
803 .
803 name => X
803 =
803 name => x
803 ;
804 name => t
804 .
804 name => Type
804 =
804 name => p
804 .
804 name => expr
804 (
804 )
804 ;
805 name => x
805 =
805 name => t
805 ;
806 }
806 ;
807 name => p
807 .
807 name => want
807 (
807 name => _Rparen
807 )
807 ;
809 default
809 :
810 name => p
810 .
810 name => syntax_error
810 (
810 literal
810 )
810 ;
811 name => p
811 .
811 name => advance
811 (
811 name => _Semi
811 ,
811 name => _Rparen
811 )
811 ;
812 }
812 ;
814 case
814 name => _Lbrack
814 :
815 name => p
815 .
815 name => next
815 (
815 )
815 ;
816 name => p
816 .
816 name => xnest
816 opop
816 ;
818 var
818 name => i
818 name => Expr
818 ;
819 if
819 name => p
819 .
819 name => tok
819 op => != 3
819 name => _Colon
819 {
820 name => i
820 =
820 name => p
820 .
820 name => expr
820 (
820 )
820 ;
821 if
821 name => p
821 .
821 name => got
821 (
821 name => _Rbrack
821 )
821 {
823 name => t
823 :=
823 name => new
823 (
823 name => IndexExpr
823 )
823 ;
824 name => t
824 .
824 name => pos
824 =
824 name => pos
824 ;
825 name => t
825 .
825 name => X
825 =
825 name => x
825 ;
826 name => t
826 .
826 name => Index
826 =
826 name => i
826 ;
827 name => x
827 =
827 name => t
827 ;
828 name => p
828 .
828 name => xnest
828 opop
828 ;
829 break
829 ;
830 }
830 ;
831 }
831 ;
834 name => t
834 :=
834 name => new
834 (
834 name => SliceExpr
834 )
834 ;
835 name => t
835 .
835 name => pos
835 =
835 name => pos
835 ;
836 name => t
836 .
836 name => X
836 =
836 name => x
836 ;
837 name => t
837 .
837 name => Index
837 [
837 literal
837 ]
837 =
837 name => i
837 ;
838 name => p
838 .
838 name => want
838 (
838 name => _Colon
838 )
838 ;
839 if
839 name => p
839 .
839 name => tok
839 op => != 3
839 name => _Colon
839 op => && 2
839 name => p
839 .
839 name => tok
839 op => != 3
839 name => _Rbrack
839 {
841 name => t
841 .
841 name => Index
841 [
841 literal
841 ]
841 =
841 name => p
841 .
841 name => expr
841 (
841 )
841 ;
842 }
842 ;
843 if
843 name => p
843 .
843 name => got
843 (
843 name => _Colon
843 )
843 {
844 name => t
844 .
844 name => Full
844 =
844 name => true
844 ;
846 if
846 name => t
846 .
846 name => Index
846 [
846 literal
846 ]
846 op => == 3
846 name => nil
846 {
847 name => p
847 .
847 name => error
847 (
847 literal
847 )
847 ;
848 }
848 ;
849 if
849 name => p
849 .
849 name => tok
849 op => != 3
849 name => _Rbrack
849 {
851 name => t
851 .
851 name => Index
851 [
851 literal
851 ]
851 =
851 name => p
851 .
851 name => expr
851 (
851 )
851 ;
852 }
852 else
852 {
853 name => p
853 .
853 name => error
853 (
853 literal
853 )
853 ;
854 }
854 ;
855 }
855 ;
856 name => p
856 .
856 name => want
856 (
856 name => _Rbrack
856 )
856 ;
858 name => x
858 =
858 name => t
858 ;
859 name => p
859 .
859 name => xnest
859 opop
859 ;
861 case
861 name => _Lparen
861 :
862 name => x
862 =
862 name => p
862 .
862 name => call
862 (
862 name => x
862 )
862 ;
864 case
864 name => _Lbrace
864 :
867 name => t
867 :=
867 name => unparen
867 (
867 name => x
867 )
867 ;
869 name => complit_ok
869 :=
869 name => false
869 ;
870 switch
870 name => t
870 .
870 (
870 type
870 )
870 {
871 case
871 *
871 name => Name
871 ,
871 *
871 name => SelectorExpr
871 :
872 if
872 name => p
872 .
872 name => xnest
872 op => >= 3
872 literal
872 {
874 name => complit_ok
874 =
874 name => true
874 ;
875 }
875 ;
876 case
876 *
876 name => ArrayType
876 ,
876 *
876 name => SliceType
876 ,
876 *
876 name => StructType
876 ,
876 *
876 name => MapType
876 :
878 name => complit_ok
878 =
878 name => true
878 ;
879 }
879 ;
880 if
880 op => ! 0
880 name => complit_ok
880 {
881 break
881 name => loop
881 ;
882 }
882 ;
883 if
883 name => t
883 op => != 3
883 name => x
883 {
884 name => p
884 .
884 name => syntax_error
884 (
884 literal
884 )
884 ;
886 }
886 ;
887 name => n
887 :=
887 name => p
887 .
887 name => complitexpr
887 (
887 )
887 ;
888 name => n
888 .
888 name => Type
888 =
888 name => x
888 ;
889 name => x
889 =
889 name => n
889 ;
891 default
891 :
892 break
892 name => loop
892 ;
893 }
893 ;
894 }
894 ;
896 return
896 name => x
896 ;
897 }
897 ;
900 func
900 (
900 name => p
900 *
900 name => parser
900 )
900 name => bare_complitexpr
900 (
900 )
900 name => Expr
900 {
901 if
901 name => trace
901 {
902 defer
902 name => p
902 .
902 name => trace
902 (
902 literal
902 )
902 (
902 )
902 ;
903 }
903 ;
905 if
905 name => p
905 .
905 name => tok
905 op => == 3
905 name => _Lbrace
905 {
907 return
907 name => p
907 .
907 name => complitexpr
907 (
907 )
907 ;
908 }
908 ;
910 return
910 name => p
910 .
910 name => expr
910 (
910 )
910 ;
911 }
911 ;
914 func
914 (
914 name => p
914 *
914 name => parser
914 )
914 name => complitexpr
914 (
914 )
914 *
914 name => CompositeLit
914 {
915 if
915 name => trace
915 {
916 defer
916 name => p
916 .
916 name => trace
916 (
916 literal
916 )
916 (
916 )
916 ;
917 }
917 ;
919 name => x
919 :=
919 name => new
919 (
919 name => CompositeLit
919 )
919 ;
920 name => x
920 .
920 name => pos
920 =
920 name => p
920 .
920 name => pos
920 (
920 )
920 ;
922 name => p
922 .
922 name => want
922 (
922 name => _Lbrace
922 )
922 ;
923 name => p
923 .
923 name => xnest
923 opop
923 ;
925 for
925 name => p
925 .
925 name => tok
925 op => != 3
925 name => _EOF
925 op => && 2
925 name => p
925 .
925 name => tok
925 op => != 3
925 name => _Rbrace
925 {
927 name => e
927 :=
927 name => p
927 .
927 name => bare_complitexpr
927 (
927 )
927 ;
928 if
928 name => p
928 .
928 name => tok
928 op => == 3
928 name => _Colon
928 {
930 name => l
930 :=
930 name => new
930 (
930 name => KeyValueExpr
930 )
930 ;
931 name => l
931 .
931 name => pos
931 =
931 name => p
931 .
931 name => pos
931 (
931 )
931 ;
932 name => p
932 .
932 name => next
932 (
932 )
932 ;
933 name => l
933 .
933 name => Key
933 =
933 name => e
933 ;
934 name => l
934 .
934 name => Value
934 =
934 name => p
934 .
934 name => bare_complitexpr
934 (
934 )
934 ;
935 name => e
935 =
935 name => l
935 ;
936 name => x
936 .
936 name => NKeys
936 opop
936 ;
937 }
937 ;
938 name => x
938 .
938 name => ElemList
938 =
938 name => append
938 (
938 name => x
938 .
938 name => ElemList
938 ,
938 name => e
938 )
938 ;
939 if
939 op => ! 0
939 name => p
939 .
939 name => ocomma
939 (
939 name => _Rbrace
939 )
939 {
940 break
940 ;
941 }
941 ;
942 }
942 ;
944 name => x
944 .
944 name => Rbrace
944 =
944 name => p
944 .
944 name => pos
944 (
944 )
944 ;
945 name => p
945 .
945 name => xnest
945 opop
945 ;
946 name => p
946 .
946 name => want
946 (
946 name => _Rbrace
946 )
946 ;
948 return
948 name => x
948 ;
949 }
949 ;
954 func
954 (
954 name => p
954 *
954 name => parser
954 )
954 name => type_
954 (
954 )
954 name => Expr
954 {
955 if
955 name => trace
955 {
956 defer
956 name => p
956 .
956 name => trace
956 (
956 literal
956 )
956 (
956 )
956 ;
957 }
957 ;
959 name => typ
959 :=
959 name => p
959 .
959 name => typeOrNil
959 (
959 )
959 ;
960 if
960 name => typ
960 op => == 3
960 name => nil
960 {
961 name => typ
961 =
961 name => p
961 .
961 name => bad
961 (
961 )
961 ;
962 name => p
962 .
962 name => syntax_error
962 (
962 literal
962 )
962 ;
963 name => p
963 .
963 name => advance
963 (
963 )
963 ;
964 }
964 ;
966 return
966 name => typ
966 ;
967 }
967 ;
969 func
969 name => newIndirect
969 (
969 name => pos
969 name => src
969 .
969 name => Pos
969 ,
969 name => typ
969 name => Expr
969 )
969 name => Expr
969 {
970 name => o
970 :=
970 name => new
970 (
970 name => Operation
970 )
970 ;
971 name => o
971 .
971 name => pos
971 =
971 name => pos
971 ;
972 name => o
972 .
972 name => Op
972 =
972 name => Mul
972 ;
973 name => o
973 .
973 name => X
973 =
973 name => typ
973 ;
974 return
974 name => o
974 ;
975 }
975 ;
984 func
984 (
984 name => p
984 *
984 name => parser
984 )
984 name => typeOrNil
984 (
984 )
984 name => Expr
984 {
985 if
985 name => trace
985 {
986 defer
986 name => p
986 .
986 name => trace
986 (
986 literal
986 )
986 (
986 )
986 ;
987 }
987 ;
989 name => pos
989 :=
989 name => p
989 .
989 name => pos
989 (
989 )
989 ;
990 switch
990 name => p
990 .
990 name => tok
990 {
991 case
991 name => _Star
991 :
993 name => p
993 .
993 name => next
993 (
993 )
993 ;
994 return
994 name => newIndirect
994 (
994 name => pos
994 ,
994 name => p
994 .
994 name => type_
994 (
994 )
994 )
994 ;
996 case
996 name => _Arrow
996 :
998 name => p
998 .
998 name => next
998 (
998 )
998 ;
999 name => p
999 .
999 name => want
999 (
999 name => _Chan
999 )
999 ;
1000 name => t
1000 :=
1000 name => new
1000 (
1000 name => ChanType
1000 )
1000 ;
1001 name => t
1001 .
1001 name => pos
1001 =
1001 name => pos
1001 ;
1002 name => t
1002 .
1002 name => Dir
1002 =
1002 name => RecvOnly
1002 ;
1003 name => t
1003 .
1003 name => Elem
1003 =
1003 name => p
1003 .
1003 name => chanElem
1003 (
1003 )
1003 ;
1004 return
1004 name => t
1004 ;
1006 case
1006 name => _Func
1006 :
1008 name => p
1008 .
1008 name => next
1008 (
1008 )
1008 ;
1009 return
1009 name => p
1009 .
1009 name => funcType
1009 (
1009 )
1009 ;
1011 case
1011 name => _Lbrack
1011 :
1014 name => p
1014 .
1014 name => next
1014 (
1014 )
1014 ;
1015 name => p
1015 .
1015 name => xnest
1015 opop
1015 ;
1016 if
1016 name => p
1016 .
1016 name => got
1016 (
1016 name => _Rbrack
1016 )
1016 {
1018 name => p
1018 .
1018 name => xnest
1018 opop
1018 ;
1019 name => t
1019 :=
1019 name => new
1019 (
1019 name => SliceType
1019 )
1019 ;
1020 name => t
1020 .
1020 name => pos
1020 =
1020 name => pos
1020 ;
1021 name => t
1021 .
1021 name => Elem
1021 =
1021 name => p
1021 .
1021 name => type_
1021 (
1021 )
1021 ;
1022 return
1022 name => t
1022 ;
1023 }
1023 ;
1026 name => t
1026 :=
1026 name => new
1026 (
1026 name => ArrayType
1026 )
1026 ;
1027 name => t
1027 .
1027 name => pos
1027 =
1027 name => pos
1027 ;
1028 if
1028 op => ! 0
1028 name => p
1028 .
1028 name => got
1028 (
1028 name => _DotDotDot
1028 )
1028 {
1029 name => t
1029 .
1029 name => Len
1029 =
1029 name => p
1029 .
1029 name => expr
1029 (
1029 )
1029 ;
1030 }
1030 ;
1031 name => p
1031 .
1031 name => want
1031 (
1031 name => _Rbrack
1031 )
1031 ;
1032 name => p
1032 .
1032 name => xnest
1032 opop
1032 ;
1033 name => t
1033 .
1033 name => Elem
1033 =
1033 name => p
1033 .
1033 name => type_
1033 (
1033 )
1033 ;
1034 return
1034 name => t
1034 ;
1036 case
1036 name => _Chan
1036 :
1039 name => p
1039 .
1039 name => next
1039 (
1039 )
1039 ;
1040 name => t
1040 :=
1040 name => new
1040 (
1040 name => ChanType
1040 )
1040 ;
1041 name => t
1041 .
1041 name => pos
1041 =
1041 name => pos
1041 ;
1042 if
1042 name => p
1042 .
1042 name => got
1042 (
1042 name => _Arrow
1042 )
1042 {
1043 name => t
1043 .
1043 name => Dir
1043 =
1043 name => SendOnly
1043 ;
1044 }
1044 ;
1045 name => t
1045 .
1045 name => Elem
1045 =
1045 name => p
1045 .
1045 name => chanElem
1045 (
1045 )
1045 ;
1046 return
1046 name => t
1046 ;
1048 case
1048 name => _Map
1048 :
1050 name => p
1050 .
1050 name => next
1050 (
1050 )
1050 ;
1051 name => p
1051 .
1051 name => want
1051 (
1051 name => _Lbrack
1051 )
1051 ;
1052 name => t
1052 :=
1052 name => new
1052 (
1052 name => MapType
1052 )
1052 ;
1053 name => t
1053 .
1053 name => pos
1053 =
1053 name => pos
1053 ;
1054 name => t
1054 .
1054 name => Key
1054 =
1054 name => p
1054 .
1054 name => type_
1054 (
1054 )
1054 ;
1055 name => p
1055 .
1055 name => want
1055 (
1055 name => _Rbrack
1055 )
1055 ;
1056 name => t
1056 .
1056 name => Value
1056 =
1056 name => p
1056 .
1056 name => type_
1056 (
1056 )
1056 ;
1057 return
1057 name => t
1057 ;
1059 case
1059 name => _Struct
1059 :
1060 return
1060 name => p
1060 .
1060 name => structType
1060 (
1060 )
1060 ;
1062 case
1062 name => _Interface
1062 :
1063 return
1063 name => p
1063 .
1063 name => interfaceType
1063 (
1063 )
1063 ;
1065 case
1065 name => _Name
1065 :
1066 return
1066 name => p
1066 .
1066 name => dotname
1066 (
1066 name => p
1066 .
1066 name => name
1066 (
1066 )
1066 )
1066 ;
1068 case
1068 name => _Lparen
1068 :
1069 name => p
1069 .
1069 name => next
1069 (
1069 )
1069 ;
1070 name => t
1070 :=
1070 name => p
1070 .
1070 name => type_
1070 (
1070 )
1070 ;
1071 name => p
1071 .
1071 name => want
1071 (
1071 name => _Rparen
1071 )
1071 ;
1072 return
1072 name => t
1072 ;
1073 }
1073 ;
1075 return
1075 name => nil
1075 ;
1076 }
1076 ;
1078 func
1078 (
1078 name => p
1078 *
1078 name => parser
1078 )
1078 name => funcType
1078 (
1078 )
1078 *
1078 name => FuncType
1078 {
1079 if
1079 name => trace
1079 {
1080 defer
1080 name => p
1080 .
1080 name => trace
1080 (
1080 literal
1080 )
1080 (
1080 )
1080 ;
1081 }
1081 ;
1083 name => typ
1083 :=
1083 name => new
1083 (
1083 name => FuncType
1083 )
1083 ;
1084 name => typ
1084 .
1084 name => pos
1084 =
1084 name => p
1084 .
1084 name => pos
1084 (
1084 )
1084 ;
1085 name => typ
1085 .
1085 name => ParamList
1085 =
1085 name => p
1085 .
1085 name => paramList
1085 (
1085 )
1085 ;
1086 name => typ
1086 .
1086 name => ResultList
1086 =
1086 name => p
1086 .
1086 name => funcResult
1086 (
1086 )
1086 ;
1088 return
1088 name => typ
1088 ;
1089 }
1089 ;
1091 func
1091 (
1091 name => p
1091 *
1091 name => parser
1091 )
1091 name => chanElem
1091 (
1091 )
1091 name => Expr
1091 {
1092 if
1092 name => trace
1092 {
1093 defer
1093 name => p
1093 .
1093 name => trace
1093 (
1093 literal
1093 )
1093 (
1093 )
1093 ;
1094 }
1094 ;
1096 name => typ
1096 :=
1096 name => p
1096 .
1096 name => typeOrNil
1096 (
1096 )
1096 ;
1097 if
1097 name => typ
1097 op => == 3
1097 name => nil
1097 {
1098 name => typ
1098 =
1098 name => p
1098 .
1098 name => bad
1098 (
1098 )
1098 ;
1099 name => p
1099 .
1099 name => syntax_error
1099 (
1099 literal
1099 )
1099 ;
1101 }
1101 ;
1103 return
1103 name => typ
1103 ;
1104 }
1104 ;
1106 func
1106 (
1106 name => p
1106 *
1106 name => parser
1106 )
1106 name => dotname
1106 (
1106 name => name
1106 *
1106 name => Name
1106 )
1106 name => Expr
1106 {
1107 if
1107 name => trace
1107 {
1108 defer
1108 name => p
1108 .
1108 name => trace
1108 (
1108 literal
1108 )
1108 (
1108 )
1108 ;
1109 }
1109 ;
1111 if
1111 name => p
1111 .
1111 name => tok
1111 op => == 3
1111 name => _Dot
1111 {
1112 name => s
1112 :=
1112 name => new
1112 (
1112 name => SelectorExpr
1112 )
1112 ;
1113 name => s
1113 .
1113 name => pos
1113 =
1113 name => p
1113 .
1113 name => pos
1113 (
1113 )
1113 ;
1114 name => p
1114 .
1114 name => next
1114 (
1114 )
1114 ;
1115 name => s
1115 .
1115 name => X
1115 =
1115 name => name
1115 ;
1116 name => s
1116 .
1116 name => Sel
1116 =
1116 name => p
1116 .
1116 name => name
1116 (
1116 )
1116 ;
1117 return
1117 name => s
1117 ;
1118 }
1118 ;
1119 return
1119 name => name
1119 ;
1120 }
1120 ;
1123 func
1123 (
1123 name => p
1123 *
1123 name => parser
1123 )
1123 name => structType
1123 (
1123 )
1123 *
1123 name => StructType
1123 {
1124 if
1124 name => trace
1124 {
1125 defer
1125 name => p
1125 .
1125 name => trace
1125 (
1125 literal
1125 )
1125 (
1125 )
1125 ;
1126 }
1126 ;
1128 name => typ
1128 :=
1128 name => new
1128 (
1128 name => StructType
1128 )
1128 ;
1129 name => typ
1129 .
1129 name => pos
1129 =
1129 name => p
1129 .
1129 name => pos
1129 (
1129 )
1129 ;
1131 name => p
1131 .
1131 name => want
1131 (
1131 name => _Struct
1131 )
1131 ;
1132 name => p
1132 .
1132 name => want
1132 (
1132 name => _Lbrace
1132 )
1132 ;
1133 for
1133 name => p
1133 .
1133 name => tok
1133 op => != 3
1133 name => _EOF
1133 op => && 2
1133 name => p
1133 .
1133 name => tok
1133 op => != 3
1133 name => _Rbrace
1133 {
1134 name => p
1134 .
1134 name => fieldDecl
1134 (
1134 name => typ
1134 )
1134 ;
1135 if
1135 op => ! 0
1135 name => p
1135 .
1135 name => osemi
1135 (
1135 name => _Rbrace
1135 )
1135 {
1136 break
1136 ;
1137 }
1137 ;
1138 }
1138 ;
1139 name => p
1139 .
1139 name => want
1139 (
1139 name => _Rbrace
1139 )
1139 ;
1141 return
1141 name => typ
1141 ;
1142 }
1142 ;
1145 func
1145 (
1145 name => p
1145 *
1145 name => parser
1145 )
1145 name => interfaceType
1145 (
1145 )
1145 *
1145 name => InterfaceType
1145 {
1146 if
1146 name => trace
1146 {
1147 defer
1147 name => p
1147 .
1147 name => trace
1147 (
1147 literal
1147 )
1147 (
1147 )
1147 ;
1148 }
1148 ;
1150 name => typ
1150 :=
1150 name => new
1150 (
1150 name => InterfaceType
1150 )
1150 ;
1151 name => typ
1151 .
1151 name => pos
1151 =
1151 name => p
1151 .
1151 name => pos
1151 (
1151 )
1151 ;
1153 name => p
1153 .
1153 name => want
1153 (
1153 name => _Interface
1153 )
1153 ;
1154 name => p
1154 .
1154 name => want
1154 (
1154 name => _Lbrace
1154 )
1154 ;
1155 for
1155 name => p
1155 .
1155 name => tok
1155 op => != 3
1155 name => _EOF
1155 op => && 2
1155 name => p
1155 .
1155 name => tok
1155 op => != 3
1155 name => _Rbrace
1155 {
1156 if
1156 name => m
1156 :=
1156 name => p
1156 .
1156 name => methodDecl
1156 (
1156 )
1156 ;
1156 name => m
1156 op => != 3
1156 name => nil
1156 {
1157 name => typ
1157 .
1157 name => MethodList
1157 =
1157 name => append
1157 (
1157 name => typ
1157 .
1157 name => MethodList
1157 ,
1157 name => m
1157 )
1157 ;
1158 }
1158 ;
1159 if
1159 op => ! 0
1159 name => p
1159 .
1159 name => osemi
1159 (
1159 name => _Rbrace
1159 )
1159 {
1160 break
1160 ;
1161 }
1161 ;
1162 }
1162 ;
1163 name => p
1163 .
1163 name => want
1163 (
1163 name => _Rbrace
1163 )
1163 ;
1165 return
1165 name => typ
1165 ;
1166 }
1166 ;
1169 func
1169 (
1169 name => p
1169 *
1169 name => parser
1169 )
1169 name => funcBody
1169 (
1169 )
1169 [
1169 ]
1169 name => Stmt
1169 {
1170 if
1170 name => trace
1170 {
1171 defer
1171 name => p
1171 .
1171 name => trace
1171 (
1171 literal
1171 )
1171 (
1171 )
1171 ;
1172 }
1172 ;
1174 name => p
1174 .
1174 name => fnest
1174 opop
1174 ;
1175 name => body
1175 :=
1175 name => p
1175 .
1175 name => stmtList
1175 (
1175 )
1175 ;
1176 name => p
1176 .
1176 name => fnest
1176 opop
1176 ;
1178 if
1178 name => body
1178 op => == 3
1178 name => nil
1178 {
1179 name => body
1179 =
1179 [
1179 ]
1179 name => Stmt
1179 {
1179 name => new
1179 (
1179 name => EmptyStmt
1179 )
1179 }
1179 ;
1180 }
1180 ;
1181 return
1181 name => body
1181 ;
1182 }
1182 ;
1185 func
1185 (
1185 name => p
1185 *
1185 name => parser
1185 )
1185 name => funcResult
1185 (
1185 )
1185 [
1185 ]
1185 *
1185 name => Field
1185 {
1186 if
1186 name => trace
1186 {
1187 defer
1187 name => p
1187 .
1187 name => trace
1187 (
1187 literal
1187 )
1187 (
1187 )
1187 ;
1188 }
1188 ;
1190 if
1190 name => p
1190 .
1190 name => tok
1190 op => == 3
1190 name => _Lparen
1190 {
1191 return
1191 name => p
1191 .
1191 name => paramList
1191 (
1191 )
1191 ;
1192 }
1192 ;
1194 name => pos
1194 :=
1194 name => p
1194 .
1194 name => pos
1194 (
1194 )
1194 ;
1195 if
1195 name => typ
1195 :=
1195 name => p
1195 .
1195 name => typeOrNil
1195 (
1195 )
1195 ;
1195 name => typ
1195 op => != 3
1195 name => nil
1195 {
1196 name => f
1196 :=
1196 name => new
1196 (
1196 name => Field
1196 )
1196 ;
1197 name => f
1197 .
1197 name => pos
1197 =
1197 name => pos
1197 ;
1198 name => f
1198 .
1198 name => Type
1198 =
1198 name => typ
1198 ;
1199 return
1199 [
1199 ]
1199 *
1199 name => Field
1199 {
1199 name => f
1199 }
1199 ;
1200 }
1200 ;
1202 return
1202 name => nil
1202 ;
1203 }
1203 ;
1205 func
1205 (
1205 name => p
1205 *
1205 name => parser
1205 )
1205 name => addField
1205 (
1205 name => styp
1205 *
1205 name => StructType
1205 ,
1205 name => pos
1205 name => src
1205 .
1205 name => Pos
1205 ,
1205 name => name
1205 *
1205 name => Name
1205 ,
1205 name => typ
1205 name => Expr
1205 ,
1205 name => tag
1205 *
1205 name => BasicLit
1205 )
1205 {
1206 if
1206 name => tag
1206 op => != 3
1206 name => nil
1206 {
1207 for
1207 name => i
1207 :=
1207 name => len
1207 (
1207 name => styp
1207 .
1207 name => FieldList
1207 )
1207 op => - 4
1207 name => len
1207 (
1207 name => styp
1207 .
1207 name => TagList
1207 )
1207 ;
1207 name => i
1207 op => > 3
1207 literal
1207 ;
1207 name => i
1207 opop
1207 {
1208 name => styp
1208 .
1208 name => TagList
1208 =
1208 name => append
1208 (
1208 name => styp
1208 .
1208 name => TagList
1208 ,
1208 name => nil
1208 )
1208 ;
1209 }
1209 ;
1210 name => styp
1210 .
1210 name => TagList
1210 =
1210 name => append
1210 (
1210 name => styp
1210 .
1210 name => TagList
1210 ,
1210 name => tag
1210 )
1210 ;
1211 }
1211 ;
1213 name => f
1213 :=
1213 name => new
1213 (
1213 name => Field
1213 )
1213 ;
1214 name => f
1214 .
1214 name => pos
1214 =
1214 name => pos
1214 ;
1215 name => f
1215 .
1215 name => Name
1215 =
1215 name => name
1215 ;
1216 name => f
1216 .
1216 name => Type
1216 =
1216 name => typ
1216 ;
1217 name => styp
1217 .
1217 name => FieldList
1217 =
1217 name => append
1217 (
1217 name => styp
1217 .
1217 name => FieldList
1217 ,
1217 name => f
1217 )
1217 ;
1219 if
1219 name => debug
1219 op => && 2
1219 name => tag
1219 op => != 3
1219 name => nil
1219 op => && 2
1219 name => len
1219 (
1219 name => styp
1219 .
1219 name => FieldList
1219 )
1219 op => != 3
1219 name => len
1219 (
1219 name => styp
1219 .
1219 name => TagList
1219 )
1219 {
1220 name => panic
1220 (
1220 literal
1220 )
1220 ;
1221 }
1221 ;
1222 }
1222 ;
1227 func
1227 (
1227 name => p
1227 *
1227 name => parser
1227 )
1227 name => fieldDecl
1227 (
1227 name => styp
1227 *
1227 name => StructType
1227 )
1227 {
1228 if
1228 name => trace
1228 {
1229 defer
1229 name => p
1229 .
1229 name => trace
1229 (
1229 literal
1229 )
1229 (
1229 )
1229 ;
1230 }
1230 ;
1232 name => pos
1232 :=
1232 name => p
1232 .
1232 name => pos
1232 (
1232 )
1232 ;
1233 switch
1233 name => p
1233 .
1233 name => tok
1233 {
1234 case
1234 name => _Name
1234 :
1235 name => name
1235 :=
1235 name => p
1235 .
1235 name => name
1235 (
1235 )
1235 ;
1236 if
1236 name => p
1236 .
1236 name => tok
1236 op => == 3
1236 name => _Dot
1236 op => || 1
1236 name => p
1236 .
1236 name => tok
1236 op => == 3
1236 name => _Literal
1236 op => || 1
1236 name => p
1236 .
1236 name => tok
1236 op => == 3
1236 name => _Semi
1236 op => || 1
1236 name => p
1236 .
1236 name => tok
1236 op => == 3
1236 name => _Rbrace
1236 {
1238 name => typ
1238 :=
1238 name => p
1238 .
1238 name => qualifiedName
1238 (
1238 name => name
1238 )
1238 ;
1239 name => tag
1239 :=
1239 name => p
1239 .
1239 name => oliteral
1239 (
1239 )
1239 ;
1240 name => p
1240 .
1240 name => addField
1240 (
1240 name => styp
1240 ,
1240 name => pos
1240 ,
1240 name => nil
1240 ,
1240 name => typ
1240 ,
1240 name => tag
1240 )
1240 ;
1241 return
1241 ;
1242 }
1242 ;
1245 name => names
1245 :=
1245 name => p
1245 .
1245 name => nameList
1245 (
1245 name => name
1245 )
1245 ;
1246 name => typ
1246 :=
1246 name => p
1246 .
1246 name => type_
1246 (
1246 )
1246 ;
1247 name => tag
1247 :=
1247 name => p
1247 .
1247 name => oliteral
1247 (
1247 )
1247 ;
1249 for
1249 name => _
1249 ,
1249 name => name
1249 :=
1249 range
1249 name => names
1249 {
1250 name => p
1250 .
1250 name => addField
1250 (
1250 name => styp
1250 ,
1250 name => name
1250 .
1250 name => Pos
1250 (
1250 )
1250 ,
1250 name => name
1250 ,
1250 name => typ
1250 ,
1250 name => tag
1250 )
1250 ;
1251 }
1251 ;
1253 case
1253 name => _Lparen
1253 :
1254 name => p
1254 .
1254 name => next
1254 (
1254 )
1254 ;
1255 if
1255 name => p
1255 .
1255 name => tok
1255 op => == 3
1255 name => _Star
1255 {
1257 name => pos
1257 :=
1257 name => p
1257 .
1257 name => pos
1257 (
1257 )
1257 ;
1258 name => p
1258 .
1258 name => next
1258 (
1258 )
1258 ;
1259 name => typ
1259 :=
1259 name => newIndirect
1259 (
1259 name => pos
1259 ,
1259 name => p
1259 .
1259 name => qualifiedName
1259 (
1259 name => nil
1259 )
1259 )
1259 ;
1260 name => p
1260 .
1260 name => want
1260 (
1260 name => _Rparen
1260 )
1260 ;
1261 name => tag
1261 :=
1261 name => p
1261 .
1261 name => oliteral
1261 (
1261 )
1261 ;
1262 name => p
1262 .
1262 name => addField
1262 (
1262 name => styp
1262 ,
1262 name => pos
1262 ,
1262 name => nil
1262 ,
1262 name => typ
1262 ,
1262 name => tag
1262 )
1262 ;
1263 name => p
1263 .
1263 name => syntax_error
1263 (
1263 literal
1263 )
1263 ;
1265 }
1265 else
1265 {
1267 name => typ
1267 :=
1267 name => p
1267 .
1267 name => qualifiedName
1267 (
1267 name => nil
1267 )
1267 ;
1268 name => p
1268 .
1268 name => want
1268 (
1268 name => _Rparen
1268 )
1268 ;
1269 name => tag
1269 :=
1269 name => p
1269 .
1269 name => oliteral
1269 (
1269 )
1269 ;
1270 name => p
1270 .
1270 name => addField
1270 (
1270 name => styp
1270 ,
1270 name => pos
1270 ,
1270 name => nil
1270 ,
1270 name => typ
1270 ,
1270 name => tag
1270 )
1270 ;
1271 name => p
1271 .
1271 name => syntax_error
1271 (
1271 literal
1271 )
1271 ;
1272 }
1272 ;
1274 case
1274 name => _Star
1274 :
1275 name => p
1275 .
1275 name => next
1275 (
1275 )
1275 ;
1276 if
1276 name => p
1276 .
1276 name => got
1276 (
1276 name => _Lparen
1276 )
1276 {
1278 name => typ
1278 :=
1278 name => newIndirect
1278 (
1278 name => pos
1278 ,
1278 name => p
1278 .
1278 name => qualifiedName
1278 (
1278 name => nil
1278 )
1278 )
1278 ;
1279 name => p
1279 .
1279 name => want
1279 (
1279 name => _Rparen
1279 )
1279 ;
1280 name => tag
1280 :=
1280 name => p
1280 .
1280 name => oliteral
1280 (
1280 )
1280 ;
1281 name => p
1281 .
1281 name => addField
1281 (
1281 name => styp
1281 ,
1281 name => pos
1281 ,
1281 name => nil
1281 ,
1281 name => typ
1281 ,
1281 name => tag
1281 )
1281 ;
1282 name => p
1282 .
1282 name => syntax_error
1282 (
1282 literal
1282 )
1282 ;
1284 }
1284 else
1284 {
1286 name => typ
1286 :=
1286 name => newIndirect
1286 (
1286 name => pos
1286 ,
1286 name => p
1286 .
1286 name => qualifiedName
1286 (
1286 name => nil
1286 )
1286 )
1286 ;
1287 name => tag
1287 :=
1287 name => p
1287 .
1287 name => oliteral
1287 (
1287 )
1287 ;
1288 name => p
1288 .
1288 name => addField
1288 (
1288 name => styp
1288 ,
1288 name => pos
1288 ,
1288 name => nil
1288 ,
1288 name => typ
1288 ,
1288 name => tag
1288 )
1288 ;
1289 }
1289 ;
1291 default
1291 :
1292 name => p
1292 .
1292 name => syntax_error
1292 (
1292 literal
1292 )
1292 ;
1293 name => p
1293 .
1293 name => advance
1293 (
1293 name => _Semi
1293 ,
1293 name => _Rbrace
1293 )
1293 ;
1294 }
1294 ;
1295 }
1295 ;
1297 func
1297 (
1297 name => p
1297 *
1297 name => parser
1297 )
1297 name => oliteral
1297 (
1297 )
1297 *
1297 name => BasicLit
1297 {
1298 if
1298 name => p
1298 .
1298 name => tok
1298 op => == 3
1298 name => _Literal
1298 {
1299 name => b
1299 :=
1299 name => new
1299 (
1299 name => BasicLit
1299 )
1299 ;
1300 name => b
1300 .
1300 name => pos
1300 =
1300 name => p
1300 .
1300 name => pos
1300 (
1300 )
1300 ;
1301 name => b
1301 .
1301 name => Value
1301 =
1301 name => p
1301 .
1301 name => lit
1301 ;
1302 name => b
1302 .
1302 name => Kind
1302 =
1302 name => p
1302 .
1302 name => kind
1302 ;
1303 name => p
1303 .
1303 name => next
1303 (
1303 )
1303 ;
1304 return
1304 name => b
1304 ;
1305 }
1305 ;
1306 return
1306 name => nil
1306 ;
1307 }
1307 ;
1312 func
1312 (
1312 name => p
1312 *
1312 name => parser
1312 )
1312 name => methodDecl
1312 (
1312 )
1312 *
1312 name => Field
1312 {
1313 if
1313 name => trace
1313 {
1314 defer
1314 name => p
1314 .
1314 name => trace
1314 (
1314 literal
1314 )
1314 (
1314 )
1314 ;
1315 }
1315 ;
1317 switch
1317 name => p
1317 .
1317 name => tok
1317 {
1318 case
1318 name => _Name
1318 :
1319 name => name
1319 :=
1319 name => p
1319 .
1319 name => name
1319 (
1319 )
1319 ;
1322 name => hasNameList
1322 :=
1322 name => false
1322 ;
1323 for
1323 name => p
1323 .
1323 name => got
1323 (
1323 name => _Comma
1323 )
1323 {
1324 name => p
1324 .
1324 name => name
1324 (
1324 )
1324 ;
1325 name => hasNameList
1325 =
1325 name => true
1325 ;
1326 }
1326 ;
1327 if
1327 name => hasNameList
1327 {
1328 name => p
1328 .
1328 name => syntax_error
1328 (
1328 literal
1328 )
1328 ;
1330 }
1330 ;
1332 name => f
1332 :=
1332 name => new
1332 (
1332 name => Field
1332 )
1332 ;
1333 name => f
1333 .
1333 name => pos
1333 =
1333 name => name
1333 .
1333 name => Pos
1333 (
1333 )
1333 ;
1334 if
1334 name => p
1334 .
1334 name => tok
1334 op => != 3
1334 name => _Lparen
1334 {
1336 name => f
1336 .
1336 name => Type
1336 =
1336 name => p
1336 .
1336 name => qualifiedName
1336 (
1336 name => name
1336 )
1336 ;
1337 return
1337 name => f
1337 ;
1338 }
1338 ;
1340 name => f
1340 .
1340 name => Name
1340 =
1340 name => name
1340 ;
1341 name => f
1341 .
1341 name => Type
1341 =
1341 name => p
1341 .
1341 name => funcType
1341 (
1341 )
1341 ;
1342 return
1342 name => f
1342 ;
1344 case
1344 name => _Lparen
1344 :
1345 name => p
1345 .
1345 name => syntax_error
1345 (
1345 literal
1345 )
1345 ;
1346 name => f
1346 :=
1346 name => new
1346 (
1346 name => Field
1346 )
1346 ;
1347 name => f
1347 .
1347 name => pos
1347 =
1347 name => p
1347 .
1347 name => pos
1347 (
1347 )
1347 ;
1348 name => p
1348 .
1348 name => next
1348 (
1348 )
1348 ;
1349 name => f
1349 .
1349 name => Type
1349 =
1349 name => p
1349 .
1349 name => qualifiedName
1349 (
1349 name => nil
1349 )
1349 ;
1350 name => p
1350 .
1350 name => want
1350 (
1350 name => _Rparen
1350 )
1350 ;
1351 return
1351 name => f
1351 ;
1353 default
1353 :
1354 name => p
1354 .
1354 name => syntax_error
1354 (
1354 literal
1354 )
1354 ;
1355 name => p
1355 .
1355 name => advance
1355 (
1355 name => _Semi
1355 ,
1355 name => _Rbrace
1355 )
1355 ;
1356 return
1356 name => nil
1356 ;
1357 }
1357 ;
1358 }
1358 ;
1361 func
1361 (
1361 name => p
1361 *
1361 name => parser
1361 )
1361 name => paramDeclOrNil
1361 (
1361 )
1361 *
1361 name => Field
1361 {
1362 if
1362 name => trace
1362 {
1363 defer
1363 name => p
1363 .
1363 name => trace
1363 (
1363 literal
1363 )
1363 (
1363 )
1363 ;
1364 }
1364 ;
1366 name => f
1366 :=
1366 name => new
1366 (
1366 name => Field
1366 )
1366 ;
1367 name => f
1367 .
1367 name => pos
1367 =
1367 name => p
1367 .
1367 name => pos
1367 (
1367 )
1367 ;
1369 switch
1369 name => p
1369 .
1369 name => tok
1369 {
1370 case
1370 name => _Name
1370 :
1371 name => f
1371 .
1371 name => Name
1371 =
1371 name => p
1371 .
1371 name => name
1371 (
1371 )
1371 ;
1372 switch
1372 name => p
1372 .
1372 name => tok
1372 {
1373 case
1373 name => _Name
1373 ,
1373 name => _Star
1373 ,
1373 name => _Arrow
1373 ,
1373 name => _Func
1373 ,
1373 name => _Lbrack
1373 ,
1373 name => _Chan
1373 ,
1373 name => _Map
1373 ,
1373 name => _Struct
1373 ,
1373 name => _Interface
1373 ,
1373 name => _Lparen
1373 :
1375 name => f
1375 .
1375 name => Type
1375 =
1375 name => p
1375 .
1375 name => type_
1375 (
1375 )
1375 ;
1377 case
1377 name => _DotDotDot
1377 :
1379 name => f
1379 .
1379 name => Type
1379 =
1379 name => p
1379 .
1379 name => dotsType
1379 (
1379 )
1379 ;
1381 case
1381 name => _Dot
1381 :
1384 name => f
1384 .
1384 name => Type
1384 =
1384 name => p
1384 .
1384 name => dotname
1384 (
1384 name => f
1384 .
1384 name => Name
1384 )
1384 ;
1385 name => f
1385 .
1385 name => Name
1385 =
1385 name => nil
1385 ;
1386 }
1386 ;
1388 case
1388 name => _Arrow
1388 ,
1388 name => _Star
1388 ,
1388 name => _Func
1388 ,
1388 name => _Lbrack
1388 ,
1388 name => _Chan
1388 ,
1388 name => _Map
1388 ,
1388 name => _Struct
1388 ,
1388 name => _Interface
1388 ,
1388 name => _Lparen
1388 :
1390 name => f
1390 .
1390 name => Type
1390 =
1390 name => p
1390 .
1390 name => type_
1390 (
1390 )
1390 ;
1392 case
1392 name => _DotDotDot
1392 :
1394 name => f
1394 .
1394 name => Type
1394 =
1394 name => p
1394 .
1394 name => dotsType
1394 (
1394 )
1394 ;
1396 default
1396 :
1397 name => p
1397 .
1397 name => syntax_error
1397 (
1397 literal
1397 )
1397 ;
1398 name => p
1398 .
1398 name => advance
1398 (
1398 name => _Comma
1398 ,
1398 name => _Rparen
1398 )
1398 ;
1399 return
1399 name => nil
1399 ;
1400 }
1400 ;
1402 return
1402 name => f
1402 ;
1403 }
1403 ;
1406 func
1406 (
1406 name => p
1406 *
1406 name => parser
1406 )
1406 name => dotsType
1406 (
1406 )
1406 *
1406 name => DotsType
1406 {
1407 if
1407 name => trace
1407 {
1408 defer
1408 name => p
1408 .
1408 name => trace
1408 (
1408 literal
1408 )
1408 (
1408 )
1408 ;
1409 }
1409 ;
1411 name => t
1411 :=
1411 name => new
1411 (
1411 name => DotsType
1411 )
1411 ;
1412 name => t
1412 .
1412 name => pos
1412 =
1412 name => p
1412 .
1412 name => pos
1412 (
1412 )
1412 ;
1414 name => p
1414 .
1414 name => want
1414 (
1414 name => _DotDotDot
1414 )
1414 ;
1415 name => t
1415 .
1415 name => Elem
1415 =
1415 name => p
1415 .
1415 name => typeOrNil
1415 (
1415 )
1415 ;
1416 if
1416 name => t
1416 .
1416 name => Elem
1416 op => == 3
1416 name => nil
1416 {
1417 name => t
1417 .
1417 name => Elem
1417 =
1417 name => p
1417 .
1417 name => bad
1417 (
1417 )
1417 ;
1418 name => p
1418 .
1418 name => syntax_error
1418 (
1418 literal
1418 )
1418 ;
1419 }
1419 ;
1421 return
1421 name => t
1421 ;
1422 }
1422 ;
1426 func
1426 (
1426 name => p
1426 *
1426 name => parser
1426 )
1426 name => paramList
1426 (
1426 )
1426 (
1426 name => list
1426 [
1426 ]
1426 *
1426 name => Field
1426 )
1426 {
1427 if
1427 name => trace
1427 {
1428 defer
1428 name => p
1428 .
1428 name => trace
1428 (
1428 literal
1428 )
1428 (
1428 )
1428 ;
1429 }
1429 ;
1431 name => pos
1431 :=
1431 name => p
1431 .
1431 name => pos
1431 (
1431 )
1431 ;
1432 name => p
1432 .
1432 name => want
1432 (
1432 name => _Lparen
1432 )
1432 ;
1434 var
1434 name => named
1434 name => int
1434 ;
1435 for
1435 name => p
1435 .
1435 name => tok
1435 op => != 3
1435 name => _EOF
1435 op => && 2
1435 name => p
1435 .
1435 name => tok
1435 op => != 3
1435 name => _Rparen
1435 {
1436 if
1436 name => par
1436 :=
1436 name => p
1436 .
1436 name => paramDeclOrNil
1436 (
1436 )
1436 ;
1436 name => par
1436 op => != 3
1436 name => nil
1436 {
1437 if
1437 name => debug
1437 op => && 2
1437 name => par
1437 .
1437 name => Name
1437 op => == 3
1437 name => nil
1437 op => && 2
1437 name => par
1437 .
1437 name => Type
1437 op => == 3
1437 name => nil
1437 {
1438 name => panic
1438 (
1438 literal
1438 )
1438 ;
1439 }
1439 ;
1440 if
1440 name => par
1440 .
1440 name => Name
1440 op => != 3
1440 name => nil
1440 op => && 2
1440 name => par
1440 .
1440 name => Type
1440 op => != 3
1440 name => nil
1440 {
1441 name => named
1441 opop
1441 ;
1442 }
1442 ;
1443 name => list
1443 =
1443 name => append
1443 (
1443 name => list
1443 ,
1443 name => par
1443 )
1443 ;
1444 }
1444 ;
1445 if
1445 op => ! 0
1445 name => p
1445 .
1445 name => ocomma
1445 (
1445 name => _Rparen
1445 )
1445 {
1446 break
1446 ;
1447 }
1447 ;
1448 }
1448 ;
1451 if
1451 name => named
1451 op => == 3
1451 literal
1451 {
1453 for
1453 name => _
1453 ,
1453 name => par
1453 :=
1453 range
1453 name => list
1453 {
1454 if
1454 name => typ
1454 :=
1454 name => par
1454 .
1454 name => Name
1454 ;
1454 name => typ
1454 op => != 3
1454 name => nil
1454 {
1455 name => par
1455 .
1455 name => Type
1455 =
1455 name => typ
1455 ;
1456 name => par
1456 .
1456 name => Name
1456 =
1456 name => nil
1456 ;
1457 }
1457 ;
1458 }
1458 ;
1459 }
1459 else
1459 if
1459 name => named
1459 op => != 3
1459 name => len
1459 (
1459 name => list
1459 )
1459 {
1461 name => ok
1461 :=
1461 name => true
1461 ;
1462 var
1462 name => typ
1462 name => Expr
1462 ;
1463 for
1463 name => i
1463 :=
1463 name => len
1463 (
1463 name => list
1463 )
1463 op => - 4
1463 literal
1463 ;
1463 name => i
1463 op => >= 3
1463 literal
1463 ;
1463 name => i
1463 opop
1463 {
1464 if
1464 name => par
1464 :=
1464 name => list
1464 [
1464 name => i
1464 ]
1464 ;
1464 name => par
1464 .
1464 name => Type
1464 op => != 3
1464 name => nil
1464 {
1465 name => typ
1465 =
1465 name => par
1465 .
1465 name => Type
1465 ;
1466 if
1466 name => par
1466 .
1466 name => Name
1466 op => == 3
1466 name => nil
1466 {
1467 name => ok
1467 =
1467 name => false
1467 ;
1468 name => n
1468 :=
1468 name => p
1468 .
1468 name => newName
1468 (
1468 literal
1468 )
1468 ;
1469 name => n
1469 .
1469 name => pos
1469 =
1469 name => typ
1469 .
1469 name => Pos
1469 (
1469 )
1469 ;
1470 name => par
1470 .
1470 name => Name
1470 =
1470 name => n
1470 ;
1471 }
1471 ;
1472 }
1472 else
1472 if
1472 name => typ
1472 op => != 3
1472 name => nil
1472 {
1473 name => par
1473 .
1473 name => Type
1473 =
1473 name => typ
1473 ;
1474 }
1474 else
1474 {
1476 name => ok
1476 =
1476 name => false
1476 ;
1477 name => t
1477 :=
1477 name => p
1477 .
1477 name => bad
1477 (
1477 )
1477 ;
1478 name => t
1478 .
1478 name => pos
1478 =
1478 name => par
1478 .
1478 name => Name
1478 .
1478 name => Pos
1478 (
1478 )
1478 ;
1479 name => par
1479 .
1479 name => Type
1479 =
1479 name => t
1479 ;
1480 }
1480 ;
1481 }
1481 ;
1482 if
1482 op => ! 0
1482 name => ok
1482 {
1483 name => p
1483 .
1483 name => syntax_error_at
1483 (
1483 name => pos
1483 ,
1483 literal
1483 )
1483 ;
1484 }
1484 ;
1485 }
1485 ;
1487 name => p
1487 .
1487 name => want
1487 (
1487 name => _Rparen
1487 )
1487 ;
1488 return
1488 ;
1489 }
1489 ;
1491 func
1491 (
1491 name => p
1491 *
1491 name => parser
1491 )
1491 name => bad
1491 (
1491 )
1491 *
1491 name => BadExpr
1491 {
1492 name => b
1492 :=
1492 name => new
1492 (
1492 name => BadExpr
1492 )
1492 ;
1493 name => b
1493 .
1493 name => pos
1493 =
1493 name => p
1493 .
1493 name => pos
1493 (
1493 )
1493 ;
1494 return
1494 name => b
1494 ;
1495 }
1495 ;
1502 var
1502 name => ImplicitOne
1502 =
1502 op => & 5
1502 name => BasicLit
1502 {
1502 name => Value
1502 :
1502 literal
1502 }
1502 ;
1505 func
1505 (
1505 name => p
1505 *
1505 name => parser
1505 )
1505 name => simpleStmt
1505 (
1505 name => lhs
1505 name => Expr
1505 ,
1505 name => rangeOk
1505 name => bool
1505 )
1505 name => SimpleStmt
1505 {
1506 if
1506 name => trace
1506 {
1507 defer
1507 name => p
1507 .
1507 name => trace
1507 (
1507 literal
1507 )
1507 (
1507 )
1507 ;
1508 }
1508 ;
1510 if
1510 name => rangeOk
1510 op => && 2
1510 name => p
1510 .
1510 name => tok
1510 op => == 3
1510 name => _Range
1510 {
1512 if
1512 name => debug
1512 op => && 2
1512 name => lhs
1512 op => != 3
1512 name => nil
1512 {
1513 name => panic
1513 (
1513 literal
1513 )
1513 ;
1514 }
1514 ;
1515 return
1515 name => p
1515 .
1515 name => newRangeClause
1515 (
1515 name => nil
1515 ,
1515 name => false
1515 )
1515 ;
1516 }
1516 ;
1518 if
1518 name => lhs
1518 op => == 3
1518 name => nil
1518 {
1519 name => lhs
1519 =
1519 name => p
1519 .
1519 name => exprList
1519 (
1519 )
1519 ;
1520 }
1520 ;
1522 if
1522 name => _
1522 ,
1522 name => ok
1522 :=
1522 name => lhs
1522 .
1522 (
1522 *
1522 name => ListExpr
1522 )
1522 ;
1522 op => ! 0
1522 name => ok
1522 op => && 2
1522 name => p
1522 .
1522 name => tok
1522 op => != 3
1522 name => _Assign
1522 op => && 2
1522 name => p
1522 .
1522 name => tok
1522 op => != 3
1522 name => _Define
1522 {
1524 name => pos
1524 :=
1524 name => p
1524 .
1524 name => pos
1524 (
1524 )
1524 ;
1525 switch
1525 name => p
1525 .
1525 name => tok
1525 {
1526 case
1526 name => _AssignOp
1526 :
1528 name => op
1528 :=
1528 name => p
1528 .
1528 name => op
1528 ;
1529 name => p
1529 .
1529 name => next
1529 (
1529 )
1529 ;
1530 return
1530 name => p
1530 .
1530 name => newAssignStmt
1530 (
1530 name => pos
1530 ,
1530 name => op
1530 ,
1530 name => lhs
1530 ,
1530 name => p
1530 .
1530 name => expr
1530 (
1530 )
1530 )
1530 ;
1532 case
1532 name => _IncOp
1532 :
1534 name => op
1534 :=
1534 name => p
1534 .
1534 name => op
1534 ;
1535 name => p
1535 .
1535 name => next
1535 (
1535 )
1535 ;
1536 return
1536 name => p
1536 .
1536 name => newAssignStmt
1536 (
1536 name => pos
1536 ,
1536 name => op
1536 ,
1536 name => lhs
1536 ,
1536 name => ImplicitOne
1536 )
1536 ;
1538 case
1538 name => _Arrow
1538 :
1540 name => s
1540 :=
1540 name => new
1540 (
1540 name => SendStmt
1540 )
1540 ;
1541 name => s
1541 .
1541 name => pos
1541 =
1541 name => pos
1541 ;
1542 name => p
1542 .
1542 name => next
1542 (
1542 )
1542 ;
1543 name => s
1543 .
1543 name => Chan
1543 =
1543 name => lhs
1543 ;
1544 name => s
1544 .
1544 name => Value
1544 =
1544 name => p
1544 .
1544 name => expr
1544 (
1544 )
1544 ;
1545 return
1545 name => s
1545 ;
1547 default
1547 :
1549 name => s
1549 :=
1549 name => new
1549 (
1549 name => ExprStmt
1549 )
1549 ;
1550 name => s
1550 .
1550 name => pos
1550 =
1550 name => lhs
1550 .
1550 name => Pos
1550 (
1550 )
1550 ;
1551 name => s
1551 .
1551 name => X
1551 =
1551 name => lhs
1551 ;
1552 return
1552 name => s
1552 ;
1553 }
1553 ;
1554 }
1554 ;
1557 name => pos
1557 :=
1557 name => p
1557 .
1557 name => pos
1557 (
1557 )
1557 ;
1558 switch
1558 name => p
1558 .
1558 name => tok
1558 {
1559 case
1559 name => _Assign
1559 :
1560 name => p
1560 .
1560 name => next
1560 (
1560 )
1560 ;
1562 if
1562 name => rangeOk
1562 op => && 2
1562 name => p
1562 .
1562 name => tok
1562 op => == 3
1562 name => _Range
1562 {
1564 return
1564 name => p
1564 .
1564 name => newRangeClause
1564 (
1564 name => lhs
1564 ,
1564 name => false
1564 )
1564 ;
1565 }
1565 ;
1568 return
1568 name => p
1568 .
1568 name => newAssignStmt
1568 (
1568 name => pos
1568 ,
1568 literal
1568 ,
1568 name => lhs
1568 ,
1568 name => p
1568 .
1568 name => exprList
1568 (
1568 )
1568 )
1568 ;
1570 case
1570 name => _Define
1570 :
1571 name => p
1571 .
1571 name => next
1571 (
1571 )
1571 ;
1573 if
1573 name => rangeOk
1573 op => && 2
1573 name => p
1573 .
1573 name => tok
1573 op => == 3
1573 name => _Range
1573 {
1575 return
1575 name => p
1575 .
1575 name => newRangeClause
1575 (
1575 name => lhs
1575 ,
1575 name => true
1575 )
1575 ;
1576 }
1576 ;
1579 name => rhs
1579 :=
1579 name => p
1579 .
1579 name => exprList
1579 (
1579 )
1579 ;
1581 if
1581 name => x
1581 ,
1581 name => ok
1581 :=
1581 name => rhs
1581 .
1581 (
1581 *
1581 name => TypeSwitchGuard
1581 )
1581 ;
1581 name => ok
1581 {
1582 switch
1582 name => lhs
1582 :=
1582 name => lhs
1582 .
1582 (
1582 type
1582 )
1582 {
1583 case
1583 *
1583 name => Name
1583 :
1584 name => x
1584 .
1584 name => Lhs
1584 =
1584 name => lhs
1584 ;
1585 case
1585 *
1585 name => ListExpr
1585 :
1586 name => p
1586 .
1586 name => error_at
1586 (
1586 name => lhs
1586 .
1586 name => Pos
1586 (
1586 )
1586 ,
1586 name => fmt
1586 .
1586 name => Sprintf
1586 (
1586 literal
1586 ,
1586 name => len
1586 (
1586 name => lhs
1586 .
1586 name => ElemList
1586 )
1586 )
1586 )
1586 ;
1588 if
1588 name => lhs
1588 ,
1588 name => ok
1588 :=
1588 name => lhs
1588 .
1588 name => ElemList
1588 [
1588 literal
1588 ]
1588 .
1588 (
1588 *
1588 name => Name
1588 )
1588 ;
1588 name => ok
1588 {
1589 name => x
1589 .
1589 name => Lhs
1589 =
1589 name => lhs
1589 ;
1590 }
1590 ;
1591 default
1591 :
1592 name => p
1592 .
1592 name => error_at
1592 (
1592 name => lhs
1592 .
1592 name => Pos
1592 (
1592 )
1592 ,
1592 name => fmt
1592 .
1592 name => Sprintf
1592 (
1592 literal
1592 ,
1592 name => String
1592 (
1592 name => lhs
1592 )
1592 )
1592 )
1592 ;
1593 }
1593 ;
1594 name => s
1594 :=
1594 name => new
1594 (
1594 name => ExprStmt
1594 )
1594 ;
1595 name => s
1595 .
1595 name => pos
1595 =
1595 name => x
1595 .
1595 name => Pos
1595 (
1595 )
1595 ;
1596 name => s
1596 .
1596 name => X
1596 =
1596 name => x
1596 ;
1597 return
1597 name => s
1597 ;
1598 }
1598 ;
1600 name => as
1600 :=
1600 name => p
1600 .
1600 name => newAssignStmt
1600 (
1600 name => pos
1600 ,
1600 name => Def
1600 ,
1600 name => lhs
1600 ,
1600 name => rhs
1600 )
1600 ;
1601 return
1601 name => as
1601 ;
1603 default
1603 :
1604 name => p
1604 .
1604 name => syntax_error
1604 (
1604 literal
1604 )
1604 ;
1605 name => p
1605 .
1605 name => advance
1605 (
1605 name => _Semi
1605 ,
1605 name => _Rbrace
1605 )
1605 ;
1607 if
1607 name => x
1607 ,
1607 name => ok
1607 :=
1607 name => lhs
1607 .
1607 (
1607 *
1607 name => ListExpr
1607 )
1607 ;
1607 name => ok
1607 {
1608 name => lhs
1608 =
1608 name => x
1608 .
1608 name => ElemList
1608 [
1608 literal
1608 ]
1608 ;
1609 }
1609 ;
1610 name => s
1610 :=
1610 name => new
1610 (
1610 name => ExprStmt
1610 )
1610 ;
1611 name => s
1611 .
1611 name => pos
1611 =
1611 name => lhs
1611 .
1611 name => Pos
1611 (
1611 )
1611 ;
1612 name => s
1612 .
1612 name => X
1612 =
1612 name => lhs
1612 ;
1613 return
1613 name => s
1613 ;
1614 }
1614 ;
1615 }
1615 ;
1617 func
1617 (
1617 name => p
1617 *
1617 name => parser
1617 )
1617 name => newRangeClause
1617 (
1617 name => lhs
1617 name => Expr
1617 ,
1617 name => def
1617 name => bool
1617 )
1617 *
1617 name => RangeClause
1617 {
1618 name => r
1618 :=
1618 name => new
1618 (
1618 name => RangeClause
1618 )
1618 ;
1619 name => r
1619 .
1619 name => pos
1619 =
1619 name => p
1619 .
1619 name => pos
1619 (
1619 )
1619 ;
1620 name => p
1620 .
1620 name => next
1620 (
1620 )
1620 ;
1621 name => r
1621 .
1621 name => Lhs
1621 =
1621 name => lhs
1621 ;
1622 name => r
1622 .
1622 name => Def
1622 =
1622 name => def
1622 ;
1623 name => r
1623 .
1623 name => X
1623 =
1623 name => p
1623 .
1623 name => expr
1623 (
1623 )
1623 ;
1624 return
1624 name => r
1624 ;
1625 }
1625 ;
1627 func
1627 (
1627 name => p
1627 *
1627 name => parser
1627 )
1627 name => newAssignStmt
1627 (
1627 name => pos
1627 name => src
1627 .
1627 name => Pos
1627 ,
1627 name => op
1627 name => Operator
1627 ,
1627 name => lhs
1627 ,
1627 name => rhs
1627 name => Expr
1627 )
1627 *
1627 name => AssignStmt
1627 {
1628 name => a
1628 :=
1628 name => new
1628 (
1628 name => AssignStmt
1628 )
1628 ;
1629 name => a
1629 .
1629 name => pos
1629 =
1629 name => pos
1629 ;
1630 name => a
1630 .
1630 name => Op
1630 =
1630 name => op
1630 ;
1631 name => a
1631 .
1631 name => Lhs
1631 =
1631 name => lhs
1631 ;
1632 name => a
1632 .
1632 name => Rhs
1632 =
1632 name => rhs
1632 ;
1633 return
1633 name => a
1633 ;
1634 }
1634 ;
1636 func
1636 (
1636 name => p
1636 *
1636 name => parser
1636 )
1636 name => labeledStmtOrNil
1636 (
1636 name => label
1636 *
1636 name => Name
1636 )
1636 name => Stmt
1636 {
1637 if
1637 name => trace
1637 {
1638 defer
1638 name => p
1638 .
1638 name => trace
1638 (
1638 literal
1638 )
1638 (
1638 )
1638 ;
1639 }
1639 ;
1641 name => s
1641 :=
1641 name => new
1641 (
1641 name => LabeledStmt
1641 )
1641 ;
1642 name => s
1642 .
1642 name => pos
1642 =
1642 name => p
1642 .
1642 name => pos
1642 (
1642 )
1642 ;
1643 name => s
1643 .
1643 name => Label
1643 =
1643 name => label
1643 ;
1645 name => p
1645 .
1645 name => want
1645 (
1645 name => _Colon
1645 )
1645 ;
1647 if
1647 name => p
1647 .
1647 name => tok
1647 op => == 3
1647 name => _Rbrace
1647 {
1651 name => e
1651 :=
1651 name => new
1651 (
1651 name => EmptyStmt
1651 )
1651 ;
1652 name => e
1652 .
1652 name => pos
1652 =
1652 name => p
1652 .
1652 name => pos
1652 (
1652 )
1652 ;
1653 name => s
1653 .
1653 name => Stmt
1653 =
1653 name => e
1653 ;
1654 return
1654 name => s
1654 ;
1655 }
1655 ;
1657 name => s
1657 .
1657 name => Stmt
1657 =
1657 name => p
1657 .
1657 name => stmtOrNil
1657 (
1657 )
1657 ;
1658 if
1658 name => s
1658 .
1658 name => Stmt
1658 op => != 3
1658 name => nil
1658 {
1659 return
1659 name => s
1659 ;
1660 }
1660 ;
1663 name => p
1663 .
1663 name => syntax_error_at
1663 (
1663 name => s
1663 .
1663 name => pos
1663 ,
1663 literal
1663 )
1663 ;
1665 return
1665 name => nil
1665 ;
1666 }
1666 ;
1668 func
1668 (
1668 name => p
1668 *
1668 name => parser
1668 )
1668 name => blockStmt
1668 (
1668 name => context
1668 name => string
1668 )
1668 *
1668 name => BlockStmt
1668 {
1669 if
1669 name => trace
1669 {
1670 defer
1670 name => p
1670 .
1670 name => trace
1670 (
1670 literal
1670 )
1670 (
1670 )
1670 ;
1671 }
1671 ;
1673 name => s
1673 :=
1673 name => new
1673 (
1673 name => BlockStmt
1673 )
1673 ;
1674 name => s
1674 .
1674 name => pos
1674 =
1674 name => p
1674 .
1674 name => pos
1674 (
1674 )
1674 ;
1676 if
1676 op => ! 0
1676 name => p
1676 .
1676 name => got
1676 (
1676 name => _Lbrace
1676 )
1676 {
1677 name => p
1677 .
1677 name => syntax_error
1677 (
1677 literal
1677 op => + 4
1677 name => context
1677 )
1677 ;
1678 name => p
1678 .
1678 name => advance
1678 (
1678 name => _Name
1678 ,
1678 name => _Rbrace
1678 )
1678 ;
1680 }
1680 ;
1682 name => s
1682 .
1682 name => List
1682 =
1682 name => p
1682 .
1682 name => stmtList
1682 (
1682 )
1682 ;
1683 name => s
1683 .
1683 name => Rbrace
1683 =
1683 name => p
1683 .
1683 name => pos
1683 (
1683 )
1683 ;
1684 name => p
1684 .
1684 name => want
1684 (
1684 name => _Rbrace
1684 )
1684 ;
1686 return
1686 name => s
1686 ;
1687 }
1687 ;
1689 func
1689 (
1689 name => p
1689 *
1689 name => parser
1689 )
1689 name => declStmt
1689 (
1689 name => f
1689 func
1689 (
1689 *
1689 name => Group
1689 )
1689 name => Decl
1689 )
1689 *
1689 name => DeclStmt
1689 {
1690 if
1690 name => trace
1690 {
1691 defer
1691 name => p
1691 .
1691 name => trace
1691 (
1691 literal
1691 )
1691 (
1691 )
1691 ;
1692 }
1692 ;
1694 name => s
1694 :=
1694 name => new
1694 (
1694 name => DeclStmt
1694 )
1694 ;
1695 name => s
1695 .
1695 name => pos
1695 =
1695 name => p
1695 .
1695 name => pos
1695 (
1695 )
1695 ;
1697 name => p
1697 .
1697 name => next
1697 (
1697 )
1697 ;
1698 name => s
1698 .
1698 name => DeclList
1698 =
1698 name => p
1698 .
1698 name => appendGroup
1698 (
1698 name => nil
1698 ,
1698 name => f
1698 )
1698 ;
1700 return
1700 name => s
1700 ;
1701 }
1701 ;
1703 func
1703 (
1703 name => p
1703 *
1703 name => parser
1703 )
1703 name => forStmt
1703 (
1703 )
1703 name => Stmt
1703 {
1704 if
1704 name => trace
1704 {
1705 defer
1705 name => p
1705 .
1705 name => trace
1705 (
1705 literal
1705 )
1705 (
1705 )
1705 ;
1706 }
1706 ;
1708 name => s
1708 :=
1708 name => new
1708 (
1708 name => ForStmt
1708 )
1708 ;
1709 name => s
1709 .
1709 name => pos
1709 =
1709 name => p
1709 .
1709 name => pos
1709 (
1709 )
1709 ;
1711 name => s
1711 .
1711 name => Init
1711 ,
1711 name => s
1711 .
1711 name => Cond
1711 ,
1711 name => s
1711 .
1711 name => Post
1711 =
1711 name => p
1711 .
1711 name => header
1711 (
1711 name => _For
1711 )
1711 ;
1712 name => s
1712 .
1712 name => Body
1712 =
1712 name => p
1712 .
1712 name => blockStmt
1712 (
1712 literal
1712 )
1712 ;
1714 return
1714 name => s
1714 ;
1715 }
1715 ;
1720 func
1720 (
1720 name => p
1720 *
1720 name => parser
1720 )
1720 name => header
1720 (
1720 name => keyword
1720 name => token
1720 )
1720 (
1720 name => init
1720 name => SimpleStmt
1720 ,
1720 name => cond
1720 name => Expr
1720 ,
1720 name => post
1720 name => SimpleStmt
1720 )
1720 {
1721 name => p
1721 .
1721 name => want
1721 (
1721 name => keyword
1721 )
1721 ;
1723 if
1723 name => p
1723 .
1723 name => tok
1723 op => == 3
1723 name => _Lbrace
1723 {
1724 if
1724 name => keyword
1724 op => == 3
1724 name => _If
1724 {
1725 name => p
1725 .
1725 name => syntax_error
1725 (
1725 literal
1725 )
1725 ;
1726 }
1726 ;
1727 return
1727 ;
1728 }
1728 ;
1731 name => outer
1731 :=
1731 name => p
1731 .
1731 name => xnest
1731 ;
1732 name => p
1732 .
1732 name => xnest
1732 =
1732 op => - 4
1732 literal
1732 ;
1734 if
1734 name => p
1734 .
1734 name => tok
1734 op => != 3
1734 name => _Semi
1734 {
1736 if
1736 name => p
1736 .
1736 name => got
1736 (
1736 name => _Var
1736 )
1736 {
1737 name => p
1737 .
1737 name => syntax_error
1737 (
1737 name => fmt
1737 .
1737 name => Sprintf
1737 (
1737 literal
1737 ,
1737 name => keyword
1737 .
1737 name => String
1737 (
1737 )
1737 )
1737 )
1737 ;
1738 }
1738 ;
1739 name => init
1739 =
1739 name => p
1739 .
1739 name => simpleStmt
1739 (
1739 name => nil
1739 ,
1739 name => keyword
1739 op => == 3
1739 name => _For
1739 )
1739 ;
1741 if
1741 name => _
1741 ,
1741 name => ok
1741 :=
1741 name => init
1741 .
1741 (
1741 *
1741 name => RangeClause
1741 )
1741 ;
1741 name => ok
1741 {
1742 name => p
1742 .
1742 name => xnest
1742 =
1742 name => outer
1742 ;
1743 return
1743 ;
1744 }
1744 ;
1745 }
1745 ;
1747 var
1747 name => condStmt
1747 name => SimpleStmt
1747 ;
1748 var
1748 name => semi
1748 struct
1748 {
1749 name => pos
1749 name => src
1749 .
1749 name => Pos
1749 ;
1750 name => lit
1750 name => string
1750 ;
1751 }
1751 ;
1752 if
1752 name => p
1752 .
1752 name => tok
1752 op => == 3
1752 name => _Semi
1752 {
1753 name => semi
1753 .
1753 name => pos
1753 =
1753 name => p
1753 .
1753 name => pos
1753 (
1753 )
1753 ;
1754 name => semi
1754 .
1754 name => lit
1754 =
1754 name => p
1754 .
1754 name => lit
1754 ;
1755 name => p
1755 .
1755 name => next
1755 (
1755 )
1755 ;
1756 if
1756 name => keyword
1756 op => == 3
1756 name => _For
1756 {
1757 if
1757 name => p
1757 .
1757 name => tok
1757 op => != 3
1757 name => _Semi
1757 {
1758 if
1758 name => p
1758 .
1758 name => tok
1758 op => == 3
1758 name => _Lbrace
1758 {
1759 name => p
1759 .
1759 name => syntax_error
1759 (
1759 literal
1759 )
1759 ;
1760 goto
1760 name => done
1760 ;
1761 }
1761 ;
1762 name => condStmt
1762 =
1762 name => p
1762 .
1762 name => simpleStmt
1762 (
1762 name => nil
1762 ,
1762 name => false
1762 )
1762 ;
1763 }
1763 ;
1764 name => p
1764 .
1764 name => want
1764 (
1764 name => _Semi
1764 )
1764 ;
1765 if
1765 name => p
1765 .
1765 name => tok
1765 op => != 3
1765 name => _Lbrace
1765 {
1766 name => post
1766 =
1766 name => p
1766 .
1766 name => simpleStmt
1766 (
1766 name => nil
1766 ,
1766 name => false
1766 )
1766 ;
1767 if
1767 name => a
1767 ,
1767 name => _
1767 :=
1767 name => post
1767 .
1767 (
1767 *
1767 name => AssignStmt
1767 )
1767 ;
1767 name => a
1767 op => != 3
1767 name => nil
1767 op => && 2
1767 name => a
1767 .
1767 name => Op
1767 op => == 3
1767 name => Def
1767 {
1768 name => p
1768 .
1768 name => syntax_error_at
1768 (
1768 name => a
1768 .
1768 name => Pos
1768 (
1768 )
1768 ,
1768 literal
1768 )
1768 ;
1769 }
1769 ;
1770 }
1770 ;
1771 }
1771 else
1771 if
1771 name => p
1771 .
1771 name => tok
1771 op => != 3
1771 name => _Lbrace
1771 {
1772 name => condStmt
1772 =
1772 name => p
1772 .
1772 name => simpleStmt
1772 (
1772 name => nil
1772 ,
1772 name => false
1772 )
1772 ;
1773 }
1773 ;
1774 }
1774 else
1774 {
1775 name => condStmt
1775 =
1775 name => init
1775 ;
1776 name => init
1776 =
1776 name => nil
1776 ;
1777 }
1777 ;
1779 name => done
1779 :
1781 switch
1781 name => s
1781 :=
1781 name => condStmt
1781 .
1781 (
1781 type
1781 )
1781 {
1782 case
1782 name => nil
1782 :
1783 if
1783 name => keyword
1783 op => == 3
1783 name => _If
1783 op => && 2
1783 name => semi
1783 .
1783 name => pos
1783 .
1783 name => IsKnown
1783 (
1783 )
1783 {
1784 if
1784 name => semi
1784 .
1784 name => lit
1784 op => != 3
1784 literal
1784 {
1785 name => p
1785 .
1785 name => syntax_error_at
1785 (
1785 name => semi
1785 .
1785 name => pos
1785 ,
1785 name => fmt
1785 .
1785 name => Sprintf
1785 (
1785 literal
1785 ,
1785 name => semi
1785 .
1785 name => lit
1785 )
1785 )
1785 ;
1786 }
1786 else
1786 {
1787 name => p
1787 .
1787 name => syntax_error_at
1787 (
1787 name => semi
1787 .
1787 name => pos
1787 ,
1787 literal
1787 )
1787 ;
1788 }
1788 ;
1789 }
1789 ;
1790 case
1790 *
1790 name => ExprStmt
1790 :
1791 name => cond
1791 =
1791 name => s
1791 .
1791 name => X
1791 ;
1792 default
1792 :
1793 name => p
1793 .
1793 name => syntax_error
1793 (
1793 name => fmt
1793 .
1793 name => Sprintf
1793 (
1793 literal
1793 ,
1793 name => String
1793 (
1793 name => s
1793 )
1793 )
1793 )
1793 ;
1794 }
1794 ;
1796 name => p
1796 .
1796 name => xnest
1796 =
1796 name => outer
1796 ;
1797 return
1797 ;
1798 }
1798 ;
1800 func
1800 (
1800 name => p
1800 *
1800 name => parser
1800 )
1800 name => ifStmt
1800 (
1800 )
1800 *
1800 name => IfStmt
1800 {
1801 if
1801 name => trace
1801 {
1802 defer
1802 name => p
1802 .
1802 name => trace
1802 (
1802 literal
1802 )
1802 (
1802 )
1802 ;
1803 }
1803 ;
1805 name => s
1805 :=
1805 name => new
1805 (
1805 name => IfStmt
1805 )
1805 ;
1806 name => s
1806 .
1806 name => pos
1806 =
1806 name => p
1806 .
1806 name => pos
1806 (
1806 )
1806 ;
1808 name => s
1808 .
1808 name => Init
1808 ,
1808 name => s
1808 .
1808 name => Cond
1808 ,
1808 name => _
1808 =
1808 name => p
1808 .
1808 name => header
1808 (
1808 name => _If
1808 )
1808 ;
1809 name => s
1809 .
1809 name => Then
1809 =
1809 name => p
1809 .
1809 name => blockStmt
1809 (
1809 literal
1809 )
1809 ;
1811 if
1811 name => p
1811 .
1811 name => got
1811 (
1811 name => _Else
1811 )
1811 {
1812 switch
1812 name => p
1812 .
1812 name => tok
1812 {
1813 case
1813 name => _If
1813 :
1814 name => s
1814 .
1814 name => Else
1814 =
1814 name => p
1814 .
1814 name => ifStmt
1814 (
1814 )
1814 ;
1815 case
1815 name => _Lbrace
1815 :
1816 name => s
1816 .
1816 name => Else
1816 =
1816 name => p
1816 .
1816 name => blockStmt
1816 (
1816 literal
1816 )
1816 ;
1817 default
1817 :
1818 name => p
1818 .
1818 name => syntax_error
1818 (
1818 literal
1818 )
1818 ;
1819 name => p
1819 .
1819 name => advance
1819 (
1819 name => _Name
1819 ,
1819 name => _Rbrace
1819 )
1819 ;
1820 }
1820 ;
1821 }
1821 ;
1823 return
1823 name => s
1823 ;
1824 }
1824 ;
1826 func
1826 (
1826 name => p
1826 *
1826 name => parser
1826 )
1826 name => switchStmt
1826 (
1826 )
1826 *
1826 name => SwitchStmt
1826 {
1827 if
1827 name => trace
1827 {
1828 defer
1828 name => p
1828 .
1828 name => trace
1828 (
1828 literal
1828 )
1828 (
1828 )
1828 ;
1829 }
1829 ;
1831 name => s
1831 :=
1831 name => new
1831 (
1831 name => SwitchStmt
1831 )
1831 ;
1832 name => s
1832 .
1832 name => pos
1832 =
1832 name => p
1832 .
1832 name => pos
1832 (
1832 )
1832 ;
1834 name => s
1834 .
1834 name => Init
1834 ,
1834 name => s
1834 .
1834 name => Tag
1834 ,
1834 name => _
1834 =
1834 name => p
1834 .
1834 name => header
1834 (
1834 name => _Switch
1834 )
1834 ;
1836 if
1836 op => ! 0
1836 name => p
1836 .
1836 name => got
1836 (
1836 name => _Lbrace
1836 )
1836 {
1837 name => p
1837 .
1837 name => syntax_error
1837 (
1837 literal
1837 )
1837 ;
1838 name => p
1838 .
1838 name => advance
1838 (
1838 name => _Case
1838 ,
1838 name => _Default
1838 ,
1838 name => _Rbrace
1838 )
1838 ;
1839 }
1839 ;
1840 for
1840 name => p
1840 .
1840 name => tok
1840 op => != 3
1840 name => _EOF
1840 op => && 2
1840 name => p
1840 .
1840 name => tok
1840 op => != 3
1840 name => _Rbrace
1840 {
1841 name => s
1841 .
1841 name => Body
1841 =
1841 name => append
1841 (
1841 name => s
1841 .
1841 name => Body
1841 ,
1841 name => p
1841 .
1841 name => caseClause
1841 (
1841 )
1841 )
1841 ;
1842 }
1842 ;
1843 name => s
1843 .
1843 name => Rbrace
1843 =
1843 name => p
1843 .
1843 name => pos
1843 (
1843 )
1843 ;
1844 name => p
1844 .
1844 name => want
1844 (
1844 name => _Rbrace
1844 )
1844 ;
1846 return
1846 name => s
1846 ;
1847 }
1847 ;
1849 func
1849 (
1849 name => p
1849 *
1849 name => parser
1849 )
1849 name => selectStmt
1849 (
1849 )
1849 *
1849 name => SelectStmt
1849 {
1850 if
1850 name => trace
1850 {
1851 defer
1851 name => p
1851 .
1851 name => trace
1851 (
1851 literal
1851 )
1851 (
1851 )
1851 ;
1852 }
1852 ;
1854 name => s
1854 :=
1854 name => new
1854 (
1854 name => SelectStmt
1854 )
1854 ;
1855 name => s
1855 .
1855 name => pos
1855 =
1855 name => p
1855 .
1855 name => pos
1855 (
1855 )
1855 ;
1857 name => p
1857 .
1857 name => want
1857 (
1857 name => _Select
1857 )
1857 ;
1858 if
1858 op => ! 0
1858 name => p
1858 .
1858 name => got
1858 (
1858 name => _Lbrace
1858 )
1858 {
1859 name => p
1859 .
1859 name => syntax_error
1859 (
1859 literal
1859 )
1859 ;
1860 name => p
1860 .
1860 name => advance
1860 (
1860 name => _Case
1860 ,
1860 name => _Default
1860 ,
1860 name => _Rbrace
1860 )
1860 ;
1861 }
1861 ;
1862 for
1862 name => p
1862 .
1862 name => tok
1862 op => != 3
1862 name => _EOF
1862 op => && 2
1862 name => p
1862 .
1862 name => tok
1862 op => != 3
1862 name => _Rbrace
1862 {
1863 name => s
1863 .
1863 name => Body
1863 =
1863 name => append
1863 (
1863 name => s
1863 .
1863 name => Body
1863 ,
1863 name => p
1863 .
1863 name => commClause
1863 (
1863 )
1863 )
1863 ;
1864 }
1864 ;
1865 name => s
1865 .
1865 name => Rbrace
1865 =
1865 name => p
1865 .
1865 name => pos
1865 (
1865 )
1865 ;
1866 name => p
1866 .
1866 name => want
1866 (
1866 name => _Rbrace
1866 )
1866 ;
1868 return
1868 name => s
1868 ;
1869 }
1869 ;
1871 func
1871 (
1871 name => p
1871 *
1871 name => parser
1871 )
1871 name => caseClause
1871 (
1871 )
1871 *
1871 name => CaseClause
1871 {
1872 if
1872 name => trace
1872 {
1873 defer
1873 name => p
1873 .
1873 name => trace
1873 (
1873 literal
1873 )
1873 (
1873 )
1873 ;
1874 }
1874 ;
1876 name => c
1876 :=
1876 name => new
1876 (
1876 name => CaseClause
1876 )
1876 ;
1877 name => c
1877 .
1877 name => pos
1877 =
1877 name => p
1877 .
1877 name => pos
1877 (
1877 )
1877 ;
1879 switch
1879 name => p
1879 .
1879 name => tok
1879 {
1880 case
1880 name => _Case
1880 :
1881 name => p
1881 .
1881 name => next
1881 (
1881 )
1881 ;
1882 name => c
1882 .
1882 name => Cases
1882 =
1882 name => p
1882 .
1882 name => exprList
1882 (
1882 )
1882 ;
1884 case
1884 name => _Default
1884 :
1885 name => p
1885 .
1885 name => next
1885 (
1885 )
1885 ;
1887 default
1887 :
1888 name => p
1888 .
1888 name => syntax_error
1888 (
1888 literal
1888 )
1888 ;
1889 name => p
1889 .
1889 name => advance
1889 (
1889 name => _Colon
1889 ,
1889 name => _Case
1889 ,
1889 name => _Default
1889 ,
1889 name => _Rbrace
1889 )
1889 ;
1890 }
1890 ;
1892 name => c
1892 .
1892 name => Colon
1892 =
1892 name => p
1892 .
1892 name => pos
1892 (
1892 )
1892 ;
1893 name => p
1893 .
1893 name => want
1893 (
1893 name => _Colon
1893 )
1893 ;
1894 name => c
1894 .
1894 name => Body
1894 =
1894 name => p
1894 .
1894 name => stmtList
1894 (
1894 )
1894 ;
1896 return
1896 name => c
1896 ;
1897 }
1897 ;
1899 func
1899 (
1899 name => p
1899 *
1899 name => parser
1899 )
1899 name => commClause
1899 (
1899 )
1899 *
1899 name => CommClause
1899 {
1900 if
1900 name => trace
1900 {
1901 defer
1901 name => p
1901 .
1901 name => trace
1901 (
1901 literal
1901 )
1901 (
1901 )
1901 ;
1902 }
1902 ;
1904 name => c
1904 :=
1904 name => new
1904 (
1904 name => CommClause
1904 )
1904 ;
1905 name => c
1905 .
1905 name => pos
1905 =
1905 name => p
1905 .
1905 name => pos
1905 (
1905 )
1905 ;
1907 switch
1907 name => p
1907 .
1907 name => tok
1907 {
1908 case
1908 name => _Case
1908 :
1909 name => p
1909 .
1909 name => next
1909 (
1909 )
1909 ;
1910 name => c
1910 .
1910 name => Comm
1910 =
1910 name => p
1910 .
1910 name => simpleStmt
1910 (
1910 name => nil
1910 ,
1910 name => false
1910 )
1910 ;
1924 case
1924 name => _Default
1924 :
1925 name => p
1925 .
1925 name => next
1925 (
1925 )
1925 ;
1927 default
1927 :
1928 name => p
1928 .
1928 name => syntax_error
1928 (
1928 literal
1928 )
1928 ;
1929 name => p
1929 .
1929 name => advance
1929 (
1929 name => _Colon
1929 ,
1929 name => _Case
1929 ,
1929 name => _Default
1929 ,
1929 name => _Rbrace
1929 )
1929 ;
1930 }
1930 ;
1932 name => c
1932 .
1932 name => Colon
1932 =
1932 name => p
1932 .
1932 name => pos
1932 (
1932 )
1932 ;
1933 name => p
1933 .
1933 name => want
1933 (
1933 name => _Colon
1933 )
1933 ;
1934 name => c
1934 .
1934 name => Body
1934 =
1934 name => p
1934 .
1934 name => stmtList
1934 (
1934 )
1934 ;
1936 return
1936 name => c
1936 ;
1937 }
1937 ;
1944 func
1944 (
1944 name => p
1944 *
1944 name => parser
1944 )
1944 name => stmtOrNil
1944 (
1944 )
1944 name => Stmt
1944 {
1945 if
1945 name => trace
1945 {
1946 defer
1946 name => p
1946 .
1946 name => trace
1946 (
1946 literal
1946 op => + 4
1946 name => p
1946 .
1946 name => tok
1946 .
1946 name => String
1946 (
1946 )
1946 )
1946 (
1946 )
1946 ;
1947 }
1947 ;
1951 if
1951 name => p
1951 .
1951 name => tok
1951 op => == 3
1951 name => _Name
1951 {
1952 name => lhs
1952 :=
1952 name => p
1952 .
1952 name => exprList
1952 (
1952 )
1952 ;
1953 if
1953 name => label
1953 ,
1953 name => ok
1953 :=
1953 name => lhs
1953 .
1953 (
1953 *
1953 name => Name
1953 )
1953 ;
1953 name => ok
1953 op => && 2
1953 name => p
1953 .
1953 name => tok
1953 op => == 3
1953 name => _Colon
1953 {
1954 return
1954 name => p
1954 .
1954 name => labeledStmtOrNil
1954 (
1954 name => label
1954 )
1954 ;
1955 }
1955 ;
1956 return
1956 name => p
1956 .
1956 name => simpleStmt
1956 (
1956 name => lhs
1956 ,
1956 name => false
1956 )
1956 ;
1957 }
1957 ;
1959 switch
1959 name => p
1959 .
1959 name => tok
1959 {
1960 case
1960 name => _Lbrace
1960 :
1961 return
1961 name => p
1961 .
1961 name => blockStmt
1961 (
1961 literal
1961 )
1961 ;
1963 case
1963 name => _Var
1963 :
1964 return
1964 name => p
1964 .
1964 name => declStmt
1964 (
1964 name => p
1964 .
1964 name => varDecl
1964 )
1964 ;
1966 case
1966 name => _Const
1966 :
1967 return
1967 name => p
1967 .
1967 name => declStmt
1967 (
1967 name => p
1967 .
1967 name => constDecl
1967 )
1967 ;
1969 case
1969 name => _Type
1969 :
1970 return
1970 name => p
1970 .
1970 name => declStmt
1970 (
1970 name => p
1970 .
1970 name => typeDecl
1970 )
1970 ;
1972 case
1972 name => _Operator
1972 ,
1972 name => _Star
1972 :
1973 switch
1973 name => p
1973 .
1973 name => op
1973 {
1974 case
1974 name => Add
1974 ,
1974 name => Sub
1974 ,
1974 name => Mul
1974 ,
1974 name => And
1974 ,
1974 name => Xor
1974 ,
1974 name => Not
1974 :
1975 return
1975 name => p
1975 .
1975 name => simpleStmt
1975 (
1975 name => nil
1975 ,
1975 name => false
1975 )
1975 ;
1976 }
1976 ;
1978 case
1978 name => _Literal
1978 ,
1978 name => _Func
1978 ,
1978 name => _Lparen
1978 ,
1979 name => _Lbrack
1979 ,
1979 name => _Struct
1979 ,
1979 name => _Map
1979 ,
1979 name => _Chan
1979 ,
1979 name => _Interface
1979 ,
1980 name => _Arrow
1980 :
1981 return
1981 name => p
1981 .
1981 name => simpleStmt
1981 (
1981 name => nil
1981 ,
1981 name => false
1981 )
1981 ;
1983 case
1983 name => _For
1983 :
1984 return
1984 name => p
1984 .
1984 name => forStmt
1984 (
1984 )
1984 ;
1986 case
1986 name => _Switch
1986 :
1987 return
1987 name => p
1987 .
1987 name => switchStmt
1987 (
1987 )
1987 ;
1989 case
1989 name => _Select
1989 :
1990 return
1990 name => p
1990 .
1990 name => selectStmt
1990 (
1990 )
1990 ;
1992 case
1992 name => _If
1992 :
1993 return
1993 name => p
1993 .
1993 name => ifStmt
1993 (
1993 )
1993 ;
1995 case
1995 name => _Fallthrough
1995 :
1996 name => s
1996 :=
1996 name => new
1996 (
1996 name => BranchStmt
1996 )
1996 ;
1997 name => s
1997 .
1997 name => pos
1997 =
1997 name => p
1997 .
1997 name => pos
1997 (
1997 )
1997 ;
1998 name => p
1998 .
1998 name => next
1998 (
1998 )
1998 ;
1999 name => s
1999 .
1999 name => Tok
1999 =
1999 name => _Fallthrough
1999 ;
2000 return
2000 name => s
2000 ;
2002 case
2002 name => _Break
2002 ,
2002 name => _Continue
2002 :
2003 name => s
2003 :=
2003 name => new
2003 (
2003 name => BranchStmt
2003 )
2003 ;
2004 name => s
2004 .
2004 name => pos
2004 =
2004 name => p
2004 .
2004 name => pos
2004 (
2004 )
2004 ;
2005 name => s
2005 .
2005 name => Tok
2005 =
2005 name => p
2005 .
2005 name => tok
2005 ;
2006 name => p
2006 .
2006 name => next
2006 (
2006 )
2006 ;
2007 if
2007 name => p
2007 .
2007 name => tok
2007 op => == 3
2007 name => _Name
2007 {
2008 name => s
2008 .
2008 name => Label
2008 =
2008 name => p
2008 .
2008 name => name
2008 (
2008 )
2008 ;
2009 }
2009 ;
2010 return
2010 name => s
2010 ;
2012 case
2012 name => _Go
2012 ,
2012 name => _Defer
2012 :
2013 return
2013 name => p
2013 .
2013 name => callStmt
2013 (
2013 )
2013 ;
2015 case
2015 name => _Goto
2015 :
2016 name => s
2016 :=
2016 name => new
2016 (
2016 name => BranchStmt
2016 )
2016 ;
2017 name => s
2017 .
2017 name => pos
2017 =
2017 name => p
2017 .
2017 name => pos
2017 (
2017 )
2017 ;
2018 name => s
2018 .
2018 name => Tok
2018 =
2018 name => _Goto
2018 ;
2019 name => p
2019 .
2019 name => next
2019 (
2019 )
2019 ;
2020 name => s
2020 .
2020 name => Label
2020 =
2020 name => p
2020 .
2020 name => name
2020 (
2020 )
2020 ;
2021 return
2021 name => s
2021 ;
2023 case
2023 name => _Return
2023 :
2024 name => s
2024 :=
2024 name => new
2024 (
2024 name => ReturnStmt
2024 )
2024 ;
2025 name => s
2025 .
2025 name => pos
2025 =
2025 name => p
2025 .
2025 name => pos
2025 (
2025 )
2025 ;
2026 name => p
2026 .
2026 name => next
2026 (
2026 )
2026 ;
2027 if
2027 name => p
2027 .
2027 name => tok
2027 op => != 3
2027 name => _Semi
2027 op => && 2
2027 name => p
2027 .
2027 name => tok
2027 op => != 3
2027 name => _Rbrace
2027 {
2028 name => s
2028 .
2028 name => Results
2028 =
2028 name => p
2028 .
2028 name => exprList
2028 (
2028 )
2028 ;
2029 }
2029 ;
2030 return
2030 name => s
2030 ;
2032 case
2032 name => _Semi
2032 :
2033 name => s
2033 :=
2033 name => new
2033 (
2033 name => EmptyStmt
2033 )
2033 ;
2034 name => s
2034 .
2034 name => pos
2034 =
2034 name => p
2034 .
2034 name => pos
2034 (
2034 )
2034 ;
2035 return
2035 name => s
2035 ;
2036 }
2036 ;
2038 return
2038 name => nil
2038 ;
2039 }
2039 ;
2042 func
2042 (
2042 name => p
2042 *
2042 name => parser
2042 )
2042 name => stmtList
2042 (
2042 )
2042 (
2042 name => l
2042 [
2042 ]
2042 name => Stmt
2042 )
2042 {
2043 if
2043 name => trace
2043 {
2044 defer
2044 name => p
2044 .
2044 name => trace
2044 (
2044 literal
2044 )
2044 (
2044 )
2044 ;
2045 }
2045 ;
2047 for
2047 name => p
2047 .
2047 name => tok
2047 op => != 3
2047 name => _EOF
2047 op => && 2
2047 name => p
2047 .
2047 name => tok
2047 op => != 3
2047 name => _Rbrace
2047 op => && 2
2047 name => p
2047 .
2047 name => tok
2047 op => != 3
2047 name => _Case
2047 op => && 2
2047 name => p
2047 .
2047 name => tok
2047 op => != 3
2047 name => _Default
2047 {
2048 name => s
2048 :=
2048 name => p
2048 .
2048 name => stmtOrNil
2048 (
2048 )
2048 ;
2049 if
2049 name => s
2049 op => == 3
2049 name => nil
2049 {
2050 break
2050 ;
2051 }
2051 ;
2052 name => l
2052 =
2052 name => append
2052 (
2052 name => l
2052 ,
2052 name => s
2052 )
2052 ;
2055 if
2055 name => p
2055 .
2055 name => tok
2055 op => == 3
2055 name => _Rparen
2055 op => || 1
2055 name => p
2055 .
2055 name => tok
2055 op => == 3
2055 name => _Rbrace
2055 {
2056 continue
2056 ;
2057 }
2057 ;
2058 if
2058 op => ! 0
2058 name => p
2058 .
2058 name => got
2058 (
2058 name => _Semi
2058 )
2058 {
2059 name => p
2059 .
2059 name => syntax_error
2059 (
2059 literal
2059 )
2059 ;
2060 name => p
2060 .
2060 name => advance
2060 (
2060 name => _Semi
2060 ,
2060 name => _Rbrace
2060 )
2060 ;
2061 }
2061 ;
2062 }
2062 ;
2063 return
2063 ;
2064 }
2064 ;
2067 func
2067 (
2067 name => p
2067 *
2067 name => parser
2067 )
2067 name => call
2067 (
2067 name => fun
2067 name => Expr
2067 )
2067 *
2067 name => CallExpr
2067 {
2068 if
2068 name => trace
2068 {
2069 defer
2069 name => p
2069 .
2069 name => trace
2069 (
2069 literal
2069 )
2069 (
2069 )
2069 ;
2070 }
2070 ;
2074 name => c
2074 :=
2074 name => new
2074 (
2074 name => CallExpr
2074 )
2074 ;
2075 name => c
2075 .
2075 name => pos
2075 =
2075 name => p
2075 .
2075 name => pos
2075 (
2075 )
2075 ;
2076 name => c
2076 .
2076 name => Fun
2076 =
2076 name => fun
2076 ;
2078 name => p
2078 .
2078 name => want
2078 (
2078 name => _Lparen
2078 )
2078 ;
2079 name => p
2079 .
2079 name => xnest
2079 opop
2079 ;
2081 for
2081 name => p
2081 .
2081 name => tok
2081 op => != 3
2081 name => _EOF
2081 op => && 2
2081 name => p
2081 .
2081 name => tok
2081 op => != 3
2081 name => _Rparen
2081 {
2082 name => c
2082 .
2082 name => ArgList
2082 =
2082 name => append
2082 (
2082 name => c
2082 .
2082 name => ArgList
2082 ,
2082 name => p
2082 .
2082 name => expr
2082 (
2082 )
2082 )
2082 ;
2083 name => c
2083 .
2083 name => HasDots
2083 =
2083 name => p
2083 .
2083 name => got
2083 (
2083 name => _DotDotDot
2083 )
2083 ;
2084 if
2084 op => ! 0
2084 name => p
2084 .
2084 name => ocomma
2084 (
2084 name => _Rparen
2084 )
2084 op => || 1
2084 name => c
2084 .
2084 name => HasDots
2084 {
2085 break
2085 ;
2086 }
2086 ;
2087 }
2087 ;
2089 name => p
2089 .
2089 name => xnest
2089 opop
2089 ;
2090 name => p
2090 .
2090 name => want
2090 (
2090 name => _Rparen
2090 )
2090 ;
2092 return
2092 name => c
2092 ;
2093 }
2093 ;
2098 func
2098 (
2098 name => p
2098 *
2098 name => parser
2098 )
2098 name => newName
2098 (
2098 name => value
2098 name => string
2098 )
2098 *
2098 name => Name
2098 {
2099 name => n
2099 :=
2099 name => new
2099 (
2099 name => Name
2099 )
2099 ;
2100 name => n
2100 .
2100 name => pos
2100 =
2100 name => p
2100 .
2100 name => pos
2100 (
2100 )
2100 ;
2101 name => n
2101 .
2101 name => Value
2101 =
2101 name => value
2101 ;
2102 return
2102 name => n
2102 ;
2103 }
2103 ;
2105 func
2105 (
2105 name => p
2105 *
2105 name => parser
2105 )
2105 name => name
2105 (
2105 )
2105 *
2105 name => Name
2105 {
2108 if
2108 name => p
2108 .
2108 name => tok
2108 op => == 3
2108 name => _Name
2108 {
2109 name => n
2109 :=
2109 name => p
2109 .
2109 name => newName
2109 (
2109 name => p
2109 .
2109 name => lit
2109 )
2109 ;
2110 name => p
2110 .
2110 name => next
2110 (
2110 )
2110 ;
2111 return
2111 name => n
2111 ;
2112 }
2112 ;
2114 name => n
2114 :=
2114 name => p
2114 .
2114 name => newName
2114 (
2114 literal
2114 )
2114 ;
2115 name => p
2115 .
2115 name => syntax_error
2115 (
2115 literal
2115 )
2115 ;
2116 name => p
2116 .
2116 name => advance
2116 (
2116 )
2116 ;
2117 return
2117 name => n
2117 ;
2118 }
2118 ;
2122 func
2122 (
2122 name => p
2122 *
2122 name => parser
2122 )
2122 name => nameList
2122 (
2122 name => first
2122 *
2122 name => Name
2122 )
2122 [
2122 ]
2122 *
2122 name => Name
2122 {
2123 if
2123 name => trace
2123 {
2124 defer
2124 name => p
2124 .
2124 name => trace
2124 (
2124 literal
2124 )
2124 (
2124 )
2124 ;
2125 }
2125 ;
2127 if
2127 name => debug
2127 op => && 2
2127 name => first
2127 op => == 3
2127 name => nil
2127 {
2128 name => panic
2128 (
2128 literal
2128 )
2128 ;
2129 }
2129 ;
2131 name => l
2131 :=
2131 [
2131 ]
2131 *
2131 name => Name
2131 {
2131 name => first
2131 }
2131 ;
2132 for
2132 name => p
2132 .
2132 name => got
2132 (
2132 name => _Comma
2132 )
2132 {
2133 name => l
2133 =
2133 name => append
2133 (
2133 name => l
2133 ,
2133 name => p
2133 .
2133 name => name
2133 (
2133 )
2133 )
2133 ;
2134 }
2134 ;
2136 return
2136 name => l
2136 ;
2137 }
2137 ;
2140 func
2140 (
2140 name => p
2140 *
2140 name => parser
2140 )
2140 name => qualifiedName
2140 (
2140 name => name
2140 *
2140 name => Name
2140 )
2140 name => Expr
2140 {
2141 if
2141 name => trace
2141 {
2142 defer
2142 name => p
2142 .
2142 name => trace
2142 (
2142 literal
2142 )
2142 (
2142 )
2142 ;
2143 }
2143 ;
2145 switch
2145 {
2146 case
2146 name => name
2146 op => != 3
2146 name => nil
2146 :
2148 case
2148 name => p
2148 .
2148 name => tok
2148 op => == 3
2148 name => _Name
2148 :
2149 name => name
2149 =
2149 name => p
2149 .
2149 name => name
2149 (
2149 )
2149 ;
2150 default
2150 :
2151 name => name
2151 =
2151 name => p
2151 .
2151 name => newName
2151 (
2151 literal
2151 )
2151 ;
2152 name => p
2152 .
2152 name => syntax_error
2152 (
2152 literal
2152 )
2152 ;
2153 name => p
2153 .
2153 name => advance
2153 (
2153 name => _Dot
2153 ,
2153 name => _Semi
2153 ,
2153 name => _Rbrace
2153 )
2153 ;
2154 }
2154 ;
2156 return
2156 name => p
2156 .
2156 name => dotname
2156 (
2156 name => name
2156 )
2156 ;
2157 }
2157 ;
2160 func
2160 (
2160 name => p
2160 *
2160 name => parser
2160 )
2160 name => exprList
2160 (
2160 )
2160 name => Expr
2160 {
2161 if
2161 name => trace
2161 {
2162 defer
2162 name => p
2162 .
2162 name => trace
2162 (
2162 literal
2162 )
2162 (
2162 )
2162 ;
2163 }
2163 ;
2165 name => x
2165 :=
2165 name => p
2165 .
2165 name => expr
2165 (
2165 )
2165 ;
2166 if
2166 name => p
2166 .
2166 name => got
2166 (
2166 name => _Comma
2166 )
2166 {
2167 name => list
2167 :=
2167 [
2167 ]
2167 name => Expr
2167 {
2167 name => x
2167 ,
2167 name => p
2167 .
2167 name => expr
2167 (
2167 )
2167 }
2167 ;
2168 for
2168 name => p
2168 .
2168 name => got
2168 (
2168 name => _Comma
2168 )
2168 {
2169 name => list
2169 =
2169 name => append
2169 (
2169 name => list
2169 ,
2169 name => p
2169 .
2169 name => expr
2169 (
2169 )
2169 )
2169 ;
2170 }
2170 ;
2171 name => t
2171 :=
2171 name => new
2171 (
2171 name => ListExpr
2171 )
2171 ;
2172 name => t
2172 .
2172 name => pos
2172 =
2172 name => x
2172 .
2172 name => Pos
2172 (
2172 )
2172 ;
2173 name => t
2173 .
2173 name => ElemList
2173 =
2173 name => list
2173 ;
2174 name => x
2174 =
2174 name => t
2174 ;
2175 }
2175 ;
2176 return
2176 name => x
2176 ;
2177 }
2177 ;
2180 func
2180 (
2180 name => p
2180 *
2180 name => parser
2180 )
2180 name => osemi
2180 (
2180 name => follow
2180 name => token
2180 )
2180 name => bool
2180 {
2181 switch
2181 name => p
2181 .
2181 name => tok
2181 {
2182 case
2182 name => _Semi
2182 :
2183 name => p
2183 .
2183 name => next
2183 (
2183 )
2183 ;
2184 return
2184 name => true
2184 ;
2186 case
2186 name => _Rparen
2186 ,
2186 name => _Rbrace
2186 :
2188 return
2188 name => true
2188 ;
2189 }
2189 ;
2191 name => p
2191 .
2191 name => syntax_error
2191 (
2191 literal
2191 op => + 4
2191 name => tokstring
2191 (
2191 name => follow
2191 )
2191 )
2191 ;
2192 name => p
2192 .
2192 name => advance
2192 (
2192 name => follow
2192 )
2192 ;
2193 return
2193 name => false
2193 ;
2194 }
2194 ;
2197 func
2197 (
2197 name => p
2197 *
2197 name => parser
2197 )
2197 name => ocomma
2197 (
2197 name => follow
2197 name => token
2197 )
2197 name => bool
2197 {
2198 switch
2198 name => p
2198 .
2198 name => tok
2198 {
2199 case
2199 name => _Comma
2199 :
2200 name => p
2200 .
2200 name => next
2200 (
2200 )
2200 ;
2201 return
2201 name => true
2201 ;
2203 case
2203 name => _Rparen
2203 ,
2203 name => _Rbrace
2203 :
2205 return
2205 name => true
2205 ;
2206 }
2206 ;
2208 name => p
2208 .
2208 name => syntax_error
2208 (
2208 literal
2208 op => + 4
2208 name => tokstring
2208 (
2208 name => follow
2208 )
2208 )
2208 ;
2209 name => p
2209 .
2209 name => advance
2209 (
2209 name => follow
2209 )
2209 ;
2210 return
2210 name => false
2210 ;
2211 }
2211 ;
2214 func
2214 name => unparen
2214 (
2214 name => x
2214 name => Expr
2214 )
2214 name => Expr
2214 {
2215 for
2215 {
2216 name => p
2216 ,
2216 name => ok
2216 :=
2216 name => x
2216 .
2216 (
2216 *
2216 name => ParenExpr
2216 )
2216 ;
2217 if
2217 op => ! 0
2217 name => ok
2217 {
2218 break
2218 ;
2219 }
2219 ;
2220 name => x
2220 =
2220 name => p
2220 .
2220 name => X
2220 ;
2221 }
2221 ;
2222 return
2222 name => x
2222 ;
2223 }
2223 ;
FAIL
exit status 1
FAIL	cmd/compile/internal/syntax	1.461s
goos: linux
goarch: amd64
pkg: cmd/compile/internal/test
BenchmarkDivconstI64-12    	2000000000	         0.99 ns/op
BenchmarkDivconstU64-12    	1000000000	         1.10 ns/op
BenchmarkDivconstI32-12    	2000000000	         0.76 ns/op
BenchmarkDivconstU32-12    	2000000000	         0.97 ns/op
BenchmarkDivconstI16-12    	2000000000	         0.78 ns/op
BenchmarkDivconstU16-12    	2000000000	         0.60 ns/op
BenchmarkDivconstI8-12     	2000000000	         0.85 ns/op
BenchmarkDivconstU8-12     	2000000000	         0.54 ns/op
PASS
ok  	cmd/compile/internal/test	13.180s
PASS
ok  	cmd/compile/internal/types	0.010s
?   	cmd/compile/internal/x86	[no test files]
PASS
ok  	cmd/cover	0.807s
?   	cmd/dist	[no test files]
PASS
ok  	cmd/doc	0.126s
PASS
ok  	cmd/fix	0.017s
PASS
ok  	cmd/go	171.067s
?   	cmd/go/internal/base	[no test files]
?   	cmd/go/internal/bug	[no test files]
?   	cmd/go/internal/buildid	[no test files]
?   	cmd/go/internal/cfg	[no test files]
?   	cmd/go/internal/clean	[no test files]
?   	cmd/go/internal/cmdflag	[no test files]
?   	cmd/go/internal/doc	[no test files]
?   	cmd/go/internal/envcmd	[no test files]
?   	cmd/go/internal/fix	[no test files]
?   	cmd/go/internal/fmtcmd	[no test files]
PASS
ok  	cmd/go/internal/generate	0.020s
PASS
ok  	cmd/go/internal/get	9.872s
?   	cmd/go/internal/help	[no test files]
?   	cmd/go/internal/list	[no test files]
PASS
ok  	cmd/go/internal/load	0.034s
?   	cmd/go/internal/run	[no test files]
?   	cmd/go/internal/str	[no test files]
?   	cmd/go/internal/test	[no test files]
?   	cmd/go/internal/tool	[no test files]
?   	cmd/go/internal/version	[no test files]
?   	cmd/go/internal/vet	[no test files]
?   	cmd/go/internal/web	[no test files]
PASS
ok  	cmd/go/internal/work	0.041s
PASS
ok  	cmd/gofmt	3.414s
?   	cmd/internal/bio	[no test files]
?   	cmd/internal/browser	[no test files]
PASS
ok  	cmd/internal/dwarf	0.019s
?   	cmd/internal/gcprog	[no test files]
?   	cmd/internal/goobj	[no test files]
PASS
ok  	cmd/internal/obj	0.015s
?   	cmd/internal/obj/arm	[no test files]
PASS
ok  	cmd/internal/obj/arm64	0.996s
?   	cmd/internal/obj/mips	[no test files]
?   	cmd/internal/obj/ppc64	[no test files]
?   	cmd/internal/obj/s390x	[no test files]
PASS
ok  	cmd/internal/obj/x86	0.200s
PASS
ok  	cmd/internal/objabi	0.010s
?   	cmd/internal/objfile	[no test files]
PASS
ok  	cmd/internal/src	0.010s
?   	cmd/internal/sys	[no test files]
PASS
ok  	cmd/link	1.799s
?   	cmd/link/internal/amd64	[no test files]
?   	cmd/link/internal/arm	[no test files]
?   	cmd/link/internal/arm64	[no test files]
PASS
ok  	cmd/link/internal/ld	1.710s
?   	cmd/link/internal/mips	[no test files]
?   	cmd/link/internal/mips64	[no test files]
?   	cmd/link/internal/ppc64	[no test files]
?   	cmd/link/internal/s390x	[no test files]
?   	cmd/link/internal/x86	[no test files]
PASS
ok  	cmd/nm	1.100s
PASS
ok  	cmd/objdump	0.830s
PASS
ok  	cmd/pack	0.669s
?   	cmd/pprof	[no test files]
PASS
ok  	cmd/trace	0.031s
PASS
ok  	cmd/vet	1.166s
PASS
ok  	cmd/vet/internal/cfg	0.019s
?   	cmd/vet/internal/whitelist	[no test files]
goos: linux
goarch: amd64
pkg: compress/bzip2
BenchmarkDecodeDigits-12    	     200	   6866723 ns/op	  14.56 MB/s	 3613273 B/op	      40 allocs/op
BenchmarkDecodeTwain-12     	     100	  24649501 ns/op	  15.73 MB/s	 3625882 B/op	      40 allocs/op
BenchmarkDecodeRand-12      	     500	   2082251 ns/op	   7.87 MB/s	 3644418 B/op	      40 allocs/op
PASS
ok  	compress/bzip2	5.943s
goos: linux
goarch: amd64
pkg: compress/flate
BenchmarkDecode/Digits/Huffman/1e4-12         	   10000	    194445 ns/op	  51.43 MB/s	   40634 B/op	       5 allocs/op
BenchmarkDecode/Digits/Huffman/1e5-12         	    1000	   1863839 ns/op	  53.65 MB/s	   40645 B/op	       5 allocs/op
BenchmarkDecode/Digits/Huffman/1e6-12         	     100	  12143147 ns/op	  82.35 MB/s	   40723 B/op	       5 allocs/op
BenchmarkDecode/Digits/Speed/1e4-12           	    5000	    239470 ns/op	  41.76 MB/s	   40715 B/op	       8 allocs/op
BenchmarkDecode/Digits/Speed/1e5-12           	    1000	   1983200 ns/op	  50.42 MB/s	   40933 B/op	      11 allocs/op
BenchmarkDecode/Digits/Speed/1e6-12           	     100	  13342994 ns/op	  74.95 MB/s	   44483 B/op	      73 allocs/op
BenchmarkDecode/Digits/Default/1e4-12         	   10000	    147438 ns/op	  67.82 MB/s	   40685 B/op	       7 allocs/op
BenchmarkDecode/Digits/Default/1e5-12         	    1000	   1395343 ns/op	  71.67 MB/s	   40933 B/op	      13 allocs/op
BenchmarkDecode/Digits/Default/1e6-12         	     100	  11917546 ns/op	  83.91 MB/s	   44899 B/op	      79 allocs/op
BenchmarkDecode/Digits/Compression/1e4-12     	   10000	    207445 ns/op	  48.21 MB/s	   40683 B/op	       7 allocs/op
BenchmarkDecode/Digits/Compression/1e5-12     	    1000	   1395279 ns/op	  71.67 MB/s	   40933 B/op	      13 allocs/op
BenchmarkDecode/Digits/Compression/1e6-12     	     100	  11554671 ns/op	  86.55 MB/s	   44899 B/op	      79 allocs/op
BenchmarkDecode/Twain/Huffman/1e4-12          	   10000	    212448 ns/op	  47.07 MB/s	   42023 B/op	      15 allocs/op
BenchmarkDecode/Twain/Huffman/1e5-12          	    1000	   1644557 ns/op	  60.81 MB/s	   43485 B/op	      20 allocs/op
BenchmarkDecode/Twain/Huffman/1e6-12          	     100	  14545436 ns/op	  68.75 MB/s	   71714 B/op	     134 allocs/op
BenchmarkDecode/Twain/Speed/1e4-12            	   10000	    223660 ns/op	  44.71 MB/s	   41287 B/op	      17 allocs/op
BenchmarkDecode/Twain/Speed/1e5-12            	    1000	   1557599 ns/op	  64.20 MB/s	   45128 B/op	      30 allocs/op
BenchmarkDecode/Twain/Speed/1e6-12            	     100	  13970809 ns/op	  71.58 MB/s	   72797 B/op	     193 allocs/op
BenchmarkDecode/Twain/Default/1e4-12          	    5000	    248117 ns/op	  40.30 MB/s	   41287 B/op	      17 allocs/op
BenchmarkDecode/Twain/Default/1e5-12          	    1000	   1602382 ns/op	  62.41 MB/s	   44368 B/op	      28 allocs/op
BenchmarkDecode/Twain/Default/1e6-12          	     100	  12630902 ns/op	  79.17 MB/s	   71117 B/op	     199 allocs/op
BenchmarkDecode/Twain/Compression/1e4-12      	    5000	    234278 ns/op	  42.68 MB/s	   41287 B/op	      17 allocs/op
BenchmarkDecode/Twain/Compression/1e5-12      	    1000	   1334521 ns/op	  74.93 MB/s	   43334 B/op	      28 allocs/op
BenchmarkDecode/Twain/Compression/1e6-12      	     100	  10346152 ns/op	  96.65 MB/s	   69176 B/op	     196 allocs/op
BenchmarkEncode/Digits/Huffman/1e4-12         	   50000	     33460 ns/op	 298.86 MB/s
BenchmarkEncode/Digits/Huffman/1e5-12         	    5000	    302985 ns/op	 330.05 MB/s
BenchmarkEncode/Digits/Huffman/1e6-12         	     500	   3218938 ns/op	 310.66 MB/s
BenchmarkEncode/Digits/Speed/1e4-12           	   10000	    199020 ns/op	  50.25 MB/s
BenchmarkEncode/Digits/Speed/1e5-12           	    1000	   1889241 ns/op	  52.93 MB/s
BenchmarkEncode/Digits/Speed/1e6-12           	     100	  15906590 ns/op	  62.87 MB/s
BenchmarkEncode/Digits/Default/1e4-12         	    5000	    288594 ns/op	  34.65 MB/s
BenchmarkEncode/Digits/Default/1e5-12         	     300	   4977953 ns/op	  20.09 MB/s
BenchmarkEncode/Digits/Default/1e6-12         	      20	  50647826 ns/op	  19.74 MB/s
BenchmarkEncode/Digits/Compression/1e4-12     	    5000	    292081 ns/op	  34.24 MB/s
BenchmarkEncode/Digits/Compression/1e5-12     	     300	   5134303 ns/op	  19.48 MB/s
BenchmarkEncode/Digits/Compression/1e6-12     	      20	  52098869 ns/op	  19.19 MB/s
BenchmarkEncode/Twain/Huffman/1e4-12          	   30000	     46783 ns/op	 213.75 MB/s
BenchmarkEncode/Twain/Huffman/1e5-12          	    3000	    336996 ns/op	 296.74 MB/s
BenchmarkEncode/Twain/Huffman/1e6-12          	     500	   3309879 ns/op	 302.13 MB/s
BenchmarkEncode/Twain/Speed/1e4-12            	   10000	    158863 ns/op	  62.95 MB/s
BenchmarkEncode/Twain/Speed/1e5-12            	    1000	   1445143 ns/op	  69.20 MB/s
BenchmarkEncode/Twain/Speed/1e6-12            	     100	  13836198 ns/op	  72.27 MB/s
BenchmarkEncode/Twain/Default/1e4-12          	    5000	    331088 ns/op	  30.20 MB/s
BenchmarkEncode/Twain/Default/1e5-12          	     200	   5569633 ns/op	  17.95 MB/s
BenchmarkEncode/Twain/Default/1e6-12          	      30	  57497712 ns/op	  17.39 MB/s
BenchmarkEncode/Twain/Compression/1e4-12      	    5000	    364215 ns/op	  27.46 MB/s
BenchmarkEncode/Twain/Compression/1e5-12      	     200	   6434150 ns/op	  15.54 MB/s
BenchmarkEncode/Twain/Compression/1e6-12      	      20	  69437315 ns/op	  14.40 MB/s
PASS
ok  	compress/flate	92.115s
PASS
ok  	compress/gzip	0.017s
goos: linux
goarch: amd64
pkg: compress/lzw
BenchmarkDecoder/1e4-12         	   10000	    138785 ns/op	  72.05 MB/s
BenchmarkDecoder/1e5-12         	    2000	   1189799 ns/op	  84.05 MB/s
BenchmarkDecoder/1e6-12         	     100	  10108192 ns/op	  98.93 MB/s
BenchmarkEncoder/1e4-12         	    5000	    267091 ns/op	  37.44 MB/s
BenchmarkEncoder/1e5-12         	    1000	   1949458 ns/op	  51.30 MB/s
BenchmarkEncoder/1e6-12         	     100	  15039948 ns/op	  66.49 MB/s
PASS
ok  	compress/lzw	11.075s
PASS
ok  	compress/zlib	0.521s
goos: linux
goarch: amd64
pkg: container/heap
BenchmarkDup-12    	    5000	    326731 ns/op
PASS
ok  	container/heap	1.679s
PASS
ok  	container/list	0.028s
PASS
ok  	container/ring	0.023s
goos: linux
goarch: amd64
pkg: context
BenchmarkContextCancelTree/depth=1/Root=Background-12         	10000000	       170 ns/op
BenchmarkContextCancelTree/depth=1/Root=OpenCanceler-12       	 1000000	      1225 ns/op
BenchmarkContextCancelTree/depth=1/Root=ClosedCanceler-12     	 3000000	       507 ns/op
BenchmarkContextCancelTree/depth=10/Root=Background-12        	  200000	      7065 ns/op
BenchmarkContextCancelTree/depth=10/Root=OpenCanceler-12      	  200000	     10527 ns/op
BenchmarkContextCancelTree/depth=10/Root=ClosedCanceler-12    	  500000	      3198 ns/op
BenchmarkContextCancelTree/depth=100/Root=Background-12       	   20000	     72024 ns/op
BenchmarkContextCancelTree/depth=100/Root=OpenCanceler-12     	   10000	    100113 ns/op
BenchmarkContextCancelTree/depth=100/Root=ClosedCanceler-12   	   50000	     36003 ns/op
BenchmarkContextCancelTree/depth=1000/Root=Background-12      	    1000	   1421638 ns/op
BenchmarkContextCancelTree/depth=1000/Root=OpenCanceler-12    	    1000	   2028288 ns/op
BenchmarkContextCancelTree/depth=1000/Root=ClosedCanceler-12  	    2000	    591366 ns/op
PASS
ok  	context	24.309s
?   	crypto	[no test files]
goos: linux
goarch: amd64
pkg: crypto/aes
BenchmarkEncrypt-12    	100000000	        17.6 ns/op	 907.94 MB/s
BenchmarkDecrypt-12    	100000000	        12.5 ns/op	1284.17 MB/s
BenchmarkExpand-12     	30000000	        40.1 ns/op
PASS
ok  	crypto/aes	4.350s
goos: linux
goarch: amd64
pkg: crypto/cipher
BenchmarkAESGCMSeal1K-12       	 5000000	       344 ns/op	2976.59 MB/s
BenchmarkAESGCMOpen1K-12       	 5000000	       362 ns/op	2828.36 MB/s
BenchmarkAESGCMSeal8K-12       	  500000	      2941 ns/op	2785.41 MB/s
BenchmarkAESGCMOpen8K-12       	  500000	      2540 ns/op	3225.01 MB/s
BenchmarkAESCFBEncrypt1K-12    	  500000	      3324 ns/op	 306.52 MB/s
BenchmarkAESCFBDecrypt1K-12    	  500000	      3197 ns/op	 318.72 MB/s
BenchmarkAESOFB1K-12           	 1000000	      1836 ns/op	 554.73 MB/s
BenchmarkAESCTR1K-12           	 1000000	      1813 ns/op	 561.96 MB/s
BenchmarkAESCBCEncrypt1K-12    	 1000000	      2745 ns/op	 373.00 MB/s
BenchmarkAESCBCDecrypt1K-12    	  500000	      2457 ns/op	 416.73 MB/s
PASS
ok  	crypto/cipher	18.772s
goos: linux
goarch: amd64
pkg: crypto/des
BenchmarkEncrypt-12        	10000000	       160 ns/op	  49.92 MB/s
BenchmarkDecrypt-12        	10000000	       153 ns/op	  52.09 MB/s
BenchmarkTDESEncrypt-12    	 5000000	       359 ns/op	  22.25 MB/s
BenchmarkTDESDecrypt-12    	 5000000	       356 ns/op	  22.41 MB/s
PASS
ok  	crypto/des	7.797s
PASS
ok  	crypto/dsa	7.774s
goos: linux
goarch: amd64
pkg: crypto/ecdsa
BenchmarkSignP256-12         	   30000	     47009 ns/op
BenchmarkSignP384-12         	     200	   8668612 ns/op
BenchmarkVerifyP256-12       	   10000	    129171 ns/op
BenchmarkKeyGeneration-12    	   50000	     32325 ns/op
PASS
ok  	crypto/ecdsa	10.791s
goos: linux
goarch: amd64
pkg: crypto/elliptic
BenchmarkBaseMult-12          	    2000	    759100 ns/op
BenchmarkBaseMultP256-12      	  100000	     21677 ns/op
BenchmarkScalarMultP256-12    	   20000	     96335 ns/op
PASS
ok  	crypto/elliptic	9.093s
goos: linux
goarch: amd64
pkg: crypto/hmac
BenchmarkHMACSHA256_1K-12    	  500000	      4024 ns/op	 254.42 MB/s
BenchmarkHMACSHA256_32-12    	 1000000	      1100 ns/op	  29.08 MB/s
PASS
ok  	crypto/hmac	4.617s
?   	crypto/internal/cipherhw	[no test files]
goos: linux
goarch: amd64
pkg: crypto/md5
BenchmarkHash8Bytes-12             	10000000	       140 ns/op	  57.00 MB/s
BenchmarkHash1K-12                 	 1000000	      1559 ns/op	 656.50 MB/s
BenchmarkHash8K-12                 	  200000	     10856 ns/op	 754.57 MB/s
BenchmarkHash8BytesUnaligned-12    	10000000	       139 ns/op	  57.47 MB/s
BenchmarkHash1KUnaligned-12        	 1000000	      1619 ns/op	 632.18 MB/s
BenchmarkHash8KUnaligned-12        	  100000	     12438 ns/op	 658.60 MB/s
PASS
ok  	crypto/md5	11.532s
goos: linux
goarch: amd64
pkg: crypto/rand
BenchmarkPrime-12    	      20	 120659859 ns/op
PASS
ok  	crypto/rand	3.011s
goos: linux
goarch: amd64
pkg: crypto/rc4
BenchmarkRC4_128-12    	10000000	       181 ns/op	 704.14 MB/s
BenchmarkRC4_1K-12     	 1000000	      1424 ns/op	 718.80 MB/s
BenchmarkRC4_8K-12     	  100000	     11282 ns/op	 717.56 MB/s
PASS
ok  	crypto/rc4	5.719s
goos: linux
goarch: amd64
pkg: crypto/rsa
BenchmarkRSA2048Decrypt-12          	     500	   2242434 ns/op
BenchmarkRSA2048Sign-12             	     500	   3061665 ns/op
Benchmark3PrimeRSA2048Decrypt-12    	    1000	   1473523 ns/op
PASS
ok  	crypto/rsa	5.592s
goos: linux
goarch: amd64
pkg: crypto/sha1
BenchmarkHash8Bytes-12      	10000000	       174 ns/op	  45.84 MB/s
BenchmarkHash320Bytes-12    	 2000000	       833 ns/op	 383.97 MB/s
BenchmarkHash1K-12          	 1000000	      1380 ns/op	 741.91 MB/s
BenchmarkHash8K-12          	  200000	      8566 ns/op	 956.30 MB/s
PASS
ok  	crypto/sha1	9.351s
goos: linux
goarch: amd64
pkg: crypto/sha256
BenchmarkHash8Bytes-12    	 5000000	       257 ns/op	  31.07 MB/s
BenchmarkHash1K-12        	  500000	      2964 ns/op	 345.47 MB/s
BenchmarkHash8K-12        	   50000	     22622 ns/op	 362.12 MB/s
PASS
ok  	crypto/sha256	5.247s
goos: linux
goarch: amd64
pkg: crypto/sha512
BenchmarkHash8Bytes-12    	 5000000	       342 ns/op	  23.33 MB/s
BenchmarkHash1K-12        	 1000000	      2188 ns/op	 468.00 MB/s
BenchmarkHash8K-12        	   50000	     25391 ns/op	 322.63 MB/s
PASS
ok  	crypto/sha512	7.622s
PASS
ok  	crypto/subtle	0.033s
goos: linux
goarch: amd64
pkg: crypto/tls
BenchmarkThroughput/MaxPacket/1MB-12         	     300	   4333669 ns/op	 241.96 MB/s
BenchmarkThroughput/MaxPacket/2MB-12         	     200	   9419121 ns/op	 222.65 MB/s
BenchmarkThroughput/MaxPacket/4MB-12         	     100	  19765570 ns/op	 212.20 MB/s
BenchmarkThroughput/MaxPacket/8MB-12         	      50	  39816089 ns/op	 210.68 MB/s
BenchmarkThroughput/MaxPacket/16MB-12        	      20	  83666637 ns/op	 200.52 MB/s
BenchmarkThroughput/MaxPacket/32MB-12        	      10	 149540050 ns/op	 224.38 MB/s
BenchmarkThroughput/MaxPacket/64MB-12        	       5	 332139805 ns/op	 202.05 MB/s
BenchmarkThroughput/DynamicPacket/1MB-12     	     300	   4476666 ns/op	 234.23 MB/s
BenchmarkThroughput/DynamicPacket/2MB-12     	     200	   7034269 ns/op	 298.13 MB/s
BenchmarkThroughput/DynamicPacket/4MB-12     	     100	  18605622 ns/op	 225.43 MB/s
BenchmarkThroughput/DynamicPacket/8MB-12     	      50	  35675439 ns/op	 235.14 MB/s
BenchmarkThroughput/DynamicPacket/16MB-12    	      20	  61057118 ns/op	 274.78 MB/s
BenchmarkThroughput/DynamicPacket/32MB-12    	      10	 184835696 ns/op	 181.54 MB/s
BenchmarkThroughput/DynamicPacket/64MB-12    	       3	 376132249 ns/op	 178.42 MB/s
BenchmarkLatency/MaxPacket/200kbps-12        	       2	 696875860 ns/op
BenchmarkLatency/MaxPacket/500kbps-12        	       5	 280171015 ns/op
BenchmarkLatency/MaxPacket/1000kbps-12       	      10	 142479679 ns/op
BenchmarkLatency/MaxPacket/2000kbps-12       	      20	  72806791 ns/op
BenchmarkLatency/MaxPacket/5000kbps-12       	      50	  30666176 ns/op
BenchmarkLatency/DynamicPacket/200kbps-12    	      10	 136303176 ns/op
BenchmarkLatency/DynamicPacket/500kbps-12    	      20	  56125577 ns/op
BenchmarkLatency/DynamicPacket/1000kbps-12   	      50	  29248743 ns/op
BenchmarkLatency/DynamicPacket/2000kbps-12   	     100	  16668006 ns/op
BenchmarkLatency/DynamicPacket/5000kbps-12   	     200	   8253914 ns/op
PASS
ok  	crypto/tls	49.094s
PASS
ok  	crypto/x509	0.718s
?   	crypto/x509/pkix	[no test files]
goos: linux
goarch: amd64
pkg: database/sql
BenchmarkConcurrentDBExec-12         	     200	   9570382 ns/op	 2634901 B/op	   15137 allocs/op
BenchmarkConcurrentStmtQuery-12      	     200	   7993325 ns/op	 2457562 B/op	   18652 allocs/op
BenchmarkConcurrentStmtExec-12       	     200	   6784327 ns/op	 1844835 B/op	    3670 allocs/op
BenchmarkConcurrentTxQuery-12        	     200	   7739296 ns/op	 2585497 B/op	   21152 allocs/op
BenchmarkConcurrentTxExec-12         	     500	   2087208 ns/op	  598828 B/op	   14644 allocs/op
BenchmarkConcurrentTxStmtQuery-12    	     500	   2690212 ns/op	  784832 B/op	   19154 allocs/op
BenchmarkConcurrentTxStmtExec-12     	    2000	    836532 ns/op	  115837 B/op	    2670 allocs/op
BenchmarkConcurrentRandom-12         	     200	   7582857 ns/op	 1763474 B/op	   14692 allocs/op
BenchmarkManyConcurrentQueries-12    	   50000	     20041 ns/op	    4025 B/op	      22 allocs/op
PASS
ok  	database/sql	19.214s
PASS
ok  	database/sql/driver	0.010s
PASS
ok  	debug/dwarf	0.017s
PASS
ok  	debug/elf	0.020s
PASS
ok  	debug/gosym	0.116s
PASS
ok  	debug/macho	0.016s
PASS
ok  	debug/pe	0.022s
PASS
ok  	debug/plan9obj	0.011s
?   	encoding	[no test files]
PASS
ok  	encoding/ascii85	0.012s
goos: linux
goarch: amd64
pkg: encoding/asn1
BenchmarkMarshal-12    	   50000	     54127 ns/op	    7664 B/op	     311 allocs/op
PASS
ok  	encoding/asn1	3.061s
goos: linux
goarch: amd64
pkg: encoding/base32
BenchmarkEncodeToString-12    	   30000	     58115 ns/op	 140.96 MB/s
BenchmarkDecodeString-12      	   10000	    171270 ns/op	  76.56 MB/s
PASS
ok  	encoding/base32	4.072s
goos: linux
goarch: amd64
pkg: encoding/base64
BenchmarkEncodeToString-12    	  100000	     20885 ns/op	 392.23 MB/s
BenchmarkDecodeString/2-12    	20000000	        57.4 ns/op	  69.72 MB/s
BenchmarkDecodeString/4-12    	20000000	        92.8 ns/op	  86.18 MB/s
BenchmarkDecodeString/8-12    	10000000	       113 ns/op	 105.61 MB/s
BenchmarkDecodeString/64-12   	 2000000	       698 ns/op	 125.91 MB/s
BenchmarkDecodeString/8192-12 	   20000	     66540 ns/op	 164.17 MB/s
PASS
ok  	encoding/base64	11.041s
goos: linux
goarch: amd64
pkg: encoding/binary
BenchmarkReadSlice1000Int32s-12     	  200000	     11236 ns/op	 355.99 MB/s
BenchmarkReadStruct-12              	  500000	      2062 ns/op	  36.36 MB/s
BenchmarkReadInts-12                	 2000000	       665 ns/op	  45.11 MB/s
BenchmarkWriteInts-12               	 2000000	       707 ns/op	  42.38 MB/s
BenchmarkWriteSlice1000Int32s-12    	  200000	     10858 ns/op	 368.37 MB/s
BenchmarkPutUint16-12               	2000000000	         0.43 ns/op	4636.27 MB/s
BenchmarkPutUint32-12               	2000000000	         0.51 ns/op	7808.54 MB/s
BenchmarkPutUint64-12               	2000000000	         0.54 ns/op	14932.75 MB/s
BenchmarkPutUvarint32-12            	50000000	        26.9 ns/op	 148.79 MB/s
BenchmarkPutUvarint64-12            	20000000	        70.4 ns/op	 113.56 MB/s
PASS
ok  	encoding/binary	16.812s
goos: linux
goarch: amd64
pkg: encoding/csv
BenchmarkRead-12                                     	  300000	      3360 ns/op	     664 B/op	      18 allocs/op
BenchmarkReadWithFieldsPerRecord-12                  	  300000	      3630 ns/op	     664 B/op	      18 allocs/op
BenchmarkReadWithoutFieldsPerRecord-12               	  500000	      3659 ns/op	     664 B/op	      18 allocs/op
BenchmarkReadLargeFields-12                          	   30000	     58919 ns/op	    3936 B/op	      24 allocs/op
BenchmarkReadReuseRecord-12                          	 1000000	      1962 ns/op	      24 B/op	       8 allocs/op
BenchmarkReadReuseRecordWithFieldsPerRecord-12       	 1000000	      2131 ns/op	      24 B/op	       8 allocs/op
BenchmarkReadReuseRecordWithoutFieldsPerRecord-12    	 1000000	      2275 ns/op	      24 B/op	       8 allocs/op
BenchmarkReadReuseRecordLargeFields-12               	   30000	     61428 ns/op	    2976 B/op	      12 allocs/op
PASS
ok  	encoding/csv	18.362s
goos: linux
goarch: amd64
pkg: encoding/gob
BenchmarkEndToEndPipe-12               	 2000000	       691 ns/op
BenchmarkEndToEndByteBuffer-12         	 5000000	       250 ns/op
BenchmarkEndToEndSliceByteBuffer-12    	  100000	     24088 ns/op
BenchmarkEncodeComplex128Slice-12      	  500000	      2690 ns/op
BenchmarkEncodeFloat64Slice-12         	 1000000	      1340 ns/op
BenchmarkEncodeInt32Slice-12           	 1000000	      1485 ns/op
BenchmarkEncodeStringSlice-12          	 1000000	      1321 ns/op
BenchmarkEncodeInterfaceSlice-12       	   20000	     66237 ns/op
BenchmarkDecodeComplex128Slice-12      	  100000	     13292 ns/op
BenchmarkDecodeFloat64Slice-12         	  200000	      7153 ns/op
BenchmarkDecodeInt32Slice-12           	  200000	      6965 ns/op
BenchmarkDecodeStringSlice-12          	  100000	     22547 ns/op
BenchmarkDecodeInterfaceSlice-12       	   10000	    158181 ns/op
BenchmarkDecodeMap-12                  	   10000	    354087 ns/op
PASS
ok  	encoding/gob	27.287s
goos: linux
goarch: amd64
pkg: encoding/hex
BenchmarkEncode/256-12         	 3000000	       369 ns/op
BenchmarkEncode/1024-12        	 1000000	      1296 ns/op
BenchmarkEncode/4096-12        	  200000	      5535 ns/op
BenchmarkEncode/16384-12       	   50000	     22952 ns/op
PASS
ok  	encoding/hex	6.208s
goos: linux
goarch: amd64
pkg: encoding/json
BenchmarkCodeEncoder-12            	    1000	   1849312 ns/op	1049.29 MB/s
BenchmarkCodeMarshal-12            	    1000	   2148618 ns/op	 903.13 MB/s
BenchmarkCodeDecoder-12            	     200	   8168617 ns/op	 237.55 MB/s
BenchmarkDecoderStream-12          	 5000000	       349 ns/op
BenchmarkCodeUnmarshal-12          	     200	   8644740 ns/op	 224.47 MB/s
BenchmarkCodeUnmarshalReuse-12     	     200	   7976530 ns/op
BenchmarkUnmarshalString-12        	20000000	        99.7 ns/op
BenchmarkUnmarshalFloat64-12       	20000000	        91.8 ns/op
BenchmarkUnmarshalInt64-12         	20000000	        82.7 ns/op
BenchmarkIssue10335-12             	20000000	       117 ns/op	     320 B/op	       4 allocs/op
BenchmarkUnmapped-12               	 3000000	       402 ns/op	     568 B/op	      18 allocs/op
BenchmarkNumberIsValid-12          	100000000	        17.6 ns/op
BenchmarkNumberIsValidRegexp-12    	 2000000	       579 ns/op
BenchmarkSkipValue-12              	     100	  11993381 ns/op	 166.79 MB/s
BenchmarkEncoderEncode-12          	20000000	        55.8 ns/op	       0 B/op	       0 allocs/op
PASS
ok  	encoding/json	31.405s
goos: linux
goarch: amd64
pkg: encoding/pem
BenchmarkEncode-12    	   20000	    101262 ns/op	 647.19 MB/s
BenchmarkDecode-12    	    2000	    885020 ns/op	 100.32 MB/s
PASS
ok  	encoding/pem	4.777s
goos: linux
goarch: amd64
pkg: encoding/xml
BenchmarkMarshal-12      	  300000	      3348 ns/op	    5776 B/op	      23 allocs/op
BenchmarkUnmarshal-12    	  200000	      7432 ns/op	    8576 B/op	     189 allocs/op
PASS
ok  	encoding/xml	2.676s
PASS
ok  	errors	0.010s
goos: linux
goarch: amd64
pkg: expvar
BenchmarkIntAdd-12                        	100000000	        14.5 ns/op
BenchmarkIntSet-12                        	100000000	        14.0 ns/op
BenchmarkFloatAdd-12                      	20000000	       118 ns/op
BenchmarkFloatSet-12                      	100000000	        14.2 ns/op
BenchmarkStringSet-12                     	30000000	        37.7 ns/op
BenchmarkMapSet-12                        	20000000	       121 ns/op
BenchmarkMapSetDifferent-12               	10000000	       139 ns/op
BenchmarkMapSetString-12                  	10000000	       121 ns/op
BenchmarkMapAddSame-12                    	10000000	       199 ns/op
BenchmarkMapAddDifferent-12               	 3000000	       581 ns/op
BenchmarkMapAddSameSteadyState-12         	100000000	        19.7 ns/op
BenchmarkMapAddDifferentSteadyState-12    	50000000	        35.7 ns/op
BenchmarkRealworldExpvarUsage-12          	 1000000	      1114 ns/op
PASS
ok  	expvar	22.899s
flag provided but not defined: -x
flag needs an argument: -b
Usage of test:
  -b	usage
PASS
ok  	flag	0.010s
goos: linux
goarch: amd64
pkg: fmt
BenchmarkSprintfPadding-12                   	20000000	        57.2 ns/op
BenchmarkSprintfEmpty-12                     	300000000	         5.89 ns/op
BenchmarkSprintfString-12                    	100000000	        16.2 ns/op
BenchmarkSprintfTruncateString-12            	50000000	        31.1 ns/op
BenchmarkSprintfQuoteString-12               	20000000	       105 ns/op
BenchmarkSprintfInt-12                       	100000000	        15.2 ns/op
BenchmarkSprintfIntInt-12                    	100000000	        23.6 ns/op
BenchmarkSprintfPrefixedInt-12               	50000000	        39.4 ns/op
BenchmarkSprintfFloat-12                     	30000000	        39.8 ns/op
BenchmarkSprintfComplex-12                   	20000000	       109 ns/op
BenchmarkSprintfBoolean-12                   	100000000	        15.6 ns/op
BenchmarkSprintfHexString-12                 	30000000	        43.3 ns/op
BenchmarkSprintfHexBytes-12                  	30000000	        55.3 ns/op
BenchmarkSprintfBytes-12                     	20000000	        92.3 ns/op
BenchmarkSprintfStringer-12                  	20000000	        72.2 ns/op
BenchmarkSprintfStructure-12                 	 5000000	       249 ns/op
BenchmarkManyArgs-12                         	20000000	        84.9 ns/op
BenchmarkFprintInt-12                        	20000000	        69.2 ns/op
BenchmarkFprintfBytes-12                     	 5000000	       217 ns/op
BenchmarkFprintIntNoAlloc-12                 	20000000	        64.7 ns/op
BenchmarkScanInts-12                         	    5000	    574186 ns/op
BenchmarkScanRecursiveInt-12                 	      30	  45324583 ns/op
BenchmarkScanRecursiveIntReaderWrapper-12    	      30	  46384136 ns/op
PASS
ok  	fmt	42.301s
PASS
ok  	go/ast	0.013s
PASS
ok  	go/build	0.202s
PASS
ok  	go/constant	0.014s
PASS
ok  	go/doc	0.035s
PASS
ok  	go/format	0.033s
?   	go/importer	[no test files]
PASS
ok  	go/internal/gccgoimporter	0.026s
PASS
ok  	go/internal/gcimporter	0.476s
PASS
ok  	go/internal/srcimporter	1.462s
goos: linux
goarch: amd64
pkg: go/parser
BenchmarkParse-12    	     300	   7162959 ns/op	   8.90 MB/s
PASS
ok  	go/parser	2.766s
goos: linux
goarch: amd64
pkg: go/printer
BenchmarkPrint-12    	     100	  11978437 ns/op
PASS
ok  	go/printer	1.451s
goos: linux
goarch: amd64
pkg: go/scanner
BenchmarkScan-12        	   50000	     23872 ns/op
BenchmarkScanFile-12    	    5000	    397473 ns/op	  44.60 MB/s
PASS
ok  	go/scanner	4.305s
PASS
ok  	go/token	0.053s
PASS
ok  	go/types	7.870s
?   	hash	[no test files]
goos: linux
goarch: amd64
pkg: hash/adler32
BenchmarkAdler32KB-12    	 3000000	       439 ns/op	2328.09 MB/s
PASS
ok  	hash/adler32	1.766s
goos: linux
goarch: amd64
pkg: hash/crc32
BenchmarkCRC32/poly=IEEE/size=15/align=0-12         	20000000	        51.0 ns/op	 294.02 MB/s
BenchmarkCRC32/poly=IEEE/size=15/align=1-12         	30000000	        49.2 ns/op	 305.16 MB/s
BenchmarkCRC32/poly=IEEE/size=40/align=0-12         	30000000	        45.7 ns/op	 876.07 MB/s
BenchmarkCRC32/poly=IEEE/size=40/align=1-12         	30000000	        44.8 ns/op	 893.50 MB/s
BenchmarkCRC32/poly=IEEE/size=512/align=0-12        	30000000	        47.6 ns/op	10748.15 MB/s
BenchmarkCRC32/poly=IEEE/size=512/align=1-12        	20000000	        50.7 ns/op	10096.63 MB/s
BenchmarkCRC32/poly=IEEE/size=1kB/align=0-12        	20000000	        74.7 ns/op	13699.43 MB/s
BenchmarkCRC32/poly=IEEE/size=1kB/align=1-12        	20000000	        78.1 ns/op	13114.05 MB/s
BenchmarkCRC32/poly=IEEE/size=4kB/align=0-12        	 5000000	       225 ns/op	18178.15 MB/s
BenchmarkCRC32/poly=IEEE/size=4kB/align=1-12        	 5000000	       229 ns/op	17851.57 MB/s
BenchmarkCRC32/poly=IEEE/size=32kB/align=0-12       	 1000000	      1697 ns/op	19299.76 MB/s
BenchmarkCRC32/poly=IEEE/size=32kB/align=1-12       	 1000000	      1601 ns/op	20462.91 MB/s
BenchmarkCRC32/poly=Castagnoli/size=15/align=0-12   	100000000	        14.8 ns/op	1012.68 MB/s
BenchmarkCRC32/poly=Castagnoli/size=15/align=1-12   	100000000	        14.6 ns/op	1025.25 MB/s
BenchmarkCRC32/poly=Castagnoli/size=40/align=0-12   	100000000	        19.2 ns/op	2084.76 MB/s
BenchmarkCRC32/poly=Castagnoli/size=40/align=1-12   	100000000	        16.5 ns/op	2424.32 MB/s
BenchmarkCRC32/poly=Castagnoli/size=512/align=0-12  	30000000	        39.9 ns/op	12840.32 MB/s
BenchmarkCRC32/poly=Castagnoli/size=512/align=1-12  	50000000	        41.2 ns/op	12431.77 MB/s
BenchmarkCRC32/poly=Castagnoli/size=1kB/align=0-12  	20000000	        66.5 ns/op	15394.69 MB/s
BenchmarkCRC32/poly=Castagnoli/size=1kB/align=1-12  	20000000	        67.2 ns/op	15237.43 MB/s
BenchmarkCRC32/poly=Castagnoli/size=4kB/align=0-12  	10000000	       174 ns/op	23423.41 MB/s
BenchmarkCRC32/poly=Castagnoli/size=4kB/align=1-12  	10000000	       177 ns/op	23061.83 MB/s
BenchmarkCRC32/poly=Castagnoli/size=32kB/align=0-12 	 1000000	      1301 ns/op	25183.37 MB/s
BenchmarkCRC32/poly=Castagnoli/size=32kB/align=1-12 	 1000000	      1371 ns/op	23895.53 MB/s
BenchmarkCRC32/poly=Koopman/size=15/align=0-12      	50000000	        35.4 ns/op	 423.86 MB/s
BenchmarkCRC32/poly=Koopman/size=15/align=1-12      	50000000	        35.4 ns/op	 423.55 MB/s
BenchmarkCRC32/poly=Koopman/size=40/align=0-12      	10000000	       103 ns/op	 387.71 MB/s
BenchmarkCRC32/poly=Koopman/size=40/align=1-12      	10000000	       102 ns/op	 388.72 MB/s
BenchmarkCRC32/poly=Koopman/size=512/align=0-12     	 1000000	      1103 ns/op	 464.04 MB/s
BenchmarkCRC32/poly=Koopman/size=512/align=1-12     	 1000000	      1104 ns/op	 463.48 MB/s
BenchmarkCRC32/poly=Koopman/size=1kB/align=0-12     	 1000000	      2228 ns/op	 459.50 MB/s
BenchmarkCRC32/poly=Koopman/size=1kB/align=1-12     	  500000	      2251 ns/op	 454.88 MB/s
BenchmarkCRC32/poly=Koopman/size=4kB/align=0-12     	  200000	      9046 ns/op	 452.75 MB/s
BenchmarkCRC32/poly=Koopman/size=4kB/align=1-12     	  200000	      9198 ns/op	 445.31 MB/s
BenchmarkCRC32/poly=Koopman/size=32kB/align=0-12    	   20000	     74725 ns/op	 438.51 MB/s
BenchmarkCRC32/poly=Koopman/size=32kB/align=1-12    	   20000	     70871 ns/op	 462.36 MB/s
PASS
ok  	hash/crc32	68.141s
goos: linux
goarch: amd64
pkg: hash/crc64
BenchmarkCrc64/ISO64KB-12         	   50000	     34690 ns/op	1889.19 MB/s
BenchmarkCrc64/ISO4KB-12          	  500000	      2633 ns/op	1555.36 MB/s
BenchmarkCrc64/ISO1KB-12          	 2000000	       754 ns/op	1358.07 MB/s
BenchmarkCrc64/ECMA64KB-12        	   30000	     42171 ns/op	1554.02 MB/s
BenchmarkCrc64/Random64KB-12      	   20000	     54482 ns/op	1202.88 MB/s
BenchmarkCrc64/Random16KB-12      	   30000	     34876 ns/op	 469.77 MB/s
PASS
ok  	hash/crc64	10.705s
goos: linux
goarch: amd64
pkg: hash/fnv
BenchmarkFnv32KB-12      	 1000000	      1224 ns/op	 836.54 MB/s
BenchmarkFnv32aKB-12     	 1000000	      1099 ns/op	 931.13 MB/s
BenchmarkFnv64KB-12      	 2000000	      1155 ns/op	 886.07 MB/s
BenchmarkFnv64aKB-12     	 2000000	      1085 ns/op	 943.18 MB/s
BenchmarkFnv128KB-12     	  300000	      5027 ns/op	 203.66 MB/s
BenchmarkFnv128aKB-12    	  300000	      4570 ns/op	 224.04 MB/s
PASS
ok  	hash/fnv	13.407s
goos: linux
goarch: amd64
pkg: html
BenchmarkEscape-12            	  100000	     23929 ns/op
BenchmarkEscapeNone-12        	  500000	      3261 ns/op
BenchmarkUnescape-12          	   50000	     36331 ns/op
BenchmarkUnescapeNone-12      	20000000	        87.8 ns/op
BenchmarkUnescapeSparse-12    	  500000	      2294 ns/op
BenchmarkUnescapeDense-12     	  100000	     22111 ns/op
PASS
ok  	html	14.693s
goos: linux
goarch: amd64
pkg: html/template
BenchmarkCSSEscaper-12                       	 1000000	      2748 ns/op
BenchmarkCSSEscaperNoSpecials-12             	